(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('path'), require('child_process'), require('util'), require('events'), require('stream'), require('buffer'), require('os'), require('assert'), require('http'), require('https'), require('url'), require('zlib'), require('fs'), require('constants'), require('tty'), require('readline'), require('string_decoder'), require('crypto')) :
    typeof define === 'function' && define.amd ? define(['exports', 'path', 'child_process', 'util', 'events', 'stream', 'buffer', 'os', 'assert', 'http', 'https', 'url', 'zlib', 'fs', 'constants', 'tty', 'readline', 'string_decoder', 'crypto'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global["@js-cli/init"] = {}, global.require$$1$3, global.cp, global.require$$0$3, global.require$$0$2, global.require$$0$4, global.require$$0$5, global.require$$0$6, global.require$$5$1, global.require$$1$2, global.require$$2$1, global.require$$0$7, global.require$$8, global.require$$0$8, global.require$$0$9, global.require$$1$4, global.require$$3$2, global.require$$1$5, global.require$$2$2));
})(this, (function (exports, require$$1$3, cp, require$$0$3, require$$0$2, require$$0$4, require$$0$5, require$$0$6, require$$5$1, require$$1$2, require$$2$1, require$$0$7, require$$8, require$$0$8, require$$0$9, require$$1$4, require$$3$2, require$$1$5, require$$2$2) { 'use strict';

    function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

    var require$$1__default$1 = /*#__PURE__*/_interopDefaultLegacy(require$$1$3);
    var cp__default = /*#__PURE__*/_interopDefaultLegacy(cp);
    var require$$0__default$1 = /*#__PURE__*/_interopDefaultLegacy(require$$0$3);
    var require$$0__default = /*#__PURE__*/_interopDefaultLegacy(require$$0$2);
    var require$$0__default$2 = /*#__PURE__*/_interopDefaultLegacy(require$$0$4);
    var require$$0__default$3 = /*#__PURE__*/_interopDefaultLegacy(require$$0$5);
    var require$$0__default$4 = /*#__PURE__*/_interopDefaultLegacy(require$$0$6);
    var require$$5__default = /*#__PURE__*/_interopDefaultLegacy(require$$5$1);
    var require$$1__default = /*#__PURE__*/_interopDefaultLegacy(require$$1$2);
    var require$$2__default = /*#__PURE__*/_interopDefaultLegacy(require$$2$1);
    var require$$0__default$5 = /*#__PURE__*/_interopDefaultLegacy(require$$0$7);
    var require$$8__default = /*#__PURE__*/_interopDefaultLegacy(require$$8);
    var require$$0__default$6 = /*#__PURE__*/_interopDefaultLegacy(require$$0$8);
    var require$$0__default$7 = /*#__PURE__*/_interopDefaultLegacy(require$$0$9);
    var require$$1__default$2 = /*#__PURE__*/_interopDefaultLegacy(require$$1$4);
    var require$$3__default = /*#__PURE__*/_interopDefaultLegacy(require$$3$2);
    var require$$1__default$3 = /*#__PURE__*/_interopDefaultLegacy(require$$1$5);
    var require$$2__default$1 = /*#__PURE__*/_interopDefaultLegacy(require$$2$2);

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */

    function __awaiter$3(thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }

    var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

    function getAugmentedNamespace(n) {
    	if (n.__esModule) return n;
    	var a = Object.defineProperty({}, '__esModule', {value: true});
    	Object.keys(n).forEach(function (k) {
    		var d = Object.getOwnPropertyDescriptor(n, k);
    		Object.defineProperty(a, k, d.get ? d : {
    			enumerable: true,
    			get: function () {
    				return n[k];
    			}
    		});
    	});
    	return a;
    }

    var log$1 = {exports: {}};

    var lib$2 = {};

    var trackerGroup = {exports: {}};

    var trackerBase = {exports: {}};

    var EventEmitter = require$$0__default["default"].EventEmitter;
    var util$9 = require$$0__default$1["default"];

    var trackerId = 0;
    var TrackerBase$2 = trackerBase.exports = function (name) {
      EventEmitter.call(this);
      this.id = ++trackerId;
      this.name = name;
    };
    util$9.inherits(TrackerBase$2, EventEmitter);

    var tracker = {exports: {}};

    var util$8 = require$$0__default$1["default"];
    var TrackerBase$1 = trackerBase.exports;

    var Tracker$2 = tracker.exports = function (name, todo) {
      TrackerBase$1.call(this, name);
      this.workDone = 0;
      this.workTodo = todo || 0;
    };
    util$8.inherits(Tracker$2, TrackerBase$1);

    Tracker$2.prototype.completed = function () {
      return this.workTodo === 0 ? 0 : this.workDone / this.workTodo
    };

    Tracker$2.prototype.addWork = function (work) {
      this.workTodo += work;
      this.emit('change', this.name, this.completed(), this);
    };

    Tracker$2.prototype.completeWork = function (work) {
      this.workDone += work;
      if (this.workDone > this.workTodo) {
        this.workDone = this.workTodo;
      }
      this.emit('change', this.name, this.completed(), this);
    };

    Tracker$2.prototype.finish = function () {
      this.workTodo = this.workDone = 1;
      this.emit('change', this.name, 1, this);
    };

    var trackerStream = {exports: {}};

    var readable = {exports: {}};

    var stream$1 = require$$0__default$2["default"];

    function ownKeys$1(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

    function _objectSpread$1(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$1(Object(source), true).forEach(function (key) { _defineProperty$3(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$1(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

    function _defineProperty$3(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

    function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

    var _require$2 = require$$0__default$3["default"],
        Buffer$d = _require$2.Buffer;

    var _require2 = require$$0__default$1["default"],
        inspect = _require2.inspect;

    var custom = inspect && inspect.custom || 'inspect';

    function copyBuffer(src, target, offset) {
      Buffer$d.prototype.copy.call(src, target, offset);
    }

    var buffer_list =
    /*#__PURE__*/
    function () {
      function BufferList() {
        _classCallCheck(this, BufferList);

        this.head = null;
        this.tail = null;
        this.length = 0;
      }

      _createClass(BufferList, [{
        key: "push",
        value: function push(v) {
          var entry = {
            data: v,
            next: null
          };
          if (this.length > 0) this.tail.next = entry;else this.head = entry;
          this.tail = entry;
          ++this.length;
        }
      }, {
        key: "unshift",
        value: function unshift(v) {
          var entry = {
            data: v,
            next: this.head
          };
          if (this.length === 0) this.tail = entry;
          this.head = entry;
          ++this.length;
        }
      }, {
        key: "shift",
        value: function shift() {
          if (this.length === 0) return;
          var ret = this.head.data;
          if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
          --this.length;
          return ret;
        }
      }, {
        key: "clear",
        value: function clear() {
          this.head = this.tail = null;
          this.length = 0;
        }
      }, {
        key: "join",
        value: function join(s) {
          if (this.length === 0) return '';
          var p = this.head;
          var ret = '' + p.data;

          while (p = p.next) {
            ret += s + p.data;
          }

          return ret;
        }
      }, {
        key: "concat",
        value: function concat(n) {
          if (this.length === 0) return Buffer$d.alloc(0);
          var ret = Buffer$d.allocUnsafe(n >>> 0);
          var p = this.head;
          var i = 0;

          while (p) {
            copyBuffer(p.data, ret, i);
            i += p.data.length;
            p = p.next;
          }

          return ret;
        } // Consumes a specified amount of bytes or characters from the buffered data.

      }, {
        key: "consume",
        value: function consume(n, hasStrings) {
          var ret;

          if (n < this.head.data.length) {
            // `slice` is the same for buffers and strings.
            ret = this.head.data.slice(0, n);
            this.head.data = this.head.data.slice(n);
          } else if (n === this.head.data.length) {
            // First chunk is a perfect match.
            ret = this.shift();
          } else {
            // Result spans more than one buffer.
            ret = hasStrings ? this._getString(n) : this._getBuffer(n);
          }

          return ret;
        }
      }, {
        key: "first",
        value: function first() {
          return this.head.data;
        } // Consumes a specified amount of characters from the buffered data.

      }, {
        key: "_getString",
        value: function _getString(n) {
          var p = this.head;
          var c = 1;
          var ret = p.data;
          n -= ret.length;

          while (p = p.next) {
            var str = p.data;
            var nb = n > str.length ? str.length : n;
            if (nb === str.length) ret += str;else ret += str.slice(0, n);
            n -= nb;

            if (n === 0) {
              if (nb === str.length) {
                ++c;
                if (p.next) this.head = p.next;else this.head = this.tail = null;
              } else {
                this.head = p;
                p.data = str.slice(nb);
              }

              break;
            }

            ++c;
          }

          this.length -= c;
          return ret;
        } // Consumes a specified amount of bytes from the buffered data.

      }, {
        key: "_getBuffer",
        value: function _getBuffer(n) {
          var ret = Buffer$d.allocUnsafe(n);
          var p = this.head;
          var c = 1;
          p.data.copy(ret);
          n -= p.data.length;

          while (p = p.next) {
            var buf = p.data;
            var nb = n > buf.length ? buf.length : n;
            buf.copy(ret, ret.length - n, 0, nb);
            n -= nb;

            if (n === 0) {
              if (nb === buf.length) {
                ++c;
                if (p.next) this.head = p.next;else this.head = this.tail = null;
              } else {
                this.head = p;
                p.data = buf.slice(nb);
              }

              break;
            }

            ++c;
          }

          this.length -= c;
          return ret;
        } // Make sure the linked list only shows the minimal necessary information.

      }, {
        key: custom,
        value: function value(_, options) {
          return inspect(this, _objectSpread$1({}, options, {
            // Only inspect one level.
            depth: 0,
            // It should not recurse.
            customInspect: false
          }));
        }
      }]);

      return BufferList;
    }();

    function destroy(err, cb) {
      var _this = this;

      var readableDestroyed = this._readableState && this._readableState.destroyed;
      var writableDestroyed = this._writableState && this._writableState.destroyed;

      if (readableDestroyed || writableDestroyed) {
        if (cb) {
          cb(err);
        } else if (err) {
          if (!this._writableState) {
            process.nextTick(emitErrorNT, this, err);
          } else if (!this._writableState.errorEmitted) {
            this._writableState.errorEmitted = true;
            process.nextTick(emitErrorNT, this, err);
          }
        }

        return this;
      } // we set destroyed to true before firing error callbacks in order
      // to make it re-entrance safe in case destroy() is called within callbacks


      if (this._readableState) {
        this._readableState.destroyed = true;
      } // if this is a duplex stream mark the writable part as destroyed as well


      if (this._writableState) {
        this._writableState.destroyed = true;
      }

      this._destroy(err || null, function (err) {
        if (!cb && err) {
          if (!_this._writableState) {
            process.nextTick(emitErrorAndCloseNT, _this, err);
          } else if (!_this._writableState.errorEmitted) {
            _this._writableState.errorEmitted = true;
            process.nextTick(emitErrorAndCloseNT, _this, err);
          } else {
            process.nextTick(emitCloseNT, _this);
          }
        } else if (cb) {
          process.nextTick(emitCloseNT, _this);
          cb(err);
        } else {
          process.nextTick(emitCloseNT, _this);
        }
      });

      return this;
    }

    function emitErrorAndCloseNT(self, err) {
      emitErrorNT(self, err);
      emitCloseNT(self);
    }

    function emitCloseNT(self) {
      if (self._writableState && !self._writableState.emitClose) return;
      if (self._readableState && !self._readableState.emitClose) return;
      self.emit('close');
    }

    function undestroy() {
      if (this._readableState) {
        this._readableState.destroyed = false;
        this._readableState.reading = false;
        this._readableState.ended = false;
        this._readableState.endEmitted = false;
      }

      if (this._writableState) {
        this._writableState.destroyed = false;
        this._writableState.ended = false;
        this._writableState.ending = false;
        this._writableState.finalCalled = false;
        this._writableState.prefinished = false;
        this._writableState.finished = false;
        this._writableState.errorEmitted = false;
      }
    }

    function emitErrorNT(self, err) {
      self.emit('error', err);
    }

    function errorOrDestroy$2(stream, err) {
      // We have tests that rely on errors being emitted
      // in the same tick, so changing this is semver major.
      // For now when you opt-in to autoDestroy we allow
      // the error to be emitted nextTick. In a future
      // semver major update we should change the default to this.
      var rState = stream._readableState;
      var wState = stream._writableState;
      if (rState && rState.autoDestroy || wState && wState.autoDestroy) stream.destroy(err);else stream.emit('error', err);
    }

    var destroy_1 = {
      destroy: destroy,
      undestroy: undestroy,
      errorOrDestroy: errorOrDestroy$2
    };

    var errors = {};

    const codes = {};

    function createErrorType$1(code, message, Base) {
      if (!Base) {
        Base = Error;
      }

      function getMessage (arg1, arg2, arg3) {
        if (typeof message === 'string') {
          return message
        } else {
          return message(arg1, arg2, arg3)
        }
      }

      class NodeError extends Base {
        constructor (arg1, arg2, arg3) {
          super(getMessage(arg1, arg2, arg3));
        }
      }

      NodeError.prototype.name = Base.name;
      NodeError.prototype.code = code;

      codes[code] = NodeError;
    }

    // https://github.com/nodejs/node/blob/v10.8.0/lib/internal/errors.js
    function oneOf(expected, thing) {
      if (Array.isArray(expected)) {
        const len = expected.length;
        expected = expected.map((i) => String(i));
        if (len > 2) {
          return `one of ${thing} ${expected.slice(0, len - 1).join(', ')}, or ` +
                 expected[len - 1];
        } else if (len === 2) {
          return `one of ${thing} ${expected[0]} or ${expected[1]}`;
        } else {
          return `of ${thing} ${expected[0]}`;
        }
      } else {
        return `of ${thing} ${String(expected)}`;
      }
    }

    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith
    function startsWith(str, search, pos) {
    	return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
    }

    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith
    function endsWith(str, search, this_len) {
    	if (this_len === undefined || this_len > str.length) {
    		this_len = str.length;
    	}
    	return str.substring(this_len - search.length, this_len) === search;
    }

    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes
    function includes(str, search, start) {
      if (typeof start !== 'number') {
        start = 0;
      }

      if (start + search.length > str.length) {
        return false;
      } else {
        return str.indexOf(search, start) !== -1;
      }
    }

    createErrorType$1('ERR_INVALID_OPT_VALUE', function (name, value) {
      return 'The value "' + value + '" is invalid for option "' + name + '"'
    }, TypeError);
    createErrorType$1('ERR_INVALID_ARG_TYPE', function (name, expected, actual) {
      // determiner: 'must be' or 'must not be'
      let determiner;
      if (typeof expected === 'string' && startsWith(expected, 'not ')) {
        determiner = 'must not be';
        expected = expected.replace(/^not /, '');
      } else {
        determiner = 'must be';
      }

      let msg;
      if (endsWith(name, ' argument')) {
        // For cases like 'first argument'
        msg = `The ${name} ${determiner} ${oneOf(expected, 'type')}`;
      } else {
        const type = includes(name, '.') ? 'property' : 'argument';
        msg = `The "${name}" ${type} ${determiner} ${oneOf(expected, 'type')}`;
      }

      msg += `. Received type ${typeof actual}`;
      return msg;
    }, TypeError);
    createErrorType$1('ERR_STREAM_PUSH_AFTER_EOF', 'stream.push() after EOF');
    createErrorType$1('ERR_METHOD_NOT_IMPLEMENTED', function (name) {
      return 'The ' + name + ' method is not implemented'
    });
    createErrorType$1('ERR_STREAM_PREMATURE_CLOSE', 'Premature close');
    createErrorType$1('ERR_STREAM_DESTROYED', function (name) {
      return 'Cannot call ' + name + ' after a stream was destroyed';
    });
    createErrorType$1('ERR_MULTIPLE_CALLBACK', 'Callback called multiple times');
    createErrorType$1('ERR_STREAM_CANNOT_PIPE', 'Cannot pipe, not readable');
    createErrorType$1('ERR_STREAM_WRITE_AFTER_END', 'write after end');
    createErrorType$1('ERR_STREAM_NULL_VALUES', 'May not write null values to stream', TypeError);
    createErrorType$1('ERR_UNKNOWN_ENCODING', function (arg) {
      return 'Unknown encoding: ' + arg
    }, TypeError);
    createErrorType$1('ERR_STREAM_UNSHIFT_AFTER_END_EVENT', 'stream.unshift() after end event');

    errors.codes = codes;

    var ERR_INVALID_OPT_VALUE = errors.codes.ERR_INVALID_OPT_VALUE;

    function highWaterMarkFrom(options, isDuplex, duplexKey) {
      return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
    }

    function getHighWaterMark$2(state, options, duplexKey, isDuplex) {
      var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);

      if (hwm != null) {
        if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
          var name = isDuplex ? duplexKey : 'highWaterMark';
          throw new ERR_INVALID_OPT_VALUE(name, hwm);
        }

        return Math.floor(hwm);
      } // Default value


      return state.objectMode ? 16 : 16 * 1024;
    }

    var state = {
      getHighWaterMark: getHighWaterMark$2
    };

    var inherits$2 = {exports: {}};

    var inherits_browser = {exports: {}};

    if (typeof Object.create === 'function') {
      // implementation from standard node.js 'util' module
      inherits_browser.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          ctor.prototype = Object.create(superCtor.prototype, {
            constructor: {
              value: ctor,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
        }
      };
    } else {
      // old school shim for old browsers
      inherits_browser.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = function () {};
          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        }
      };
    }

    try {
      var util$7 = require('util');
      /* istanbul ignore next */
      if (typeof util$7.inherits !== 'function') throw '';
      inherits$2.exports = util$7.inherits;
    } catch (e) {
      /* istanbul ignore next */
      inherits$2.exports = inherits_browser.exports;
    }

    /**
     * For Node.js, simply re-export the core `util.deprecate` function.
     */

    var node = require$$0__default$1["default"].deprecate;

    var _stream_writable = Writable$2;
    // there will be only 2 of these for each stream


    function CorkedRequest(state) {
      var _this = this;

      this.next = null;
      this.entry = null;

      this.finish = function () {
        onCorkedFinish(_this, state);
      };
    }
    /* </replacement> */

    /*<replacement>*/


    var Duplex$3;
    /*</replacement>*/

    Writable$2.WritableState = WritableState;
    /*<replacement>*/

    var internalUtil = {
      deprecate: node
    };
    /*</replacement>*/

    /*<replacement>*/

    var Stream$3 = stream$1;
    /*</replacement>*/


    var Buffer$c = require$$0__default$3["default"].Buffer;

    var OurUint8Array$1 = commonjsGlobal.Uint8Array || function () {};

    function _uint8ArrayToBuffer$1(chunk) {
      return Buffer$c.from(chunk);
    }

    function _isUint8Array$1(obj) {
      return Buffer$c.isBuffer(obj) || obj instanceof OurUint8Array$1;
    }

    var destroyImpl$1 = destroy_1;

    var _require$1 = state,
        getHighWaterMark$1 = _require$1.getHighWaterMark;

    var _require$codes$3 = errors.codes,
        ERR_INVALID_ARG_TYPE$2 = _require$codes$3.ERR_INVALID_ARG_TYPE,
        ERR_METHOD_NOT_IMPLEMENTED$2 = _require$codes$3.ERR_METHOD_NOT_IMPLEMENTED,
        ERR_MULTIPLE_CALLBACK$1 = _require$codes$3.ERR_MULTIPLE_CALLBACK,
        ERR_STREAM_CANNOT_PIPE = _require$codes$3.ERR_STREAM_CANNOT_PIPE,
        ERR_STREAM_DESTROYED$1 = _require$codes$3.ERR_STREAM_DESTROYED,
        ERR_STREAM_NULL_VALUES = _require$codes$3.ERR_STREAM_NULL_VALUES,
        ERR_STREAM_WRITE_AFTER_END = _require$codes$3.ERR_STREAM_WRITE_AFTER_END,
        ERR_UNKNOWN_ENCODING = _require$codes$3.ERR_UNKNOWN_ENCODING;

    var errorOrDestroy$1 = destroyImpl$1.errorOrDestroy;

    inherits$2.exports(Writable$2, Stream$3);

    function nop() {}

    function WritableState(options, stream, isDuplex) {
      Duplex$3 = Duplex$3 || _stream_duplex;
      options = options || {}; // Duplex streams are both readable and writable, but share
      // the same options object.
      // However, some cases require setting options to different
      // values for the readable and the writable sides of the duplex stream,
      // e.g. options.readableObjectMode vs. options.writableObjectMode, etc.

      if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex$3; // object stream flag to indicate whether or not this stream
      // contains buffers or objects.

      this.objectMode = !!options.objectMode;
      if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode; // the point at which write() starts returning false
      // Note: 0 is a valid value, means that we always return false if
      // the entire buffer is not flushed immediately on write()

      this.highWaterMark = getHighWaterMark$1(this, options, 'writableHighWaterMark', isDuplex); // if _final has been called

      this.finalCalled = false; // drain event flag.

      this.needDrain = false; // at the start of calling end()

      this.ending = false; // when end() has been called, and returned

      this.ended = false; // when 'finish' is emitted

      this.finished = false; // has it been destroyed

      this.destroyed = false; // should we decode strings into buffers before passing to _write?
      // this is here so that some node-core streams can optimize string
      // handling at a lower level.

      var noDecode = options.decodeStrings === false;
      this.decodeStrings = !noDecode; // Crypto is kind of old and crusty.  Historically, its default string
      // encoding is 'binary' so we have to make this configurable.
      // Everything else in the universe uses 'utf8', though.

      this.defaultEncoding = options.defaultEncoding || 'utf8'; // not an actual buffer we keep track of, but a measurement
      // of how much we're waiting to get pushed to some underlying
      // socket or file.

      this.length = 0; // a flag to see when we're in the middle of a write.

      this.writing = false; // when true all writes will be buffered until .uncork() call

      this.corked = 0; // a flag to be able to tell if the onwrite cb is called immediately,
      // or on a later tick.  We set this to true at first, because any
      // actions that shouldn't happen until "later" should generally also
      // not happen before the first write call.

      this.sync = true; // a flag to know if we're processing previously buffered items, which
      // may call the _write() callback in the same tick, so that we don't
      // end up in an overlapped onwrite situation.

      this.bufferProcessing = false; // the callback that's passed to _write(chunk,cb)

      this.onwrite = function (er) {
        onwrite(stream, er);
      }; // the callback that the user supplies to write(chunk,encoding,cb)


      this.writecb = null; // the amount that is being written when _write is called.

      this.writelen = 0;
      this.bufferedRequest = null;
      this.lastBufferedRequest = null; // number of pending user-supplied write callbacks
      // this must be 0 before 'finish' can be emitted

      this.pendingcb = 0; // emit prefinish if the only thing we're waiting for is _write cbs
      // This is relevant for synchronous Transform streams

      this.prefinished = false; // True if the error was already emitted and should not be thrown again

      this.errorEmitted = false; // Should close be emitted on destroy. Defaults to true.

      this.emitClose = options.emitClose !== false; // Should .destroy() be called after 'finish' (and potentially 'end')

      this.autoDestroy = !!options.autoDestroy; // count buffered requests

      this.bufferedRequestCount = 0; // allocate the first CorkedRequest, there is always
      // one allocated and free to use, and we maintain at most two

      this.corkedRequestsFree = new CorkedRequest(this);
    }

    WritableState.prototype.getBuffer = function getBuffer() {
      var current = this.bufferedRequest;
      var out = [];

      while (current) {
        out.push(current);
        current = current.next;
      }

      return out;
    };

    (function () {
      try {
        Object.defineProperty(WritableState.prototype, 'buffer', {
          get: internalUtil.deprecate(function writableStateBufferGetter() {
            return this.getBuffer();
          }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')
        });
      } catch (_) {}
    })(); // Test _writableState for inheritance to account for Duplex streams,
    // whose prototype chain only points to Readable.


    var realHasInstance;

    if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
      realHasInstance = Function.prototype[Symbol.hasInstance];
      Object.defineProperty(Writable$2, Symbol.hasInstance, {
        value: function value(object) {
          if (realHasInstance.call(this, object)) return true;
          if (this !== Writable$2) return false;
          return object && object._writableState instanceof WritableState;
        }
      });
    } else {
      realHasInstance = function realHasInstance(object) {
        return object instanceof this;
      };
    }

    function Writable$2(options) {
      Duplex$3 = Duplex$3 || _stream_duplex; // Writable ctor is applied to Duplexes, too.
      // `realHasInstance` is necessary because using plain `instanceof`
      // would return false, as no `_writableState` property is attached.
      // Trying to use the custom `instanceof` for Writable here will also break the
      // Node.js LazyTransform implementation, which has a non-trivial getter for
      // `_writableState` that would lead to infinite recursion.
      // Checking for a Stream.Duplex instance is faster here instead of inside
      // the WritableState constructor, at least with V8 6.5

      var isDuplex = this instanceof Duplex$3;
      if (!isDuplex && !realHasInstance.call(Writable$2, this)) return new Writable$2(options);
      this._writableState = new WritableState(options, this, isDuplex); // legacy.

      this.writable = true;

      if (options) {
        if (typeof options.write === 'function') this._write = options.write;
        if (typeof options.writev === 'function') this._writev = options.writev;
        if (typeof options.destroy === 'function') this._destroy = options.destroy;
        if (typeof options.final === 'function') this._final = options.final;
      }

      Stream$3.call(this);
    } // Otherwise people can pipe Writable streams, which is just wrong.


    Writable$2.prototype.pipe = function () {
      errorOrDestroy$1(this, new ERR_STREAM_CANNOT_PIPE());
    };

    function writeAfterEnd(stream, cb) {
      var er = new ERR_STREAM_WRITE_AFTER_END(); // TODO: defer error events consistently everywhere, not just the cb

      errorOrDestroy$1(stream, er);
      process.nextTick(cb, er);
    } // Checks that a user-supplied chunk is valid, especially for the particular
    // mode the stream is in. Currently this means that `null` is never accepted
    // and undefined/non-string values are only allowed in object mode.


    function validChunk(stream, state, chunk, cb) {
      var er;

      if (chunk === null) {
        er = new ERR_STREAM_NULL_VALUES();
      } else if (typeof chunk !== 'string' && !state.objectMode) {
        er = new ERR_INVALID_ARG_TYPE$2('chunk', ['string', 'Buffer'], chunk);
      }

      if (er) {
        errorOrDestroy$1(stream, er);
        process.nextTick(cb, er);
        return false;
      }

      return true;
    }

    Writable$2.prototype.write = function (chunk, encoding, cb) {
      var state = this._writableState;
      var ret = false;

      var isBuf = !state.objectMode && _isUint8Array$1(chunk);

      if (isBuf && !Buffer$c.isBuffer(chunk)) {
        chunk = _uint8ArrayToBuffer$1(chunk);
      }

      if (typeof encoding === 'function') {
        cb = encoding;
        encoding = null;
      }

      if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;
      if (typeof cb !== 'function') cb = nop;
      if (state.ending) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {
        state.pendingcb++;
        ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
      }
      return ret;
    };

    Writable$2.prototype.cork = function () {
      this._writableState.corked++;
    };

    Writable$2.prototype.uncork = function () {
      var state = this._writableState;

      if (state.corked) {
        state.corked--;
        if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
      }
    };

    Writable$2.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
      // node::ParseEncoding() requires lower case.
      if (typeof encoding === 'string') encoding = encoding.toLowerCase();
      if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new ERR_UNKNOWN_ENCODING(encoding);
      this._writableState.defaultEncoding = encoding;
      return this;
    };

    Object.defineProperty(Writable$2.prototype, 'writableBuffer', {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState && this._writableState.getBuffer();
      }
    });

    function decodeChunk(state, chunk, encoding) {
      if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
        chunk = Buffer$c.from(chunk, encoding);
      }

      return chunk;
    }

    Object.defineProperty(Writable$2.prototype, 'writableHighWaterMark', {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState.highWaterMark;
      }
    }); // if we're already writing something, then just put this
    // in the queue, and wait our turn.  Otherwise, call _write
    // If we return false, then we need a drain event, so set that flag.

    function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
      if (!isBuf) {
        var newChunk = decodeChunk(state, chunk, encoding);

        if (chunk !== newChunk) {
          isBuf = true;
          encoding = 'buffer';
          chunk = newChunk;
        }
      }

      var len = state.objectMode ? 1 : chunk.length;
      state.length += len;
      var ret = state.length < state.highWaterMark; // we must ensure that previous needDrain will not be reset to false.

      if (!ret) state.needDrain = true;

      if (state.writing || state.corked) {
        var last = state.lastBufferedRequest;
        state.lastBufferedRequest = {
          chunk: chunk,
          encoding: encoding,
          isBuf: isBuf,
          callback: cb,
          next: null
        };

        if (last) {
          last.next = state.lastBufferedRequest;
        } else {
          state.bufferedRequest = state.lastBufferedRequest;
        }

        state.bufferedRequestCount += 1;
      } else {
        doWrite(stream, state, false, len, chunk, encoding, cb);
      }

      return ret;
    }

    function doWrite(stream, state, writev, len, chunk, encoding, cb) {
      state.writelen = len;
      state.writecb = cb;
      state.writing = true;
      state.sync = true;
      if (state.destroyed) state.onwrite(new ERR_STREAM_DESTROYED$1('write'));else if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
      state.sync = false;
    }

    function onwriteError(stream, state, sync, er, cb) {
      --state.pendingcb;

      if (sync) {
        // defer the callback if we are being called synchronously
        // to avoid piling up things on the stack
        process.nextTick(cb, er); // this can emit finish, and it will always happen
        // after error

        process.nextTick(finishMaybe, stream, state);
        stream._writableState.errorEmitted = true;
        errorOrDestroy$1(stream, er);
      } else {
        // the caller expect this to happen before if
        // it is async
        cb(er);
        stream._writableState.errorEmitted = true;
        errorOrDestroy$1(stream, er); // this can emit finish, but finish must
        // always follow error

        finishMaybe(stream, state);
      }
    }

    function onwriteStateUpdate(state) {
      state.writing = false;
      state.writecb = null;
      state.length -= state.writelen;
      state.writelen = 0;
    }

    function onwrite(stream, er) {
      var state = stream._writableState;
      var sync = state.sync;
      var cb = state.writecb;
      if (typeof cb !== 'function') throw new ERR_MULTIPLE_CALLBACK$1();
      onwriteStateUpdate(state);
      if (er) onwriteError(stream, state, sync, er, cb);else {
        // Check if we're actually ready to finish, but don't emit yet
        var finished = needFinish(state) || stream.destroyed;

        if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
          clearBuffer(stream, state);
        }

        if (sync) {
          process.nextTick(afterWrite, stream, state, finished, cb);
        } else {
          afterWrite(stream, state, finished, cb);
        }
      }
    }

    function afterWrite(stream, state, finished, cb) {
      if (!finished) onwriteDrain(stream, state);
      state.pendingcb--;
      cb();
      finishMaybe(stream, state);
    } // Must force callback to be called on nextTick, so that we don't
    // emit 'drain' before the write() consumer gets the 'false' return
    // value, and has a chance to attach a 'drain' listener.


    function onwriteDrain(stream, state) {
      if (state.length === 0 && state.needDrain) {
        state.needDrain = false;
        stream.emit('drain');
      }
    } // if there's something in the buffer waiting, then process it


    function clearBuffer(stream, state) {
      state.bufferProcessing = true;
      var entry = state.bufferedRequest;

      if (stream._writev && entry && entry.next) {
        // Fast case, write everything using _writev()
        var l = state.bufferedRequestCount;
        var buffer = new Array(l);
        var holder = state.corkedRequestsFree;
        holder.entry = entry;
        var count = 0;
        var allBuffers = true;

        while (entry) {
          buffer[count] = entry;
          if (!entry.isBuf) allBuffers = false;
          entry = entry.next;
          count += 1;
        }

        buffer.allBuffers = allBuffers;
        doWrite(stream, state, true, state.length, buffer, '', holder.finish); // doWrite is almost always async, defer these to save a bit of time
        // as the hot path ends with doWrite

        state.pendingcb++;
        state.lastBufferedRequest = null;

        if (holder.next) {
          state.corkedRequestsFree = holder.next;
          holder.next = null;
        } else {
          state.corkedRequestsFree = new CorkedRequest(state);
        }

        state.bufferedRequestCount = 0;
      } else {
        // Slow case, write chunks one-by-one
        while (entry) {
          var chunk = entry.chunk;
          var encoding = entry.encoding;
          var cb = entry.callback;
          var len = state.objectMode ? 1 : chunk.length;
          doWrite(stream, state, false, len, chunk, encoding, cb);
          entry = entry.next;
          state.bufferedRequestCount--; // if we didn't call the onwrite immediately, then
          // it means that we need to wait until it does.
          // also, that means that the chunk and cb are currently
          // being processed, so move the buffer counter past them.

          if (state.writing) {
            break;
          }
        }

        if (entry === null) state.lastBufferedRequest = null;
      }

      state.bufferedRequest = entry;
      state.bufferProcessing = false;
    }

    Writable$2.prototype._write = function (chunk, encoding, cb) {
      cb(new ERR_METHOD_NOT_IMPLEMENTED$2('_write()'));
    };

    Writable$2.prototype._writev = null;

    Writable$2.prototype.end = function (chunk, encoding, cb) {
      var state = this._writableState;

      if (typeof chunk === 'function') {
        cb = chunk;
        chunk = null;
        encoding = null;
      } else if (typeof encoding === 'function') {
        cb = encoding;
        encoding = null;
      }

      if (chunk !== null && chunk !== undefined) this.write(chunk, encoding); // .end() fully uncorks

      if (state.corked) {
        state.corked = 1;
        this.uncork();
      } // ignore unnecessary end() calls.


      if (!state.ending) endWritable(this, state, cb);
      return this;
    };

    Object.defineProperty(Writable$2.prototype, 'writableLength', {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState.length;
      }
    });

    function needFinish(state) {
      return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
    }

    function callFinal(stream, state) {
      stream._final(function (err) {
        state.pendingcb--;

        if (err) {
          errorOrDestroy$1(stream, err);
        }

        state.prefinished = true;
        stream.emit('prefinish');
        finishMaybe(stream, state);
      });
    }

    function prefinish$1(stream, state) {
      if (!state.prefinished && !state.finalCalled) {
        if (typeof stream._final === 'function' && !state.destroyed) {
          state.pendingcb++;
          state.finalCalled = true;
          process.nextTick(callFinal, stream, state);
        } else {
          state.prefinished = true;
          stream.emit('prefinish');
        }
      }
    }

    function finishMaybe(stream, state) {
      var need = needFinish(state);

      if (need) {
        prefinish$1(stream, state);

        if (state.pendingcb === 0) {
          state.finished = true;
          stream.emit('finish');

          if (state.autoDestroy) {
            // In case of duplex streams we need a way to detect
            // if the readable side is ready for autoDestroy as well
            var rState = stream._readableState;

            if (!rState || rState.autoDestroy && rState.endEmitted) {
              stream.destroy();
            }
          }
        }
      }

      return need;
    }

    function endWritable(stream, state, cb) {
      state.ending = true;
      finishMaybe(stream, state);

      if (cb) {
        if (state.finished) process.nextTick(cb);else stream.once('finish', cb);
      }

      state.ended = true;
      stream.writable = false;
    }

    function onCorkedFinish(corkReq, state, err) {
      var entry = corkReq.entry;
      corkReq.entry = null;

      while (entry) {
        var cb = entry.callback;
        state.pendingcb--;
        cb(err);
        entry = entry.next;
      } // reuse the free corkReq.


      state.corkedRequestsFree.next = corkReq;
    }

    Object.defineProperty(Writable$2.prototype, 'destroyed', {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        if (this._writableState === undefined) {
          return false;
        }

        return this._writableState.destroyed;
      },
      set: function set(value) {
        // we ignore the value if the stream
        // has not been initialized yet
        if (!this._writableState) {
          return;
        } // backward compatibility, the user is explicitly
        // managing destroyed


        this._writableState.destroyed = value;
      }
    });
    Writable$2.prototype.destroy = destroyImpl$1.destroy;
    Writable$2.prototype._undestroy = destroyImpl$1.undestroy;

    Writable$2.prototype._destroy = function (err, cb) {
      cb(err);
    };

    /*<replacement>*/

    var objectKeys = Object.keys || function (obj) {
      var keys = [];

      for (var key in obj) {
        keys.push(key);
      }

      return keys;
    };
    /*</replacement>*/


    var _stream_duplex = Duplex$2;

    var Readable$1 = _stream_readable;

    var Writable$1 = _stream_writable;

    inherits$2.exports(Duplex$2, Readable$1);

    {
      // Allow the keys array to be GC'ed.
      var keys$8 = objectKeys(Writable$1.prototype);

      for (var v = 0; v < keys$8.length; v++) {
        var method = keys$8[v];
        if (!Duplex$2.prototype[method]) Duplex$2.prototype[method] = Writable$1.prototype[method];
      }
    }

    function Duplex$2(options) {
      if (!(this instanceof Duplex$2)) return new Duplex$2(options);
      Readable$1.call(this, options);
      Writable$1.call(this, options);
      this.allowHalfOpen = true;

      if (options) {
        if (options.readable === false) this.readable = false;
        if (options.writable === false) this.writable = false;

        if (options.allowHalfOpen === false) {
          this.allowHalfOpen = false;
          this.once('end', onend);
        }
      }
    }

    Object.defineProperty(Duplex$2.prototype, 'writableHighWaterMark', {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState.highWaterMark;
      }
    });
    Object.defineProperty(Duplex$2.prototype, 'writableBuffer', {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState && this._writableState.getBuffer();
      }
    });
    Object.defineProperty(Duplex$2.prototype, 'writableLength', {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState.length;
      }
    }); // the no-half-open enforcer

    function onend() {
      // If the writable side ended, then we're ok.
      if (this._writableState.ended) return; // no more data can be written.
      // But allow more writes to happen in this tick.

      process.nextTick(onEndNT, this);
    }

    function onEndNT(self) {
      self.end();
    }

    Object.defineProperty(Duplex$2.prototype, 'destroyed', {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        if (this._readableState === undefined || this._writableState === undefined) {
          return false;
        }

        return this._readableState.destroyed && this._writableState.destroyed;
      },
      set: function set(value) {
        // we ignore the value if the stream
        // has not been initialized yet
        if (this._readableState === undefined || this._writableState === undefined) {
          return;
        } // backward compatibility, the user is explicitly
        // managing destroyed


        this._readableState.destroyed = value;
        this._writableState.destroyed = value;
      }
    });

    var string_decoder = {};

    var safeBuffer = {exports: {}};

    /*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */

    (function (module, exports) {
    /* eslint-disable node/no-deprecated-api */
    var buffer = require$$0__default$3["default"];
    var Buffer = buffer.Buffer;

    // alternative to using Object.keys for old browsers
    function copyProps (src, dst) {
      for (var key in src) {
        dst[key] = src[key];
      }
    }
    if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
      module.exports = buffer;
    } else {
      // Copy properties from require('buffer')
      copyProps(buffer, exports);
      exports.Buffer = SafeBuffer;
    }

    function SafeBuffer (arg, encodingOrOffset, length) {
      return Buffer(arg, encodingOrOffset, length)
    }

    SafeBuffer.prototype = Object.create(Buffer.prototype);

    // Copy static methods from Buffer
    copyProps(Buffer, SafeBuffer);

    SafeBuffer.from = function (arg, encodingOrOffset, length) {
      if (typeof arg === 'number') {
        throw new TypeError('Argument must not be a number')
      }
      return Buffer(arg, encodingOrOffset, length)
    };

    SafeBuffer.alloc = function (size, fill, encoding) {
      if (typeof size !== 'number') {
        throw new TypeError('Argument must be a number')
      }
      var buf = Buffer(size);
      if (fill !== undefined) {
        if (typeof encoding === 'string') {
          buf.fill(fill, encoding);
        } else {
          buf.fill(fill);
        }
      } else {
        buf.fill(0);
      }
      return buf
    };

    SafeBuffer.allocUnsafe = function (size) {
      if (typeof size !== 'number') {
        throw new TypeError('Argument must be a number')
      }
      return Buffer(size)
    };

    SafeBuffer.allocUnsafeSlow = function (size) {
      if (typeof size !== 'number') {
        throw new TypeError('Argument must be a number')
      }
      return buffer.SlowBuffer(size)
    };
    }(safeBuffer, safeBuffer.exports));

    /*<replacement>*/

    var Buffer$b = safeBuffer.exports.Buffer;
    /*</replacement>*/

    var isEncoding = Buffer$b.isEncoding || function (encoding) {
      encoding = '' + encoding;
      switch (encoding && encoding.toLowerCase()) {
        case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':
          return true;
        default:
          return false;
      }
    };

    function _normalizeEncoding(enc) {
      if (!enc) return 'utf8';
      var retried;
      while (true) {
        switch (enc) {
          case 'utf8':
          case 'utf-8':
            return 'utf8';
          case 'ucs2':
          case 'ucs-2':
          case 'utf16le':
          case 'utf-16le':
            return 'utf16le';
          case 'latin1':
          case 'binary':
            return 'latin1';
          case 'base64':
          case 'ascii':
          case 'hex':
            return enc;
          default:
            if (retried) return; // undefined
            enc = ('' + enc).toLowerCase();
            retried = true;
        }
      }
    }
    // Do not cache `Buffer.isEncoding` when checking encoding names as some
    // modules monkey-patch it to support additional encodings
    function normalizeEncoding(enc) {
      var nenc = _normalizeEncoding(enc);
      if (typeof nenc !== 'string' && (Buffer$b.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);
      return nenc || enc;
    }

    // StringDecoder provides an interface for efficiently splitting a series of
    // buffers into a series of JS strings without breaking apart multi-byte
    // characters.
    string_decoder.StringDecoder = StringDecoder$2;
    function StringDecoder$2(encoding) {
      this.encoding = normalizeEncoding(encoding);
      var nb;
      switch (this.encoding) {
        case 'utf16le':
          this.text = utf16Text;
          this.end = utf16End;
          nb = 4;
          break;
        case 'utf8':
          this.fillLast = utf8FillLast;
          nb = 4;
          break;
        case 'base64':
          this.text = base64Text;
          this.end = base64End;
          nb = 3;
          break;
        default:
          this.write = simpleWrite;
          this.end = simpleEnd;
          return;
      }
      this.lastNeed = 0;
      this.lastTotal = 0;
      this.lastChar = Buffer$b.allocUnsafe(nb);
    }

    StringDecoder$2.prototype.write = function (buf) {
      if (buf.length === 0) return '';
      var r;
      var i;
      if (this.lastNeed) {
        r = this.fillLast(buf);
        if (r === undefined) return '';
        i = this.lastNeed;
        this.lastNeed = 0;
      } else {
        i = 0;
      }
      if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
      return r || '';
    };

    StringDecoder$2.prototype.end = utf8End;

    // Returns only complete characters in a Buffer
    StringDecoder$2.prototype.text = utf8Text;

    // Attempts to complete a partial non-UTF-8 character using bytes from a Buffer
    StringDecoder$2.prototype.fillLast = function (buf) {
      if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
      }
      buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
      this.lastNeed -= buf.length;
    };

    // Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
    // continuation byte. If an invalid byte is detected, -2 is returned.
    function utf8CheckByte(byte) {
      if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;
      return byte >> 6 === 0x02 ? -1 : -2;
    }

    // Checks at most 3 bytes at the end of a Buffer in order to detect an
    // incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
    // needed to complete the UTF-8 character (if applicable) are returned.
    function utf8CheckIncomplete(self, buf, i) {
      var j = buf.length - 1;
      if (j < i) return 0;
      var nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0) self.lastNeed = nb - 1;
        return nb;
      }
      if (--j < i || nb === -2) return 0;
      nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0) self.lastNeed = nb - 2;
        return nb;
      }
      if (--j < i || nb === -2) return 0;
      nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0) {
          if (nb === 2) nb = 0;else self.lastNeed = nb - 3;
        }
        return nb;
      }
      return 0;
    }

    // Validates as many continuation bytes for a multi-byte UTF-8 character as
    // needed or are available. If we see a non-continuation byte where we expect
    // one, we "replace" the validated continuation bytes we've seen so far with
    // a single UTF-8 replacement character ('\ufffd'), to match v8's UTF-8 decoding
    // behavior. The continuation byte check is included three times in the case
    // where all of the continuation bytes for a character exist in the same buffer.
    // It is also done this way as a slight performance increase instead of using a
    // loop.
    function utf8CheckExtraBytes(self, buf, p) {
      if ((buf[0] & 0xC0) !== 0x80) {
        self.lastNeed = 0;
        return '\ufffd';
      }
      if (self.lastNeed > 1 && buf.length > 1) {
        if ((buf[1] & 0xC0) !== 0x80) {
          self.lastNeed = 1;
          return '\ufffd';
        }
        if (self.lastNeed > 2 && buf.length > 2) {
          if ((buf[2] & 0xC0) !== 0x80) {
            self.lastNeed = 2;
            return '\ufffd';
          }
        }
      }
    }

    // Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.
    function utf8FillLast(buf) {
      var p = this.lastTotal - this.lastNeed;
      var r = utf8CheckExtraBytes(this, buf);
      if (r !== undefined) return r;
      if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, p, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
      }
      buf.copy(this.lastChar, p, 0, buf.length);
      this.lastNeed -= buf.length;
    }

    // Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
    // partial character, the character's bytes are buffered until the required
    // number of bytes are available.
    function utf8Text(buf, i) {
      var total = utf8CheckIncomplete(this, buf, i);
      if (!this.lastNeed) return buf.toString('utf8', i);
      this.lastTotal = total;
      var end = buf.length - (total - this.lastNeed);
      buf.copy(this.lastChar, 0, end);
      return buf.toString('utf8', i, end);
    }

    // For UTF-8, a replacement character is added when ending on a partial
    // character.
    function utf8End(buf) {
      var r = buf && buf.length ? this.write(buf) : '';
      if (this.lastNeed) return r + '\ufffd';
      return r;
    }

    // UTF-16LE typically needs two bytes per character, but even if we have an even
    // number of bytes available, we need to check if we end on a leading/high
    // surrogate. In that case, we need to wait for the next two bytes in order to
    // decode the last character properly.
    function utf16Text(buf, i) {
      if ((buf.length - i) % 2 === 0) {
        var r = buf.toString('utf16le', i);
        if (r) {
          var c = r.charCodeAt(r.length - 1);
          if (c >= 0xD800 && c <= 0xDBFF) {
            this.lastNeed = 2;
            this.lastTotal = 4;
            this.lastChar[0] = buf[buf.length - 2];
            this.lastChar[1] = buf[buf.length - 1];
            return r.slice(0, -1);
          }
        }
        return r;
      }
      this.lastNeed = 1;
      this.lastTotal = 2;
      this.lastChar[0] = buf[buf.length - 1];
      return buf.toString('utf16le', i, buf.length - 1);
    }

    // For UTF-16LE we do not explicitly append special replacement characters if we
    // end on a partial character, we simply let v8 handle that.
    function utf16End(buf) {
      var r = buf && buf.length ? this.write(buf) : '';
      if (this.lastNeed) {
        var end = this.lastTotal - this.lastNeed;
        return r + this.lastChar.toString('utf16le', 0, end);
      }
      return r;
    }

    function base64Text(buf, i) {
      var n = (buf.length - i) % 3;
      if (n === 0) return buf.toString('base64', i);
      this.lastNeed = 3 - n;
      this.lastTotal = 3;
      if (n === 1) {
        this.lastChar[0] = buf[buf.length - 1];
      } else {
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
      }
      return buf.toString('base64', i, buf.length - n);
    }

    function base64End(buf) {
      var r = buf && buf.length ? this.write(buf) : '';
      if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);
      return r;
    }

    // Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)
    function simpleWrite(buf) {
      return buf.toString(this.encoding);
    }

    function simpleEnd(buf) {
      return buf && buf.length ? this.write(buf) : '';
    }

    var ERR_STREAM_PREMATURE_CLOSE = errors.codes.ERR_STREAM_PREMATURE_CLOSE;

    function once$5(callback) {
      var called = false;
      return function () {
        if (called) return;
        called = true;

        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        callback.apply(this, args);
      };
    }

    function noop$6() {}

    function isRequest$1(stream) {
      return stream.setHeader && typeof stream.abort === 'function';
    }

    function eos$1(stream, opts, callback) {
      if (typeof opts === 'function') return eos$1(stream, null, opts);
      if (!opts) opts = {};
      callback = once$5(callback || noop$6);
      var readable = opts.readable || opts.readable !== false && stream.readable;
      var writable = opts.writable || opts.writable !== false && stream.writable;

      var onlegacyfinish = function onlegacyfinish() {
        if (!stream.writable) onfinish();
      };

      var writableEnded = stream._writableState && stream._writableState.finished;

      var onfinish = function onfinish() {
        writable = false;
        writableEnded = true;
        if (!readable) callback.call(stream);
      };

      var readableEnded = stream._readableState && stream._readableState.endEmitted;

      var onend = function onend() {
        readable = false;
        readableEnded = true;
        if (!writable) callback.call(stream);
      };

      var onerror = function onerror(err) {
        callback.call(stream, err);
      };

      var onclose = function onclose() {
        var err;

        if (readable && !readableEnded) {
          if (!stream._readableState || !stream._readableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
          return callback.call(stream, err);
        }

        if (writable && !writableEnded) {
          if (!stream._writableState || !stream._writableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
          return callback.call(stream, err);
        }
      };

      var onrequest = function onrequest() {
        stream.req.on('finish', onfinish);
      };

      if (isRequest$1(stream)) {
        stream.on('complete', onfinish);
        stream.on('abort', onclose);
        if (stream.req) onrequest();else stream.on('request', onrequest);
      } else if (writable && !stream._writableState) {
        // legacy streams
        stream.on('end', onlegacyfinish);
        stream.on('close', onlegacyfinish);
      }

      stream.on('end', onend);
      stream.on('finish', onfinish);
      if (opts.error !== false) stream.on('error', onerror);
      stream.on('close', onclose);
      return function () {
        stream.removeListener('complete', onfinish);
        stream.removeListener('abort', onclose);
        stream.removeListener('request', onrequest);
        if (stream.req) stream.req.removeListener('finish', onfinish);
        stream.removeListener('end', onlegacyfinish);
        stream.removeListener('close', onlegacyfinish);
        stream.removeListener('finish', onfinish);
        stream.removeListener('end', onend);
        stream.removeListener('error', onerror);
        stream.removeListener('close', onclose);
      };
    }

    var endOfStream = eos$1;

    var _Object$setPrototypeO;

    function _defineProperty$2(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

    var finished = endOfStream;

    var kLastResolve = Symbol('lastResolve');
    var kLastReject = Symbol('lastReject');
    var kError = Symbol('error');
    var kEnded = Symbol('ended');
    var kLastPromise = Symbol('lastPromise');
    var kHandlePromise = Symbol('handlePromise');
    var kStream = Symbol('stream');

    function createIterResult(value, done) {
      return {
        value: value,
        done: done
      };
    }

    function readAndResolve(iter) {
      var resolve = iter[kLastResolve];

      if (resolve !== null) {
        var data = iter[kStream].read(); // we defer if data is null
        // we can be expecting either 'end' or
        // 'error'

        if (data !== null) {
          iter[kLastPromise] = null;
          iter[kLastResolve] = null;
          iter[kLastReject] = null;
          resolve(createIterResult(data, false));
        }
      }
    }

    function onReadable(iter) {
      // we wait for the next tick, because it might
      // emit an error with process.nextTick
      process.nextTick(readAndResolve, iter);
    }

    function wrapForNext(lastPromise, iter) {
      return function (resolve, reject) {
        lastPromise.then(function () {
          if (iter[kEnded]) {
            resolve(createIterResult(undefined, true));
            return;
          }

          iter[kHandlePromise](resolve, reject);
        }, reject);
      };
    }

    var AsyncIteratorPrototype = Object.getPrototypeOf(function () {});
    var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
      get stream() {
        return this[kStream];
      },

      next: function next() {
        var _this = this;

        // if we have detected an error in the meanwhile
        // reject straight away
        var error = this[kError];

        if (error !== null) {
          return Promise.reject(error);
        }

        if (this[kEnded]) {
          return Promise.resolve(createIterResult(undefined, true));
        }

        if (this[kStream].destroyed) {
          // We need to defer via nextTick because if .destroy(err) is
          // called, the error will be emitted via nextTick, and
          // we cannot guarantee that there is no error lingering around
          // waiting to be emitted.
          return new Promise(function (resolve, reject) {
            process.nextTick(function () {
              if (_this[kError]) {
                reject(_this[kError]);
              } else {
                resolve(createIterResult(undefined, true));
              }
            });
          });
        } // if we have multiple next() calls
        // we will wait for the previous Promise to finish
        // this logic is optimized to support for await loops,
        // where next() is only called once at a time


        var lastPromise = this[kLastPromise];
        var promise;

        if (lastPromise) {
          promise = new Promise(wrapForNext(lastPromise, this));
        } else {
          // fast path needed to support multiple this.push()
          // without triggering the next() queue
          var data = this[kStream].read();

          if (data !== null) {
            return Promise.resolve(createIterResult(data, false));
          }

          promise = new Promise(this[kHandlePromise]);
        }

        this[kLastPromise] = promise;
        return promise;
      }
    }, _defineProperty$2(_Object$setPrototypeO, Symbol.asyncIterator, function () {
      return this;
    }), _defineProperty$2(_Object$setPrototypeO, "return", function _return() {
      var _this2 = this;

      // destroy(err, cb) is a private API
      // we can guarantee we have that here, because we control the
      // Readable class this is attached to
      return new Promise(function (resolve, reject) {
        _this2[kStream].destroy(null, function (err) {
          if (err) {
            reject(err);
            return;
          }

          resolve(createIterResult(undefined, true));
        });
      });
    }), _Object$setPrototypeO), AsyncIteratorPrototype);

    var createReadableStreamAsyncIterator$1 = function createReadableStreamAsyncIterator(stream) {
      var _Object$create;

      var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty$2(_Object$create, kStream, {
        value: stream,
        writable: true
      }), _defineProperty$2(_Object$create, kLastResolve, {
        value: null,
        writable: true
      }), _defineProperty$2(_Object$create, kLastReject, {
        value: null,
        writable: true
      }), _defineProperty$2(_Object$create, kError, {
        value: null,
        writable: true
      }), _defineProperty$2(_Object$create, kEnded, {
        value: stream._readableState.endEmitted,
        writable: true
      }), _defineProperty$2(_Object$create, kHandlePromise, {
        value: function value(resolve, reject) {
          var data = iterator[kStream].read();

          if (data) {
            iterator[kLastPromise] = null;
            iterator[kLastResolve] = null;
            iterator[kLastReject] = null;
            resolve(createIterResult(data, false));
          } else {
            iterator[kLastResolve] = resolve;
            iterator[kLastReject] = reject;
          }
        },
        writable: true
      }), _Object$create));
      iterator[kLastPromise] = null;
      finished(stream, function (err) {
        if (err && err.code !== 'ERR_STREAM_PREMATURE_CLOSE') {
          var reject = iterator[kLastReject]; // reject if we are waiting for data in the Promise
          // returned by next() and store the error

          if (reject !== null) {
            iterator[kLastPromise] = null;
            iterator[kLastResolve] = null;
            iterator[kLastReject] = null;
            reject(err);
          }

          iterator[kError] = err;
          return;
        }

        var resolve = iterator[kLastResolve];

        if (resolve !== null) {
          iterator[kLastPromise] = null;
          iterator[kLastResolve] = null;
          iterator[kLastReject] = null;
          resolve(createIterResult(undefined, true));
        }

        iterator[kEnded] = true;
      });
      stream.on('readable', onReadable.bind(null, iterator));
      return iterator;
    };

    var async_iterator = createReadableStreamAsyncIterator$1;

    function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

    function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

    function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

    function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty$1(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

    function _defineProperty$1(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

    var ERR_INVALID_ARG_TYPE$1 = errors.codes.ERR_INVALID_ARG_TYPE;

    function from$4(Readable, iterable, opts) {
      var iterator;

      if (iterable && typeof iterable.next === 'function') {
        iterator = iterable;
      } else if (iterable && iterable[Symbol.asyncIterator]) iterator = iterable[Symbol.asyncIterator]();else if (iterable && iterable[Symbol.iterator]) iterator = iterable[Symbol.iterator]();else throw new ERR_INVALID_ARG_TYPE$1('iterable', ['Iterable'], iterable);

      var readable = new Readable(_objectSpread({
        objectMode: true
      }, opts)); // Reading boolean to protect against _read
      // being called before last iteration completion.

      var reading = false;

      readable._read = function () {
        if (!reading) {
          reading = true;
          next();
        }
      };

      function next() {
        return _next2.apply(this, arguments);
      }

      function _next2() {
        _next2 = _asyncToGenerator(function* () {
          try {
            var _ref = yield iterator.next(),
                value = _ref.value,
                done = _ref.done;

            if (done) {
              readable.push(null);
            } else if (readable.push((yield value))) {
              next();
            } else {
              reading = false;
            }
          } catch (err) {
            readable.destroy(err);
          }
        });
        return _next2.apply(this, arguments);
      }

      return readable;
    }

    var from_1 = from$4;

    var _stream_readable = Readable;
    /*<replacement>*/

    var Duplex$1;
    /*</replacement>*/

    Readable.ReadableState = ReadableState;
    /*<replacement>*/

    require$$0__default["default"].EventEmitter;

    var EElistenerCount = function EElistenerCount(emitter, type) {
      return emitter.listeners(type).length;
    };
    /*</replacement>*/

    /*<replacement>*/


    var Stream$2 = stream$1;
    /*</replacement>*/


    var Buffer$a = require$$0__default$3["default"].Buffer;

    var OurUint8Array = commonjsGlobal.Uint8Array || function () {};

    function _uint8ArrayToBuffer(chunk) {
      return Buffer$a.from(chunk);
    }

    function _isUint8Array(obj) {
      return Buffer$a.isBuffer(obj) || obj instanceof OurUint8Array;
    }
    /*<replacement>*/


    var debugUtil = require$$0__default$1["default"];

    var debug$7;

    if (debugUtil && debugUtil.debuglog) {
      debug$7 = debugUtil.debuglog('stream');
    } else {
      debug$7 = function debug() {};
    }
    /*</replacement>*/


    var BufferList$2 = buffer_list;

    var destroyImpl = destroy_1;

    var _require = state,
        getHighWaterMark = _require.getHighWaterMark;

    var _require$codes$2 = errors.codes,
        ERR_INVALID_ARG_TYPE = _require$codes$2.ERR_INVALID_ARG_TYPE,
        ERR_STREAM_PUSH_AFTER_EOF = _require$codes$2.ERR_STREAM_PUSH_AFTER_EOF,
        ERR_METHOD_NOT_IMPLEMENTED$1 = _require$codes$2.ERR_METHOD_NOT_IMPLEMENTED,
        ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes$2.ERR_STREAM_UNSHIFT_AFTER_END_EVENT; // Lazy loaded to improve the startup performance.


    var StringDecoder$1;
    var createReadableStreamAsyncIterator;
    var from$3;

    inherits$2.exports(Readable, Stream$2);

    var errorOrDestroy = destroyImpl.errorOrDestroy;
    var kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];

    function prependListener(emitter, event, fn) {
      // Sadly this is not cacheable as some libraries bundle their own
      // event emitter implementation with them.
      if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn); // This is a hack to make sure that our error handler is attached before any
      // userland ones.  NEVER DO THIS. This is here only because this code needs
      // to continue to work with older versions of Node.js that do not include
      // the prependListener() method. The goal is to eventually remove this hack.

      if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (Array.isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
    }

    function ReadableState(options, stream, isDuplex) {
      Duplex$1 = Duplex$1 || _stream_duplex;
      options = options || {}; // Duplex streams are both readable and writable, but share
      // the same options object.
      // However, some cases require setting options to different
      // values for the readable and the writable sides of the duplex stream.
      // These options can be provided separately as readableXXX and writableXXX.

      if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex$1; // object stream flag. Used to make read(n) ignore n and to
      // make all the buffer merging and length checks go away

      this.objectMode = !!options.objectMode;
      if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode; // the point at which it stops calling _read() to fill the buffer
      // Note: 0 is a valid value, means "don't call _read preemptively ever"

      this.highWaterMark = getHighWaterMark(this, options, 'readableHighWaterMark', isDuplex); // A linked list is used to store data chunks instead of an array because the
      // linked list can remove elements from the beginning faster than
      // array.shift()

      this.buffer = new BufferList$2();
      this.length = 0;
      this.pipes = null;
      this.pipesCount = 0;
      this.flowing = null;
      this.ended = false;
      this.endEmitted = false;
      this.reading = false; // a flag to be able to tell if the event 'readable'/'data' is emitted
      // immediately, or on a later tick.  We set this to true at first, because
      // any actions that shouldn't happen until "later" should generally also
      // not happen before the first read call.

      this.sync = true; // whenever we return null, then we set a flag to say
      // that we're awaiting a 'readable' event emission.

      this.needReadable = false;
      this.emittedReadable = false;
      this.readableListening = false;
      this.resumeScheduled = false;
      this.paused = true; // Should close be emitted on destroy. Defaults to true.

      this.emitClose = options.emitClose !== false; // Should .destroy() be called after 'end' (and potentially 'finish')

      this.autoDestroy = !!options.autoDestroy; // has it been destroyed

      this.destroyed = false; // Crypto is kind of old and crusty.  Historically, its default string
      // encoding is 'binary' so we have to make this configurable.
      // Everything else in the universe uses 'utf8', though.

      this.defaultEncoding = options.defaultEncoding || 'utf8'; // the number of writers that are awaiting a drain event in .pipe()s

      this.awaitDrain = 0; // if true, a maybeReadMore has been scheduled

      this.readingMore = false;
      this.decoder = null;
      this.encoding = null;

      if (options.encoding) {
        if (!StringDecoder$1) StringDecoder$1 = string_decoder.StringDecoder;
        this.decoder = new StringDecoder$1(options.encoding);
        this.encoding = options.encoding;
      }
    }

    function Readable(options) {
      Duplex$1 = Duplex$1 || _stream_duplex;
      if (!(this instanceof Readable)) return new Readable(options); // Checking for a Stream.Duplex instance is faster here instead of inside
      // the ReadableState constructor, at least with V8 6.5

      var isDuplex = this instanceof Duplex$1;
      this._readableState = new ReadableState(options, this, isDuplex); // legacy

      this.readable = true;

      if (options) {
        if (typeof options.read === 'function') this._read = options.read;
        if (typeof options.destroy === 'function') this._destroy = options.destroy;
      }

      Stream$2.call(this);
    }

    Object.defineProperty(Readable.prototype, 'destroyed', {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        if (this._readableState === undefined) {
          return false;
        }

        return this._readableState.destroyed;
      },
      set: function set(value) {
        // we ignore the value if the stream
        // has not been initialized yet
        if (!this._readableState) {
          return;
        } // backward compatibility, the user is explicitly
        // managing destroyed


        this._readableState.destroyed = value;
      }
    });
    Readable.prototype.destroy = destroyImpl.destroy;
    Readable.prototype._undestroy = destroyImpl.undestroy;

    Readable.prototype._destroy = function (err, cb) {
      cb(err);
    }; // Manually shove something into the read() buffer.
    // This returns true if the highWaterMark has not been hit yet,
    // similar to how Writable.write() returns true if you should
    // write() some more.


    Readable.prototype.push = function (chunk, encoding) {
      var state = this._readableState;
      var skipChunkCheck;

      if (!state.objectMode) {
        if (typeof chunk === 'string') {
          encoding = encoding || state.defaultEncoding;

          if (encoding !== state.encoding) {
            chunk = Buffer$a.from(chunk, encoding);
            encoding = '';
          }

          skipChunkCheck = true;
        }
      } else {
        skipChunkCheck = true;
      }

      return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
    }; // Unshift should *always* be something directly out of read()


    Readable.prototype.unshift = function (chunk) {
      return readableAddChunk(this, chunk, null, true, false);
    };

    function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
      debug$7('readableAddChunk', chunk);
      var state = stream._readableState;

      if (chunk === null) {
        state.reading = false;
        onEofChunk(stream, state);
      } else {
        var er;
        if (!skipChunkCheck) er = chunkInvalid(state, chunk);

        if (er) {
          errorOrDestroy(stream, er);
        } else if (state.objectMode || chunk && chunk.length > 0) {
          if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer$a.prototype) {
            chunk = _uint8ArrayToBuffer(chunk);
          }

          if (addToFront) {
            if (state.endEmitted) errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());else addChunk(stream, state, chunk, true);
          } else if (state.ended) {
            errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
          } else if (state.destroyed) {
            return false;
          } else {
            state.reading = false;

            if (state.decoder && !encoding) {
              chunk = state.decoder.write(chunk);
              if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);
            } else {
              addChunk(stream, state, chunk, false);
            }
          }
        } else if (!addToFront) {
          state.reading = false;
          maybeReadMore(stream, state);
        }
      } // We can push more data if we are below the highWaterMark.
      // Also, if we have no data yet, we can stand some more bytes.
      // This is to work around cases where hwm=0, such as the repl.


      return !state.ended && (state.length < state.highWaterMark || state.length === 0);
    }

    function addChunk(stream, state, chunk, addToFront) {
      if (state.flowing && state.length === 0 && !state.sync) {
        state.awaitDrain = 0;
        stream.emit('data', chunk);
      } else {
        // update the buffer info.
        state.length += state.objectMode ? 1 : chunk.length;
        if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);
        if (state.needReadable) emitReadable(stream);
      }

      maybeReadMore(stream, state);
    }

    function chunkInvalid(state, chunk) {
      var er;

      if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
        er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer', 'Uint8Array'], chunk);
      }

      return er;
    }

    Readable.prototype.isPaused = function () {
      return this._readableState.flowing === false;
    }; // backwards compatibility.


    Readable.prototype.setEncoding = function (enc) {
      if (!StringDecoder$1) StringDecoder$1 = string_decoder.StringDecoder;
      var decoder = new StringDecoder$1(enc);
      this._readableState.decoder = decoder; // If setEncoding(null), decoder.encoding equals utf8

      this._readableState.encoding = this._readableState.decoder.encoding; // Iterate over current buffer to convert already stored Buffers:

      var p = this._readableState.buffer.head;
      var content = '';

      while (p !== null) {
        content += decoder.write(p.data);
        p = p.next;
      }

      this._readableState.buffer.clear();

      if (content !== '') this._readableState.buffer.push(content);
      this._readableState.length = content.length;
      return this;
    }; // Don't raise the hwm > 1GB


    var MAX_HWM = 0x40000000;

    function computeNewHighWaterMark(n) {
      if (n >= MAX_HWM) {
        // TODO(ronag): Throw ERR_VALUE_OUT_OF_RANGE.
        n = MAX_HWM;
      } else {
        // Get the next highest power of 2 to prevent increasing hwm excessively in
        // tiny amounts
        n--;
        n |= n >>> 1;
        n |= n >>> 2;
        n |= n >>> 4;
        n |= n >>> 8;
        n |= n >>> 16;
        n++;
      }

      return n;
    } // This function is designed to be inlinable, so please take care when making
    // changes to the function body.


    function howMuchToRead(n, state) {
      if (n <= 0 || state.length === 0 && state.ended) return 0;
      if (state.objectMode) return 1;

      if (n !== n) {
        // Only flow one buffer at a time
        if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
      } // If we're asking for more than the current hwm, then raise the hwm.


      if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
      if (n <= state.length) return n; // Don't have enough

      if (!state.ended) {
        state.needReadable = true;
        return 0;
      }

      return state.length;
    } // you can override either this method, or the async _read(n) below.


    Readable.prototype.read = function (n) {
      debug$7('read', n);
      n = parseInt(n, 10);
      var state = this._readableState;
      var nOrig = n;
      if (n !== 0) state.emittedReadable = false; // if we're doing read(0) to trigger a readable event, but we
      // already have a bunch of data in the buffer, then just trigger
      // the 'readable' event and move on.

      if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
        debug$7('read: emitReadable', state.length, state.ended);
        if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
        return null;
      }

      n = howMuchToRead(n, state); // if we've ended, and we're now clear, then finish it up.

      if (n === 0 && state.ended) {
        if (state.length === 0) endReadable(this);
        return null;
      } // All the actual chunk generation logic needs to be
      // *below* the call to _read.  The reason is that in certain
      // synthetic stream cases, such as passthrough streams, _read
      // may be a completely synchronous operation which may change
      // the state of the read buffer, providing enough data when
      // before there was *not* enough.
      //
      // So, the steps are:
      // 1. Figure out what the state of things will be after we do
      // a read from the buffer.
      //
      // 2. If that resulting state will trigger a _read, then call _read.
      // Note that this may be asynchronous, or synchronous.  Yes, it is
      // deeply ugly to write APIs this way, but that still doesn't mean
      // that the Readable class should behave improperly, as streams are
      // designed to be sync/async agnostic.
      // Take note if the _read call is sync or async (ie, if the read call
      // has returned yet), so that we know whether or not it's safe to emit
      // 'readable' etc.
      //
      // 3. Actually pull the requested chunks out of the buffer and return.
      // if we need a readable event, then we need to do some reading.


      var doRead = state.needReadable;
      debug$7('need readable', doRead); // if we currently have less than the highWaterMark, then also read some

      if (state.length === 0 || state.length - n < state.highWaterMark) {
        doRead = true;
        debug$7('length less than watermark', doRead);
      } // however, if we've ended, then there's no point, and if we're already
      // reading, then it's unnecessary.


      if (state.ended || state.reading) {
        doRead = false;
        debug$7('reading or ended', doRead);
      } else if (doRead) {
        debug$7('do read');
        state.reading = true;
        state.sync = true; // if the length is currently zero, then we *need* a readable event.

        if (state.length === 0) state.needReadable = true; // call internal read method

        this._read(state.highWaterMark);

        state.sync = false; // If _read pushed data synchronously, then `reading` will be false,
        // and we need to re-evaluate how much data we can return to the user.

        if (!state.reading) n = howMuchToRead(nOrig, state);
      }

      var ret;
      if (n > 0) ret = fromList(n, state);else ret = null;

      if (ret === null) {
        state.needReadable = state.length <= state.highWaterMark;
        n = 0;
      } else {
        state.length -= n;
        state.awaitDrain = 0;
      }

      if (state.length === 0) {
        // If we have nothing in the buffer, then we want to know
        // as soon as we *do* get something into the buffer.
        if (!state.ended) state.needReadable = true; // If we tried to read() past the EOF, then emit end on the next tick.

        if (nOrig !== n && state.ended) endReadable(this);
      }

      if (ret !== null) this.emit('data', ret);
      return ret;
    };

    function onEofChunk(stream, state) {
      debug$7('onEofChunk');
      if (state.ended) return;

      if (state.decoder) {
        var chunk = state.decoder.end();

        if (chunk && chunk.length) {
          state.buffer.push(chunk);
          state.length += state.objectMode ? 1 : chunk.length;
        }
      }

      state.ended = true;

      if (state.sync) {
        // if we are sync, wait until next tick to emit the data.
        // Otherwise we risk emitting data in the flow()
        // the readable code triggers during a read() call
        emitReadable(stream);
      } else {
        // emit 'readable' now to make sure it gets picked up.
        state.needReadable = false;

        if (!state.emittedReadable) {
          state.emittedReadable = true;
          emitReadable_(stream);
        }
      }
    } // Don't emit readable right away in sync mode, because this can trigger
    // another read() call => stack overflow.  This way, it might trigger
    // a nextTick recursion warning, but that's not so bad.


    function emitReadable(stream) {
      var state = stream._readableState;
      debug$7('emitReadable', state.needReadable, state.emittedReadable);
      state.needReadable = false;

      if (!state.emittedReadable) {
        debug$7('emitReadable', state.flowing);
        state.emittedReadable = true;
        process.nextTick(emitReadable_, stream);
      }
    }

    function emitReadable_(stream) {
      var state = stream._readableState;
      debug$7('emitReadable_', state.destroyed, state.length, state.ended);

      if (!state.destroyed && (state.length || state.ended)) {
        stream.emit('readable');
        state.emittedReadable = false;
      } // The stream needs another readable event if
      // 1. It is not flowing, as the flow mechanism will take
      //    care of it.
      // 2. It is not ended.
      // 3. It is below the highWaterMark, so we can schedule
      //    another readable later.


      state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
      flow(stream);
    } // at this point, the user has presumably seen the 'readable' event,
    // and called read() to consume some data.  that may have triggered
    // in turn another _read(n) call, in which case reading = true if
    // it's in progress.
    // However, if we're not ended, or reading, and the length < hwm,
    // then go ahead and try to read some more preemptively.


    function maybeReadMore(stream, state) {
      if (!state.readingMore) {
        state.readingMore = true;
        process.nextTick(maybeReadMore_, stream, state);
      }
    }

    function maybeReadMore_(stream, state) {
      // Attempt to read more data if we should.
      //
      // The conditions for reading more data are (one of):
      // - Not enough data buffered (state.length < state.highWaterMark). The loop
      //   is responsible for filling the buffer with enough data if such data
      //   is available. If highWaterMark is 0 and we are not in the flowing mode
      //   we should _not_ attempt to buffer any extra data. We'll get more data
      //   when the stream consumer calls read() instead.
      // - No data in the buffer, and the stream is in flowing mode. In this mode
      //   the loop below is responsible for ensuring read() is called. Failing to
      //   call read here would abort the flow and there's no other mechanism for
      //   continuing the flow if the stream consumer has just subscribed to the
      //   'data' event.
      //
      // In addition to the above conditions to keep reading data, the following
      // conditions prevent the data from being read:
      // - The stream has ended (state.ended).
      // - There is already a pending 'read' operation (state.reading). This is a
      //   case where the the stream has called the implementation defined _read()
      //   method, but they are processing the call asynchronously and have _not_
      //   called push() with new data. In this case we skip performing more
      //   read()s. The execution ends in this method again after the _read() ends
      //   up calling push() with more data.
      while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
        var len = state.length;
        debug$7('maybeReadMore read 0');
        stream.read(0);
        if (len === state.length) // didn't get any data, stop spinning.
          break;
      }

      state.readingMore = false;
    } // abstract method.  to be overridden in specific implementation classes.
    // call cb(er, data) where data is <= n in length.
    // for virtual (non-string, non-buffer) streams, "length" is somewhat
    // arbitrary, and perhaps not very meaningful.


    Readable.prototype._read = function (n) {
      errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED$1('_read()'));
    };

    Readable.prototype.pipe = function (dest, pipeOpts) {
      var src = this;
      var state = this._readableState;

      switch (state.pipesCount) {
        case 0:
          state.pipes = dest;
          break;

        case 1:
          state.pipes = [state.pipes, dest];
          break;

        default:
          state.pipes.push(dest);
          break;
      }

      state.pipesCount += 1;
      debug$7('pipe count=%d opts=%j', state.pipesCount, pipeOpts);
      var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
      var endFn = doEnd ? onend : unpipe;
      if (state.endEmitted) process.nextTick(endFn);else src.once('end', endFn);
      dest.on('unpipe', onunpipe);

      function onunpipe(readable, unpipeInfo) {
        debug$7('onunpipe');

        if (readable === src) {
          if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
            unpipeInfo.hasUnpiped = true;
            cleanup();
          }
        }
      }

      function onend() {
        debug$7('onend');
        dest.end();
      } // when the dest drains, it reduces the awaitDrain counter
      // on the source.  This would be more elegant with a .once()
      // handler in flow(), but adding and removing repeatedly is
      // too slow.


      var ondrain = pipeOnDrain(src);
      dest.on('drain', ondrain);
      var cleanedUp = false;

      function cleanup() {
        debug$7('cleanup'); // cleanup event handlers once the pipe is broken

        dest.removeListener('close', onclose);
        dest.removeListener('finish', onfinish);
        dest.removeListener('drain', ondrain);
        dest.removeListener('error', onerror);
        dest.removeListener('unpipe', onunpipe);
        src.removeListener('end', onend);
        src.removeListener('end', unpipe);
        src.removeListener('data', ondata);
        cleanedUp = true; // if the reader is waiting for a drain event from this
        // specific writer, then it would cause it to never start
        // flowing again.
        // So, if this is awaiting a drain, then we just call it now.
        // If we don't know, then assume that we are waiting for one.

        if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
      }

      src.on('data', ondata);

      function ondata(chunk) {
        debug$7('ondata');
        var ret = dest.write(chunk);
        debug$7('dest.write', ret);

        if (ret === false) {
          // If the user unpiped during `dest.write()`, it is possible
          // to get stuck in a permanently paused state if that write
          // also returned false.
          // => Check whether `dest` is still a piping destination.
          if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
            debug$7('false write response, pause', state.awaitDrain);
            state.awaitDrain++;
          }

          src.pause();
        }
      } // if the dest has an error, then stop piping into it.
      // however, don't suppress the throwing behavior for this.


      function onerror(er) {
        debug$7('onerror', er);
        unpipe();
        dest.removeListener('error', onerror);
        if (EElistenerCount(dest, 'error') === 0) errorOrDestroy(dest, er);
      } // Make sure our error handler is attached before userland ones.


      prependListener(dest, 'error', onerror); // Both close and finish should trigger unpipe, but only once.

      function onclose() {
        dest.removeListener('finish', onfinish);
        unpipe();
      }

      dest.once('close', onclose);

      function onfinish() {
        debug$7('onfinish');
        dest.removeListener('close', onclose);
        unpipe();
      }

      dest.once('finish', onfinish);

      function unpipe() {
        debug$7('unpipe');
        src.unpipe(dest);
      } // tell the dest that it's being piped to


      dest.emit('pipe', src); // start the flow if it hasn't been started already.

      if (!state.flowing) {
        debug$7('pipe resume');
        src.resume();
      }

      return dest;
    };

    function pipeOnDrain(src) {
      return function pipeOnDrainFunctionResult() {
        var state = src._readableState;
        debug$7('pipeOnDrain', state.awaitDrain);
        if (state.awaitDrain) state.awaitDrain--;

        if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
          state.flowing = true;
          flow(src);
        }
      };
    }

    Readable.prototype.unpipe = function (dest) {
      var state = this._readableState;
      var unpipeInfo = {
        hasUnpiped: false
      }; // if we're not piping anywhere, then do nothing.

      if (state.pipesCount === 0) return this; // just one destination.  most common case.

      if (state.pipesCount === 1) {
        // passed in one, but it's not the right one.
        if (dest && dest !== state.pipes) return this;
        if (!dest) dest = state.pipes; // got a match.

        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        if (dest) dest.emit('unpipe', this, unpipeInfo);
        return this;
      } // slow case. multiple pipe destinations.


      if (!dest) {
        // remove all.
        var dests = state.pipes;
        var len = state.pipesCount;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;

        for (var i = 0; i < len; i++) {
          dests[i].emit('unpipe', this, {
            hasUnpiped: false
          });
        }

        return this;
      } // try to find the right one.


      var index = indexOf(state.pipes, dest);
      if (index === -1) return this;
      state.pipes.splice(index, 1);
      state.pipesCount -= 1;
      if (state.pipesCount === 1) state.pipes = state.pipes[0];
      dest.emit('unpipe', this, unpipeInfo);
      return this;
    }; // set up data events if they are asked for
    // Ensure readable listeners eventually get something


    Readable.prototype.on = function (ev, fn) {
      var res = Stream$2.prototype.on.call(this, ev, fn);
      var state = this._readableState;

      if (ev === 'data') {
        // update readableListening so that resume() may be a no-op
        // a few lines down. This is needed to support once('readable').
        state.readableListening = this.listenerCount('readable') > 0; // Try start flowing on next tick if stream isn't explicitly paused

        if (state.flowing !== false) this.resume();
      } else if (ev === 'readable') {
        if (!state.endEmitted && !state.readableListening) {
          state.readableListening = state.needReadable = true;
          state.flowing = false;
          state.emittedReadable = false;
          debug$7('on readable', state.length, state.reading);

          if (state.length) {
            emitReadable(this);
          } else if (!state.reading) {
            process.nextTick(nReadingNextTick, this);
          }
        }
      }

      return res;
    };

    Readable.prototype.addListener = Readable.prototype.on;

    Readable.prototype.removeListener = function (ev, fn) {
      var res = Stream$2.prototype.removeListener.call(this, ev, fn);

      if (ev === 'readable') {
        // We need to check if there is someone still listening to
        // readable and reset the state. However this needs to happen
        // after readable has been emitted but before I/O (nextTick) to
        // support once('readable', fn) cycles. This means that calling
        // resume within the same tick will have no
        // effect.
        process.nextTick(updateReadableListening, this);
      }

      return res;
    };

    Readable.prototype.removeAllListeners = function (ev) {
      var res = Stream$2.prototype.removeAllListeners.apply(this, arguments);

      if (ev === 'readable' || ev === undefined) {
        // We need to check if there is someone still listening to
        // readable and reset the state. However this needs to happen
        // after readable has been emitted but before I/O (nextTick) to
        // support once('readable', fn) cycles. This means that calling
        // resume within the same tick will have no
        // effect.
        process.nextTick(updateReadableListening, this);
      }

      return res;
    };

    function updateReadableListening(self) {
      var state = self._readableState;
      state.readableListening = self.listenerCount('readable') > 0;

      if (state.resumeScheduled && !state.paused) {
        // flowing needs to be set to true now, otherwise
        // the upcoming resume will not flow.
        state.flowing = true; // crude way to check if we should resume
      } else if (self.listenerCount('data') > 0) {
        self.resume();
      }
    }

    function nReadingNextTick(self) {
      debug$7('readable nexttick read 0');
      self.read(0);
    } // pause() and resume() are remnants of the legacy readable stream API
    // If the user uses them, then switch into old mode.


    Readable.prototype.resume = function () {
      var state = this._readableState;

      if (!state.flowing) {
        debug$7('resume'); // we flow only if there is no one listening
        // for readable, but we still have to call
        // resume()

        state.flowing = !state.readableListening;
        resume(this, state);
      }

      state.paused = false;
      return this;
    };

    function resume(stream, state) {
      if (!state.resumeScheduled) {
        state.resumeScheduled = true;
        process.nextTick(resume_, stream, state);
      }
    }

    function resume_(stream, state) {
      debug$7('resume', state.reading);

      if (!state.reading) {
        stream.read(0);
      }

      state.resumeScheduled = false;
      stream.emit('resume');
      flow(stream);
      if (state.flowing && !state.reading) stream.read(0);
    }

    Readable.prototype.pause = function () {
      debug$7('call pause flowing=%j', this._readableState.flowing);

      if (this._readableState.flowing !== false) {
        debug$7('pause');
        this._readableState.flowing = false;
        this.emit('pause');
      }

      this._readableState.paused = true;
      return this;
    };

    function flow(stream) {
      var state = stream._readableState;
      debug$7('flow', state.flowing);

      while (state.flowing && stream.read() !== null) {
      }
    } // wrap an old-style stream as the async data source.
    // This is *not* part of the readable stream interface.
    // It is an ugly unfortunate mess of history.


    Readable.prototype.wrap = function (stream) {
      var _this = this;

      var state = this._readableState;
      var paused = false;
      stream.on('end', function () {
        debug$7('wrapped end');

        if (state.decoder && !state.ended) {
          var chunk = state.decoder.end();
          if (chunk && chunk.length) _this.push(chunk);
        }

        _this.push(null);
      });
      stream.on('data', function (chunk) {
        debug$7('wrapped data');
        if (state.decoder) chunk = state.decoder.write(chunk); // don't skip over falsy values in objectMode

        if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;

        var ret = _this.push(chunk);

        if (!ret) {
          paused = true;
          stream.pause();
        }
      }); // proxy all the other methods.
      // important when wrapping filters and duplexes.

      for (var i in stream) {
        if (this[i] === undefined && typeof stream[i] === 'function') {
          this[i] = function methodWrap(method) {
            return function methodWrapReturnFunction() {
              return stream[method].apply(stream, arguments);
            };
          }(i);
        }
      } // proxy certain important events.


      for (var n = 0; n < kProxyEvents.length; n++) {
        stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
      } // when we try to consume some more bytes, simply unpause the
      // underlying stream.


      this._read = function (n) {
        debug$7('wrapped _read', n);

        if (paused) {
          paused = false;
          stream.resume();
        }
      };

      return this;
    };

    if (typeof Symbol === 'function') {
      Readable.prototype[Symbol.asyncIterator] = function () {
        if (createReadableStreamAsyncIterator === undefined) {
          createReadableStreamAsyncIterator = async_iterator;
        }

        return createReadableStreamAsyncIterator(this);
      };
    }

    Object.defineProperty(Readable.prototype, 'readableHighWaterMark', {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._readableState.highWaterMark;
      }
    });
    Object.defineProperty(Readable.prototype, 'readableBuffer', {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._readableState && this._readableState.buffer;
      }
    });
    Object.defineProperty(Readable.prototype, 'readableFlowing', {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._readableState.flowing;
      },
      set: function set(state) {
        if (this._readableState) {
          this._readableState.flowing = state;
        }
      }
    }); // exposed for testing purposes only.

    Readable._fromList = fromList;
    Object.defineProperty(Readable.prototype, 'readableLength', {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._readableState.length;
      }
    }); // Pluck off n bytes from an array of buffers.
    // Length is the combined lengths of all the buffers in the list.
    // This function is designed to be inlinable, so please take care when making
    // changes to the function body.

    function fromList(n, state) {
      // nothing buffered
      if (state.length === 0) return null;
      var ret;
      if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
        // read it all, truncate the list
        if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.first();else ret = state.buffer.concat(state.length);
        state.buffer.clear();
      } else {
        // read part of list
        ret = state.buffer.consume(n, state.decoder);
      }
      return ret;
    }

    function endReadable(stream) {
      var state = stream._readableState;
      debug$7('endReadable', state.endEmitted);

      if (!state.endEmitted) {
        state.ended = true;
        process.nextTick(endReadableNT, state, stream);
      }
    }

    function endReadableNT(state, stream) {
      debug$7('endReadableNT', state.endEmitted, state.length); // Check that we didn't get one last unshift.

      if (!state.endEmitted && state.length === 0) {
        state.endEmitted = true;
        stream.readable = false;
        stream.emit('end');

        if (state.autoDestroy) {
          // In case of duplex streams we need a way to detect
          // if the writable side is ready for autoDestroy as well
          var wState = stream._writableState;

          if (!wState || wState.autoDestroy && wState.finished) {
            stream.destroy();
          }
        }
      }
    }

    if (typeof Symbol === 'function') {
      Readable.from = function (iterable, opts) {
        if (from$3 === undefined) {
          from$3 = from_1;
        }

        return from$3(Readable, iterable, opts);
      };
    }

    function indexOf(xs, x) {
      for (var i = 0, l = xs.length; i < l; i++) {
        if (xs[i] === x) return i;
      }

      return -1;
    }

    var _stream_transform = Transform$2;

    var _require$codes$1 = errors.codes,
        ERR_METHOD_NOT_IMPLEMENTED = _require$codes$1.ERR_METHOD_NOT_IMPLEMENTED,
        ERR_MULTIPLE_CALLBACK = _require$codes$1.ERR_MULTIPLE_CALLBACK,
        ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes$1.ERR_TRANSFORM_ALREADY_TRANSFORMING,
        ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes$1.ERR_TRANSFORM_WITH_LENGTH_0;

    var Duplex = _stream_duplex;

    inherits$2.exports(Transform$2, Duplex);

    function afterTransform(er, data) {
      var ts = this._transformState;
      ts.transforming = false;
      var cb = ts.writecb;

      if (cb === null) {
        return this.emit('error', new ERR_MULTIPLE_CALLBACK());
      }

      ts.writechunk = null;
      ts.writecb = null;
      if (data != null) // single equals check for both `null` and `undefined`
        this.push(data);
      cb(er);
      var rs = this._readableState;
      rs.reading = false;

      if (rs.needReadable || rs.length < rs.highWaterMark) {
        this._read(rs.highWaterMark);
      }
    }

    function Transform$2(options) {
      if (!(this instanceof Transform$2)) return new Transform$2(options);
      Duplex.call(this, options);
      this._transformState = {
        afterTransform: afterTransform.bind(this),
        needTransform: false,
        transforming: false,
        writecb: null,
        writechunk: null,
        writeencoding: null
      }; // start out asking for a readable event once data is transformed.

      this._readableState.needReadable = true; // we have implemented the _read method, and done the other things
      // that Readable wants before the first _read call, so unset the
      // sync guard flag.

      this._readableState.sync = false;

      if (options) {
        if (typeof options.transform === 'function') this._transform = options.transform;
        if (typeof options.flush === 'function') this._flush = options.flush;
      } // When the writable side finishes, then flush out anything remaining.


      this.on('prefinish', prefinish);
    }

    function prefinish() {
      var _this = this;

      if (typeof this._flush === 'function' && !this._readableState.destroyed) {
        this._flush(function (er, data) {
          done(_this, er, data);
        });
      } else {
        done(this, null, null);
      }
    }

    Transform$2.prototype.push = function (chunk, encoding) {
      this._transformState.needTransform = false;
      return Duplex.prototype.push.call(this, chunk, encoding);
    }; // This is the part where you do stuff!
    // override this function in implementation classes.
    // 'chunk' is an input chunk.
    //
    // Call `push(newChunk)` to pass along transformed output
    // to the readable side.  You may call 'push' zero or more times.
    //
    // Call `cb(err)` when you are done with this chunk.  If you pass
    // an error, then that'll put the hurt on the whole operation.  If you
    // never call cb(), then you'll never get another chunk.


    Transform$2.prototype._transform = function (chunk, encoding, cb) {
      cb(new ERR_METHOD_NOT_IMPLEMENTED('_transform()'));
    };

    Transform$2.prototype._write = function (chunk, encoding, cb) {
      var ts = this._transformState;
      ts.writecb = cb;
      ts.writechunk = chunk;
      ts.writeencoding = encoding;

      if (!ts.transforming) {
        var rs = this._readableState;
        if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
      }
    }; // Doesn't matter what the args are here.
    // _transform does all the work.
    // That we got here means that the readable side wants more data.


    Transform$2.prototype._read = function (n) {
      var ts = this._transformState;

      if (ts.writechunk !== null && !ts.transforming) {
        ts.transforming = true;

        this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
      } else {
        // mark that we need a transform, so that any data that comes in
        // will get processed, now that we've asked for it.
        ts.needTransform = true;
      }
    };

    Transform$2.prototype._destroy = function (err, cb) {
      Duplex.prototype._destroy.call(this, err, function (err2) {
        cb(err2);
      });
    };

    function done(stream, er, data) {
      if (er) return stream.emit('error', er);
      if (data != null) // single equals check for both `null` and `undefined`
        stream.push(data); // TODO(BridgeAR): Write a test for these two error cases
      // if there's nothing in the write buffer, then that means
      // that nothing more will ever be provided

      if (stream._writableState.length) throw new ERR_TRANSFORM_WITH_LENGTH_0();
      if (stream._transformState.transforming) throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
      return stream.push(null);
    }

    var _stream_passthrough = PassThrough;

    var Transform$1 = _stream_transform;

    inherits$2.exports(PassThrough, Transform$1);

    function PassThrough(options) {
      if (!(this instanceof PassThrough)) return new PassThrough(options);
      Transform$1.call(this, options);
    }

    PassThrough.prototype._transform = function (chunk, encoding, cb) {
      cb(null, chunk);
    };

    var eos;

    function once$4(callback) {
      var called = false;
      return function () {
        if (called) return;
        called = true;
        callback.apply(void 0, arguments);
      };
    }

    var _require$codes = errors.codes,
        ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS,
        ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;

    function noop$5(err) {
      // Rethrow the error if it exists to avoid swallowing it
      if (err) throw err;
    }

    function isRequest(stream) {
      return stream.setHeader && typeof stream.abort === 'function';
    }

    function destroyer(stream, reading, writing, callback) {
      callback = once$4(callback);
      var closed = false;
      stream.on('close', function () {
        closed = true;
      });
      if (eos === undefined) eos = endOfStream;
      eos(stream, {
        readable: reading,
        writable: writing
      }, function (err) {
        if (err) return callback(err);
        closed = true;
        callback();
      });
      var destroyed = false;
      return function (err) {
        if (closed) return;
        if (destroyed) return;
        destroyed = true; // request.destroy just do .end - .abort is what we want

        if (isRequest(stream)) return stream.abort();
        if (typeof stream.destroy === 'function') return stream.destroy();
        callback(err || new ERR_STREAM_DESTROYED('pipe'));
      };
    }

    function call(fn) {
      fn();
    }

    function pipe$2(from, to) {
      return from.pipe(to);
    }

    function popCallback(streams) {
      if (!streams.length) return noop$5;
      if (typeof streams[streams.length - 1] !== 'function') return noop$5;
      return streams.pop();
    }

    function pipeline() {
      for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
        streams[_key] = arguments[_key];
      }

      var callback = popCallback(streams);
      if (Array.isArray(streams[0])) streams = streams[0];

      if (streams.length < 2) {
        throw new ERR_MISSING_ARGS('streams');
      }

      var error;
      var destroys = streams.map(function (stream, i) {
        var reading = i < streams.length - 1;
        var writing = i > 0;
        return destroyer(stream, reading, writing, function (err) {
          if (!error) error = err;
          if (err) destroys.forEach(call);
          if (reading) return;
          destroys.forEach(call);
          callback(error);
        });
      });
      return streams.reduce(pipe$2);
    }

    var pipeline_1 = pipeline;

    (function (module, exports) {
    var Stream = require$$0__default$2["default"];
    if (process.env.READABLE_STREAM === 'disable' && Stream) {
      module.exports = Stream.Readable;
      Object.assign(module.exports, Stream);
      module.exports.Stream = Stream;
    } else {
      exports = module.exports = _stream_readable;
      exports.Stream = Stream || exports;
      exports.Readable = exports;
      exports.Writable = _stream_writable;
      exports.Duplex = _stream_duplex;
      exports.Transform = _stream_transform;
      exports.PassThrough = _stream_passthrough;
      exports.finished = endOfStream;
      exports.pipeline = pipeline_1;
    }
    }(readable, readable.exports));

    /**
     * Expose `Delegator`.
     */

    var delegates = Delegator;

    /**
     * Initialize a delegator.
     *
     * @param {Object} proto
     * @param {String} target
     * @api public
     */

    function Delegator(proto, target) {
      if (!(this instanceof Delegator)) return new Delegator(proto, target);
      this.proto = proto;
      this.target = target;
      this.methods = [];
      this.getters = [];
      this.setters = [];
      this.fluents = [];
    }

    /**
     * Delegate method `name`.
     *
     * @param {String} name
     * @return {Delegator} self
     * @api public
     */

    Delegator.prototype.method = function(name){
      var proto = this.proto;
      var target = this.target;
      this.methods.push(name);

      proto[name] = function(){
        return this[target][name].apply(this[target], arguments);
      };

      return this;
    };

    /**
     * Delegator accessor `name`.
     *
     * @param {String} name
     * @return {Delegator} self
     * @api public
     */

    Delegator.prototype.access = function(name){
      return this.getter(name).setter(name);
    };

    /**
     * Delegator getter `name`.
     *
     * @param {String} name
     * @return {Delegator} self
     * @api public
     */

    Delegator.prototype.getter = function(name){
      var proto = this.proto;
      var target = this.target;
      this.getters.push(name);

      proto.__defineGetter__(name, function(){
        return this[target][name];
      });

      return this;
    };

    /**
     * Delegator setter `name`.
     *
     * @param {String} name
     * @return {Delegator} self
     * @api public
     */

    Delegator.prototype.setter = function(name){
      var proto = this.proto;
      var target = this.target;
      this.setters.push(name);

      proto.__defineSetter__(name, function(val){
        return this[target][name] = val;
      });

      return this;
    };

    /**
     * Delegator fluent accessor
     *
     * @param {String} name
     * @return {Delegator} self
     * @api public
     */

    Delegator.prototype.fluent = function (name) {
      var proto = this.proto;
      var target = this.target;
      this.fluents.push(name);

      proto[name] = function(val){
        if ('undefined' != typeof val) {
          this[target][name] = val;
          return this;
        } else {
          return this[target][name];
        }
      };

      return this;
    };

    var util$6 = require$$0__default$1["default"];
    var stream = readable.exports;
    var delegate = delegates;
    var Tracker$1 = tracker.exports;

    var TrackerStream$1 = trackerStream.exports = function (name, size, options) {
      stream.Transform.call(this, options);
      this.tracker = new Tracker$1(name, size);
      this.name = name;
      this.id = this.tracker.id;
      this.tracker.on('change', delegateChange(this));
    };
    util$6.inherits(TrackerStream$1, stream.Transform);

    function delegateChange (trackerStream) {
      return function (name, completion, tracker) {
        trackerStream.emit('change', name, completion, trackerStream);
      }
    }

    TrackerStream$1.prototype._transform = function (data, encoding, cb) {
      this.tracker.completeWork(data.length ? data.length : 1);
      this.push(data);
      cb();
    };

    TrackerStream$1.prototype._flush = function (cb) {
      this.tracker.finish();
      cb();
    };

    delegate(TrackerStream$1.prototype, 'tracker')
      .method('completed')
      .method('addWork')
      .method('finish');

    var util$5 = require$$0__default$1["default"];
    var TrackerBase = trackerBase.exports;
    var Tracker = tracker.exports;
    var TrackerStream = trackerStream.exports;

    var TrackerGroup = trackerGroup.exports = function (name) {
      TrackerBase.call(this, name);
      this.parentGroup = null;
      this.trackers = [];
      this.completion = {};
      this.weight = {};
      this.totalWeight = 0;
      this.finished = false;
      this.bubbleChange = bubbleChange(this);
    };
    util$5.inherits(TrackerGroup, TrackerBase);

    function bubbleChange (trackerGroup) {
      return function (name, completed, tracker) {
        trackerGroup.completion[tracker.id] = completed;
        if (trackerGroup.finished) {
          return
        }
        trackerGroup.emit('change', name || trackerGroup.name, trackerGroup.completed(), trackerGroup);
      }
    }

    TrackerGroup.prototype.nameInTree = function () {
      var names = [];
      var from = this;
      while (from) {
        names.unshift(from.name);
        from = from.parentGroup;
      }
      return names.join('/')
    };

    TrackerGroup.prototype.addUnit = function (unit, weight) {
      if (unit.addUnit) {
        var toTest = this;
        while (toTest) {
          if (unit === toTest) {
            throw new Error(
              'Attempted to add tracker group ' +
              unit.name + ' to tree that already includes it ' +
              this.nameInTree(this))
          }
          toTest = toTest.parentGroup;
        }
        unit.parentGroup = this;
      }
      this.weight[unit.id] = weight || 1;
      this.totalWeight += this.weight[unit.id];
      this.trackers.push(unit);
      this.completion[unit.id] = unit.completed();
      unit.on('change', this.bubbleChange);
      if (!this.finished) {
        this.emit('change', unit.name, this.completion[unit.id], unit);
      }
      return unit
    };

    TrackerGroup.prototype.completed = function () {
      if (this.trackers.length === 0) {
        return 0
      }
      var valPerWeight = 1 / this.totalWeight;
      var completed = 0;
      for (var ii = 0; ii < this.trackers.length; ii++) {
        var trackerId = this.trackers[ii].id;
        completed +=
          valPerWeight * this.weight[trackerId] * this.completion[trackerId];
      }
      return completed
    };

    TrackerGroup.prototype.newGroup = function (name, weight) {
      return this.addUnit(new TrackerGroup(name), weight)
    };

    TrackerGroup.prototype.newItem = function (name, todo, weight) {
      return this.addUnit(new Tracker(name, todo), weight)
    };

    TrackerGroup.prototype.newStream = function (name, todo, weight) {
      return this.addUnit(new TrackerStream(name, todo), weight)
    };

    TrackerGroup.prototype.finish = function () {
      this.finished = true;
      if (!this.trackers.length) {
        this.addUnit(new Tracker(), 1, true);
      }
      for (var ii = 0; ii < this.trackers.length; ii++) {
        var tracker = this.trackers[ii];
        tracker.finish();
        tracker.removeListener('change', this.bubbleChange);
      }
      this.emit('change', this.name, 1, this);
    };

    var buffer$2 = '                                  ';
    TrackerGroup.prototype.debug = function (depth) {
      depth = depth || 0;
      var indent = depth ? buffer$2.substr(0, depth) : '';
      var output = indent + (this.name || 'top') + ': ' + this.completed() + '\n';
      this.trackers.forEach(function (tracker) {
        if (tracker instanceof TrackerGroup) {
          output += tracker.debug(depth + 1);
        } else {
          output += indent + ' ' + tracker.name + ': ' + tracker.completed() + '\n';
        }
      });
      return output
    };

    lib$2.TrackerGroup = trackerGroup.exports;
    lib$2.Tracker = tracker.exports;
    lib$2.TrackerStream = trackerStream.exports;

    var plumbing = {exports: {}};

    var consoleControlStrings = {};

    // These tables borrowed from `ansi`

    var prefix = '\x1b[';

    consoleControlStrings.up = function up (num) {
      return prefix + (num || '') + 'A'
    };

    consoleControlStrings.down = function down (num) {
      return prefix + (num || '') + 'B'
    };

    consoleControlStrings.forward = function forward (num) {
      return prefix + (num || '') + 'C'
    };

    consoleControlStrings.back = function back (num) {
      return prefix + (num || '') + 'D'
    };

    consoleControlStrings.nextLine = function nextLine (num) {
      return prefix + (num || '') + 'E'
    };

    consoleControlStrings.previousLine = function previousLine (num) {
      return prefix + (num || '') + 'F'
    };

    consoleControlStrings.horizontalAbsolute = function horizontalAbsolute (num) {
      if (num == null) throw new Error('horizontalAboslute requires a column to position to')
      return prefix + num + 'G'
    };

    consoleControlStrings.eraseData = function eraseData () {
      return prefix + 'J'
    };

    consoleControlStrings.eraseLine = function eraseLine () {
      return prefix + 'K'
    };

    consoleControlStrings.goto = function (x, y) {
      return prefix + y + ';' + x + 'H'
    };

    consoleControlStrings.gotoSOL = function () {
      return '\r'
    };

    consoleControlStrings.beep = function () {
      return '\x07'
    };

    consoleControlStrings.hideCursor = function hideCursor () {
      return prefix + '?25l'
    };

    consoleControlStrings.showCursor = function showCursor () {
      return prefix + '?25h'
    };

    var colors = {
      reset: 0,
    // styles
      bold: 1,
      italic: 3,
      underline: 4,
      inverse: 7,
    // resets
      stopBold: 22,
      stopItalic: 23,
      stopUnderline: 24,
      stopInverse: 27,
    // colors
      white: 37,
      black: 30,
      blue: 34,
      cyan: 36,
      green: 32,
      magenta: 35,
      red: 31,
      yellow: 33,
      bgWhite: 47,
      bgBlack: 40,
      bgBlue: 44,
      bgCyan: 46,
      bgGreen: 42,
      bgMagenta: 45,
      bgRed: 41,
      bgYellow: 43,

      grey: 90,
      brightBlack: 90,
      brightRed: 91,
      brightGreen: 92,
      brightYellow: 93,
      brightBlue: 94,
      brightMagenta: 95,
      brightCyan: 96,
      brightWhite: 97,

      bgGrey: 100,
      bgBrightBlack: 100,
      bgBrightRed: 101,
      bgBrightGreen: 102,
      bgBrightYellow: 103,
      bgBrightBlue: 104,
      bgBrightMagenta: 105,
      bgBrightCyan: 106,
      bgBrightWhite: 107
    };

    consoleControlStrings.color = function color (colorWith) {
      if (arguments.length !== 1 || !Array.isArray(colorWith)) {
        colorWith = Array.prototype.slice.call(arguments);
      }
      return prefix + colorWith.map(colorNameToCode).join(';') + 'm'
    };

    function colorNameToCode (color) {
      if (colors[color] != null) return colors[color]
      throw new Error('Unknown color or style name: ' + color)
    }

    var renderTemplate$3 = {exports: {}};

    var align$1 = {};

    var ansiRegex$3 = () => {
    	const pattern = [
    		'[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:[a-zA-Z\\d]*(?:;[a-zA-Z\\d]*)*)?\\u0007)',
    		'(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PRZcf-ntqry=><~]))'
    	].join('|');

    	return new RegExp(pattern, 'g');
    };

    const ansiRegex$2 = ansiRegex$3;

    var stripAnsi$6 = input => typeof input === 'string' ? input.replace(ansiRegex$2(), '') : input;

    /* eslint-disable yoda */
    var isFullwidthCodePoint$4 = x => {
    	if (Number.isNaN(x)) {
    		return false;
    	}

    	// code points are derived from:
    	// http://www.unix.org/Public/UNIDATA/EastAsianWidth.txt
    	if (
    		x >= 0x1100 && (
    			x <= 0x115f ||  // Hangul Jamo
    			x === 0x2329 || // LEFT-POINTING ANGLE BRACKET
    			x === 0x232a || // RIGHT-POINTING ANGLE BRACKET
    			// CJK Radicals Supplement .. Enclosed CJK Letters and Months
    			(0x2e80 <= x && x <= 0x3247 && x !== 0x303f) ||
    			// Enclosed CJK Letters and Months .. CJK Unified Ideographs Extension A
    			(0x3250 <= x && x <= 0x4dbf) ||
    			// CJK Unified Ideographs .. Yi Radicals
    			(0x4e00 <= x && x <= 0xa4c6) ||
    			// Hangul Jamo Extended-A
    			(0xa960 <= x && x <= 0xa97c) ||
    			// Hangul Syllables
    			(0xac00 <= x && x <= 0xd7a3) ||
    			// CJK Compatibility Ideographs
    			(0xf900 <= x && x <= 0xfaff) ||
    			// Vertical Forms
    			(0xfe10 <= x && x <= 0xfe19) ||
    			// CJK Compatibility Forms .. Small Form Variants
    			(0xfe30 <= x && x <= 0xfe6b) ||
    			// Halfwidth and Fullwidth Forms
    			(0xff01 <= x && x <= 0xff60) ||
    			(0xffe0 <= x && x <= 0xffe6) ||
    			// Kana Supplement
    			(0x1b000 <= x && x <= 0x1b001) ||
    			// Enclosed Ideographic Supplement
    			(0x1f200 <= x && x <= 0x1f251) ||
    			// CJK Unified Ideographs Extension B .. Tertiary Ideographic Plane
    			(0x20000 <= x && x <= 0x3fffd)
    		)
    	) {
    		return true;
    	}

    	return false;
    };

    const stripAnsi$5 = stripAnsi$6;
    const isFullwidthCodePoint$3 = isFullwidthCodePoint$4;

    var stringWidth$7 = str => {
    	if (typeof str !== 'string' || str.length === 0) {
    		return 0;
    	}

    	str = stripAnsi$5(str);

    	let width = 0;

    	for (let i = 0; i < str.length; i++) {
    		const code = str.codePointAt(i);

    		// Ignore control characters
    		if (code <= 0x1F || (code >= 0x7F && code <= 0x9F)) {
    			continue;
    		}

    		// Ignore combining characters
    		if (code >= 0x300 && code <= 0x36F) {
    			continue;
    		}

    		// Surrogates
    		if (code > 0xFFFF) {
    			i++;
    		}

    		width += isFullwidthCodePoint$3(code) ? 2 : 1;
    	}

    	return width;
    };

    var stringWidth$6 = stringWidth$7;

    align$1.center = alignCenter;
    align$1.left = alignLeft;
    align$1.right = alignRight;

    // lodash's way of generating pad characters.

    function createPadding (width) {
      var result = '';
      var string = ' ';
      var n = width;
      do {
        if (n % 2) {
          result += string;
        }
        n = Math.floor(n / 2);
        string += string;
      } while (n);

      return result;
    }

    function alignLeft (str, width) {
      var trimmed = str.trimRight();
      if (trimmed.length === 0 && str.length >= width) return str
      var padding = '';
      var strWidth = stringWidth$6(trimmed);

      if (strWidth < width) {
        padding = createPadding(width - strWidth);
      }

      return trimmed + padding
    }

    function alignRight (str, width) {
      var trimmed = str.trimLeft();
      if (trimmed.length === 0 && str.length >= width) return str
      var padding = '';
      var strWidth = stringWidth$6(trimmed);

      if (strWidth < width) {
        padding = createPadding(width - strWidth);
      }

      return padding + trimmed
    }

    function alignCenter (str, width) {
      var trimmed = str.trim();
      if (trimmed.length === 0 && str.length >= width) return str
      var padLeft = '';
      var padRight = '';
      var strWidth = stringWidth$6(trimmed);

      if (strWidth < width) {
        var padLeftBy = parseInt((width - strWidth) / 2, 10); 
        padLeft = createPadding(padLeftBy);
        padRight = createPadding(width - (strWidth + padLeftBy));
      }

      return padLeft + trimmed + padRight
    }

    var aproba = validate$3;

    function isArguments$4 (thingy) {
      return thingy != null && typeof thingy === 'object' && thingy.hasOwnProperty('callee')
    }

    const types = {
      '*': {label: 'any', check: () => true},
      A: {label: 'array', check: _ => Array.isArray(_) || isArguments$4(_)},
      S: {label: 'string', check: _ => typeof _ === 'string'},
      N: {label: 'number', check: _ => typeof _ === 'number'},
      F: {label: 'function', check: _ => typeof _ === 'function'},
      O: {label: 'object', check: _ => typeof _ === 'object' && _ != null && !types.A.check(_) && !types.E.check(_)},
      B: {label: 'boolean', check: _ => typeof _ === 'boolean'},
      E: {label: 'error', check: _ => _ instanceof Error},
      Z: {label: 'null', check: _ => _ == null}
    };

    function addSchema (schema, arity) {
      const group = arity[schema.length] = arity[schema.length] || [];
      if (group.indexOf(schema) === -1) group.push(schema);
    }

    function validate$3 (rawSchemas, args) {
      if (arguments.length !== 2) throw wrongNumberOfArgs(['SA'], arguments.length)
      if (!rawSchemas) throw missingRequiredArg(0)
      if (!args) throw missingRequiredArg(1)
      if (!types.S.check(rawSchemas)) throw invalidType(0, ['string'], rawSchemas)
      if (!types.A.check(args)) throw invalidType(1, ['array'], args)
      const schemas = rawSchemas.split('|');
      const arity = {};

      schemas.forEach(schema => {
        for (let ii = 0; ii < schema.length; ++ii) {
          const type = schema[ii];
          if (!types[type]) throw unknownType(ii, type)
        }
        if (/E.*E/.test(schema)) throw moreThanOneError(schema)
        addSchema(schema, arity);
        if (/E/.test(schema)) {
          addSchema(schema.replace(/E.*$/, 'E'), arity);
          addSchema(schema.replace(/E/, 'Z'), arity);
          if (schema.length === 1) addSchema('', arity);
        }
      });
      let matching = arity[args.length];
      if (!matching) {
        throw wrongNumberOfArgs(Object.keys(arity), args.length)
      }
      for (let ii = 0; ii < args.length; ++ii) {
        let newMatching = matching.filter(schema => {
          const type = schema[ii];
          const typeCheck = types[type].check;
          return typeCheck(args[ii])
        });
        if (!newMatching.length) {
          const labels = matching.map(_ => types[_[ii]].label).filter(_ => _ != null);
          throw invalidType(ii, labels, args[ii])
        }
        matching = newMatching;
      }
    }

    function missingRequiredArg (num) {
      return newException('EMISSINGARG', 'Missing required argument #' + (num + 1))
    }

    function unknownType (num, type) {
      return newException('EUNKNOWNTYPE', 'Unknown type ' + type + ' in argument #' + (num + 1))
    }

    function invalidType (num, expectedTypes, value) {
      let valueType;
      Object.keys(types).forEach(typeCode => {
        if (types[typeCode].check(value)) valueType = types[typeCode].label;
      });
      return newException('EINVALIDTYPE', 'Argument #' + (num + 1) + ': Expected ' +
        englishList(expectedTypes) + ' but got ' + valueType)
    }

    function englishList (list) {
      return list.join(', ').replace(/, ([^,]+)$/, ' or $1')
    }

    function wrongNumberOfArgs (expected, got) {
      const english = englishList(expected);
      const args = expected.every(ex => ex.length === 1)
        ? 'argument'
        : 'arguments';
      return newException('EWRONGARGCOUNT', 'Expected ' + english + ' ' + args + ' but got ' + got)
    }

    function moreThanOneError (schema) {
      return newException('ETOOMANYERRORTYPES',
        'Only one error type per argument signature is allowed, more than one found in "' + schema + '"')
    }

    function newException (code, msg) {
      const err = new Error(msg);
      err.code = code;
      /* istanbul ignore else */
      if (Error.captureStackTrace) Error.captureStackTrace(err, validate$3);
      return err
    }

    var stringWidth$5 = stringWidth$7;
    var stripAnsi$4 = stripAnsi$6;

    var wideTruncate_1 = wideTruncate$2;

    function wideTruncate$2 (str, target) {
      if (stringWidth$5(str) === 0) return str
      if (target <= 0) return ''
      if (stringWidth$5(str) <= target) return str

      // We compute the number of bytes of ansi sequences here and add
      // that to our initial truncation to ensure that we don't slice one
      // that we want to keep in half.
      var noAnsi = stripAnsi$4(str);
      var ansiSize = str.length + noAnsi.length;
      var truncated = str.slice(0, target + ansiSize);

      // we have to shrink the result to account for our ansi sequence buffer
      // (if an ansi sequence was truncated) and double width characters.
      while (stringWidth$5(truncated) > target) {
        truncated = truncated.slice(0, -1);
      }
      return truncated
    }

    var error$1 = {};

    var util$4 = require$$0__default$1["default"];

    var User = error$1.User = function User (msg) {
      var err = new Error(msg);
      Error.captureStackTrace(err, User);
      err.code = 'EGAUGE';
      return err
    };

    error$1.MissingTemplateValue = function MissingTemplateValue (item, values) {
      var err = new User(util$4.format('Missing template value "%s"', item.type));
      Error.captureStackTrace(err, MissingTemplateValue);
      err.template = item;
      err.values = values;
      return err
    };

    error$1.Internal = function Internal (msg) {
      var err = new Error(msg);
      Error.captureStackTrace(err, Internal);
      err.code = 'EGAUGEINTERNAL';
      return err
    };

    var stringWidth$4 = stringWidth$7;

    var templateItem = TemplateItem$1;

    function isPercent (num) {
      if (typeof num !== 'string') return false
      return num.slice(-1) === '%'
    }

    function percent (num) {
      return Number(num.slice(0, -1)) / 100
    }

    function TemplateItem$1 (values, outputLength) {
      this.overallOutputLength = outputLength;
      this.finished = false;
      this.type = null;
      this.value = null;
      this.length = null;
      this.maxLength = null;
      this.minLength = null;
      this.kerning = null;
      this.align = 'left';
      this.padLeft = 0;
      this.padRight = 0;
      this.index = null;
      this.first = null;
      this.last = null;
      if (typeof values === 'string') {
        this.value = values;
      } else {
        for (var prop in values) this[prop] = values[prop];
      }
      // Realize percents
      if (isPercent(this.length)) {
        this.length = Math.round(this.overallOutputLength * percent(this.length));
      }
      if (isPercent(this.minLength)) {
        this.minLength = Math.round(this.overallOutputLength * percent(this.minLength));
      }
      if (isPercent(this.maxLength)) {
        this.maxLength = Math.round(this.overallOutputLength * percent(this.maxLength));
      }
      return this
    }

    TemplateItem$1.prototype = {};

    TemplateItem$1.prototype.getBaseLength = function () {
      var length = this.length;
      if (length == null && typeof this.value === 'string' && this.maxLength == null && this.minLength == null) {
        length = stringWidth$4(this.value);
      }
      return length
    };

    TemplateItem$1.prototype.getLength = function () {
      var length = this.getBaseLength();
      if (length == null) return null
      return length + this.padLeft + this.padRight
    };

    TemplateItem$1.prototype.getMaxLength = function () {
      if (this.maxLength == null) return null
      return this.maxLength + this.padLeft + this.padRight
    };

    TemplateItem$1.prototype.getMinLength = function () {
      if (this.minLength == null) return null
      return this.minLength + this.padLeft + this.padRight
    };

    var align = align$1;
    var validate$2 = aproba;
    var wideTruncate$1 = wideTruncate_1;
    var error = error$1;
    var TemplateItem = templateItem;

    function renderValueWithValues (values) {
      return function (item) {
        return renderValue(item, values)
      }
    }

    var renderTemplate$2 = renderTemplate$3.exports = function (width, template, values) {
      var items = prepareItems(width, template, values);
      var rendered = items.map(renderValueWithValues(values)).join('');
      return align.left(wideTruncate$1(rendered, width), width)
    };

    function preType (item) {
      var cappedTypeName = item.type[0].toUpperCase() + item.type.slice(1);
      return 'pre' + cappedTypeName
    }

    function postType (item) {
      var cappedTypeName = item.type[0].toUpperCase() + item.type.slice(1);
      return 'post' + cappedTypeName
    }

    function hasPreOrPost (item, values) {
      if (!item.type) return
      return values[preType(item)] || values[postType(item)]
    }

    function generatePreAndPost (baseItem, parentValues) {
      var item = Object.assign({}, baseItem);
      var values = Object.create(parentValues);
      var template = [];
      var pre = preType(item);
      var post = postType(item);
      if (values[pre]) {
        template.push({value: values[pre]});
        values[pre] = null;
      }
      item.minLength = null;
      item.length = null;
      item.maxLength = null;
      template.push(item);
      values[item.type] = values[item.type];
      if (values[post]) {
        template.push({value: values[post]});
        values[post] = null;
      }
      return function ($1, $2, length) {
        return renderTemplate$2(length, template, values)
      }
    }

    function prepareItems (width, template, values) {
      function cloneAndObjectify (item, index, arr) {
        var cloned = new TemplateItem(item, width);
        var type = cloned.type;
        if (cloned.value == null) {
          if (!(type in values)) {
            if (cloned.default == null) {
              throw new error.MissingTemplateValue(cloned, values)
            } else {
              cloned.value = cloned.default;
            }
          } else {
            cloned.value = values[type];
          }
        }
        if (cloned.value == null || cloned.value === '') return null
        cloned.index = index;
        cloned.first = index === 0;
        cloned.last = index === arr.length - 1;
        if (hasPreOrPost(cloned, values)) cloned.value = generatePreAndPost(cloned, values);
        return cloned
      }

      var output = template.map(cloneAndObjectify).filter(function (item) { return item != null });

      var remainingSpace = width;
      var variableCount = output.length;

      function consumeSpace (length) {
        if (length > remainingSpace) length = remainingSpace;
        remainingSpace -= length;
      }

      function finishSizing (item, length) {
        if (item.finished) throw new error.Internal('Tried to finish template item that was already finished')
        if (length === Infinity) throw new error.Internal('Length of template item cannot be infinity')
        if (length != null) item.length = length;
        item.minLength = null;
        item.maxLength = null;
        --variableCount;
        item.finished = true;
        if (item.length == null) item.length = item.getBaseLength();
        if (item.length == null) throw new error.Internal('Finished template items must have a length')
        consumeSpace(item.getLength());
      }

      output.forEach(function (item) {
        if (!item.kerning) return
        var prevPadRight = item.first ? 0 : output[item.index - 1].padRight;
        if (!item.first && prevPadRight < item.kerning) item.padLeft = item.kerning - prevPadRight;
        if (!item.last) item.padRight = item.kerning;
      });

      // Finish any that have a fixed (literal or intuited) length
      output.forEach(function (item) {
        if (item.getBaseLength() == null) return
        finishSizing(item);
      });

      var resized = 0;
      var resizing;
      var hunkSize;
      do {
        resizing = false;
        hunkSize = Math.round(remainingSpace / variableCount);
        output.forEach(function (item) {
          if (item.finished) return
          if (!item.maxLength) return
          if (item.getMaxLength() < hunkSize) {
            finishSizing(item, item.maxLength);
            resizing = true;
          }
        });
      } while (resizing && resized++ < output.length)
      if (resizing) throw new error.Internal('Resize loop iterated too many times while determining maxLength')

      resized = 0;
      do {
        resizing = false;
        hunkSize = Math.round(remainingSpace / variableCount);
        output.forEach(function (item) {
          if (item.finished) return
          if (!item.minLength) return
          if (item.getMinLength() >= hunkSize) {
            finishSizing(item, item.minLength);
            resizing = true;
          }
        });
      } while (resizing && resized++ < output.length)
      if (resizing) throw new error.Internal('Resize loop iterated too many times while determining minLength')

      hunkSize = Math.round(remainingSpace / variableCount);
      output.forEach(function (item) {
        if (item.finished) return
        finishSizing(item, hunkSize);
      });

      return output
    }

    function renderFunction (item, values, length) {
      validate$2('OON', arguments);
      if (item.type) {
        return item.value(values, values[item.type + 'Theme'] || {}, length)
      } else {
        return item.value(values, {}, length)
      }
    }

    function renderValue (item, values) {
      var length = item.getBaseLength();
      var value = typeof item.value === 'function' ? renderFunction(item, values, length) : item.value;
      if (value == null || value === '') return ''
      var alignWith = align[item.align] || align.left;
      var leftPadding = item.padLeft ? align.left('', item.padLeft) : '';
      var rightPadding = item.padRight ? align.right('', item.padRight) : '';
      var truncated = wideTruncate$1(String(value), length);
      var aligned = alignWith(truncated, length);
      return leftPadding + aligned + rightPadding
    }

    var consoleControl = consoleControlStrings;
    var renderTemplate$1 = renderTemplate$3.exports;
    var validate$1 = aproba;

    var Plumbing$1 = plumbing.exports = function (theme, template, width) {
      if (!width) width = 80;
      validate$1('OAN', [theme, template, width]);
      this.showing = false;
      this.theme = theme;
      this.width = width;
      this.template = template;
    };
    Plumbing$1.prototype = {};

    Plumbing$1.prototype.setTheme = function (theme) {
      validate$1('O', [theme]);
      this.theme = theme;
    };

    Plumbing$1.prototype.setTemplate = function (template) {
      validate$1('A', [template]);
      this.template = template;
    };

    Plumbing$1.prototype.setWidth = function (width) {
      validate$1('N', [width]);
      this.width = width;
    };

    Plumbing$1.prototype.hide = function () {
      return consoleControl.gotoSOL() + consoleControl.eraseLine()
    };

    Plumbing$1.prototype.hideCursor = consoleControl.hideCursor;

    Plumbing$1.prototype.showCursor = consoleControl.showCursor;

    Plumbing$1.prototype.show = function (status) {
      var values = Object.create(this.theme);
      for (var key in status) {
        values[key] = status[key];
      }

      return renderTemplate$1(this.width, this.template, values).trim() +
             consoleControl.color('reset') +
             consoleControl.eraseLine() + consoleControl.gotoSOL()
    };

    var hasUnicode$1 = {exports: {}};

    var os$1 = require$$0__default$4["default"];

    hasUnicode$1.exports = function () {
      // Recent Win32 platforms (>XP) CAN support unicode in the console but
      // don't have to, and in non-english locales often use traditional local
      // code pages. There's no way, short of windows system calls or execing
      // the chcp command line program to figure this out. As such, we default
      // this to false and encourage your users to override it via config if
      // appropriate.
      if (os$1.type() == "Windows_NT") { return false }

      var isUTF8 = /UTF-?8$/i;
      var ctype = process.env.LC_ALL || process.env.LC_CTYPE || process.env.LANG;
      return isUTF8.test(ctype)
    };

    // call it on itself so we can test the export val for basic stuff
    var colorSupport_1 = colorSupport$1({ alwaysReturn: true }, colorSupport$1);

    function hasNone (obj, options) {
      obj.level = 0;
      obj.hasBasic = false;
      obj.has256 = false;
      obj.has16m = false;
      if (!options.alwaysReturn) {
        return false
      }
      return obj
    }

    function hasBasic (obj) {
      obj.hasBasic = true;
      obj.has256 = false;
      obj.has16m = false;
      obj.level = 1;
      return obj
    }

    function has256 (obj) {
      obj.hasBasic = true;
      obj.has256 = true;
      obj.has16m = false;
      obj.level = 2;
      return obj
    }

    function has16m (obj) {
      obj.hasBasic = true;
      obj.has256 = true;
      obj.has16m = true;
      obj.level = 3;
      return obj
    }

    function colorSupport$1 (options, obj) {
      options = options || {};

      obj = obj || {};

      // if just requesting a specific level, then return that.
      if (typeof options.level === 'number') {
        switch (options.level) {
          case 0:
            return hasNone(obj, options)
          case 1:
            return hasBasic(obj)
          case 2:
            return has256(obj)
          case 3:
            return has16m(obj)
        }
      }

      obj.level = 0;
      obj.hasBasic = false;
      obj.has256 = false;
      obj.has16m = false;

      if (typeof process === 'undefined' ||
          !process ||
          !process.stdout ||
          !process.env ||
          !process.platform) {
        return hasNone(obj, options)
      }

      var env = options.env || process.env;
      var stream = options.stream || process.stdout;
      var term = options.term || env.TERM || '';
      var platform = options.platform || process.platform;

      if (!options.ignoreTTY && !stream.isTTY) {
        return hasNone(obj, options)
      }

      if (!options.ignoreDumb && term === 'dumb' && !env.COLORTERM) {
        return hasNone(obj, options)
      }

      if (platform === 'win32') {
        return hasBasic(obj)
      }

      if (env.TMUX) {
        return has256(obj)
      }

      if (!options.ignoreCI && (env.CI || env.TEAMCITY_VERSION)) {
        if (env.TRAVIS) {
          return has256(obj)
        } else {
          return hasNone(obj, options)
        }
      }

      // TODO: add more term programs
      switch (env.TERM_PROGRAM) {
        case 'iTerm.app':
          var ver = env.TERM_PROGRAM_VERSION || '0.';
          if (/^[0-2]\./.test(ver)) {
            return has256(obj)
          } else {
            return has16m(obj)
          }

        case 'HyperTerm':
        case 'Hyper':
          return has16m(obj)

        case 'MacTerm':
          return has16m(obj)

        case 'Apple_Terminal':
          return has256(obj)
      }

      if (/^xterm-256/.test(term)) {
        return has256(obj)
      }

      if (/^screen|^xterm|^vt100|color|ansi|cygwin|linux/i.test(term)) {
        return hasBasic(obj)
      }

      if (env.COLORTERM) {
        return hasBasic(obj)
      }

      return hasNone(obj, options)
    }

    var colorSupport = colorSupport_1;

    var hasColor$1 = colorSupport().hasBasic;

    var signalExit$1 = {exports: {}};

    var signals$1 = {exports: {}};

    (function (module) {
    // This is not the set of all possible signals.
    //
    // It IS, however, the set of all signals that trigger
    // an exit on either Linux or BSD systems.  Linux is a
    // superset of the signal names supported on BSD, and
    // the unknown signals just fail to register, so we can
    // catch that easily enough.
    //
    // Don't bother with SIGKILL.  It's uncatchable, which
    // means that we can't fire any callbacks anyway.
    //
    // If a user does happen to register a handler on a non-
    // fatal signal like SIGWINCH or something, and then
    // exit, it'll end up firing `process.emit('exit')`, so
    // the handler will be fired anyway.
    //
    // SIGBUS, SIGFPE, SIGSEGV and SIGILL, when not raised
    // artificially, inherently leave the process in a
    // state from which it is not safe to try and enter JS
    // listeners.
    module.exports = [
      'SIGABRT',
      'SIGALRM',
      'SIGHUP',
      'SIGINT',
      'SIGTERM'
    ];

    if (process.platform !== 'win32') {
      module.exports.push(
        'SIGVTALRM',
        'SIGXCPU',
        'SIGXFSZ',
        'SIGUSR2',
        'SIGTRAP',
        'SIGSYS',
        'SIGQUIT',
        'SIGIOT'
        // should detect profiler and enable/disable accordingly.
        // see #21
        // 'SIGPROF'
      );
    }

    if (process.platform === 'linux') {
      module.exports.push(
        'SIGIO',
        'SIGPOLL',
        'SIGPWR',
        'SIGSTKFLT',
        'SIGUNUSED'
      );
    }
    }(signals$1));

    // Note: since nyc uses this module to output coverage, any lines
    // that are in the direct sync flow of nyc's outputCoverage are
    // ignored, since we can never get coverage for them.
    // grab a reference to node's real process object right away
    var process$4 = commonjsGlobal.process;

    const processOk = function (process) {
      return process &&
        typeof process === 'object' &&
        typeof process.removeListener === 'function' &&
        typeof process.emit === 'function' &&
        typeof process.reallyExit === 'function' &&
        typeof process.listeners === 'function' &&
        typeof process.kill === 'function' &&
        typeof process.pid === 'number' &&
        typeof process.on === 'function'
    };

    // some kind of non-node environment, just no-op
    /* istanbul ignore if */
    if (!processOk(process$4)) {
      signalExit$1.exports = function () {};
    } else {
      var assert$5 = require$$5__default["default"];
      var signals = signals$1.exports;
      var isWin = /^win/i.test(process$4.platform);

      var EE$1 = require$$0__default["default"];
      /* istanbul ignore if */
      if (typeof EE$1 !== 'function') {
        EE$1 = EE$1.EventEmitter;
      }

      var emitter;
      if (process$4.__signal_exit_emitter__) {
        emitter = process$4.__signal_exit_emitter__;
      } else {
        emitter = process$4.__signal_exit_emitter__ = new EE$1();
        emitter.count = 0;
        emitter.emitted = {};
      }

      // Because this emitter is a global, we have to check to see if a
      // previous version of this library failed to enable infinite listeners.
      // I know what you're about to say.  But literally everything about
      // signal-exit is a compromise with evil.  Get used to it.
      if (!emitter.infinite) {
        emitter.setMaxListeners(Infinity);
        emitter.infinite = true;
      }

      signalExit$1.exports = function (cb, opts) {
        /* istanbul ignore if */
        if (!processOk(commonjsGlobal.process)) {
          return
        }
        assert$5.equal(typeof cb, 'function', 'a callback must be provided for exit handler');

        if (loaded === false) {
          load();
        }

        var ev = 'exit';
        if (opts && opts.alwaysLast) {
          ev = 'afterexit';
        }

        var remove = function () {
          emitter.removeListener(ev, cb);
          if (emitter.listeners('exit').length === 0 &&
              emitter.listeners('afterexit').length === 0) {
            unload();
          }
        };
        emitter.on(ev, cb);

        return remove
      };

      var unload = function unload () {
        if (!loaded || !processOk(commonjsGlobal.process)) {
          return
        }
        loaded = false;

        signals.forEach(function (sig) {
          try {
            process$4.removeListener(sig, sigListeners[sig]);
          } catch (er) {}
        });
        process$4.emit = originalProcessEmit;
        process$4.reallyExit = originalProcessReallyExit;
        emitter.count -= 1;
      };
      signalExit$1.exports.unload = unload;

      var emit = function emit (event, code, signal) {
        /* istanbul ignore if */
        if (emitter.emitted[event]) {
          return
        }
        emitter.emitted[event] = true;
        emitter.emit(event, code, signal);
      };

      // { <signal>: <listener fn>, ... }
      var sigListeners = {};
      signals.forEach(function (sig) {
        sigListeners[sig] = function listener () {
          /* istanbul ignore if */
          if (!processOk(commonjsGlobal.process)) {
            return
          }
          // If there are no other listeners, an exit is coming!
          // Simplest way: remove us and then re-send the signal.
          // We know that this will kill the process, so we can
          // safely emit now.
          var listeners = process$4.listeners(sig);
          if (listeners.length === emitter.count) {
            unload();
            emit('exit', null, sig);
            /* istanbul ignore next */
            emit('afterexit', null, sig);
            /* istanbul ignore next */
            if (isWin && sig === 'SIGHUP') {
              // "SIGHUP" throws an `ENOSYS` error on Windows,
              // so use a supported signal instead
              sig = 'SIGINT';
            }
            /* istanbul ignore next */
            process$4.kill(process$4.pid, sig);
          }
        };
      });

      signalExit$1.exports.signals = function () {
        return signals
      };

      var loaded = false;

      var load = function load () {
        if (loaded || !processOk(commonjsGlobal.process)) {
          return
        }
        loaded = true;

        // This is the number of onSignalExit's that are in play.
        // It's important so that we can count the correct number of
        // listeners on signals, and don't wait for the other one to
        // handle it instead of us.
        emitter.count += 1;

        signals = signals.filter(function (sig) {
          try {
            process$4.on(sig, sigListeners[sig]);
            return true
          } catch (er) {
            return false
          }
        });

        process$4.emit = processEmit;
        process$4.reallyExit = processReallyExit;
      };
      signalExit$1.exports.load = load;

      var originalProcessReallyExit = process$4.reallyExit;
      var processReallyExit = function processReallyExit (code) {
        /* istanbul ignore if */
        if (!processOk(commonjsGlobal.process)) {
          return
        }
        process$4.exitCode = code || /* istanbul ignore next */ 0;
        emit('exit', process$4.exitCode, null);
        /* istanbul ignore next */
        emit('afterexit', process$4.exitCode, null);
        /* istanbul ignore next */
        originalProcessReallyExit.call(process$4, process$4.exitCode);
      };

      var originalProcessEmit = process$4.emit;
      var processEmit = function processEmit (ev, arg) {
        if (ev === 'exit' && processOk(commonjsGlobal.process)) {
          /* istanbul ignore else */
          if (arg !== undefined) {
            process$4.exitCode = arg;
          }
          var ret = originalProcessEmit.apply(this, arguments);
          /* istanbul ignore next */
          emit('exit', process$4.exitCode, null);
          /* istanbul ignore next */
          emit('afterexit', process$4.exitCode, null);
          /* istanbul ignore next */
          return ret
        } else {
          return originalProcessEmit.apply(this, arguments)
        }
      };
    }

    var themes$1 = {exports: {}};

    /*
    object-assign
    (c) Sindre Sorhus
    @license MIT
    */
    /* eslint-disable no-unused-vars */
    var getOwnPropertySymbols = Object.getOwnPropertySymbols;
    var hasOwnProperty$f = Object.prototype.hasOwnProperty;
    var propIsEnumerable = Object.prototype.propertyIsEnumerable;

    function toObject(val) {
    	if (val === null || val === undefined) {
    		throw new TypeError('Object.assign cannot be called with null or undefined');
    	}

    	return Object(val);
    }

    function shouldUseNative() {
    	try {
    		if (!Object.assign) {
    			return false;
    		}

    		// Detect buggy property enumeration order in older V8 versions.

    		// https://bugs.chromium.org/p/v8/issues/detail?id=4118
    		var test1 = new String('abc');  // eslint-disable-line no-new-wrappers
    		test1[5] = 'de';
    		if (Object.getOwnPropertyNames(test1)[0] === '5') {
    			return false;
    		}

    		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
    		var test2 = {};
    		for (var i = 0; i < 10; i++) {
    			test2['_' + String.fromCharCode(i)] = i;
    		}
    		var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
    			return test2[n];
    		});
    		if (order2.join('') !== '0123456789') {
    			return false;
    		}

    		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
    		var test3 = {};
    		'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
    			test3[letter] = letter;
    		});
    		if (Object.keys(Object.assign({}, test3)).join('') !==
    				'abcdefghijklmnopqrst') {
    			return false;
    		}

    		return true;
    	} catch (err) {
    		// We don't expect any of the above to throw, but better to be safe.
    		return false;
    	}
    }

    var objectAssign$1 = shouldUseNative() ? Object.assign : function (target, source) {
    	var from;
    	var to = toObject(target);
    	var symbols;

    	for (var s = 1; s < arguments.length; s++) {
    		from = Object(arguments[s]);

    		for (var key in from) {
    			if (hasOwnProperty$f.call(from, key)) {
    				to[key] = from[key];
    			}
    		}

    		if (getOwnPropertySymbols) {
    			symbols = getOwnPropertySymbols(from);
    			for (var i = 0; i < symbols.length; i++) {
    				if (propIsEnumerable.call(from, symbols[i])) {
    					to[symbols[i]] = from[symbols[i]];
    				}
    			}
    		}
    	}

    	return to;
    };

    var spin$1 = function spin (spinstr, spun) {
      return spinstr[spun % spinstr.length]
    };

    var validate = aproba;
    var renderTemplate = renderTemplate$3.exports;
    var wideTruncate = wideTruncate_1;
    var stringWidth$3 = stringWidth$7;

    var progressBar$1 = function (theme, width, completed) {
      validate('ONN', [theme, width, completed]);
      if (completed < 0) completed = 0;
      if (completed > 1) completed = 1;
      if (width <= 0) return ''
      var sofar = Math.round(width * completed);
      var rest = width - sofar;
      var template = [
        {type: 'complete', value: repeat$1(theme.complete, sofar), length: sofar},
        {type: 'remaining', value: repeat$1(theme.remaining, rest), length: rest}
      ];
      return renderTemplate(width, template, theme)
    };

    // lodash's way of repeating
    function repeat$1 (string, width) {
      var result = '';
      var n = width;
      do {
        if (n % 2) {
          result += string;
        }
        n = Math.floor(n / 2);
        /* eslint no-self-assign: 0 */
        string += string;
      } while (n && stringWidth$3(result) < width)

      return wideTruncate(result, width)
    }

    var spin = spin$1;
    var progressBar = progressBar$1;

    var baseTheme = {
      activityIndicator: function (values, theme, width) {
        if (values.spun == null) return
        return spin(theme, values.spun)
      },
      progressbar: function (values, theme, width) {
        if (values.completed == null) return
        return progressBar(theme, width, values.completed)
      }
    };

    var objectAssign = objectAssign$1;

    var themeSet = function () {
      return ThemeSetProto.newThemeSet()
    };

    var ThemeSetProto = {};

    ThemeSetProto.baseTheme = baseTheme;

    ThemeSetProto.newTheme = function (parent, theme) {
      if (!theme) {
        theme = parent;
        parent = this.baseTheme;
      }
      return objectAssign({}, parent, theme)
    };

    ThemeSetProto.getThemeNames = function () {
      return Object.keys(this.themes)
    };

    ThemeSetProto.addTheme = function (name, parent, theme) {
      this.themes[name] = this.newTheme(parent, theme);
    };

    ThemeSetProto.addToAllThemes = function (theme) {
      var themes = this.themes;
      Object.keys(themes).forEach(function (name) {
        objectAssign(themes[name], theme);
      });
      objectAssign(this.baseTheme, theme);
    };

    ThemeSetProto.getTheme = function (name) {
      if (!this.themes[name]) throw this.newMissingThemeError(name)
      return this.themes[name]
    };

    ThemeSetProto.setDefault = function (opts, name) {
      if (name == null) {
        name = opts;
        opts = {};
      }
      var platform = opts.platform == null ? 'fallback' : opts.platform;
      var hasUnicode = !!opts.hasUnicode;
      var hasColor = !!opts.hasColor;
      if (!this.defaults[platform]) this.defaults[platform] = {true: {}, false: {}};
      this.defaults[platform][hasUnicode][hasColor] = name;
    };

    ThemeSetProto.getDefault = function (opts) {
      if (!opts) opts = {};
      var platformName = opts.platform || process.platform;
      var platform = this.defaults[platformName] || this.defaults.fallback;
      var hasUnicode = !!opts.hasUnicode;
      var hasColor = !!opts.hasColor;
      if (!platform) throw this.newMissingDefaultThemeError(platformName, hasUnicode, hasColor)
      if (!platform[hasUnicode][hasColor]) {
        if (hasUnicode && hasColor && platform[!hasUnicode][hasColor]) {
          hasUnicode = false;
        } else if (hasUnicode && hasColor && platform[hasUnicode][!hasColor]) {
          hasColor = false;
        } else if (hasUnicode && hasColor && platform[!hasUnicode][!hasColor]) {
          hasUnicode = false;
          hasColor = false;
        } else if (hasUnicode && !hasColor && platform[!hasUnicode][hasColor]) {
          hasUnicode = false;
        } else if (!hasUnicode && hasColor && platform[hasUnicode][!hasColor]) {
          hasColor = false;
        } else if (platform === this.defaults.fallback) {
          throw this.newMissingDefaultThemeError(platformName, hasUnicode, hasColor)
        }
      }
      if (platform[hasUnicode][hasColor]) {
        return this.getTheme(platform[hasUnicode][hasColor])
      } else {
        return this.getDefault(objectAssign({}, opts, {platform: 'fallback'}))
      }
    };

    ThemeSetProto.newMissingThemeError = function newMissingThemeError (name) {
      var err = new Error('Could not find a gauge theme named "' + name + '"');
      Error.captureStackTrace.call(err, newMissingThemeError);
      err.theme = name;
      err.code = 'EMISSINGTHEME';
      return err
    };

    ThemeSetProto.newMissingDefaultThemeError = function newMissingDefaultThemeError (platformName, hasUnicode, hasColor) {
      var err = new Error(
        'Could not find a gauge theme for your platform/unicode/color use combo:\n' +
        '    platform = ' + platformName + '\n' +
        '    hasUnicode = ' + hasUnicode + '\n' +
        '    hasColor = ' + hasColor);
      Error.captureStackTrace.call(err, newMissingDefaultThemeError);
      err.platform = platformName;
      err.hasUnicode = hasUnicode;
      err.hasColor = hasColor;
      err.code = 'EMISSINGTHEME';
      return err
    };

    ThemeSetProto.newThemeSet = function () {
      var themeset = function (opts) {
        return themeset.getDefault(opts)
      };
      return objectAssign(themeset, ThemeSetProto, {
        themes: objectAssign({}, this.themes),
        baseTheme: objectAssign({}, this.baseTheme),
        defaults: JSON.parse(JSON.stringify(this.defaults || {}))
      })
    };

    var color = consoleControlStrings.color;
    var ThemeSet = themeSet;

    var themes = themes$1.exports = new ThemeSet();

    themes.addTheme('ASCII', {
      preProgressbar: '[',
      postProgressbar: ']',
      progressbarTheme: {
        complete: '#',
        remaining: '.'
      },
      activityIndicatorTheme: '-\\|/',
      preSubsection: '>'
    });

    themes.addTheme('colorASCII', themes.getTheme('ASCII'), {
      progressbarTheme: {
        preComplete: color('bgBrightWhite', 'brightWhite'),
        complete: '#',
        postComplete: color('reset'),
        preRemaining: color('bgBrightBlack', 'brightBlack'),
        remaining: '.',
        postRemaining: color('reset')
      }
    });

    themes.addTheme('brailleSpinner', {
      preProgressbar: '',
      postProgressbar: '',
      progressbarTheme: {
        complete: '#',
        remaining: ''
      },
      activityIndicatorTheme: '',
      preSubsection: '>'
    });

    themes.addTheme('colorBrailleSpinner', themes.getTheme('brailleSpinner'), {
      progressbarTheme: {
        preComplete: color('bgBrightWhite', 'brightWhite'),
        complete: '#',
        postComplete: color('reset'),
        preRemaining: color('bgBrightBlack', 'brightBlack'),
        remaining: '',
        postRemaining: color('reset')
      }
    });

    themes.setDefault({}, 'ASCII');
    themes.setDefault({hasColor: true}, 'colorASCII');
    themes.setDefault({platform: 'darwin', hasUnicode: true}, 'brailleSpinner');
    themes.setDefault({platform: 'darwin', hasUnicode: true, hasColor: true}, 'colorBrailleSpinner');
    themes.setDefault({platform: 'linux', hasUnicode: true}, 'brailleSpinner');
    themes.setDefault({platform: 'linux', hasUnicode: true, hasColor: true}, 'colorBrailleSpinner');

    // this exists so we can replace it during testing
    var setInterval_1 = setInterval;

    // this exists so we can replace it during testing
    var process_1 = process;

    var setImmediate$3 = {exports: {}};

    var process$3 = process_1;
    try {
      setImmediate$3.exports = setImmediate;
    } catch (ex) {
      setImmediate$3.exports = process$3.nextTick;
    }

    var Plumbing = plumbing.exports;
    var hasUnicode = hasUnicode$1.exports;
    var hasColor = hasColor$1;
    var onExit = signalExit$1.exports;
    var defaultThemes = themes$1.exports;
    var setInterval$1 = setInterval_1;
    var process$2 = process_1;
    var setImmediate$2 = setImmediate$3.exports;

    var gauge = Gauge;

    function callWith (obj, method) {
      return function () {
        return method.call(obj)
      }
    }

    function Gauge (arg1, arg2) {
      var options, writeTo;
      if (arg1 && arg1.write) {
        writeTo = arg1;
        options = arg2 || {};
      } else if (arg2 && arg2.write) {
        writeTo = arg2;
        options = arg1 || {};
      } else {
        writeTo = process$2.stderr;
        options = arg1 || arg2 || {};
      }

      this._status = {
        spun: 0,
        section: '',
        subsection: ''
      };
      this._paused = false; // are we paused for back pressure?
      this._disabled = true; // are all progress bar updates disabled?
      this._showing = false; // do we WANT the progress bar on screen
      this._onScreen = false; // IS the progress bar on screen
      this._needsRedraw = false; // should we print something at next tick?
      this._hideCursor = options.hideCursor == null ? true : options.hideCursor;
      this._fixedFramerate = options.fixedFramerate == null
        ? !(/^v0\.8\./.test(process$2.version))
        : options.fixedFramerate;
      this._lastUpdateAt = null;
      this._updateInterval = options.updateInterval == null ? 50 : options.updateInterval;

      this._themes = options.themes || defaultThemes;
      this._theme = options.theme;
      var theme = this._computeTheme(options.theme);
      var template = options.template || [
        {type: 'progressbar', length: 20},
        {type: 'activityIndicator', kerning: 1, length: 1},
        {type: 'section', kerning: 1, default: ''},
        {type: 'subsection', kerning: 1, default: ''}
      ];
      this.setWriteTo(writeTo, options.tty);
      var PlumbingClass = options.Plumbing || Plumbing;
      this._gauge = new PlumbingClass(theme, template, this.getWidth());

      this._$$doRedraw = callWith(this, this._doRedraw);
      this._$$handleSizeChange = callWith(this, this._handleSizeChange);

      this._cleanupOnExit = options.cleanupOnExit == null || options.cleanupOnExit;
      this._removeOnExit = null;

      if (options.enabled || (options.enabled == null && this._tty && this._tty.isTTY)) {
        this.enable();
      } else {
        this.disable();
      }
    }
    Gauge.prototype = {};

    Gauge.prototype.isEnabled = function () {
      return !this._disabled
    };

    Gauge.prototype.setTemplate = function (template) {
      this._gauge.setTemplate(template);
      if (this._showing) this._requestRedraw();
    };

    Gauge.prototype._computeTheme = function (theme) {
      if (!theme) theme = {};
      if (typeof theme === 'string') {
        theme = this._themes.getTheme(theme);
      } else if (theme && (Object.keys(theme).length === 0 || theme.hasUnicode != null || theme.hasColor != null)) {
        var useUnicode = theme.hasUnicode == null ? hasUnicode() : theme.hasUnicode;
        var useColor = theme.hasColor == null ? hasColor : theme.hasColor;
        theme = this._themes.getDefault({hasUnicode: useUnicode, hasColor: useColor, platform: theme.platform});
      }
      return theme
    };

    Gauge.prototype.setThemeset = function (themes) {
      this._themes = themes;
      this.setTheme(this._theme);
    };

    Gauge.prototype.setTheme = function (theme) {
      this._gauge.setTheme(this._computeTheme(theme));
      if (this._showing) this._requestRedraw();
      this._theme = theme;
    };

    Gauge.prototype._requestRedraw = function () {
      this._needsRedraw = true;
      if (!this._fixedFramerate) this._doRedraw();
    };

    Gauge.prototype.getWidth = function () {
      return ((this._tty && this._tty.columns) || 80) - 1
    };

    Gauge.prototype.setWriteTo = function (writeTo, tty) {
      var enabled = !this._disabled;
      if (enabled) this.disable();
      this._writeTo = writeTo;
      this._tty = tty ||
        (writeTo === process$2.stderr && process$2.stdout.isTTY && process$2.stdout) ||
        (writeTo.isTTY && writeTo) ||
        this._tty;
      if (this._gauge) this._gauge.setWidth(this.getWidth());
      if (enabled) this.enable();
    };

    Gauge.prototype.enable = function () {
      if (!this._disabled) return
      this._disabled = false;
      if (this._tty) this._enableEvents();
      if (this._showing) this.show();
    };

    Gauge.prototype.disable = function () {
      if (this._disabled) return
      if (this._showing) {
        this._lastUpdateAt = null;
        this._showing = false;
        this._doRedraw();
        this._showing = true;
      }
      this._disabled = true;
      if (this._tty) this._disableEvents();
    };

    Gauge.prototype._enableEvents = function () {
      if (this._cleanupOnExit) {
        this._removeOnExit = onExit(callWith(this, this.disable));
      }
      this._tty.on('resize', this._$$handleSizeChange);
      if (this._fixedFramerate) {
        this.redrawTracker = setInterval$1(this._$$doRedraw, this._updateInterval);
        if (this.redrawTracker.unref) this.redrawTracker.unref();
      }
    };

    Gauge.prototype._disableEvents = function () {
      this._tty.removeListener('resize', this._$$handleSizeChange);
      if (this._fixedFramerate) clearInterval(this.redrawTracker);
      if (this._removeOnExit) this._removeOnExit();
    };

    Gauge.prototype.hide = function (cb) {
      if (this._disabled) return cb && process$2.nextTick(cb)
      if (!this._showing) return cb && process$2.nextTick(cb)
      this._showing = false;
      this._doRedraw();
      cb && setImmediate$2(cb);
    };

    Gauge.prototype.show = function (section, completed) {
      this._showing = true;
      if (typeof section === 'string') {
        this._status.section = section;
      } else if (typeof section === 'object') {
        var sectionKeys = Object.keys(section);
        for (var ii = 0; ii < sectionKeys.length; ++ii) {
          var key = sectionKeys[ii];
          this._status[key] = section[key];
        }
      }
      if (completed != null) this._status.completed = completed;
      if (this._disabled) return
      this._requestRedraw();
    };

    Gauge.prototype.pulse = function (subsection) {
      this._status.subsection = subsection || '';
      this._status.spun++;
      if (this._disabled) return
      if (!this._showing) return
      this._requestRedraw();
    };

    Gauge.prototype._handleSizeChange = function () {
      this._gauge.setWidth(this._tty.columns - 1);
      this._requestRedraw();
    };

    Gauge.prototype._doRedraw = function () {
      if (this._disabled || this._paused) return
      if (!this._fixedFramerate) {
        var now = Date.now();
        if (this._lastUpdateAt && now - this._lastUpdateAt < this._updateInterval) return
        this._lastUpdateAt = now;
      }
      if (!this._showing && this._onScreen) {
        this._onScreen = false;
        var result = this._gauge.hide();
        if (this._hideCursor) {
          result += this._gauge.showCursor();
        }
        return this._writeTo.write(result)
      }
      if (!this._showing && !this._onScreen) return
      if (this._showing && !this._onScreen) {
        this._onScreen = true;
        this._needsRedraw = true;
        if (this._hideCursor) {
          this._writeTo.write(this._gauge.hideCursor());
        }
      }
      if (!this._needsRedraw) return
      if (!this._writeTo.write(this._gauge.show(this._status))) {
        this._paused = true;
        this._writeTo.on('drain', callWith(this, function () {
          this._paused = false;
          this._doRedraw();
        }));
      }
    };

    var setBlocking = function (blocking) {
      [process.stdout, process.stderr].forEach(function (stream) {
        if (stream._handle && stream.isTTY && typeof stream._handle.setBlocking === 'function') {
          stream._handle.setBlocking(blocking);
        }
      });
    };

    (function (module, exports) {
    var Progress = lib$2;
    var Gauge = gauge;
    var EE = require$$0__default["default"].EventEmitter;
    var log = module.exports = new EE();
    var util = require$$0__default$1["default"];

    var setBlocking$1 = setBlocking;
    var consoleControl = consoleControlStrings;

    setBlocking$1(true);
    var stream = process.stderr;
    Object.defineProperty(log, 'stream', {
      set: function (newStream) {
        stream = newStream;
        if (this.gauge) {
          this.gauge.setWriteTo(stream, stream);
        }
      },
      get: function () {
        return stream
      },
    });

    // by default, decide based on tty-ness.
    var colorEnabled;
    log.useColor = function () {
      return colorEnabled != null ? colorEnabled : stream.isTTY
    };

    log.enableColor = function () {
      colorEnabled = true;
      this.gauge.setTheme({hasColor: colorEnabled, hasUnicode: unicodeEnabled});
    };
    log.disableColor = function () {
      colorEnabled = false;
      this.gauge.setTheme({hasColor: colorEnabled, hasUnicode: unicodeEnabled});
    };

    // default level
    log.level = 'info';

    log.gauge = new Gauge(stream, {
      enabled: false, // no progress bars unless asked
      theme: {hasColor: log.useColor()},
      template: [
        {type: 'progressbar', length: 20},
        {type: 'activityIndicator', kerning: 1, length: 1},
        {type: 'section', default: ''},
        ':',
        {type: 'logline', kerning: 1, default: ''},
      ],
    });

    log.tracker = new Progress.TrackerGroup();

    // we track this separately as we may need to temporarily disable the
    // display of the status bar for our own loggy purposes.
    log.progressEnabled = log.gauge.isEnabled();

    var unicodeEnabled;

    log.enableUnicode = function () {
      unicodeEnabled = true;
      this.gauge.setTheme({hasColor: this.useColor(), hasUnicode: unicodeEnabled});
    };

    log.disableUnicode = function () {
      unicodeEnabled = false;
      this.gauge.setTheme({hasColor: this.useColor(), hasUnicode: unicodeEnabled});
    };

    log.setGaugeThemeset = function (themes) {
      this.gauge.setThemeset(themes);
    };

    log.setGaugeTemplate = function (template) {
      this.gauge.setTemplate(template);
    };

    log.enableProgress = function () {
      if (this.progressEnabled) {
        return
      }

      this.progressEnabled = true;
      this.tracker.on('change', this.showProgress);
      if (this._paused) {
        return
      }

      this.gauge.enable();
    };

    log.disableProgress = function () {
      if (!this.progressEnabled) {
        return
      }
      this.progressEnabled = false;
      this.tracker.removeListener('change', this.showProgress);
      this.gauge.disable();
    };

    var trackerConstructors = ['newGroup', 'newItem', 'newStream'];

    var mixinLog = function (tracker) {
      // mixin the public methods from log into the tracker
      // (except: conflicts and one's we handle specially)
      Object.keys(log).forEach(function (P) {
        if (P[0] === '_') {
          return
        }

        if (trackerConstructors.filter(function (C) {
          return C === P
        }).length) {
          return
        }

        if (tracker[P]) {
          return
        }

        if (typeof log[P] !== 'function') {
          return
        }

        var func = log[P];
        tracker[P] = function () {
          return func.apply(log, arguments)
        };
      });
      // if the new tracker is a group, make sure any subtrackers get
      // mixed in too
      if (tracker instanceof Progress.TrackerGroup) {
        trackerConstructors.forEach(function (C) {
          var func = tracker[C];
          tracker[C] = function () {
            return mixinLog(func.apply(tracker, arguments))
          };
        });
      }
      return tracker
    };

    // Add tracker constructors to the top level log object
    trackerConstructors.forEach(function (C) {
      log[C] = function () {
        return mixinLog(this.tracker[C].apply(this.tracker, arguments))
      };
    });

    log.clearProgress = function (cb) {
      if (!this.progressEnabled) {
        return cb && process.nextTick(cb)
      }

      this.gauge.hide(cb);
    };

    log.showProgress = function (name, completed) {
      if (!this.progressEnabled) {
        return
      }

      var values = {};
      if (name) {
        values.section = name;
      }

      var last = log.record[log.record.length - 1];
      if (last) {
        values.subsection = last.prefix;
        var disp = log.disp[last.level] || last.level;
        var logline = this._format(disp, log.style[last.level]);
        if (last.prefix) {
          logline += ' ' + this._format(last.prefix, this.prefixStyle);
        }

        logline += ' ' + last.message.split(/\r?\n/)[0];
        values.logline = logline;
      }
      values.completed = completed || this.tracker.completed();
      this.gauge.show(values);
    }.bind(log); // bind for use in tracker's on-change listener

    // temporarily stop emitting, but don't drop
    log.pause = function () {
      this._paused = true;
      if (this.progressEnabled) {
        this.gauge.disable();
      }
    };

    log.resume = function () {
      if (!this._paused) {
        return
      }

      this._paused = false;

      var b = this._buffer;
      this._buffer = [];
      b.forEach(function (m) {
        this.emitLog(m);
      }, this);
      if (this.progressEnabled) {
        this.gauge.enable();
      }
    };

    log._buffer = [];

    var id = 0;
    log.record = [];
    log.maxRecordSize = 10000;
    log.log = function (lvl, prefix, message) {
      var l = this.levels[lvl];
      if (l === undefined) {
        return this.emit('error', new Error(util.format(
          'Undefined log level: %j', lvl)))
      }

      var a = new Array(arguments.length - 2);
      var stack = null;
      for (var i = 2; i < arguments.length; i++) {
        var arg = a[i - 2] = arguments[i];

        // resolve stack traces to a plain string.
        if (typeof arg === 'object' && arg instanceof Error && arg.stack) {
          Object.defineProperty(arg, 'stack', {
            value: stack = arg.stack + '',
            enumerable: true,
            writable: true,
          });
        }
      }
      if (stack) {
        a.unshift(stack + '\n');
      }
      message = util.format.apply(util, a);

      var m = {
        id: id++,
        level: lvl,
        prefix: String(prefix || ''),
        message: message,
        messageRaw: a,
      };

      this.emit('log', m);
      this.emit('log.' + lvl, m);
      if (m.prefix) {
        this.emit(m.prefix, m);
      }

      this.record.push(m);
      var mrs = this.maxRecordSize;
      var n = this.record.length - mrs;
      if (n > mrs / 10) {
        var newSize = Math.floor(mrs * 0.9);
        this.record = this.record.slice(-1 * newSize);
      }

      this.emitLog(m);
    }.bind(log);

    log.emitLog = function (m) {
      if (this._paused) {
        this._buffer.push(m);
        return
      }
      if (this.progressEnabled) {
        this.gauge.pulse(m.prefix);
      }

      var l = this.levels[m.level];
      if (l === undefined) {
        return
      }

      if (l < this.levels[this.level]) {
        return
      }

      if (l > 0 && !isFinite(l)) {
        return
      }

      // If 'disp' is null or undefined, use the lvl as a default
      // Allows: '', 0 as valid disp
      var disp = log.disp[m.level] != null ? log.disp[m.level] : m.level;
      this.clearProgress();
      m.message.split(/\r?\n/).forEach(function (line) {
        if (this.heading) {
          this.write(this.heading, this.headingStyle);
          this.write(' ');
        }
        this.write(disp, log.style[m.level]);
        var p = m.prefix || '';
        if (p) {
          this.write(' ');
        }

        this.write(p, this.prefixStyle);
        this.write(' ' + line + '\n');
      }, this);
      this.showProgress();
    };

    log._format = function (msg, style) {
      if (!stream) {
        return
      }

      var output = '';
      if (this.useColor()) {
        style = style || {};
        var settings = [];
        if (style.fg) {
          settings.push(style.fg);
        }

        if (style.bg) {
          settings.push('bg' + style.bg[0].toUpperCase() + style.bg.slice(1));
        }

        if (style.bold) {
          settings.push('bold');
        }

        if (style.underline) {
          settings.push('underline');
        }

        if (style.inverse) {
          settings.push('inverse');
        }

        if (settings.length) {
          output += consoleControl.color(settings);
        }

        if (style.beep) {
          output += consoleControl.beep();
        }
      }
      output += msg;
      if (this.useColor()) {
        output += consoleControl.color('reset');
      }

      return output
    };

    log.write = function (msg, style) {
      if (!stream) {
        return
      }

      stream.write(this._format(msg, style));
    };

    log.addLevel = function (lvl, n, style, disp) {
      // If 'disp' is null or undefined, use the lvl as a default
      if (disp == null) {
        disp = lvl;
      }

      this.levels[lvl] = n;
      this.style[lvl] = style;
      if (!this[lvl]) {
        this[lvl] = function () {
          var a = new Array(arguments.length + 1);
          a[0] = lvl;
          for (var i = 0; i < arguments.length; i++) {
            a[i + 1] = arguments[i];
          }

          return this.log.apply(this, a)
        }.bind(this);
      }
      this.disp[lvl] = disp;
    };

    log.prefixStyle = { fg: 'magenta' };
    log.headingStyle = { fg: 'white', bg: 'black' };

    log.style = {};
    log.levels = {};
    log.disp = {};
    log.addLevel('silly', -Infinity, { inverse: true }, 'sill');
    log.addLevel('verbose', 1000, { fg: 'blue', bg: 'black' }, 'verb');
    log.addLevel('info', 2000, { fg: 'green' });
    log.addLevel('timing', 2500, { fg: 'green', bg: 'black' });
    log.addLevel('http', 3000, { fg: 'green', bg: 'black' });
    log.addLevel('notice', 3500, { fg: 'blue', bg: 'black' });
    log.addLevel('warn', 4000, { fg: 'black', bg: 'yellow' }, 'WARN');
    log.addLevel('error', 5000, { fg: 'red', bg: 'black' }, 'ERR!');
    log.addLevel('silent', Infinity);

    // allow 'error' prefix
    log.on('error', function () {});
    }(log$1));

    var log = log$1.exports;

    var axios$2 = {exports: {}};

    var bind$2 = function bind(fn, thisArg) {
      return function wrap() {
        var args = new Array(arguments.length);
        for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i];
        }
        return fn.apply(thisArg, args);
      };
    };

    var bind$1 = bind$2;

    // utils is a library of generic helper functions non-specific to axios

    var toString$2 = Object.prototype.toString;

    /**
     * Determine if a value is an Array
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is an Array, otherwise false
     */
    function isArray$j(val) {
      return toString$2.call(val) === '[object Array]';
    }

    /**
     * Determine if a value is undefined
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if the value is undefined, otherwise false
     */
    function isUndefined(val) {
      return typeof val === 'undefined';
    }

    /**
     * Determine if a value is a Buffer
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is a Buffer, otherwise false
     */
    function isBuffer$4(val) {
      return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor)
        && typeof val.constructor.isBuffer === 'function' && val.constructor.isBuffer(val);
    }

    /**
     * Determine if a value is an ArrayBuffer
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is an ArrayBuffer, otherwise false
     */
    function isArrayBuffer(val) {
      return toString$2.call(val) === '[object ArrayBuffer]';
    }

    /**
     * Determine if a value is a FormData
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is an FormData, otherwise false
     */
    function isFormData(val) {
      return (typeof FormData !== 'undefined') && (val instanceof FormData);
    }

    /**
     * Determine if a value is a view on an ArrayBuffer
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
     */
    function isArrayBufferView(val) {
      var result;
      if ((typeof ArrayBuffer !== 'undefined') && (ArrayBuffer.isView)) {
        result = ArrayBuffer.isView(val);
      } else {
        result = (val) && (val.buffer) && (val.buffer instanceof ArrayBuffer);
      }
      return result;
    }

    /**
     * Determine if a value is a String
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is a String, otherwise false
     */
    function isString$1(val) {
      return typeof val === 'string';
    }

    /**
     * Determine if a value is a Number
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is a Number, otherwise false
     */
    function isNumber$1(val) {
      return typeof val === 'number';
    }

    /**
     * Determine if a value is an Object
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is an Object, otherwise false
     */
    function isObject$b(val) {
      return val !== null && typeof val === 'object';
    }

    /**
     * Determine if a value is a plain Object
     *
     * @param {Object} val The value to test
     * @return {boolean} True if value is a plain Object, otherwise false
     */
    function isPlainObject$2(val) {
      if (toString$2.call(val) !== '[object Object]') {
        return false;
      }

      var prototype = Object.getPrototypeOf(val);
      return prototype === null || prototype === Object.prototype;
    }

    /**
     * Determine if a value is a Date
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is a Date, otherwise false
     */
    function isDate(val) {
      return toString$2.call(val) === '[object Date]';
    }

    /**
     * Determine if a value is a File
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is a File, otherwise false
     */
    function isFile(val) {
      return toString$2.call(val) === '[object File]';
    }

    /**
     * Determine if a value is a Blob
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is a Blob, otherwise false
     */
    function isBlob(val) {
      return toString$2.call(val) === '[object Blob]';
    }

    /**
     * Determine if a value is a Function
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is a Function, otherwise false
     */
    function isFunction$4(val) {
      return toString$2.call(val) === '[object Function]';
    }

    /**
     * Determine if a value is a Stream
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is a Stream, otherwise false
     */
    function isStream(val) {
      return isObject$b(val) && isFunction$4(val.pipe);
    }

    /**
     * Determine if a value is a URLSearchParams object
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is a URLSearchParams object, otherwise false
     */
    function isURLSearchParams(val) {
      return typeof URLSearchParams !== 'undefined' && val instanceof URLSearchParams;
    }

    /**
     * Trim excess whitespace off the beginning and end of a string
     *
     * @param {String} str The String to trim
     * @returns {String} The String freed of excess whitespace
     */
    function trim$1(str) {
      return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, '');
    }

    /**
     * Determine if we're running in a standard browser environment
     *
     * This allows axios to run in a web worker, and react-native.
     * Both environments support XMLHttpRequest, but not fully standard globals.
     *
     * web workers:
     *  typeof window -> undefined
     *  typeof document -> undefined
     *
     * react-native:
     *  navigator.product -> 'ReactNative'
     * nativescript
     *  navigator.product -> 'NativeScript' or 'NS'
     */
    function isStandardBrowserEnv() {
      if (typeof navigator !== 'undefined' && (navigator.product === 'ReactNative' ||
                                               navigator.product === 'NativeScript' ||
                                               navigator.product === 'NS')) {
        return false;
      }
      return (
        typeof window !== 'undefined' &&
        typeof document !== 'undefined'
      );
    }

    /**
     * Iterate over an Array or an Object invoking a function for each item.
     *
     * If `obj` is an Array callback will be called passing
     * the value, index, and complete array for each item.
     *
     * If 'obj' is an Object callback will be called passing
     * the value, key, and complete object for each property.
     *
     * @param {Object|Array} obj The object to iterate
     * @param {Function} fn The callback to invoke for each item
     */
    function forEach(obj, fn) {
      // Don't bother if no value provided
      if (obj === null || typeof obj === 'undefined') {
        return;
      }

      // Force an array if not already something iterable
      if (typeof obj !== 'object') {
        /*eslint no-param-reassign:0*/
        obj = [obj];
      }

      if (isArray$j(obj)) {
        // Iterate over array values
        for (var i = 0, l = obj.length; i < l; i++) {
          fn.call(null, obj[i], i, obj);
        }
      } else {
        // Iterate over object keys
        for (var key in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key)) {
            fn.call(null, obj[key], key, obj);
          }
        }
      }
    }

    /**
     * Accepts varargs expecting each argument to be an object, then
     * immutably merges the properties of each object and returns result.
     *
     * When multiple objects contain the same key the later object in
     * the arguments list will take precedence.
     *
     * Example:
     *
     * ```js
     * var result = merge({foo: 123}, {foo: 456});
     * console.log(result.foo); // outputs 456
     * ```
     *
     * @param {Object} obj1 Object to merge
     * @returns {Object} Result of all merge properties
     */
    function merge$2(/* obj1, obj2, obj3, ... */) {
      var result = {};
      function assignValue(val, key) {
        if (isPlainObject$2(result[key]) && isPlainObject$2(val)) {
          result[key] = merge$2(result[key], val);
        } else if (isPlainObject$2(val)) {
          result[key] = merge$2({}, val);
        } else if (isArray$j(val)) {
          result[key] = val.slice();
        } else {
          result[key] = val;
        }
      }

      for (var i = 0, l = arguments.length; i < l; i++) {
        forEach(arguments[i], assignValue);
      }
      return result;
    }

    /**
     * Extends object a by mutably adding to it the properties of object b.
     *
     * @param {Object} a The object to be extended
     * @param {Object} b The object to copy properties from
     * @param {Object} thisArg The object to bind function to
     * @return {Object} The resulting value of object a
     */
    function extend$2(a, b, thisArg) {
      forEach(b, function assignValue(val, key) {
        if (thisArg && typeof val === 'function') {
          a[key] = bind$1(val, thisArg);
        } else {
          a[key] = val;
        }
      });
      return a;
    }

    /**
     * Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)
     *
     * @param {string} content with BOM
     * @return {string} content value without BOM
     */
    function stripBOM(content) {
      if (content.charCodeAt(0) === 0xFEFF) {
        content = content.slice(1);
      }
      return content;
    }

    var utils$j = {
      isArray: isArray$j,
      isArrayBuffer: isArrayBuffer,
      isBuffer: isBuffer$4,
      isFormData: isFormData,
      isArrayBufferView: isArrayBufferView,
      isString: isString$1,
      isNumber: isNumber$1,
      isObject: isObject$b,
      isPlainObject: isPlainObject$2,
      isUndefined: isUndefined,
      isDate: isDate,
      isFile: isFile,
      isBlob: isBlob,
      isFunction: isFunction$4,
      isStream: isStream,
      isURLSearchParams: isURLSearchParams,
      isStandardBrowserEnv: isStandardBrowserEnv,
      forEach: forEach,
      merge: merge$2,
      extend: extend$2,
      trim: trim$1,
      stripBOM: stripBOM
    };

    var utils$i = utils$j;

    function encode(val) {
      return encodeURIComponent(val).
        replace(/%3A/gi, ':').
        replace(/%24/g, '$').
        replace(/%2C/gi, ',').
        replace(/%20/g, '+').
        replace(/%5B/gi, '[').
        replace(/%5D/gi, ']');
    }

    /**
     * Build a URL by appending params to the end
     *
     * @param {string} url The base of the url (e.g., http://www.google.com)
     * @param {object} [params] The params to be appended
     * @returns {string} The formatted url
     */
    var buildURL$3 = function buildURL(url, params, paramsSerializer) {
      /*eslint no-param-reassign:0*/
      if (!params) {
        return url;
      }

      var serializedParams;
      if (paramsSerializer) {
        serializedParams = paramsSerializer(params);
      } else if (utils$i.isURLSearchParams(params)) {
        serializedParams = params.toString();
      } else {
        var parts = [];

        utils$i.forEach(params, function serialize(val, key) {
          if (val === null || typeof val === 'undefined') {
            return;
          }

          if (utils$i.isArray(val)) {
            key = key + '[]';
          } else {
            val = [val];
          }

          utils$i.forEach(val, function parseValue(v) {
            if (utils$i.isDate(v)) {
              v = v.toISOString();
            } else if (utils$i.isObject(v)) {
              v = JSON.stringify(v);
            }
            parts.push(encode(key) + '=' + encode(v));
          });
        });

        serializedParams = parts.join('&');
      }

      if (serializedParams) {
        var hashmarkIndex = url.indexOf('#');
        if (hashmarkIndex !== -1) {
          url = url.slice(0, hashmarkIndex);
        }

        url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;
      }

      return url;
    };

    var utils$h = utils$j;

    function InterceptorManager$1() {
      this.handlers = [];
    }

    /**
     * Add a new interceptor to the stack
     *
     * @param {Function} fulfilled The function to handle `then` for a `Promise`
     * @param {Function} rejected The function to handle `reject` for a `Promise`
     *
     * @return {Number} An ID used to remove interceptor later
     */
    InterceptorManager$1.prototype.use = function use(fulfilled, rejected, options) {
      this.handlers.push({
        fulfilled: fulfilled,
        rejected: rejected,
        synchronous: options ? options.synchronous : false,
        runWhen: options ? options.runWhen : null
      });
      return this.handlers.length - 1;
    };

    /**
     * Remove an interceptor from the stack
     *
     * @param {Number} id The ID that was returned by `use`
     */
    InterceptorManager$1.prototype.eject = function eject(id) {
      if (this.handlers[id]) {
        this.handlers[id] = null;
      }
    };

    /**
     * Iterate over all the registered interceptors
     *
     * This method is particularly useful for skipping over any
     * interceptors that may have become `null` calling `eject`.
     *
     * @param {Function} fn The function to call for each interceptor
     */
    InterceptorManager$1.prototype.forEach = function forEach(fn) {
      utils$h.forEach(this.handlers, function forEachHandler(h) {
        if (h !== null) {
          fn(h);
        }
      });
    };

    var InterceptorManager_1 = InterceptorManager$1;

    var utils$g = utils$j;

    var normalizeHeaderName$1 = function normalizeHeaderName(headers, normalizedName) {
      utils$g.forEach(headers, function processHeader(value, name) {
        if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
          headers[normalizedName] = value;
          delete headers[name];
        }
      });
    };

    /**
     * Update an Error with the specified config, error code, and response.
     *
     * @param {Error} error The error to update.
     * @param {Object} config The config.
     * @param {string} [code] The error code (for example, 'ECONNABORTED').
     * @param {Object} [request] The request.
     * @param {Object} [response] The response.
     * @returns {Error} The error.
     */
    var enhanceError$3 = function enhanceError(error, config, code, request, response) {
      error.config = config;
      if (code) {
        error.code = code;
      }

      error.request = request;
      error.response = response;
      error.isAxiosError = true;

      error.toJSON = function toJSON() {
        return {
          // Standard
          message: this.message,
          name: this.name,
          // Microsoft
          description: this.description,
          number: this.number,
          // Mozilla
          fileName: this.fileName,
          lineNumber: this.lineNumber,
          columnNumber: this.columnNumber,
          stack: this.stack,
          // Axios
          config: this.config,
          code: this.code,
          status: this.response && this.response.status ? this.response.status : null
        };
      };
      return error;
    };

    var enhanceError$2 = enhanceError$3;

    /**
     * Create an Error with the specified message, config, error code, request and response.
     *
     * @param {string} message The error message.
     * @param {Object} config The config.
     * @param {string} [code] The error code (for example, 'ECONNABORTED').
     * @param {Object} [request] The request.
     * @param {Object} [response] The response.
     * @returns {Error} The created error.
     */
    var createError$3 = function createError(message, config, code, request, response) {
      var error = new Error(message);
      return enhanceError$2(error, config, code, request, response);
    };

    var createError$2 = createError$3;

    /**
     * Resolve or reject a Promise based on response status.
     *
     * @param {Function} resolve A function that resolves the promise.
     * @param {Function} reject A function that rejects the promise.
     * @param {object} response The response.
     */
    var settle$2 = function settle(resolve, reject, response) {
      var validateStatus = response.config.validateStatus;
      if (!response.status || !validateStatus || validateStatus(response.status)) {
        resolve(response);
      } else {
        reject(createError$2(
          'Request failed with status code ' + response.status,
          response.config,
          null,
          response.request,
          response
        ));
      }
    };

    var utils$f = utils$j;

    var cookies$1 = (
      utils$f.isStandardBrowserEnv() ?

      // Standard browser envs support document.cookie
        (function standardBrowserEnv() {
          return {
            write: function write(name, value, expires, path, domain, secure) {
              var cookie = [];
              cookie.push(name + '=' + encodeURIComponent(value));

              if (utils$f.isNumber(expires)) {
                cookie.push('expires=' + new Date(expires).toGMTString());
              }

              if (utils$f.isString(path)) {
                cookie.push('path=' + path);
              }

              if (utils$f.isString(domain)) {
                cookie.push('domain=' + domain);
              }

              if (secure === true) {
                cookie.push('secure');
              }

              document.cookie = cookie.join('; ');
            },

            read: function read(name) {
              var match = document.cookie.match(new RegExp('(^|;\\s*)(' + name + ')=([^;]*)'));
              return (match ? decodeURIComponent(match[3]) : null);
            },

            remove: function remove(name) {
              this.write(name, '', Date.now() - 86400000);
            }
          };
        })() :

      // Non standard browser env (web workers, react-native) lack needed support.
        (function nonStandardBrowserEnv() {
          return {
            write: function write() {},
            read: function read() { return null; },
            remove: function remove() {}
          };
        })()
    );

    /**
     * Determines whether the specified URL is absolute
     *
     * @param {string} url The URL to test
     * @returns {boolean} True if the specified URL is absolute, otherwise false
     */
    var isAbsoluteURL$1 = function isAbsoluteURL(url) {
      // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
      // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
      // by any combination of letters, digits, plus, period, or hyphen.
      return /^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(url);
    };

    /**
     * Creates a new URL by combining the specified URLs
     *
     * @param {string} baseURL The base URL
     * @param {string} relativeURL The relative URL
     * @returns {string} The combined URL
     */
    var combineURLs$1 = function combineURLs(baseURL, relativeURL) {
      return relativeURL
        ? baseURL.replace(/\/+$/, '') + '/' + relativeURL.replace(/^\/+/, '')
        : baseURL;
    };

    var isAbsoluteURL = isAbsoluteURL$1;
    var combineURLs = combineURLs$1;

    /**
     * Creates a new URL by combining the baseURL with the requestedURL,
     * only when the requestedURL is not already an absolute URL.
     * If the requestURL is absolute, this function returns the requestedURL untouched.
     *
     * @param {string} baseURL The base URL
     * @param {string} requestedURL Absolute or relative URL to combine
     * @returns {string} The combined full path
     */
    var buildFullPath$2 = function buildFullPath(baseURL, requestedURL) {
      if (baseURL && !isAbsoluteURL(requestedURL)) {
        return combineURLs(baseURL, requestedURL);
      }
      return requestedURL;
    };

    var utils$e = utils$j;

    // Headers whose duplicates are ignored by node
    // c.f. https://nodejs.org/api/http.html#http_message_headers
    var ignoreDuplicateOf = [
      'age', 'authorization', 'content-length', 'content-type', 'etag',
      'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since',
      'last-modified', 'location', 'max-forwards', 'proxy-authorization',
      'referer', 'retry-after', 'user-agent'
    ];

    /**
     * Parse headers into an object
     *
     * ```
     * Date: Wed, 27 Aug 2014 08:58:49 GMT
     * Content-Type: application/json
     * Connection: keep-alive
     * Transfer-Encoding: chunked
     * ```
     *
     * @param {String} headers Headers needing to be parsed
     * @returns {Object} Headers parsed into an object
     */
    var parseHeaders$1 = function parseHeaders(headers) {
      var parsed = {};
      var key;
      var val;
      var i;

      if (!headers) { return parsed; }

      utils$e.forEach(headers.split('\n'), function parser(line) {
        i = line.indexOf(':');
        key = utils$e.trim(line.substr(0, i)).toLowerCase();
        val = utils$e.trim(line.substr(i + 1));

        if (key) {
          if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
            return;
          }
          if (key === 'set-cookie') {
            parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
          } else {
            parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
          }
        }
      });

      return parsed;
    };

    var utils$d = utils$j;

    var isURLSameOrigin$1 = (
      utils$d.isStandardBrowserEnv() ?

      // Standard browser envs have full support of the APIs needed to test
      // whether the request URL is of the same origin as current location.
        (function standardBrowserEnv() {
          var msie = /(msie|trident)/i.test(navigator.userAgent);
          var urlParsingNode = document.createElement('a');
          var originURL;

          /**
        * Parse a URL to discover it's components
        *
        * @param {String} url The URL to be parsed
        * @returns {Object}
        */
          function resolveURL(url) {
            var href = url;

            if (msie) {
            // IE needs attribute set twice to normalize properties
              urlParsingNode.setAttribute('href', href);
              href = urlParsingNode.href;
            }

            urlParsingNode.setAttribute('href', href);

            // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils
            return {
              href: urlParsingNode.href,
              protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',
              host: urlParsingNode.host,
              search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, '') : '',
              hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',
              hostname: urlParsingNode.hostname,
              port: urlParsingNode.port,
              pathname: (urlParsingNode.pathname.charAt(0) === '/') ?
                urlParsingNode.pathname :
                '/' + urlParsingNode.pathname
            };
          }

          originURL = resolveURL(window.location.href);

          /**
        * Determine if a URL shares the same origin as the current location
        *
        * @param {String} requestURL The URL to test
        * @returns {boolean} True if URL shares the same origin, otherwise false
        */
          return function isURLSameOrigin(requestURL) {
            var parsed = (utils$d.isString(requestURL)) ? resolveURL(requestURL) : requestURL;
            return (parsed.protocol === originURL.protocol &&
                parsed.host === originURL.host);
          };
        })() :

      // Non standard browser envs (web workers, react-native) lack needed support.
        (function nonStandardBrowserEnv() {
          return function isURLSameOrigin() {
            return true;
          };
        })()
    );

    /**
     * A `Cancel` is an object that is thrown when an operation is canceled.
     *
     * @class
     * @param {string=} message The message.
     */
    function Cancel$4(message) {
      this.message = message;
    }

    Cancel$4.prototype.toString = function toString() {
      return 'Cancel' + (this.message ? ': ' + this.message : '');
    };

    Cancel$4.prototype.__CANCEL__ = true;

    var Cancel_1 = Cancel$4;

    var utils$c = utils$j;
    var settle$1 = settle$2;
    var cookies = cookies$1;
    var buildURL$2 = buildURL$3;
    var buildFullPath$1 = buildFullPath$2;
    var parseHeaders = parseHeaders$1;
    var isURLSameOrigin = isURLSameOrigin$1;
    var createError$1 = createError$3;
    var defaults$9 = defaults_1$1;
    var Cancel$3 = Cancel_1;

    var xhr = function xhrAdapter(config) {
      return new Promise(function dispatchXhrRequest(resolve, reject) {
        var requestData = config.data;
        var requestHeaders = config.headers;
        var responseType = config.responseType;
        var onCanceled;
        function done() {
          if (config.cancelToken) {
            config.cancelToken.unsubscribe(onCanceled);
          }

          if (config.signal) {
            config.signal.removeEventListener('abort', onCanceled);
          }
        }

        if (utils$c.isFormData(requestData)) {
          delete requestHeaders['Content-Type']; // Let the browser set it
        }

        var request = new XMLHttpRequest();

        // HTTP basic authentication
        if (config.auth) {
          var username = config.auth.username || '';
          var password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : '';
          requestHeaders.Authorization = 'Basic ' + btoa(username + ':' + password);
        }

        var fullPath = buildFullPath$1(config.baseURL, config.url);
        request.open(config.method.toUpperCase(), buildURL$2(fullPath, config.params, config.paramsSerializer), true);

        // Set the request timeout in MS
        request.timeout = config.timeout;

        function onloadend() {
          if (!request) {
            return;
          }
          // Prepare the response
          var responseHeaders = 'getAllResponseHeaders' in request ? parseHeaders(request.getAllResponseHeaders()) : null;
          var responseData = !responseType || responseType === 'text' ||  responseType === 'json' ?
            request.responseText : request.response;
          var response = {
            data: responseData,
            status: request.status,
            statusText: request.statusText,
            headers: responseHeaders,
            config: config,
            request: request
          };

          settle$1(function _resolve(value) {
            resolve(value);
            done();
          }, function _reject(err) {
            reject(err);
            done();
          }, response);

          // Clean up request
          request = null;
        }

        if ('onloadend' in request) {
          // Use onloadend if available
          request.onloadend = onloadend;
        } else {
          // Listen for ready state to emulate onloadend
          request.onreadystatechange = function handleLoad() {
            if (!request || request.readyState !== 4) {
              return;
            }

            // The request errored out and we didn't get a response, this will be
            // handled by onerror instead
            // With one exception: request that using file: protocol, most browsers
            // will return status as 0 even though it's a successful request
            if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {
              return;
            }
            // readystate handler is calling before onerror or ontimeout handlers,
            // so we should call onloadend on the next 'tick'
            setTimeout(onloadend);
          };
        }

        // Handle browser request cancellation (as opposed to a manual cancellation)
        request.onabort = function handleAbort() {
          if (!request) {
            return;
          }

          reject(createError$1('Request aborted', config, 'ECONNABORTED', request));

          // Clean up request
          request = null;
        };

        // Handle low level network errors
        request.onerror = function handleError() {
          // Real errors are hidden from us by the browser
          // onerror should only fire if it's a network error
          reject(createError$1('Network Error', config, null, request));

          // Clean up request
          request = null;
        };

        // Handle timeout
        request.ontimeout = function handleTimeout() {
          var timeoutErrorMessage = config.timeout ? 'timeout of ' + config.timeout + 'ms exceeded' : 'timeout exceeded';
          var transitional = config.transitional || defaults$9.transitional;
          if (config.timeoutErrorMessage) {
            timeoutErrorMessage = config.timeoutErrorMessage;
          }
          reject(createError$1(
            timeoutErrorMessage,
            config,
            transitional.clarifyTimeoutError ? 'ETIMEDOUT' : 'ECONNABORTED',
            request));

          // Clean up request
          request = null;
        };

        // Add xsrf header
        // This is only done if running in a standard browser environment.
        // Specifically not if we're in a web worker, or react-native.
        if (utils$c.isStandardBrowserEnv()) {
          // Add xsrf header
          var xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath)) && config.xsrfCookieName ?
            cookies.read(config.xsrfCookieName) :
            undefined;

          if (xsrfValue) {
            requestHeaders[config.xsrfHeaderName] = xsrfValue;
          }
        }

        // Add headers to the request
        if ('setRequestHeader' in request) {
          utils$c.forEach(requestHeaders, function setRequestHeader(val, key) {
            if (typeof requestData === 'undefined' && key.toLowerCase() === 'content-type') {
              // Remove Content-Type if data is undefined
              delete requestHeaders[key];
            } else {
              // Otherwise add header to the request
              request.setRequestHeader(key, val);
            }
          });
        }

        // Add withCredentials to request if needed
        if (!utils$c.isUndefined(config.withCredentials)) {
          request.withCredentials = !!config.withCredentials;
        }

        // Add responseType to request if needed
        if (responseType && responseType !== 'json') {
          request.responseType = config.responseType;
        }

        // Handle progress if needed
        if (typeof config.onDownloadProgress === 'function') {
          request.addEventListener('progress', config.onDownloadProgress);
        }

        // Not all browsers support upload events
        if (typeof config.onUploadProgress === 'function' && request.upload) {
          request.upload.addEventListener('progress', config.onUploadProgress);
        }

        if (config.cancelToken || config.signal) {
          // Handle cancellation
          // eslint-disable-next-line func-names
          onCanceled = function(cancel) {
            if (!request) {
              return;
            }
            reject(!cancel || (cancel && cancel.type) ? new Cancel$3('canceled') : cancel);
            request.abort();
            request = null;
          };

          config.cancelToken && config.cancelToken.subscribe(onCanceled);
          if (config.signal) {
            config.signal.aborted ? onCanceled() : config.signal.addEventListener('abort', onCanceled);
          }
        }

        if (!requestData) {
          requestData = null;
        }

        // Send the request
        request.send(requestData);
      });
    };

    var followRedirects = {exports: {}};

    var debug$6;

    var debug_1$1 = function () {
      if (!debug$6) {
        try {
          /* eslint global-require: off */
          debug$6 = require("debug")("follow-redirects");
        }
        catch (error) { /* */ }
        if (typeof debug$6 !== "function") {
          debug$6 = function () { /* */ };
        }
      }
      debug$6.apply(null, arguments);
    };

    var url$1 = require$$0__default$5["default"];
    var URL = url$1.URL;
    var http$1 = require$$1__default["default"];
    var https$1 = require$$2__default["default"];
    var Writable = require$$0__default$2["default"].Writable;
    var assert$4 = require$$5__default["default"];
    var debug$5 = debug_1$1;

    // Create handlers that pass events from native requests
    var events$1 = ["abort", "aborted", "connect", "error", "socket", "timeout"];
    var eventHandlers = Object.create(null);
    events$1.forEach(function (event) {
      eventHandlers[event] = function (arg1, arg2, arg3) {
        this._redirectable.emit(event, arg1, arg2, arg3);
      };
    });

    // Error types with codes
    var RedirectionError = createErrorType(
      "ERR_FR_REDIRECTION_FAILURE",
      "Redirected request failed"
    );
    var TooManyRedirectsError = createErrorType(
      "ERR_FR_TOO_MANY_REDIRECTS",
      "Maximum number of redirects exceeded"
    );
    var MaxBodyLengthExceededError = createErrorType(
      "ERR_FR_MAX_BODY_LENGTH_EXCEEDED",
      "Request body larger than maxBodyLength limit"
    );
    var WriteAfterEndError = createErrorType(
      "ERR_STREAM_WRITE_AFTER_END",
      "write after end"
    );

    // An HTTP(S) request that can be redirected
    function RedirectableRequest(options, responseCallback) {
      // Initialize the request
      Writable.call(this);
      this._sanitizeOptions(options);
      this._options = options;
      this._ended = false;
      this._ending = false;
      this._redirectCount = 0;
      this._redirects = [];
      this._requestBodyLength = 0;
      this._requestBodyBuffers = [];

      // Attach a callback if passed
      if (responseCallback) {
        this.on("response", responseCallback);
      }

      // React to responses of native requests
      var self = this;
      this._onNativeResponse = function (response) {
        self._processResponse(response);
      };

      // Perform the first request
      this._performRequest();
    }
    RedirectableRequest.prototype = Object.create(Writable.prototype);

    RedirectableRequest.prototype.abort = function () {
      abortRequest(this._currentRequest);
      this.emit("abort");
    };

    // Writes buffered data to the current native request
    RedirectableRequest.prototype.write = function (data, encoding, callback) {
      // Writing is not allowed if end has been called
      if (this._ending) {
        throw new WriteAfterEndError();
      }

      // Validate input and shift parameters if necessary
      if (!(typeof data === "string" || typeof data === "object" && ("length" in data))) {
        throw new TypeError("data should be a string, Buffer or Uint8Array");
      }
      if (typeof encoding === "function") {
        callback = encoding;
        encoding = null;
      }

      // Ignore empty buffers, since writing them doesn't invoke the callback
      // https://github.com/nodejs/node/issues/22066
      if (data.length === 0) {
        if (callback) {
          callback();
        }
        return;
      }
      // Only write when we don't exceed the maximum body length
      if (this._requestBodyLength + data.length <= this._options.maxBodyLength) {
        this._requestBodyLength += data.length;
        this._requestBodyBuffers.push({ data: data, encoding: encoding });
        this._currentRequest.write(data, encoding, callback);
      }
      // Error when we exceed the maximum body length
      else {
        this.emit("error", new MaxBodyLengthExceededError());
        this.abort();
      }
    };

    // Ends the current native request
    RedirectableRequest.prototype.end = function (data, encoding, callback) {
      // Shift parameters if necessary
      if (typeof data === "function") {
        callback = data;
        data = encoding = null;
      }
      else if (typeof encoding === "function") {
        callback = encoding;
        encoding = null;
      }

      // Write data if needed and end
      if (!data) {
        this._ended = this._ending = true;
        this._currentRequest.end(null, null, callback);
      }
      else {
        var self = this;
        var currentRequest = this._currentRequest;
        this.write(data, encoding, function () {
          self._ended = true;
          currentRequest.end(null, null, callback);
        });
        this._ending = true;
      }
    };

    // Sets a header value on the current native request
    RedirectableRequest.prototype.setHeader = function (name, value) {
      this._options.headers[name] = value;
      this._currentRequest.setHeader(name, value);
    };

    // Clears a header value on the current native request
    RedirectableRequest.prototype.removeHeader = function (name) {
      delete this._options.headers[name];
      this._currentRequest.removeHeader(name);
    };

    // Global timeout for all underlying requests
    RedirectableRequest.prototype.setTimeout = function (msecs, callback) {
      var self = this;

      // Destroys the socket on timeout
      function destroyOnTimeout(socket) {
        socket.setTimeout(msecs);
        socket.removeListener("timeout", socket.destroy);
        socket.addListener("timeout", socket.destroy);
      }

      // Sets up a timer to trigger a timeout event
      function startTimer(socket) {
        if (self._timeout) {
          clearTimeout(self._timeout);
        }
        self._timeout = setTimeout(function () {
          self.emit("timeout");
          clearTimer();
        }, msecs);
        destroyOnTimeout(socket);
      }

      // Stops a timeout from triggering
      function clearTimer() {
        // Clear the timeout
        if (self._timeout) {
          clearTimeout(self._timeout);
          self._timeout = null;
        }

        // Clean up all attached listeners
        self.removeListener("abort", clearTimer);
        self.removeListener("error", clearTimer);
        self.removeListener("response", clearTimer);
        if (callback) {
          self.removeListener("timeout", callback);
        }
        if (!self.socket) {
          self._currentRequest.removeListener("socket", startTimer);
        }
      }

      // Attach callback if passed
      if (callback) {
        this.on("timeout", callback);
      }

      // Start the timer if or when the socket is opened
      if (this.socket) {
        startTimer(this.socket);
      }
      else {
        this._currentRequest.once("socket", startTimer);
      }

      // Clean up on events
      this.on("socket", destroyOnTimeout);
      this.on("abort", clearTimer);
      this.on("error", clearTimer);
      this.on("response", clearTimer);

      return this;
    };

    // Proxy all other public ClientRequest methods
    [
      "flushHeaders", "getHeader",
      "setNoDelay", "setSocketKeepAlive",
    ].forEach(function (method) {
      RedirectableRequest.prototype[method] = function (a, b) {
        return this._currentRequest[method](a, b);
      };
    });

    // Proxy all public ClientRequest properties
    ["aborted", "connection", "socket"].forEach(function (property) {
      Object.defineProperty(RedirectableRequest.prototype, property, {
        get: function () { return this._currentRequest[property]; },
      });
    });

    RedirectableRequest.prototype._sanitizeOptions = function (options) {
      // Ensure headers are always present
      if (!options.headers) {
        options.headers = {};
      }

      // Since http.request treats host as an alias of hostname,
      // but the url module interprets host as hostname plus port,
      // eliminate the host property to avoid confusion.
      if (options.host) {
        // Use hostname if set, because it has precedence
        if (!options.hostname) {
          options.hostname = options.host;
        }
        delete options.host;
      }

      // Complete the URL object when necessary
      if (!options.pathname && options.path) {
        var searchPos = options.path.indexOf("?");
        if (searchPos < 0) {
          options.pathname = options.path;
        }
        else {
          options.pathname = options.path.substring(0, searchPos);
          options.search = options.path.substring(searchPos);
        }
      }
    };


    // Executes the next native request (initial or redirect)
    RedirectableRequest.prototype._performRequest = function () {
      // Load the native protocol
      var protocol = this._options.protocol;
      var nativeProtocol = this._options.nativeProtocols[protocol];
      if (!nativeProtocol) {
        this.emit("error", new TypeError("Unsupported protocol " + protocol));
        return;
      }

      // If specified, use the agent corresponding to the protocol
      // (HTTP and HTTPS use different types of agents)
      if (this._options.agents) {
        var scheme = protocol.substr(0, protocol.length - 1);
        this._options.agent = this._options.agents[scheme];
      }

      // Create the native request
      var request = this._currentRequest =
            nativeProtocol.request(this._options, this._onNativeResponse);
      this._currentUrl = url$1.format(this._options);

      // Set up event handlers
      request._redirectable = this;
      for (var e = 0; e < events$1.length; e++) {
        request.on(events$1[e], eventHandlers[events$1[e]]);
      }

      // End a redirected request
      // (The first request must be ended explicitly with RedirectableRequest#end)
      if (this._isRedirect) {
        // Write the request entity and end.
        var i = 0;
        var self = this;
        var buffers = this._requestBodyBuffers;
        (function writeNext(error) {
          // Only write if this request has not been redirected yet
          /* istanbul ignore else */
          if (request === self._currentRequest) {
            // Report any write errors
            /* istanbul ignore if */
            if (error) {
              self.emit("error", error);
            }
            // Write the next buffer if there are still left
            else if (i < buffers.length) {
              var buffer = buffers[i++];
              /* istanbul ignore else */
              if (!request.finished) {
                request.write(buffer.data, buffer.encoding, writeNext);
              }
            }
            // End the request if `end` has been called on us
            else if (self._ended) {
              request.end();
            }
          }
        }());
      }
    };

    // Processes a response from the current native request
    RedirectableRequest.prototype._processResponse = function (response) {
      // Store the redirected response
      var statusCode = response.statusCode;
      if (this._options.trackRedirects) {
        this._redirects.push({
          url: this._currentUrl,
          headers: response.headers,
          statusCode: statusCode,
        });
      }

      // RFC72316.4: The 3xx (Redirection) class of status code indicates
      // that further action needs to be taken by the user agent in order to
      // fulfill the request. If a Location header field is provided,
      // the user agent MAY automatically redirect its request to the URI
      // referenced by the Location field value,
      // even if the specific status code is not understood.
      var location = response.headers.location;
      if (location && this._options.followRedirects !== false &&
          statusCode >= 300 && statusCode < 400) {
        // Abort the current request
        abortRequest(this._currentRequest);
        // Discard the remainder of the response to avoid waiting for data
        response.destroy();

        // RFC72316.4: A client SHOULD detect and intervene
        // in cyclical redirections (i.e., "infinite" redirection loops).
        if (++this._redirectCount > this._options.maxRedirects) {
          this.emit("error", new TooManyRedirectsError());
          return;
        }

        // RFC72316.4: Automatic redirection needs to done with
        // care for methods not known to be safe, []
        // RFC72316.4.23: For historical reasons, a user agent MAY change
        // the request method from POST to GET for the subsequent request.
        if ((statusCode === 301 || statusCode === 302) && this._options.method === "POST" ||
            // RFC72316.4.4: The 303 (See Other) status code indicates that
            // the server is redirecting the user agent to a different resource []
            // A user agent can perform a retrieval request targeting that URI
            // (a GET or HEAD request if using HTTP) []
            (statusCode === 303) && !/^(?:GET|HEAD)$/.test(this._options.method)) {
          this._options.method = "GET";
          // Drop a possible entity and headers related to it
          this._requestBodyBuffers = [];
          removeMatchingHeaders(/^content-/i, this._options.headers);
        }

        // Drop the Host header, as the redirect might lead to a different host
        var currentHostHeader = removeMatchingHeaders(/^host$/i, this._options.headers);

        // If the redirect is relative, carry over the host of the last request
        var currentUrlParts = url$1.parse(this._currentUrl);
        var currentHost = currentHostHeader || currentUrlParts.host;
        var currentUrl = /^\w+:/.test(location) ? this._currentUrl :
          url$1.format(Object.assign(currentUrlParts, { host: currentHost }));

        // Determine the URL of the redirection
        var redirectUrl;
        try {
          redirectUrl = url$1.resolve(currentUrl, location);
        }
        catch (cause) {
          this.emit("error", new RedirectionError(cause));
          return;
        }

        // Create the redirected request
        debug$5("redirecting to", redirectUrl);
        this._isRedirect = true;
        var redirectUrlParts = url$1.parse(redirectUrl);
        Object.assign(this._options, redirectUrlParts);

        // Drop the Authorization header if redirecting to another domain
        if (!(redirectUrlParts.host === currentHost || isSubdomainOf(redirectUrlParts.host, currentHost))) {
          removeMatchingHeaders(/^authorization$/i, this._options.headers);
        }

        // Evaluate the beforeRedirect callback
        if (typeof this._options.beforeRedirect === "function") {
          var responseDetails = { headers: response.headers };
          try {
            this._options.beforeRedirect.call(null, this._options, responseDetails);
          }
          catch (err) {
            this.emit("error", err);
            return;
          }
          this._sanitizeOptions(this._options);
        }

        // Perform the redirected request
        try {
          this._performRequest();
        }
        catch (cause) {
          this.emit("error", new RedirectionError(cause));
        }
      }
      else {
        // The response is not a redirect; return it as-is
        response.responseUrl = this._currentUrl;
        response.redirects = this._redirects;
        this.emit("response", response);

        // Clean up
        this._requestBodyBuffers = [];
      }
    };

    // Wraps the key/value object of protocols with redirect functionality
    function wrap(protocols) {
      // Default settings
      var exports = {
        maxRedirects: 21,
        maxBodyLength: 10 * 1024 * 1024,
      };

      // Wrap each protocol
      var nativeProtocols = {};
      Object.keys(protocols).forEach(function (scheme) {
        var protocol = scheme + ":";
        var nativeProtocol = nativeProtocols[protocol] = protocols[scheme];
        var wrappedProtocol = exports[scheme] = Object.create(nativeProtocol);

        // Executes a request, following redirects
        function request(input, options, callback) {
          // Parse parameters
          if (typeof input === "string") {
            var urlStr = input;
            try {
              input = urlToOptions(new URL(urlStr));
            }
            catch (err) {
              /* istanbul ignore next */
              input = url$1.parse(urlStr);
            }
          }
          else if (URL && (input instanceof URL)) {
            input = urlToOptions(input);
          }
          else {
            callback = options;
            options = input;
            input = { protocol: protocol };
          }
          if (typeof options === "function") {
            callback = options;
            options = null;
          }

          // Set defaults
          options = Object.assign({
            maxRedirects: exports.maxRedirects,
            maxBodyLength: exports.maxBodyLength,
          }, input, options);
          options.nativeProtocols = nativeProtocols;

          assert$4.equal(options.protocol, protocol, "protocol mismatch");
          debug$5("options", options);
          return new RedirectableRequest(options, callback);
        }

        // Executes a GET request, following redirects
        function get(input, options, callback) {
          var wrappedRequest = wrappedProtocol.request(input, options, callback);
          wrappedRequest.end();
          return wrappedRequest;
        }

        // Expose the properties on the wrapped protocol
        Object.defineProperties(wrappedProtocol, {
          request: { value: request, configurable: true, enumerable: true, writable: true },
          get: { value: get, configurable: true, enumerable: true, writable: true },
        });
      });
      return exports;
    }

    /* istanbul ignore next */
    function noop$4() { /* empty */ }

    // from https://github.com/nodejs/node/blob/master/lib/internal/url.js
    function urlToOptions(urlObject) {
      var options = {
        protocol: urlObject.protocol,
        hostname: urlObject.hostname.startsWith("[") ?
          /* istanbul ignore next */
          urlObject.hostname.slice(1, -1) :
          urlObject.hostname,
        hash: urlObject.hash,
        search: urlObject.search,
        pathname: urlObject.pathname,
        path: urlObject.pathname + urlObject.search,
        href: urlObject.href,
      };
      if (urlObject.port !== "") {
        options.port = Number(urlObject.port);
      }
      return options;
    }

    function removeMatchingHeaders(regex, headers) {
      var lastValue;
      for (var header in headers) {
        if (regex.test(header)) {
          lastValue = headers[header].toString().trim();
          delete headers[header];
        }
      }
      return lastValue;
    }

    function createErrorType(code, defaultMessage) {
      function CustomError(cause) {
        Error.captureStackTrace(this, this.constructor);
        if (!cause) {
          this.message = defaultMessage;
        }
        else {
          this.message = defaultMessage + ": " + cause.message;
          this.cause = cause;
        }
      }
      CustomError.prototype = new Error();
      CustomError.prototype.constructor = CustomError;
      CustomError.prototype.name = "Error [" + code + "]";
      CustomError.prototype.code = code;
      return CustomError;
    }

    function abortRequest(request) {
      for (var e = 0; e < events$1.length; e++) {
        request.removeListener(events$1[e], eventHandlers[events$1[e]]);
      }
      request.on("error", noop$4);
      request.abort();
    }

    function isSubdomainOf(subdomain, domain) {
      const dot = subdomain.length - domain.length - 1;
      return dot > 0 && subdomain[dot] === "." && subdomain.endsWith(domain);
    }

    // Exports
    followRedirects.exports = wrap({ http: http$1, https: https$1 });
    followRedirects.exports.wrap = wrap;

    var data = {
      "version": "0.24.0"
    };

    var utils$b = utils$j;
    var settle = settle$2;
    var buildFullPath = buildFullPath$2;
    var buildURL$1 = buildURL$3;
    var http = require$$1__default["default"];
    var https = require$$2__default["default"];
    var httpFollow = followRedirects.exports.http;
    var httpsFollow = followRedirects.exports.https;
    var url = require$$0__default$5["default"];
    var zlib = require$$8__default["default"];
    var VERSION$1 = data.version;
    var createError = createError$3;
    var enhanceError$1 = enhanceError$3;
    var defaults$8 = defaults_1$1;
    var Cancel$2 = Cancel_1;

    var isHttps = /https:?/;

    /**
     *
     * @param {http.ClientRequestArgs} options
     * @param {AxiosProxyConfig} proxy
     * @param {string} location
     */
    function setProxy(options, proxy, location) {
      options.hostname = proxy.host;
      options.host = proxy.host;
      options.port = proxy.port;
      options.path = location;

      // Basic proxy authorization
      if (proxy.auth) {
        var base64 = Buffer.from(proxy.auth.username + ':' + proxy.auth.password, 'utf8').toString('base64');
        options.headers['Proxy-Authorization'] = 'Basic ' + base64;
      }

      // If a proxy is used, any redirects must also pass through the proxy
      options.beforeRedirect = function beforeRedirect(redirection) {
        redirection.headers.host = redirection.host;
        setProxy(redirection, proxy, redirection.href);
      };
    }

    /*eslint consistent-return:0*/
    var http_1 = function httpAdapter(config) {
      return new Promise(function dispatchHttpRequest(resolvePromise, rejectPromise) {
        var onCanceled;
        function done() {
          if (config.cancelToken) {
            config.cancelToken.unsubscribe(onCanceled);
          }

          if (config.signal) {
            config.signal.removeEventListener('abort', onCanceled);
          }
        }
        var resolve = function resolve(value) {
          done();
          resolvePromise(value);
        };
        var reject = function reject(value) {
          done();
          rejectPromise(value);
        };
        var data = config.data;
        var headers = config.headers;
        var headerNames = {};

        Object.keys(headers).forEach(function storeLowerName(name) {
          headerNames[name.toLowerCase()] = name;
        });

        // Set User-Agent (required by some servers)
        // See https://github.com/axios/axios/issues/69
        if ('user-agent' in headerNames) {
          // User-Agent is specified; handle case where no UA header is desired
          if (!headers[headerNames['user-agent']]) {
            delete headers[headerNames['user-agent']];
          }
          // Otherwise, use specified value
        } else {
          // Only set header if it hasn't been set in config
          headers['User-Agent'] = 'axios/' + VERSION$1;
        }

        if (data && !utils$b.isStream(data)) {
          if (Buffer.isBuffer(data)) ; else if (utils$b.isArrayBuffer(data)) {
            data = Buffer.from(new Uint8Array(data));
          } else if (utils$b.isString(data)) {
            data = Buffer.from(data, 'utf-8');
          } else {
            return reject(createError(
              'Data after transformation must be a string, an ArrayBuffer, a Buffer, or a Stream',
              config
            ));
          }

          // Add Content-Length header if data exists
          if (!headerNames['content-length']) {
            headers['Content-Length'] = data.length;
          }
        }

        // HTTP basic authentication
        var auth = undefined;
        if (config.auth) {
          var username = config.auth.username || '';
          var password = config.auth.password || '';
          auth = username + ':' + password;
        }

        // Parse url
        var fullPath = buildFullPath(config.baseURL, config.url);
        var parsed = url.parse(fullPath);
        var protocol = parsed.protocol || 'http:';

        if (!auth && parsed.auth) {
          var urlAuth = parsed.auth.split(':');
          var urlUsername = urlAuth[0] || '';
          var urlPassword = urlAuth[1] || '';
          auth = urlUsername + ':' + urlPassword;
        }

        if (auth && headerNames.authorization) {
          delete headers[headerNames.authorization];
        }

        var isHttpsRequest = isHttps.test(protocol);
        var agent = isHttpsRequest ? config.httpsAgent : config.httpAgent;

        var options = {
          path: buildURL$1(parsed.path, config.params, config.paramsSerializer).replace(/^\?/, ''),
          method: config.method.toUpperCase(),
          headers: headers,
          agent: agent,
          agents: { http: config.httpAgent, https: config.httpsAgent },
          auth: auth
        };

        if (config.socketPath) {
          options.socketPath = config.socketPath;
        } else {
          options.hostname = parsed.hostname;
          options.port = parsed.port;
        }

        var proxy = config.proxy;
        if (!proxy && proxy !== false) {
          var proxyEnv = protocol.slice(0, -1) + '_proxy';
          var proxyUrl = process.env[proxyEnv] || process.env[proxyEnv.toUpperCase()];
          if (proxyUrl) {
            var parsedProxyUrl = url.parse(proxyUrl);
            var noProxyEnv = process.env.no_proxy || process.env.NO_PROXY;
            var shouldProxy = true;

            if (noProxyEnv) {
              var noProxy = noProxyEnv.split(',').map(function trim(s) {
                return s.trim();
              });

              shouldProxy = !noProxy.some(function proxyMatch(proxyElement) {
                if (!proxyElement) {
                  return false;
                }
                if (proxyElement === '*') {
                  return true;
                }
                if (proxyElement[0] === '.' &&
                    parsed.hostname.substr(parsed.hostname.length - proxyElement.length) === proxyElement) {
                  return true;
                }

                return parsed.hostname === proxyElement;
              });
            }

            if (shouldProxy) {
              proxy = {
                host: parsedProxyUrl.hostname,
                port: parsedProxyUrl.port,
                protocol: parsedProxyUrl.protocol
              };

              if (parsedProxyUrl.auth) {
                var proxyUrlAuth = parsedProxyUrl.auth.split(':');
                proxy.auth = {
                  username: proxyUrlAuth[0],
                  password: proxyUrlAuth[1]
                };
              }
            }
          }
        }

        if (proxy) {
          options.headers.host = parsed.hostname + (parsed.port ? ':' + parsed.port : '');
          setProxy(options, proxy, protocol + '//' + parsed.hostname + (parsed.port ? ':' + parsed.port : '') + options.path);
        }

        var transport;
        var isHttpsProxy = isHttpsRequest && (proxy ? isHttps.test(proxy.protocol) : true);
        if (config.transport) {
          transport = config.transport;
        } else if (config.maxRedirects === 0) {
          transport = isHttpsProxy ? https : http;
        } else {
          if (config.maxRedirects) {
            options.maxRedirects = config.maxRedirects;
          }
          transport = isHttpsProxy ? httpsFollow : httpFollow;
        }

        if (config.maxBodyLength > -1) {
          options.maxBodyLength = config.maxBodyLength;
        }

        if (config.insecureHTTPParser) {
          options.insecureHTTPParser = config.insecureHTTPParser;
        }

        // Create the request
        var req = transport.request(options, function handleResponse(res) {
          if (req.aborted) return;

          // uncompress the response body transparently if required
          var stream = res;

          // return the last request in case of redirects
          var lastRequest = res.req || req;


          // if no content, is HEAD request or decompress disabled we should not decompress
          if (res.statusCode !== 204 && lastRequest.method !== 'HEAD' && config.decompress !== false) {
            switch (res.headers['content-encoding']) {
            /*eslint default-case:0*/
            case 'gzip':
            case 'compress':
            case 'deflate':
            // add the unzipper to the body stream processing pipeline
              stream = stream.pipe(zlib.createUnzip());

              // remove the content-encoding in order to not confuse downstream operations
              delete res.headers['content-encoding'];
              break;
            }
          }

          var response = {
            status: res.statusCode,
            statusText: res.statusMessage,
            headers: res.headers,
            config: config,
            request: lastRequest
          };

          if (config.responseType === 'stream') {
            response.data = stream;
            settle(resolve, reject, response);
          } else {
            var responseBuffer = [];
            var totalResponseBytes = 0;
            stream.on('data', function handleStreamData(chunk) {
              responseBuffer.push(chunk);
              totalResponseBytes += chunk.length;

              // make sure the content length is not over the maxContentLength if specified
              if (config.maxContentLength > -1 && totalResponseBytes > config.maxContentLength) {
                stream.destroy();
                reject(createError('maxContentLength size of ' + config.maxContentLength + ' exceeded',
                  config, null, lastRequest));
              }
            });

            stream.on('error', function handleStreamError(err) {
              if (req.aborted) return;
              reject(enhanceError$1(err, config, null, lastRequest));
            });

            stream.on('end', function handleStreamEnd() {
              var responseData = Buffer.concat(responseBuffer);
              if (config.responseType !== 'arraybuffer') {
                responseData = responseData.toString(config.responseEncoding);
                if (!config.responseEncoding || config.responseEncoding === 'utf8') {
                  responseData = utils$b.stripBOM(responseData);
                }
              }

              response.data = responseData;
              settle(resolve, reject, response);
            });
          }
        });

        // Handle errors
        req.on('error', function handleRequestError(err) {
          if (req.aborted && err.code !== 'ERR_FR_TOO_MANY_REDIRECTS') return;
          reject(enhanceError$1(err, config, null, req));
        });

        // Handle request timeout
        if (config.timeout) {
          // This is forcing a int timeout to avoid problems if the `req` interface doesn't handle other types.
          var timeout = parseInt(config.timeout, 10);

          if (isNaN(timeout)) {
            reject(createError(
              'error trying to parse `config.timeout` to int',
              config,
              'ERR_PARSE_TIMEOUT',
              req
            ));

            return;
          }

          // Sometime, the response will be very slow, and does not respond, the connect event will be block by event loop system.
          // And timer callback will be fired, and abort() will be invoked before connection, then get "socket hang up" and code ECONNRESET.
          // At this time, if we have a large number of request, nodejs will hang up some socket on background. and the number will up and up.
          // And then these socket which be hang up will devoring CPU little by little.
          // ClientRequest.setTimeout will be fired on the specify milliseconds, and can make sure that abort() will be fired after connect.
          req.setTimeout(timeout, function handleRequestTimeout() {
            req.abort();
            var transitional = config.transitional || defaults$8.transitional;
            reject(createError(
              'timeout of ' + timeout + 'ms exceeded',
              config,
              transitional.clarifyTimeoutError ? 'ETIMEDOUT' : 'ECONNABORTED',
              req
            ));
          });
        }

        if (config.cancelToken || config.signal) {
          // Handle cancellation
          // eslint-disable-next-line func-names
          onCanceled = function(cancel) {
            if (req.aborted) return;

            req.abort();
            reject(!cancel || (cancel && cancel.type) ? new Cancel$2('canceled') : cancel);
          };

          config.cancelToken && config.cancelToken.subscribe(onCanceled);
          if (config.signal) {
            config.signal.aborted ? onCanceled() : config.signal.addEventListener('abort', onCanceled);
          }
        }


        // Send the request
        if (utils$b.isStream(data)) {
          data.on('error', function handleStreamError(err) {
            reject(enhanceError$1(err, config, null, req));
          }).pipe(req);
        } else {
          req.end(data);
        }
      });
    };

    var utils$a = utils$j;
    var normalizeHeaderName = normalizeHeaderName$1;
    var enhanceError = enhanceError$3;

    var DEFAULT_CONTENT_TYPE = {
      'Content-Type': 'application/x-www-form-urlencoded'
    };

    function setContentTypeIfUnset(headers, value) {
      if (!utils$a.isUndefined(headers) && utils$a.isUndefined(headers['Content-Type'])) {
        headers['Content-Type'] = value;
      }
    }

    function getDefaultAdapter() {
      var adapter;
      if (typeof XMLHttpRequest !== 'undefined') {
        // For browsers use XHR adapter
        adapter = xhr;
      } else if (typeof process !== 'undefined' && Object.prototype.toString.call(process) === '[object process]') {
        // For node use HTTP adapter
        adapter = http_1;
      }
      return adapter;
    }

    function stringifySafely(rawValue, parser, encoder) {
      if (utils$a.isString(rawValue)) {
        try {
          (parser || JSON.parse)(rawValue);
          return utils$a.trim(rawValue);
        } catch (e) {
          if (e.name !== 'SyntaxError') {
            throw e;
          }
        }
      }

      return (encoder || JSON.stringify)(rawValue);
    }

    var defaults$7 = {

      transitional: {
        silentJSONParsing: true,
        forcedJSONParsing: true,
        clarifyTimeoutError: false
      },

      adapter: getDefaultAdapter(),

      transformRequest: [function transformRequest(data, headers) {
        normalizeHeaderName(headers, 'Accept');
        normalizeHeaderName(headers, 'Content-Type');

        if (utils$a.isFormData(data) ||
          utils$a.isArrayBuffer(data) ||
          utils$a.isBuffer(data) ||
          utils$a.isStream(data) ||
          utils$a.isFile(data) ||
          utils$a.isBlob(data)
        ) {
          return data;
        }
        if (utils$a.isArrayBufferView(data)) {
          return data.buffer;
        }
        if (utils$a.isURLSearchParams(data)) {
          setContentTypeIfUnset(headers, 'application/x-www-form-urlencoded;charset=utf-8');
          return data.toString();
        }
        if (utils$a.isObject(data) || (headers && headers['Content-Type'] === 'application/json')) {
          setContentTypeIfUnset(headers, 'application/json');
          return stringifySafely(data);
        }
        return data;
      }],

      transformResponse: [function transformResponse(data) {
        var transitional = this.transitional || defaults$7.transitional;
        var silentJSONParsing = transitional && transitional.silentJSONParsing;
        var forcedJSONParsing = transitional && transitional.forcedJSONParsing;
        var strictJSONParsing = !silentJSONParsing && this.responseType === 'json';

        if (strictJSONParsing || (forcedJSONParsing && utils$a.isString(data) && data.length)) {
          try {
            return JSON.parse(data);
          } catch (e) {
            if (strictJSONParsing) {
              if (e.name === 'SyntaxError') {
                throw enhanceError(e, this, 'E_JSON_PARSE');
              }
              throw e;
            }
          }
        }

        return data;
      }],

      /**
       * A timeout in milliseconds to abort a request. If set to 0 (default) a
       * timeout is not created.
       */
      timeout: 0,

      xsrfCookieName: 'XSRF-TOKEN',
      xsrfHeaderName: 'X-XSRF-TOKEN',

      maxContentLength: -1,
      maxBodyLength: -1,

      validateStatus: function validateStatus(status) {
        return status >= 200 && status < 300;
      },

      headers: {
        common: {
          'Accept': 'application/json, text/plain, */*'
        }
      }
    };

    utils$a.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) {
      defaults$7.headers[method] = {};
    });

    utils$a.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
      defaults$7.headers[method] = utils$a.merge(DEFAULT_CONTENT_TYPE);
    });

    var defaults_1$1 = defaults$7;

    var utils$9 = utils$j;
    var defaults$6 = defaults_1$1;

    /**
     * Transform the data for a request or a response
     *
     * @param {Object|String} data The data to be transformed
     * @param {Array} headers The headers for the request or response
     * @param {Array|Function} fns A single function or Array of functions
     * @returns {*} The resulting transformed data
     */
    var transformData$1 = function transformData(data, headers, fns) {
      var context = this || defaults$6;
      /*eslint no-param-reassign:0*/
      utils$9.forEach(fns, function transform(fn) {
        data = fn.call(context, data, headers);
      });

      return data;
    };

    var isCancel$1 = function isCancel(value) {
      return !!(value && value.__CANCEL__);
    };

    var utils$8 = utils$j;
    var transformData = transformData$1;
    var isCancel = isCancel$1;
    var defaults$5 = defaults_1$1;
    var Cancel$1 = Cancel_1;

    /**
     * Throws a `Cancel` if cancellation has been requested.
     */
    function throwIfCancellationRequested(config) {
      if (config.cancelToken) {
        config.cancelToken.throwIfRequested();
      }

      if (config.signal && config.signal.aborted) {
        throw new Cancel$1('canceled');
      }
    }

    /**
     * Dispatch a request to the server using the configured adapter.
     *
     * @param {object} config The config that is to be used for the request
     * @returns {Promise} The Promise to be fulfilled
     */
    var dispatchRequest$1 = function dispatchRequest(config) {
      throwIfCancellationRequested(config);

      // Ensure headers exist
      config.headers = config.headers || {};

      // Transform request data
      config.data = transformData.call(
        config,
        config.data,
        config.headers,
        config.transformRequest
      );

      // Flatten headers
      config.headers = utils$8.merge(
        config.headers.common || {},
        config.headers[config.method] || {},
        config.headers
      );

      utils$8.forEach(
        ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],
        function cleanHeaderConfig(method) {
          delete config.headers[method];
        }
      );

      var adapter = config.adapter || defaults$5.adapter;

      return adapter(config).then(function onAdapterResolution(response) {
        throwIfCancellationRequested(config);

        // Transform response data
        response.data = transformData.call(
          config,
          response.data,
          response.headers,
          config.transformResponse
        );

        return response;
      }, function onAdapterRejection(reason) {
        if (!isCancel(reason)) {
          throwIfCancellationRequested(config);

          // Transform response data
          if (reason && reason.response) {
            reason.response.data = transformData.call(
              config,
              reason.response.data,
              reason.response.headers,
              config.transformResponse
            );
          }
        }

        return Promise.reject(reason);
      });
    };

    var utils$7 = utils$j;

    /**
     * Config-specific merge-function which creates a new config-object
     * by merging two configuration objects together.
     *
     * @param {Object} config1
     * @param {Object} config2
     * @returns {Object} New object resulting from merging config2 to config1
     */
    var mergeConfig$2 = function mergeConfig(config1, config2) {
      // eslint-disable-next-line no-param-reassign
      config2 = config2 || {};
      var config = {};

      function getMergedValue(target, source) {
        if (utils$7.isPlainObject(target) && utils$7.isPlainObject(source)) {
          return utils$7.merge(target, source);
        } else if (utils$7.isPlainObject(source)) {
          return utils$7.merge({}, source);
        } else if (utils$7.isArray(source)) {
          return source.slice();
        }
        return source;
      }

      // eslint-disable-next-line consistent-return
      function mergeDeepProperties(prop) {
        if (!utils$7.isUndefined(config2[prop])) {
          return getMergedValue(config1[prop], config2[prop]);
        } else if (!utils$7.isUndefined(config1[prop])) {
          return getMergedValue(undefined, config1[prop]);
        }
      }

      // eslint-disable-next-line consistent-return
      function valueFromConfig2(prop) {
        if (!utils$7.isUndefined(config2[prop])) {
          return getMergedValue(undefined, config2[prop]);
        }
      }

      // eslint-disable-next-line consistent-return
      function defaultToConfig2(prop) {
        if (!utils$7.isUndefined(config2[prop])) {
          return getMergedValue(undefined, config2[prop]);
        } else if (!utils$7.isUndefined(config1[prop])) {
          return getMergedValue(undefined, config1[prop]);
        }
      }

      // eslint-disable-next-line consistent-return
      function mergeDirectKeys(prop) {
        if (prop in config2) {
          return getMergedValue(config1[prop], config2[prop]);
        } else if (prop in config1) {
          return getMergedValue(undefined, config1[prop]);
        }
      }

      var mergeMap = {
        'url': valueFromConfig2,
        'method': valueFromConfig2,
        'data': valueFromConfig2,
        'baseURL': defaultToConfig2,
        'transformRequest': defaultToConfig2,
        'transformResponse': defaultToConfig2,
        'paramsSerializer': defaultToConfig2,
        'timeout': defaultToConfig2,
        'timeoutMessage': defaultToConfig2,
        'withCredentials': defaultToConfig2,
        'adapter': defaultToConfig2,
        'responseType': defaultToConfig2,
        'xsrfCookieName': defaultToConfig2,
        'xsrfHeaderName': defaultToConfig2,
        'onUploadProgress': defaultToConfig2,
        'onDownloadProgress': defaultToConfig2,
        'decompress': defaultToConfig2,
        'maxContentLength': defaultToConfig2,
        'maxBodyLength': defaultToConfig2,
        'transport': defaultToConfig2,
        'httpAgent': defaultToConfig2,
        'httpsAgent': defaultToConfig2,
        'cancelToken': defaultToConfig2,
        'socketPath': defaultToConfig2,
        'responseEncoding': defaultToConfig2,
        'validateStatus': mergeDirectKeys
      };

      utils$7.forEach(Object.keys(config1).concat(Object.keys(config2)), function computeConfigValue(prop) {
        var merge = mergeMap[prop] || mergeDeepProperties;
        var configValue = merge(prop);
        (utils$7.isUndefined(configValue) && merge !== mergeDirectKeys) || (config[prop] = configValue);
      });

      return config;
    };

    var VERSION = data.version;

    var validators$1 = {};

    // eslint-disable-next-line func-names
    ['object', 'boolean', 'number', 'function', 'string', 'symbol'].forEach(function(type, i) {
      validators$1[type] = function validator(thing) {
        return typeof thing === type || 'a' + (i < 1 ? 'n ' : ' ') + type;
      };
    });

    var deprecatedWarnings = {};

    /**
     * Transitional option validator
     * @param {function|boolean?} validator - set to false if the transitional option has been removed
     * @param {string?} version - deprecated version / removed since version
     * @param {string?} message - some message with additional info
     * @returns {function}
     */
    validators$1.transitional = function transitional(validator, version, message) {
      function formatMessage(opt, desc) {
        return '[Axios v' + VERSION + '] Transitional option \'' + opt + '\'' + desc + (message ? '. ' + message : '');
      }

      // eslint-disable-next-line func-names
      return function(value, opt, opts) {
        if (validator === false) {
          throw new Error(formatMessage(opt, ' has been removed' + (version ? ' in ' + version : '')));
        }

        if (version && !deprecatedWarnings[opt]) {
          deprecatedWarnings[opt] = true;
          // eslint-disable-next-line no-console
          console.warn(
            formatMessage(
              opt,
              ' has been deprecated since v' + version + ' and will be removed in the near future'
            )
          );
        }

        return validator ? validator(value, opt, opts) : true;
      };
    };

    /**
     * Assert object's properties type
     * @param {object} options
     * @param {object} schema
     * @param {boolean?} allowUnknown
     */

    function assertOptions(options, schema, allowUnknown) {
      if (typeof options !== 'object') {
        throw new TypeError('options must be an object');
      }
      var keys = Object.keys(options);
      var i = keys.length;
      while (i-- > 0) {
        var opt = keys[i];
        var validator = schema[opt];
        if (validator) {
          var value = options[opt];
          var result = value === undefined || validator(value, opt, options);
          if (result !== true) {
            throw new TypeError('option ' + opt + ' must be ' + result);
          }
          continue;
        }
        if (allowUnknown !== true) {
          throw Error('Unknown option ' + opt);
        }
      }
    }

    var validator$1 = {
      assertOptions: assertOptions,
      validators: validators$1
    };

    var utils$6 = utils$j;
    var buildURL = buildURL$3;
    var InterceptorManager = InterceptorManager_1;
    var dispatchRequest = dispatchRequest$1;
    var mergeConfig$1 = mergeConfig$2;
    var validator = validator$1;

    var validators = validator.validators;
    /**
     * Create a new instance of Axios
     *
     * @param {Object} instanceConfig The default config for the instance
     */
    function Axios$1(instanceConfig) {
      this.defaults = instanceConfig;
      this.interceptors = {
        request: new InterceptorManager(),
        response: new InterceptorManager()
      };
    }

    /**
     * Dispatch a request
     *
     * @param {Object} config The config specific for this request (merged with this.defaults)
     */
    Axios$1.prototype.request = function request(config) {
      /*eslint no-param-reassign:0*/
      // Allow for axios('example/url'[, config]) a la fetch API
      if (typeof config === 'string') {
        config = arguments[1] || {};
        config.url = arguments[0];
      } else {
        config = config || {};
      }

      config = mergeConfig$1(this.defaults, config);

      // Set config.method
      if (config.method) {
        config.method = config.method.toLowerCase();
      } else if (this.defaults.method) {
        config.method = this.defaults.method.toLowerCase();
      } else {
        config.method = 'get';
      }

      var transitional = config.transitional;

      if (transitional !== undefined) {
        validator.assertOptions(transitional, {
          silentJSONParsing: validators.transitional(validators.boolean),
          forcedJSONParsing: validators.transitional(validators.boolean),
          clarifyTimeoutError: validators.transitional(validators.boolean)
        }, false);
      }

      // filter out skipped interceptors
      var requestInterceptorChain = [];
      var synchronousRequestInterceptors = true;
      this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
        if (typeof interceptor.runWhen === 'function' && interceptor.runWhen(config) === false) {
          return;
        }

        synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;

        requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
      });

      var responseInterceptorChain = [];
      this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
        responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
      });

      var promise;

      if (!synchronousRequestInterceptors) {
        var chain = [dispatchRequest, undefined];

        Array.prototype.unshift.apply(chain, requestInterceptorChain);
        chain = chain.concat(responseInterceptorChain);

        promise = Promise.resolve(config);
        while (chain.length) {
          promise = promise.then(chain.shift(), chain.shift());
        }

        return promise;
      }


      var newConfig = config;
      while (requestInterceptorChain.length) {
        var onFulfilled = requestInterceptorChain.shift();
        var onRejected = requestInterceptorChain.shift();
        try {
          newConfig = onFulfilled(newConfig);
        } catch (error) {
          onRejected(error);
          break;
        }
      }

      try {
        promise = dispatchRequest(newConfig);
      } catch (error) {
        return Promise.reject(error);
      }

      while (responseInterceptorChain.length) {
        promise = promise.then(responseInterceptorChain.shift(), responseInterceptorChain.shift());
      }

      return promise;
    };

    Axios$1.prototype.getUri = function getUri(config) {
      config = mergeConfig$1(this.defaults, config);
      return buildURL(config.url, config.params, config.paramsSerializer).replace(/^\?/, '');
    };

    // Provide aliases for supported request methods
    utils$6.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {
      /*eslint func-names:0*/
      Axios$1.prototype[method] = function(url, config) {
        return this.request(mergeConfig$1(config || {}, {
          method: method,
          url: url,
          data: (config || {}).data
        }));
      };
    });

    utils$6.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
      /*eslint func-names:0*/
      Axios$1.prototype[method] = function(url, data, config) {
        return this.request(mergeConfig$1(config || {}, {
          method: method,
          url: url,
          data: data
        }));
      };
    });

    var Axios_1 = Axios$1;

    var Cancel = Cancel_1;

    /**
     * A `CancelToken` is an object that can be used to request cancellation of an operation.
     *
     * @class
     * @param {Function} executor The executor function.
     */
    function CancelToken(executor) {
      if (typeof executor !== 'function') {
        throw new TypeError('executor must be a function.');
      }

      var resolvePromise;

      this.promise = new Promise(function promiseExecutor(resolve) {
        resolvePromise = resolve;
      });

      var token = this;

      // eslint-disable-next-line func-names
      this.promise.then(function(cancel) {
        if (!token._listeners) return;

        var i;
        var l = token._listeners.length;

        for (i = 0; i < l; i++) {
          token._listeners[i](cancel);
        }
        token._listeners = null;
      });

      // eslint-disable-next-line func-names
      this.promise.then = function(onfulfilled) {
        var _resolve;
        // eslint-disable-next-line func-names
        var promise = new Promise(function(resolve) {
          token.subscribe(resolve);
          _resolve = resolve;
        }).then(onfulfilled);

        promise.cancel = function reject() {
          token.unsubscribe(_resolve);
        };

        return promise;
      };

      executor(function cancel(message) {
        if (token.reason) {
          // Cancellation has already been requested
          return;
        }

        token.reason = new Cancel(message);
        resolvePromise(token.reason);
      });
    }

    /**
     * Throws a `Cancel` if cancellation has been requested.
     */
    CancelToken.prototype.throwIfRequested = function throwIfRequested() {
      if (this.reason) {
        throw this.reason;
      }
    };

    /**
     * Subscribe to the cancel signal
     */

    CancelToken.prototype.subscribe = function subscribe(listener) {
      if (this.reason) {
        listener(this.reason);
        return;
      }

      if (this._listeners) {
        this._listeners.push(listener);
      } else {
        this._listeners = [listener];
      }
    };

    /**
     * Unsubscribe from the cancel signal
     */

    CancelToken.prototype.unsubscribe = function unsubscribe(listener) {
      if (!this._listeners) {
        return;
      }
      var index = this._listeners.indexOf(listener);
      if (index !== -1) {
        this._listeners.splice(index, 1);
      }
    };

    /**
     * Returns an object that contains a new `CancelToken` and a function that, when called,
     * cancels the `CancelToken`.
     */
    CancelToken.source = function source() {
      var cancel;
      var token = new CancelToken(function executor(c) {
        cancel = c;
      });
      return {
        token: token,
        cancel: cancel
      };
    };

    var CancelToken_1 = CancelToken;

    /**
     * Syntactic sugar for invoking a function and expanding an array for arguments.
     *
     * Common use case would be to use `Function.prototype.apply`.
     *
     *  ```js
     *  function f(x, y, z) {}
     *  var args = [1, 2, 3];
     *  f.apply(null, args);
     *  ```
     *
     * With `spread` this example can be re-written.
     *
     *  ```js
     *  spread(function(x, y, z) {})([1, 2, 3]);
     *  ```
     *
     * @param {Function} callback
     * @returns {Function}
     */
    var spread = function spread(callback) {
      return function wrap(arr) {
        return callback.apply(null, arr);
      };
    };

    /**
     * Determines whether the payload is an error thrown by Axios
     *
     * @param {*} payload The value to test
     * @returns {boolean} True if the payload is an error thrown by Axios, otherwise false
     */
    var isAxiosError = function isAxiosError(payload) {
      return (typeof payload === 'object') && (payload.isAxiosError === true);
    };

    var utils$5 = utils$j;
    var bind = bind$2;
    var Axios = Axios_1;
    var mergeConfig = mergeConfig$2;
    var defaults$4 = defaults_1$1;

    /**
     * Create an instance of Axios
     *
     * @param {Object} defaultConfig The default config for the instance
     * @return {Axios} A new instance of Axios
     */
    function createInstance(defaultConfig) {
      var context = new Axios(defaultConfig);
      var instance = bind(Axios.prototype.request, context);

      // Copy axios.prototype to instance
      utils$5.extend(instance, Axios.prototype, context);

      // Copy context to instance
      utils$5.extend(instance, context);

      // Factory for creating new instances
      instance.create = function create(instanceConfig) {
        return createInstance(mergeConfig(defaultConfig, instanceConfig));
      };

      return instance;
    }

    // Create the default instance to be exported
    var axios$1 = createInstance(defaults$4);

    // Expose Axios class to allow class inheritance
    axios$1.Axios = Axios;

    // Expose Cancel & CancelToken
    axios$1.Cancel = Cancel_1;
    axios$1.CancelToken = CancelToken_1;
    axios$1.isCancel = isCancel$1;
    axios$1.VERSION = data.version;

    // Expose all/spread
    axios$1.all = function all(promises) {
      return Promise.all(promises);
    };
    axios$1.spread = spread;

    // Expose isAxiosError
    axios$1.isAxiosError = isAxiosError;

    axios$2.exports = axios$1;

    // Allow use of default import syntax in TypeScript
    axios$2.exports.default = axios$1;

    var axios = axios$2.exports;

    var urlJoin$1 = {exports: {}};

    (function (module) {
    (function (name, context, definition) {
      if (module.exports) module.exports = definition();
      else context[name] = definition();
    })('urljoin', commonjsGlobal, function () {

      function normalize (strArray) {
        var resultArray = [];
        if (strArray.length === 0) { return ''; }

        if (typeof strArray[0] !== 'string') {
          throw new TypeError('Url must be a string. Received ' + strArray[0]);
        }

        // If the first part is a plain protocol, we combine it with the next part.
        if (strArray[0].match(/^[^/:]+:\/*$/) && strArray.length > 1) {
          var first = strArray.shift();
          strArray[0] = first + strArray[0];
        }

        // There must be two or three slashes in the file protocol, two slashes in anything else.
        if (strArray[0].match(/^file:\/\/\//)) {
          strArray[0] = strArray[0].replace(/^([^/:]+):\/*/, '$1:///');
        } else {
          strArray[0] = strArray[0].replace(/^([^/:]+):\/*/, '$1://');
        }

        for (var i = 0; i < strArray.length; i++) {
          var component = strArray[i];

          if (typeof component !== 'string') {
            throw new TypeError('Url must be a string. Received ' + component);
          }

          if (component === '') { continue; }

          if (i > 0) {
            // Removing the starting slashes for each component but the first.
            component = component.replace(/^[\/]+/, '');
          }
          if (i < strArray.length - 1) {
            // Removing the ending slashes for each component but the last.
            component = component.replace(/[\/]+$/, '');
          } else {
            // For the last component we will combine multiple slashes to a single one.
            component = component.replace(/[\/]+$/, '/');
          }

          resultArray.push(component);

        }

        var str = resultArray.join('/');
        // Each input component is now separated by a single slash except the possible first plain protocol part.

        // remove trailing slash before parameters or hash
        str = str.replace(/\/(\?|&|#[^!])/g, '$1');

        // replace ? in parameters with &
        var parts = str.split('?');
        str = parts.shift() + (parts.length > 0 ? '?': '') + parts.join('&');

        return str;
      }

      return function () {
        var input;

        if (typeof arguments[0] === 'object') {
          input = arguments[0];
        } else {
          input = [].slice.call(arguments);
        }

        return normalize(input);
      };

    });
    }(urlJoin$1));

    var urlJoin = urlJoin$1.exports;

    var re$5 = {exports: {}};

    // Note: this is the semver.org version of the spec that it implements
    // Not necessarily the package version of this code.
    const SEMVER_SPEC_VERSION = '2.0.0';

    const MAX_LENGTH$2 = 256;
    const MAX_SAFE_INTEGER$3 = Number.MAX_SAFE_INTEGER ||
      /* istanbul ignore next */ 9007199254740991;

    // Max safe segment length for coercion.
    const MAX_SAFE_COMPONENT_LENGTH = 16;

    var constants$1 = {
      SEMVER_SPEC_VERSION,
      MAX_LENGTH: MAX_LENGTH$2,
      MAX_SAFE_INTEGER: MAX_SAFE_INTEGER$3,
      MAX_SAFE_COMPONENT_LENGTH
    };

    const debug$4 = (
      typeof process === 'object' &&
      process.env &&
      process.env.NODE_DEBUG &&
      /\bsemver\b/i.test(process.env.NODE_DEBUG)
    ) ? (...args) => console.error('SEMVER', ...args)
      : () => {};

    var debug_1 = debug$4;

    (function (module, exports) {
    const { MAX_SAFE_COMPONENT_LENGTH } = constants$1;
    const debug = debug_1;
    exports = module.exports = {};

    // The actual regexps go on exports.re
    const re = exports.re = [];
    const src = exports.src = [];
    const t = exports.t = {};
    let R = 0;

    const createToken = (name, value, isGlobal) => {
      const index = R++;
      debug(index, value);
      t[name] = index;
      src[index] = value;
      re[index] = new RegExp(value, isGlobal ? 'g' : undefined);
    };

    // The following Regular Expressions can be used for tokenizing,
    // validating, and parsing SemVer version strings.

    // ## Numeric Identifier
    // A single `0`, or a non-zero digit followed by zero or more digits.

    createToken('NUMERICIDENTIFIER', '0|[1-9]\\d*');
    createToken('NUMERICIDENTIFIERLOOSE', '[0-9]+');

    // ## Non-numeric Identifier
    // Zero or more digits, followed by a letter or hyphen, and then zero or
    // more letters, digits, or hyphens.

    createToken('NONNUMERICIDENTIFIER', '\\d*[a-zA-Z-][a-zA-Z0-9-]*');

    // ## Main Version
    // Three dot-separated numeric identifiers.

    createToken('MAINVERSION', `(${src[t.NUMERICIDENTIFIER]})\\.` +
                       `(${src[t.NUMERICIDENTIFIER]})\\.` +
                       `(${src[t.NUMERICIDENTIFIER]})`);

    createToken('MAINVERSIONLOOSE', `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.` +
                            `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.` +
                            `(${src[t.NUMERICIDENTIFIERLOOSE]})`);

    // ## Pre-release Version Identifier
    // A numeric identifier, or a non-numeric identifier.

    createToken('PRERELEASEIDENTIFIER', `(?:${src[t.NUMERICIDENTIFIER]
}|${src[t.NONNUMERICIDENTIFIER]})`);

    createToken('PRERELEASEIDENTIFIERLOOSE', `(?:${src[t.NUMERICIDENTIFIERLOOSE]
}|${src[t.NONNUMERICIDENTIFIER]})`);

    // ## Pre-release Version
    // Hyphen, followed by one or more dot-separated pre-release version
    // identifiers.

    createToken('PRERELEASE', `(?:-(${src[t.PRERELEASEIDENTIFIER]
}(?:\\.${src[t.PRERELEASEIDENTIFIER]})*))`);

    createToken('PRERELEASELOOSE', `(?:-?(${src[t.PRERELEASEIDENTIFIERLOOSE]
}(?:\\.${src[t.PRERELEASEIDENTIFIERLOOSE]})*))`);

    // ## Build Metadata Identifier
    // Any combination of digits, letters, or hyphens.

    createToken('BUILDIDENTIFIER', '[0-9A-Za-z-]+');

    // ## Build Metadata
    // Plus sign, followed by one or more period-separated build metadata
    // identifiers.

    createToken('BUILD', `(?:\\+(${src[t.BUILDIDENTIFIER]
}(?:\\.${src[t.BUILDIDENTIFIER]})*))`);

    // ## Full Version String
    // A main version, followed optionally by a pre-release version and
    // build metadata.

    // Note that the only major, minor, patch, and pre-release sections of
    // the version string are capturing groups.  The build metadata is not a
    // capturing group, because it should not ever be used in version
    // comparison.

    createToken('FULLPLAIN', `v?${src[t.MAINVERSION]
}${src[t.PRERELEASE]}?${
  src[t.BUILD]}?`);

    createToken('FULL', `^${src[t.FULLPLAIN]}$`);

    // like full, but allows v1.2.3 and =1.2.3, which people do sometimes.
    // also, 1.0.0alpha1 (prerelease without the hyphen) which is pretty
    // common in the npm registry.
    createToken('LOOSEPLAIN', `[v=\\s]*${src[t.MAINVERSIONLOOSE]
}${src[t.PRERELEASELOOSE]}?${
  src[t.BUILD]}?`);

    createToken('LOOSE', `^${src[t.LOOSEPLAIN]}$`);

    createToken('GTLT', '((?:<|>)?=?)');

    // Something like "2.*" or "1.2.x".
    // Note that "x.x" is a valid xRange identifer, meaning "any version"
    // Only the first item is strictly required.
    createToken('XRANGEIDENTIFIERLOOSE', `${src[t.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`);
    createToken('XRANGEIDENTIFIER', `${src[t.NUMERICIDENTIFIER]}|x|X|\\*`);

    createToken('XRANGEPLAIN', `[v=\\s]*(${src[t.XRANGEIDENTIFIER]})` +
                       `(?:\\.(${src[t.XRANGEIDENTIFIER]})` +
                       `(?:\\.(${src[t.XRANGEIDENTIFIER]})` +
                       `(?:${src[t.PRERELEASE]})?${
                     src[t.BUILD]}?` +
                       `)?)?`);

    createToken('XRANGEPLAINLOOSE', `[v=\\s]*(${src[t.XRANGEIDENTIFIERLOOSE]})` +
                            `(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})` +
                            `(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})` +
                            `(?:${src[t.PRERELEASELOOSE]})?${
                          src[t.BUILD]}?` +
                            `)?)?`);

    createToken('XRANGE', `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAIN]}$`);
    createToken('XRANGELOOSE', `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAINLOOSE]}$`);

    // Coercion.
    // Extract anything that could conceivably be a part of a valid semver
    createToken('COERCE', `${'(^|[^\\d])' +
              '(\\d{1,'}${MAX_SAFE_COMPONENT_LENGTH}})` +
                  `(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?` +
                  `(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?` +
                  `(?:$|[^\\d])`);
    createToken('COERCERTL', src[t.COERCE], true);

    // Tilde ranges.
    // Meaning is "reasonably at or greater than"
    createToken('LONETILDE', '(?:~>?)');

    createToken('TILDETRIM', `(\\s*)${src[t.LONETILDE]}\\s+`, true);
    exports.tildeTrimReplace = '$1~';

    createToken('TILDE', `^${src[t.LONETILDE]}${src[t.XRANGEPLAIN]}$`);
    createToken('TILDELOOSE', `^${src[t.LONETILDE]}${src[t.XRANGEPLAINLOOSE]}$`);

    // Caret ranges.
    // Meaning is "at least and backwards compatible with"
    createToken('LONECARET', '(?:\\^)');

    createToken('CARETTRIM', `(\\s*)${src[t.LONECARET]}\\s+`, true);
    exports.caretTrimReplace = '$1^';

    createToken('CARET', `^${src[t.LONECARET]}${src[t.XRANGEPLAIN]}$`);
    createToken('CARETLOOSE', `^${src[t.LONECARET]}${src[t.XRANGEPLAINLOOSE]}$`);

    // A simple gt/lt/eq thing, or just "" to indicate "any version"
    createToken('COMPARATORLOOSE', `^${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]})$|^$`);
    createToken('COMPARATOR', `^${src[t.GTLT]}\\s*(${src[t.FULLPLAIN]})$|^$`);

    // An expression to strip any whitespace between the gtlt and the thing
    // it modifies, so that `> 1.2.3` ==> `>1.2.3`
    createToken('COMPARATORTRIM', `(\\s*)${src[t.GTLT]
}\\s*(${src[t.LOOSEPLAIN]}|${src[t.XRANGEPLAIN]})`, true);
    exports.comparatorTrimReplace = '$1$2$3';

    // Something like `1.2.3 - 1.2.4`
    // Note that these all use the loose form, because they'll be
    // checked against either the strict or loose comparator form
    // later.
    createToken('HYPHENRANGE', `^\\s*(${src[t.XRANGEPLAIN]})` +
                       `\\s+-\\s+` +
                       `(${src[t.XRANGEPLAIN]})` +
                       `\\s*$`);

    createToken('HYPHENRANGELOOSE', `^\\s*(${src[t.XRANGEPLAINLOOSE]})` +
                            `\\s+-\\s+` +
                            `(${src[t.XRANGEPLAINLOOSE]})` +
                            `\\s*$`);

    // Star ranges basically just allow anything at all.
    createToken('STAR', '(<|>)?=?\\s*\\*');
    // >=0.0.0 is like a star
    createToken('GTE0', '^\\s*>=\\s*0\.0\.0\\s*$');
    createToken('GTE0PRE', '^\\s*>=\\s*0\.0\.0-0\\s*$');
    }(re$5, re$5.exports));

    // parse out just the options we care about so we always get a consistent
    // obj with keys in a consistent order.
    const opts = ['includePrerelease', 'loose', 'rtl'];
    const parseOptions$4 = options =>
      !options ? {}
      : typeof options !== 'object' ? { loose: true }
      : opts.filter(k => options[k]).reduce((options, k) => {
        options[k] = true;
        return options
      }, {});
    var parseOptions_1 = parseOptions$4;

    const numeric$1 = /^[0-9]+$/;
    const compareIdentifiers$1 = (a, b) => {
      const anum = numeric$1.test(a);
      const bnum = numeric$1.test(b);

      if (anum && bnum) {
        a = +a;
        b = +b;
      }

      return a === b ? 0
        : (anum && !bnum) ? -1
        : (bnum && !anum) ? 1
        : a < b ? -1
        : 1
    };

    const rcompareIdentifiers = (a, b) => compareIdentifiers$1(b, a);

    var identifiers = {
      compareIdentifiers: compareIdentifiers$1,
      rcompareIdentifiers
    };

    const debug$3 = debug_1;
    const { MAX_LENGTH: MAX_LENGTH$1, MAX_SAFE_INTEGER: MAX_SAFE_INTEGER$2 } = constants$1;
    const { re: re$4, t: t$4 } = re$5.exports;

    const parseOptions$3 = parseOptions_1;
    const { compareIdentifiers } = identifiers;
    class SemVer$e {
      constructor (version, options) {
        options = parseOptions$3(options);

        if (version instanceof SemVer$e) {
          if (version.loose === !!options.loose &&
              version.includePrerelease === !!options.includePrerelease) {
            return version
          } else {
            version = version.version;
          }
        } else if (typeof version !== 'string') {
          throw new TypeError(`Invalid Version: ${version}`)
        }

        if (version.length > MAX_LENGTH$1) {
          throw new TypeError(
            `version is longer than ${MAX_LENGTH$1} characters`
          )
        }

        debug$3('SemVer', version, options);
        this.options = options;
        this.loose = !!options.loose;
        // this isn't actually relevant for versions, but keep it so that we
        // don't run into trouble passing this.options around.
        this.includePrerelease = !!options.includePrerelease;

        const m = version.trim().match(options.loose ? re$4[t$4.LOOSE] : re$4[t$4.FULL]);

        if (!m) {
          throw new TypeError(`Invalid Version: ${version}`)
        }

        this.raw = version;

        // these are actually numbers
        this.major = +m[1];
        this.minor = +m[2];
        this.patch = +m[3];

        if (this.major > MAX_SAFE_INTEGER$2 || this.major < 0) {
          throw new TypeError('Invalid major version')
        }

        if (this.minor > MAX_SAFE_INTEGER$2 || this.minor < 0) {
          throw new TypeError('Invalid minor version')
        }

        if (this.patch > MAX_SAFE_INTEGER$2 || this.patch < 0) {
          throw new TypeError('Invalid patch version')
        }

        // numberify any prerelease numeric ids
        if (!m[4]) {
          this.prerelease = [];
        } else {
          this.prerelease = m[4].split('.').map((id) => {
            if (/^[0-9]+$/.test(id)) {
              const num = +id;
              if (num >= 0 && num < MAX_SAFE_INTEGER$2) {
                return num
              }
            }
            return id
          });
        }

        this.build = m[5] ? m[5].split('.') : [];
        this.format();
      }

      format () {
        this.version = `${this.major}.${this.minor}.${this.patch}`;
        if (this.prerelease.length) {
          this.version += `-${this.prerelease.join('.')}`;
        }
        return this.version
      }

      toString () {
        return this.version
      }

      compare (other) {
        debug$3('SemVer.compare', this.version, this.options, other);
        if (!(other instanceof SemVer$e)) {
          if (typeof other === 'string' && other === this.version) {
            return 0
          }
          other = new SemVer$e(other, this.options);
        }

        if (other.version === this.version) {
          return 0
        }

        return this.compareMain(other) || this.comparePre(other)
      }

      compareMain (other) {
        if (!(other instanceof SemVer$e)) {
          other = new SemVer$e(other, this.options);
        }

        return (
          compareIdentifiers(this.major, other.major) ||
          compareIdentifiers(this.minor, other.minor) ||
          compareIdentifiers(this.patch, other.patch)
        )
      }

      comparePre (other) {
        if (!(other instanceof SemVer$e)) {
          other = new SemVer$e(other, this.options);
        }

        // NOT having a prerelease is > having one
        if (this.prerelease.length && !other.prerelease.length) {
          return -1
        } else if (!this.prerelease.length && other.prerelease.length) {
          return 1
        } else if (!this.prerelease.length && !other.prerelease.length) {
          return 0
        }

        let i = 0;
        do {
          const a = this.prerelease[i];
          const b = other.prerelease[i];
          debug$3('prerelease compare', i, a, b);
          if (a === undefined && b === undefined) {
            return 0
          } else if (b === undefined) {
            return 1
          } else if (a === undefined) {
            return -1
          } else if (a === b) {
            continue
          } else {
            return compareIdentifiers(a, b)
          }
        } while (++i)
      }

      compareBuild (other) {
        if (!(other instanceof SemVer$e)) {
          other = new SemVer$e(other, this.options);
        }

        let i = 0;
        do {
          const a = this.build[i];
          const b = other.build[i];
          debug$3('prerelease compare', i, a, b);
          if (a === undefined && b === undefined) {
            return 0
          } else if (b === undefined) {
            return 1
          } else if (a === undefined) {
            return -1
          } else if (a === b) {
            continue
          } else {
            return compareIdentifiers(a, b)
          }
        } while (++i)
      }

      // preminor will bump the version up to the next minor release, and immediately
      // down to pre-release. premajor and prepatch work the same way.
      inc (release, identifier) {
        switch (release) {
          case 'premajor':
            this.prerelease.length = 0;
            this.patch = 0;
            this.minor = 0;
            this.major++;
            this.inc('pre', identifier);
            break
          case 'preminor':
            this.prerelease.length = 0;
            this.patch = 0;
            this.minor++;
            this.inc('pre', identifier);
            break
          case 'prepatch':
            // If this is already a prerelease, it will bump to the next version
            // drop any prereleases that might already exist, since they are not
            // relevant at this point.
            this.prerelease.length = 0;
            this.inc('patch', identifier);
            this.inc('pre', identifier);
            break
          // If the input is a non-prerelease version, this acts the same as
          // prepatch.
          case 'prerelease':
            if (this.prerelease.length === 0) {
              this.inc('patch', identifier);
            }
            this.inc('pre', identifier);
            break

          case 'major':
            // If this is a pre-major version, bump up to the same major version.
            // Otherwise increment major.
            // 1.0.0-5 bumps to 1.0.0
            // 1.1.0 bumps to 2.0.0
            if (
              this.minor !== 0 ||
              this.patch !== 0 ||
              this.prerelease.length === 0
            ) {
              this.major++;
            }
            this.minor = 0;
            this.patch = 0;
            this.prerelease = [];
            break
          case 'minor':
            // If this is a pre-minor version, bump up to the same minor version.
            // Otherwise increment minor.
            // 1.2.0-5 bumps to 1.2.0
            // 1.2.1 bumps to 1.3.0
            if (this.patch !== 0 || this.prerelease.length === 0) {
              this.minor++;
            }
            this.patch = 0;
            this.prerelease = [];
            break
          case 'patch':
            // If this is not a pre-release version, it will increment the patch.
            // If it is a pre-release it will bump up to the same patch version.
            // 1.2.0-5 patches to 1.2.0
            // 1.2.0 patches to 1.2.1
            if (this.prerelease.length === 0) {
              this.patch++;
            }
            this.prerelease = [];
            break
          // This probably shouldn't be used publicly.
          // 1.0.0 'pre' would become 1.0.0-0 which is the wrong direction.
          case 'pre':
            if (this.prerelease.length === 0) {
              this.prerelease = [0];
            } else {
              let i = this.prerelease.length;
              while (--i >= 0) {
                if (typeof this.prerelease[i] === 'number') {
                  this.prerelease[i]++;
                  i = -2;
                }
              }
              if (i === -1) {
                // didn't increment anything
                this.prerelease.push(0);
              }
            }
            if (identifier) {
              // 1.2.0-beta.1 bumps to 1.2.0-beta.2,
              // 1.2.0-beta.fooblz or 1.2.0-beta bumps to 1.2.0-beta.0
              if (this.prerelease[0] === identifier) {
                if (isNaN(this.prerelease[1])) {
                  this.prerelease = [identifier, 0];
                }
              } else {
                this.prerelease = [identifier, 0];
              }
            }
            break

          default:
            throw new Error(`invalid increment argument: ${release}`)
        }
        this.format();
        this.raw = this.version;
        return this
      }
    }

    var semver$3 = SemVer$e;

    const {MAX_LENGTH} = constants$1;
    const { re: re$3, t: t$3 } = re$5.exports;
    const SemVer$d = semver$3;

    const parseOptions$2 = parseOptions_1;
    const parse$6 = (version, options) => {
      options = parseOptions$2(options);

      if (version instanceof SemVer$d) {
        return version
      }

      if (typeof version !== 'string') {
        return null
      }

      if (version.length > MAX_LENGTH) {
        return null
      }

      const r = options.loose ? re$3[t$3.LOOSE] : re$3[t$3.FULL];
      if (!r.test(version)) {
        return null
      }

      try {
        return new SemVer$d(version, options)
      } catch (er) {
        return null
      }
    };

    var parse_1 = parse$6;

    const parse$5 = parse_1;
    const valid$1 = (version, options) => {
      const v = parse$5(version, options);
      return v ? v.version : null
    };
    var valid_1 = valid$1;

    const parse$4 = parse_1;
    const clean = (version, options) => {
      const s = parse$4(version.trim().replace(/^[=v]+/, ''), options);
      return s ? s.version : null
    };
    var clean_1 = clean;

    const SemVer$c = semver$3;

    const inc = (version, release, options, identifier) => {
      if (typeof (options) === 'string') {
        identifier = options;
        options = undefined;
      }

      try {
        return new SemVer$c(version, options).inc(release, identifier).version
      } catch (er) {
        return null
      }
    };
    var inc_1 = inc;

    const SemVer$b = semver$3;
    const compare$a = (a, b, loose) =>
      new SemVer$b(a, loose).compare(new SemVer$b(b, loose));

    var compare_1 = compare$a;

    const compare$9 = compare_1;
    const eq$8 = (a, b, loose) => compare$9(a, b, loose) === 0;
    var eq_1$1 = eq$8;

    const parse$3 = parse_1;
    const eq$7 = eq_1$1;

    const diff = (version1, version2) => {
      if (eq$7(version1, version2)) {
        return null
      } else {
        const v1 = parse$3(version1);
        const v2 = parse$3(version2);
        const hasPre = v1.prerelease.length || v2.prerelease.length;
        const prefix = hasPre ? 'pre' : '';
        const defaultResult = hasPre ? 'prerelease' : '';
        for (const key in v1) {
          if (key === 'major' || key === 'minor' || key === 'patch') {
            if (v1[key] !== v2[key]) {
              return prefix + key
            }
          }
        }
        return defaultResult // may be undefined
      }
    };
    var diff_1 = diff;

    const SemVer$a = semver$3;
    const major = (a, loose) => new SemVer$a(a, loose).major;
    var major_1 = major;

    const SemVer$9 = semver$3;
    const minor = (a, loose) => new SemVer$9(a, loose).minor;
    var minor_1 = minor;

    const SemVer$8 = semver$3;
    const patch$2 = (a, loose) => new SemVer$8(a, loose).patch;
    var patch_1 = patch$2;

    const parse$2 = parse_1;
    const prerelease = (version, options) => {
      const parsed = parse$2(version, options);
      return (parsed && parsed.prerelease.length) ? parsed.prerelease : null
    };
    var prerelease_1 = prerelease;

    const compare$8 = compare_1;
    const rcompare = (a, b, loose) => compare$8(b, a, loose);
    var rcompare_1 = rcompare;

    const compare$7 = compare_1;
    const compareLoose = (a, b) => compare$7(a, b, true);
    var compareLoose_1 = compareLoose;

    const SemVer$7 = semver$3;
    const compareBuild$2 = (a, b, loose) => {
      const versionA = new SemVer$7(a, loose);
      const versionB = new SemVer$7(b, loose);
      return versionA.compare(versionB) || versionA.compareBuild(versionB)
    };
    var compareBuild_1 = compareBuild$2;

    const compareBuild$1 = compareBuild_1;
    const sort$1 = (list, loose) => list.sort((a, b) => compareBuild$1(a, b, loose));
    var sort_1 = sort$1;

    const compareBuild = compareBuild_1;
    const rsort = (list, loose) => list.sort((a, b) => compareBuild(b, a, loose));
    var rsort_1 = rsort;

    const compare$6 = compare_1;
    const gt$3 = (a, b, loose) => compare$6(a, b, loose) > 0;
    var gt_1 = gt$3;

    const compare$5 = compare_1;
    const lt$2 = (a, b, loose) => compare$5(a, b, loose) < 0;
    var lt_1 = lt$2;

    const compare$4 = compare_1;
    const neq$1 = (a, b, loose) => compare$4(a, b, loose) !== 0;
    var neq_1 = neq$1;

    const compare$3 = compare_1;
    const gte$3 = (a, b, loose) => compare$3(a, b, loose) >= 0;
    var gte_1 = gte$3;

    const compare$2 = compare_1;
    const lte$3 = (a, b, loose) => compare$2(a, b, loose) <= 0;
    var lte_1 = lte$3;

    const eq$6 = eq_1$1;
    const neq = neq_1;
    const gt$2 = gt_1;
    const gte$2 = gte_1;
    const lt$1 = lt_1;
    const lte$2 = lte_1;

    const cmp$1 = (a, op, b, loose) => {
      switch (op) {
        case '===':
          if (typeof a === 'object')
            a = a.version;
          if (typeof b === 'object')
            b = b.version;
          return a === b

        case '!==':
          if (typeof a === 'object')
            a = a.version;
          if (typeof b === 'object')
            b = b.version;
          return a !== b

        case '':
        case '=':
        case '==':
          return eq$6(a, b, loose)

        case '!=':
          return neq(a, b, loose)

        case '>':
          return gt$2(a, b, loose)

        case '>=':
          return gte$2(a, b, loose)

        case '<':
          return lt$1(a, b, loose)

        case '<=':
          return lte$2(a, b, loose)

        default:
          throw new TypeError(`Invalid operator: ${op}`)
      }
    };
    var cmp_1 = cmp$1;

    const SemVer$6 = semver$3;
    const parse$1 = parse_1;
    const {re: re$2, t: t$2} = re$5.exports;

    const coerce = (version, options) => {
      if (version instanceof SemVer$6) {
        return version
      }

      if (typeof version === 'number') {
        version = String(version);
      }

      if (typeof version !== 'string') {
        return null
      }

      options = options || {};

      let match = null;
      if (!options.rtl) {
        match = version.match(re$2[t$2.COERCE]);
      } else {
        // Find the right-most coercible string that does not share
        // a terminus with a more left-ward coercible string.
        // Eg, '1.2.3.4' wants to coerce '2.3.4', not '3.4' or '4'
        //
        // Walk through the string checking with a /g regexp
        // Manually set the index so as to pick up overlapping matches.
        // Stop when we get a match that ends at the string end, since no
        // coercible string can be more right-ward without the same terminus.
        let next;
        while ((next = re$2[t$2.COERCERTL].exec(version)) &&
            (!match || match.index + match[0].length !== version.length)
        ) {
          if (!match ||
                next.index + next[0].length !== match.index + match[0].length) {
            match = next;
          }
          re$2[t$2.COERCERTL].lastIndex = next.index + next[1].length + next[2].length;
        }
        // leave it in a clean state
        re$2[t$2.COERCERTL].lastIndex = -1;
      }

      if (match === null)
        return null

      return parse$1(`${match[2]}.${match[3] || '0'}.${match[4] || '0'}`, options)
    };
    var coerce_1 = coerce;

    var yallist = Yallist$1;

    Yallist$1.Node = Node$1;
    Yallist$1.create = Yallist$1;

    function Yallist$1 (list) {
      var self = this;
      if (!(self instanceof Yallist$1)) {
        self = new Yallist$1();
      }

      self.tail = null;
      self.head = null;
      self.length = 0;

      if (list && typeof list.forEach === 'function') {
        list.forEach(function (item) {
          self.push(item);
        });
      } else if (arguments.length > 0) {
        for (var i = 0, l = arguments.length; i < l; i++) {
          self.push(arguments[i]);
        }
      }

      return self
    }

    Yallist$1.prototype.removeNode = function (node) {
      if (node.list !== this) {
        throw new Error('removing node which does not belong to this list')
      }

      var next = node.next;
      var prev = node.prev;

      if (next) {
        next.prev = prev;
      }

      if (prev) {
        prev.next = next;
      }

      if (node === this.head) {
        this.head = next;
      }
      if (node === this.tail) {
        this.tail = prev;
      }

      node.list.length--;
      node.next = null;
      node.prev = null;
      node.list = null;

      return next
    };

    Yallist$1.prototype.unshiftNode = function (node) {
      if (node === this.head) {
        return
      }

      if (node.list) {
        node.list.removeNode(node);
      }

      var head = this.head;
      node.list = this;
      node.next = head;
      if (head) {
        head.prev = node;
      }

      this.head = node;
      if (!this.tail) {
        this.tail = node;
      }
      this.length++;
    };

    Yallist$1.prototype.pushNode = function (node) {
      if (node === this.tail) {
        return
      }

      if (node.list) {
        node.list.removeNode(node);
      }

      var tail = this.tail;
      node.list = this;
      node.prev = tail;
      if (tail) {
        tail.next = node;
      }

      this.tail = node;
      if (!this.head) {
        this.head = node;
      }
      this.length++;
    };

    Yallist$1.prototype.push = function () {
      for (var i = 0, l = arguments.length; i < l; i++) {
        push(this, arguments[i]);
      }
      return this.length
    };

    Yallist$1.prototype.unshift = function () {
      for (var i = 0, l = arguments.length; i < l; i++) {
        unshift(this, arguments[i]);
      }
      return this.length
    };

    Yallist$1.prototype.pop = function () {
      if (!this.tail) {
        return undefined
      }

      var res = this.tail.value;
      this.tail = this.tail.prev;
      if (this.tail) {
        this.tail.next = null;
      } else {
        this.head = null;
      }
      this.length--;
      return res
    };

    Yallist$1.prototype.shift = function () {
      if (!this.head) {
        return undefined
      }

      var res = this.head.value;
      this.head = this.head.next;
      if (this.head) {
        this.head.prev = null;
      } else {
        this.tail = null;
      }
      this.length--;
      return res
    };

    Yallist$1.prototype.forEach = function (fn, thisp) {
      thisp = thisp || this;
      for (var walker = this.head, i = 0; walker !== null; i++) {
        fn.call(thisp, walker.value, i, this);
        walker = walker.next;
      }
    };

    Yallist$1.prototype.forEachReverse = function (fn, thisp) {
      thisp = thisp || this;
      for (var walker = this.tail, i = this.length - 1; walker !== null; i--) {
        fn.call(thisp, walker.value, i, this);
        walker = walker.prev;
      }
    };

    Yallist$1.prototype.get = function (n) {
      for (var i = 0, walker = this.head; walker !== null && i < n; i++) {
        // abort out of the list early if we hit a cycle
        walker = walker.next;
      }
      if (i === n && walker !== null) {
        return walker.value
      }
    };

    Yallist$1.prototype.getReverse = function (n) {
      for (var i = 0, walker = this.tail; walker !== null && i < n; i++) {
        // abort out of the list early if we hit a cycle
        walker = walker.prev;
      }
      if (i === n && walker !== null) {
        return walker.value
      }
    };

    Yallist$1.prototype.map = function (fn, thisp) {
      thisp = thisp || this;
      var res = new Yallist$1();
      for (var walker = this.head; walker !== null;) {
        res.push(fn.call(thisp, walker.value, this));
        walker = walker.next;
      }
      return res
    };

    Yallist$1.prototype.mapReverse = function (fn, thisp) {
      thisp = thisp || this;
      var res = new Yallist$1();
      for (var walker = this.tail; walker !== null;) {
        res.push(fn.call(thisp, walker.value, this));
        walker = walker.prev;
      }
      return res
    };

    Yallist$1.prototype.reduce = function (fn, initial) {
      var acc;
      var walker = this.head;
      if (arguments.length > 1) {
        acc = initial;
      } else if (this.head) {
        walker = this.head.next;
        acc = this.head.value;
      } else {
        throw new TypeError('Reduce of empty list with no initial value')
      }

      for (var i = 0; walker !== null; i++) {
        acc = fn(acc, walker.value, i);
        walker = walker.next;
      }

      return acc
    };

    Yallist$1.prototype.reduceReverse = function (fn, initial) {
      var acc;
      var walker = this.tail;
      if (arguments.length > 1) {
        acc = initial;
      } else if (this.tail) {
        walker = this.tail.prev;
        acc = this.tail.value;
      } else {
        throw new TypeError('Reduce of empty list with no initial value')
      }

      for (var i = this.length - 1; walker !== null; i--) {
        acc = fn(acc, walker.value, i);
        walker = walker.prev;
      }

      return acc
    };

    Yallist$1.prototype.toArray = function () {
      var arr = new Array(this.length);
      for (var i = 0, walker = this.head; walker !== null; i++) {
        arr[i] = walker.value;
        walker = walker.next;
      }
      return arr
    };

    Yallist$1.prototype.toArrayReverse = function () {
      var arr = new Array(this.length);
      for (var i = 0, walker = this.tail; walker !== null; i++) {
        arr[i] = walker.value;
        walker = walker.prev;
      }
      return arr
    };

    Yallist$1.prototype.slice = function (from, to) {
      to = to || this.length;
      if (to < 0) {
        to += this.length;
      }
      from = from || 0;
      if (from < 0) {
        from += this.length;
      }
      var ret = new Yallist$1();
      if (to < from || to < 0) {
        return ret
      }
      if (from < 0) {
        from = 0;
      }
      if (to > this.length) {
        to = this.length;
      }
      for (var i = 0, walker = this.head; walker !== null && i < from; i++) {
        walker = walker.next;
      }
      for (; walker !== null && i < to; i++, walker = walker.next) {
        ret.push(walker.value);
      }
      return ret
    };

    Yallist$1.prototype.sliceReverse = function (from, to) {
      to = to || this.length;
      if (to < 0) {
        to += this.length;
      }
      from = from || 0;
      if (from < 0) {
        from += this.length;
      }
      var ret = new Yallist$1();
      if (to < from || to < 0) {
        return ret
      }
      if (from < 0) {
        from = 0;
      }
      if (to > this.length) {
        to = this.length;
      }
      for (var i = this.length, walker = this.tail; walker !== null && i > to; i--) {
        walker = walker.prev;
      }
      for (; walker !== null && i > from; i--, walker = walker.prev) {
        ret.push(walker.value);
      }
      return ret
    };

    Yallist$1.prototype.splice = function (start, deleteCount, ...nodes) {
      if (start > this.length) {
        start = this.length - 1;
      }
      if (start < 0) {
        start = this.length + start;
      }

      for (var i = 0, walker = this.head; walker !== null && i < start; i++) {
        walker = walker.next;
      }

      var ret = [];
      for (var i = 0; walker && i < deleteCount; i++) {
        ret.push(walker.value);
        walker = this.removeNode(walker);
      }
      if (walker === null) {
        walker = this.tail;
      }

      if (walker !== this.head && walker !== this.tail) {
        walker = walker.prev;
      }

      for (var i = 0; i < nodes.length; i++) {
        walker = insert(this, walker, nodes[i]);
      }
      return ret;
    };

    Yallist$1.prototype.reverse = function () {
      var head = this.head;
      var tail = this.tail;
      for (var walker = head; walker !== null; walker = walker.prev) {
        var p = walker.prev;
        walker.prev = walker.next;
        walker.next = p;
      }
      this.head = tail;
      this.tail = head;
      return this
    };

    function insert (self, node, value) {
      var inserted = node === self.head ?
        new Node$1(value, null, node, self) :
        new Node$1(value, node, node.next, self);

      if (inserted.next === null) {
        self.tail = inserted;
      }
      if (inserted.prev === null) {
        self.head = inserted;
      }

      self.length++;

      return inserted
    }

    function push (self, item) {
      self.tail = new Node$1(item, self.tail, null, self);
      if (!self.head) {
        self.head = self.tail;
      }
      self.length++;
    }

    function unshift (self, item) {
      self.head = new Node$1(item, null, self.head, self);
      if (!self.tail) {
        self.tail = self.head;
      }
      self.length++;
    }

    function Node$1 (value, prev, next, list) {
      if (!(this instanceof Node$1)) {
        return new Node$1(value, prev, next, list)
      }

      this.list = list;
      this.value = value;

      if (prev) {
        prev.next = this;
        this.prev = prev;
      } else {
        this.prev = null;
      }

      if (next) {
        next.prev = this;
        this.next = next;
      } else {
        this.next = null;
      }
    }

    try {
      // add if support for Symbol.iterator is present
      require('./iterator.js')(Yallist$1);
    } catch (er) {}

    // A linked list to keep track of recently-used-ness
    const Yallist = yallist;

    const MAX = Symbol('max');
    const LENGTH = Symbol('length');
    const LENGTH_CALCULATOR = Symbol('lengthCalculator');
    const ALLOW_STALE = Symbol('allowStale');
    const MAX_AGE = Symbol('maxAge');
    const DISPOSE = Symbol('dispose');
    const NO_DISPOSE_ON_SET = Symbol('noDisposeOnSet');
    const LRU_LIST = Symbol('lruList');
    const CACHE = Symbol('cache');
    const UPDATE_AGE_ON_GET = Symbol('updateAgeOnGet');

    const naiveLength = () => 1;

    // lruList is a yallist where the head is the youngest
    // item, and the tail is the oldest.  the list contains the Hit
    // objects as the entries.
    // Each Hit object has a reference to its Yallist.Node.  This
    // never changes.
    //
    // cache is a Map (or PseudoMap) that matches the keys to
    // the Yallist.Node object.
    class LRUCache {
      constructor (options) {
        if (typeof options === 'number')
          options = { max: options };

        if (!options)
          options = {};

        if (options.max && (typeof options.max !== 'number' || options.max < 0))
          throw new TypeError('max must be a non-negative number')
        // Kind of weird to have a default max of Infinity, but oh well.
        this[MAX] = options.max || Infinity;

        const lc = options.length || naiveLength;
        this[LENGTH_CALCULATOR] = (typeof lc !== 'function') ? naiveLength : lc;
        this[ALLOW_STALE] = options.stale || false;
        if (options.maxAge && typeof options.maxAge !== 'number')
          throw new TypeError('maxAge must be a number')
        this[MAX_AGE] = options.maxAge || 0;
        this[DISPOSE] = options.dispose;
        this[NO_DISPOSE_ON_SET] = options.noDisposeOnSet || false;
        this[UPDATE_AGE_ON_GET] = options.updateAgeOnGet || false;
        this.reset();
      }

      // resize the cache when the max changes.
      set max (mL) {
        if (typeof mL !== 'number' || mL < 0)
          throw new TypeError('max must be a non-negative number')

        this[MAX] = mL || Infinity;
        trim(this);
      }
      get max () {
        return this[MAX]
      }

      set allowStale (allowStale) {
        this[ALLOW_STALE] = !!allowStale;
      }
      get allowStale () {
        return this[ALLOW_STALE]
      }

      set maxAge (mA) {
        if (typeof mA !== 'number')
          throw new TypeError('maxAge must be a non-negative number')

        this[MAX_AGE] = mA;
        trim(this);
      }
      get maxAge () {
        return this[MAX_AGE]
      }

      // resize the cache when the lengthCalculator changes.
      set lengthCalculator (lC) {
        if (typeof lC !== 'function')
          lC = naiveLength;

        if (lC !== this[LENGTH_CALCULATOR]) {
          this[LENGTH_CALCULATOR] = lC;
          this[LENGTH] = 0;
          this[LRU_LIST].forEach(hit => {
            hit.length = this[LENGTH_CALCULATOR](hit.value, hit.key);
            this[LENGTH] += hit.length;
          });
        }
        trim(this);
      }
      get lengthCalculator () { return this[LENGTH_CALCULATOR] }

      get length () { return this[LENGTH] }
      get itemCount () { return this[LRU_LIST].length }

      rforEach (fn, thisp) {
        thisp = thisp || this;
        for (let walker = this[LRU_LIST].tail; walker !== null;) {
          const prev = walker.prev;
          forEachStep(this, fn, walker, thisp);
          walker = prev;
        }
      }

      forEach (fn, thisp) {
        thisp = thisp || this;
        for (let walker = this[LRU_LIST].head; walker !== null;) {
          const next = walker.next;
          forEachStep(this, fn, walker, thisp);
          walker = next;
        }
      }

      keys () {
        return this[LRU_LIST].toArray().map(k => k.key)
      }

      values () {
        return this[LRU_LIST].toArray().map(k => k.value)
      }

      reset () {
        if (this[DISPOSE] &&
            this[LRU_LIST] &&
            this[LRU_LIST].length) {
          this[LRU_LIST].forEach(hit => this[DISPOSE](hit.key, hit.value));
        }

        this[CACHE] = new Map(); // hash of items by key
        this[LRU_LIST] = new Yallist(); // list of items in order of use recency
        this[LENGTH] = 0; // length of items in the list
      }

      dump () {
        return this[LRU_LIST].map(hit =>
          isStale(this, hit) ? false : {
            k: hit.key,
            v: hit.value,
            e: hit.now + (hit.maxAge || 0)
          }).toArray().filter(h => h)
      }

      dumpLru () {
        return this[LRU_LIST]
      }

      set (key, value, maxAge) {
        maxAge = maxAge || this[MAX_AGE];

        if (maxAge && typeof maxAge !== 'number')
          throw new TypeError('maxAge must be a number')

        const now = maxAge ? Date.now() : 0;
        const len = this[LENGTH_CALCULATOR](value, key);

        if (this[CACHE].has(key)) {
          if (len > this[MAX]) {
            del(this, this[CACHE].get(key));
            return false
          }

          const node = this[CACHE].get(key);
          const item = node.value;

          // dispose of the old one before overwriting
          // split out into 2 ifs for better coverage tracking
          if (this[DISPOSE]) {
            if (!this[NO_DISPOSE_ON_SET])
              this[DISPOSE](key, item.value);
          }

          item.now = now;
          item.maxAge = maxAge;
          item.value = value;
          this[LENGTH] += len - item.length;
          item.length = len;
          this.get(key);
          trim(this);
          return true
        }

        const hit = new Entry(key, value, len, now, maxAge);

        // oversized objects fall out of cache automatically.
        if (hit.length > this[MAX]) {
          if (this[DISPOSE])
            this[DISPOSE](key, value);

          return false
        }

        this[LENGTH] += hit.length;
        this[LRU_LIST].unshift(hit);
        this[CACHE].set(key, this[LRU_LIST].head);
        trim(this);
        return true
      }

      has (key) {
        if (!this[CACHE].has(key)) return false
        const hit = this[CACHE].get(key).value;
        return !isStale(this, hit)
      }

      get (key) {
        return get$2(this, key, true)
      }

      peek (key) {
        return get$2(this, key, false)
      }

      pop () {
        const node = this[LRU_LIST].tail;
        if (!node)
          return null

        del(this, node);
        return node.value
      }

      del (key) {
        del(this, this[CACHE].get(key));
      }

      load (arr) {
        // reset the cache
        this.reset();

        const now = Date.now();
        // A previous serialized cache has the most recent items first
        for (let l = arr.length - 1; l >= 0; l--) {
          const hit = arr[l];
          const expiresAt = hit.e || 0;
          if (expiresAt === 0)
            // the item was created without expiration in a non aged cache
            this.set(hit.k, hit.v);
          else {
            const maxAge = expiresAt - now;
            // dont add already expired items
            if (maxAge > 0) {
              this.set(hit.k, hit.v, maxAge);
            }
          }
        }
      }

      prune () {
        this[CACHE].forEach((value, key) => get$2(this, key, false));
      }
    }

    const get$2 = (self, key, doUse) => {
      const node = self[CACHE].get(key);
      if (node) {
        const hit = node.value;
        if (isStale(self, hit)) {
          del(self, node);
          if (!self[ALLOW_STALE])
            return undefined
        } else {
          if (doUse) {
            if (self[UPDATE_AGE_ON_GET])
              node.value.now = Date.now();
            self[LRU_LIST].unshiftNode(node);
          }
        }
        return hit.value
      }
    };

    const isStale = (self, hit) => {
      if (!hit || (!hit.maxAge && !self[MAX_AGE]))
        return false

      const diff = Date.now() - hit.now;
      return hit.maxAge ? diff > hit.maxAge
        : self[MAX_AGE] && (diff > self[MAX_AGE])
    };

    const trim = self => {
      if (self[LENGTH] > self[MAX]) {
        for (let walker = self[LRU_LIST].tail;
          self[LENGTH] > self[MAX] && walker !== null;) {
          // We know that we're about to delete this one, and also
          // what the next least recently used key will be, so just
          // go ahead and set it now.
          const prev = walker.prev;
          del(self, walker);
          walker = prev;
        }
      }
    };

    const del = (self, node) => {
      if (node) {
        const hit = node.value;
        if (self[DISPOSE])
          self[DISPOSE](hit.key, hit.value);

        self[LENGTH] -= hit.length;
        self[CACHE].delete(hit.key);
        self[LRU_LIST].removeNode(node);
      }
    };

    class Entry {
      constructor (key, value, length, now, maxAge) {
        this.key = key;
        this.value = value;
        this.length = length;
        this.now = now;
        this.maxAge = maxAge || 0;
      }
    }

    const forEachStep = (self, fn, node, thisp) => {
      let hit = node.value;
      if (isStale(self, hit)) {
        del(self, node);
        if (!self[ALLOW_STALE])
          hit = undefined;
      }
      if (hit)
        fn.call(thisp, hit.value, hit.key, self);
    };

    var lruCache = LRUCache;

    // hoisted class for cyclic dependency
    class Range$a {
      constructor (range, options) {
        options = parseOptions$1(options);

        if (range instanceof Range$a) {
          if (
            range.loose === !!options.loose &&
            range.includePrerelease === !!options.includePrerelease
          ) {
            return range
          } else {
            return new Range$a(range.raw, options)
          }
        }

        if (range instanceof Comparator$3) {
          // just put it in the set and return
          this.raw = range.value;
          this.set = [[range]];
          this.format();
          return this
        }

        this.options = options;
        this.loose = !!options.loose;
        this.includePrerelease = !!options.includePrerelease;

        // First, split based on boolean or ||
        this.raw = range;
        this.set = range
          .split(/\s*\|\|\s*/)
          // map the range to a 2d array of comparators
          .map(range => this.parseRange(range.trim()))
          // throw out any comparator lists that are empty
          // this generally means that it was not a valid range, which is allowed
          // in loose mode, but will still throw if the WHOLE range is invalid.
          .filter(c => c.length);

        if (!this.set.length) {
          throw new TypeError(`Invalid SemVer Range: ${range}`)
        }

        // if we have any that are not the null set, throw out null sets.
        if (this.set.length > 1) {
          // keep the first one, in case they're all null sets
          const first = this.set[0];
          this.set = this.set.filter(c => !isNullSet(c[0]));
          if (this.set.length === 0)
            this.set = [first];
          else if (this.set.length > 1) {
            // if we have any that are *, then the range is just *
            for (const c of this.set) {
              if (c.length === 1 && isAny(c[0])) {
                this.set = [c];
                break
              }
            }
          }
        }

        this.format();
      }

      format () {
        this.range = this.set
          .map((comps) => {
            return comps.join(' ').trim()
          })
          .join('||')
          .trim();
        return this.range
      }

      toString () {
        return this.range
      }

      parseRange (range) {
        range = range.trim();

        // memoize range parsing for performance.
        // this is a very hot path, and fully deterministic.
        const memoOpts = Object.keys(this.options).join(',');
        const memoKey = `parseRange:${memoOpts}:${range}`;
        const cached = cache.get(memoKey);
        if (cached)
          return cached

        const loose = this.options.loose;
        // `1.2.3 - 1.2.4` => `>=1.2.3 <=1.2.4`
        const hr = loose ? re$1[t$1.HYPHENRANGELOOSE] : re$1[t$1.HYPHENRANGE];
        range = range.replace(hr, hyphenReplace(this.options.includePrerelease));
        debug$2('hyphen replace', range);
        // `> 1.2.3 < 1.2.5` => `>1.2.3 <1.2.5`
        range = range.replace(re$1[t$1.COMPARATORTRIM], comparatorTrimReplace);
        debug$2('comparator trim', range, re$1[t$1.COMPARATORTRIM]);

        // `~ 1.2.3` => `~1.2.3`
        range = range.replace(re$1[t$1.TILDETRIM], tildeTrimReplace);

        // `^ 1.2.3` => `^1.2.3`
        range = range.replace(re$1[t$1.CARETTRIM], caretTrimReplace);

        // normalize spaces
        range = range.split(/\s+/).join(' ');

        // At this point, the range is completely trimmed and
        // ready to be split into comparators.

        const compRe = loose ? re$1[t$1.COMPARATORLOOSE] : re$1[t$1.COMPARATOR];
        const rangeList = range
          .split(' ')
          .map(comp => parseComparator(comp, this.options))
          .join(' ')
          .split(/\s+/)
          // >=0.0.0 is equivalent to *
          .map(comp => replaceGTE0(comp, this.options))
          // in loose mode, throw out any that are not valid comparators
          .filter(this.options.loose ? comp => !!comp.match(compRe) : () => true)
          .map(comp => new Comparator$3(comp, this.options));

        // if any comparators are the null set, then replace with JUST null set
        // if more than one comparator, remove any * comparators
        // also, don't include the same comparator more than once
        rangeList.length;
        const rangeMap = new Map();
        for (const comp of rangeList) {
          if (isNullSet(comp))
            return [comp]
          rangeMap.set(comp.value, comp);
        }
        if (rangeMap.size > 1 && rangeMap.has(''))
          rangeMap.delete('');

        const result = [...rangeMap.values()];
        cache.set(memoKey, result);
        return result
      }

      intersects (range, options) {
        if (!(range instanceof Range$a)) {
          throw new TypeError('a Range is required')
        }

        return this.set.some((thisComparators) => {
          return (
            isSatisfiable(thisComparators, options) &&
            range.set.some((rangeComparators) => {
              return (
                isSatisfiable(rangeComparators, options) &&
                thisComparators.every((thisComparator) => {
                  return rangeComparators.every((rangeComparator) => {
                    return thisComparator.intersects(rangeComparator, options)
                  })
                })
              )
            })
          )
        })
      }

      // if ANY of the sets match ALL of its comparators, then pass
      test (version) {
        if (!version) {
          return false
        }

        if (typeof version === 'string') {
          try {
            version = new SemVer$5(version, this.options);
          } catch (er) {
            return false
          }
        }

        for (let i = 0; i < this.set.length; i++) {
          if (testSet(this.set[i], version, this.options)) {
            return true
          }
        }
        return false
      }
    }
    var range$2 = Range$a;

    const LRU = lruCache;
    const cache = new LRU({ max: 1000 });

    const parseOptions$1 = parseOptions_1;
    const Comparator$3 = comparator;
    const debug$2 = debug_1;
    const SemVer$5 = semver$3;
    const {
      re: re$1,
      t: t$1,
      comparatorTrimReplace,
      tildeTrimReplace,
      caretTrimReplace
    } = re$5.exports;

    const isNullSet = c => c.value === '<0.0.0-0';
    const isAny = c => c.value === '';

    // take a set of comparators and determine whether there
    // exists a version which can satisfy it
    const isSatisfiable = (comparators, options) => {
      let result = true;
      const remainingComparators = comparators.slice();
      let testComparator = remainingComparators.pop();

      while (result && remainingComparators.length) {
        result = remainingComparators.every((otherComparator) => {
          return testComparator.intersects(otherComparator, options)
        });

        testComparator = remainingComparators.pop();
      }

      return result
    };

    // comprised of xranges, tildes, stars, and gtlt's at this point.
    // already replaced the hyphen ranges
    // turn into a set of JUST comparators.
    const parseComparator = (comp, options) => {
      debug$2('comp', comp, options);
      comp = replaceCarets(comp, options);
      debug$2('caret', comp);
      comp = replaceTildes(comp, options);
      debug$2('tildes', comp);
      comp = replaceXRanges(comp, options);
      debug$2('xrange', comp);
      comp = replaceStars(comp, options);
      debug$2('stars', comp);
      return comp
    };

    const isX = id => !id || id.toLowerCase() === 'x' || id === '*';

    // ~, ~> --> * (any, kinda silly)
    // ~2, ~2.x, ~2.x.x, ~>2, ~>2.x ~>2.x.x --> >=2.0.0 <3.0.0-0
    // ~2.0, ~2.0.x, ~>2.0, ~>2.0.x --> >=2.0.0 <2.1.0-0
    // ~1.2, ~1.2.x, ~>1.2, ~>1.2.x --> >=1.2.0 <1.3.0-0
    // ~1.2.3, ~>1.2.3 --> >=1.2.3 <1.3.0-0
    // ~1.2.0, ~>1.2.0 --> >=1.2.0 <1.3.0-0
    const replaceTildes = (comp, options) =>
      comp.trim().split(/\s+/).map((comp) => {
        return replaceTilde(comp, options)
      }).join(' ');

    const replaceTilde = (comp, options) => {
      const r = options.loose ? re$1[t$1.TILDELOOSE] : re$1[t$1.TILDE];
      return comp.replace(r, (_, M, m, p, pr) => {
        debug$2('tilde', comp, _, M, m, p, pr);
        let ret;

        if (isX(M)) {
          ret = '';
        } else if (isX(m)) {
          ret = `>=${M}.0.0 <${+M + 1}.0.0-0`;
        } else if (isX(p)) {
          // ~1.2 == >=1.2.0 <1.3.0-0
          ret = `>=${M}.${m}.0 <${M}.${+m + 1}.0-0`;
        } else if (pr) {
          debug$2('replaceTilde pr', pr);
          ret = `>=${M}.${m}.${p}-${pr
      } <${M}.${+m + 1}.0-0`;
        } else {
          // ~1.2.3 == >=1.2.3 <1.3.0-0
          ret = `>=${M}.${m}.${p
      } <${M}.${+m + 1}.0-0`;
        }

        debug$2('tilde return', ret);
        return ret
      })
    };

    // ^ --> * (any, kinda silly)
    // ^2, ^2.x, ^2.x.x --> >=2.0.0 <3.0.0-0
    // ^2.0, ^2.0.x --> >=2.0.0 <3.0.0-0
    // ^1.2, ^1.2.x --> >=1.2.0 <2.0.0-0
    // ^1.2.3 --> >=1.2.3 <2.0.0-0
    // ^1.2.0 --> >=1.2.0 <2.0.0-0
    const replaceCarets = (comp, options) =>
      comp.trim().split(/\s+/).map((comp) => {
        return replaceCaret(comp, options)
      }).join(' ');

    const replaceCaret = (comp, options) => {
      debug$2('caret', comp, options);
      const r = options.loose ? re$1[t$1.CARETLOOSE] : re$1[t$1.CARET];
      const z = options.includePrerelease ? '-0' : '';
      return comp.replace(r, (_, M, m, p, pr) => {
        debug$2('caret', comp, _, M, m, p, pr);
        let ret;

        if (isX(M)) {
          ret = '';
        } else if (isX(m)) {
          ret = `>=${M}.0.0${z} <${+M + 1}.0.0-0`;
        } else if (isX(p)) {
          if (M === '0') {
            ret = `>=${M}.${m}.0${z} <${M}.${+m + 1}.0-0`;
          } else {
            ret = `>=${M}.${m}.0${z} <${+M + 1}.0.0-0`;
          }
        } else if (pr) {
          debug$2('replaceCaret pr', pr);
          if (M === '0') {
            if (m === '0') {
              ret = `>=${M}.${m}.${p}-${pr
          } <${M}.${m}.${+p + 1}-0`;
            } else {
              ret = `>=${M}.${m}.${p}-${pr
          } <${M}.${+m + 1}.0-0`;
            }
          } else {
            ret = `>=${M}.${m}.${p}-${pr
        } <${+M + 1}.0.0-0`;
          }
        } else {
          debug$2('no pr');
          if (M === '0') {
            if (m === '0') {
              ret = `>=${M}.${m}.${p
          }${z} <${M}.${m}.${+p + 1}-0`;
            } else {
              ret = `>=${M}.${m}.${p
          }${z} <${M}.${+m + 1}.0-0`;
            }
          } else {
            ret = `>=${M}.${m}.${p
        } <${+M + 1}.0.0-0`;
          }
        }

        debug$2('caret return', ret);
        return ret
      })
    };

    const replaceXRanges = (comp, options) => {
      debug$2('replaceXRanges', comp, options);
      return comp.split(/\s+/).map((comp) => {
        return replaceXRange(comp, options)
      }).join(' ')
    };

    const replaceXRange = (comp, options) => {
      comp = comp.trim();
      const r = options.loose ? re$1[t$1.XRANGELOOSE] : re$1[t$1.XRANGE];
      return comp.replace(r, (ret, gtlt, M, m, p, pr) => {
        debug$2('xRange', comp, ret, gtlt, M, m, p, pr);
        const xM = isX(M);
        const xm = xM || isX(m);
        const xp = xm || isX(p);
        const anyX = xp;

        if (gtlt === '=' && anyX) {
          gtlt = '';
        }

        // if we're including prereleases in the match, then we need
        // to fix this to -0, the lowest possible prerelease value
        pr = options.includePrerelease ? '-0' : '';

        if (xM) {
          if (gtlt === '>' || gtlt === '<') {
            // nothing is allowed
            ret = '<0.0.0-0';
          } else {
            // nothing is forbidden
            ret = '*';
          }
        } else if (gtlt && anyX) {
          // we know patch is an x, because we have any x at all.
          // replace X with 0
          if (xm) {
            m = 0;
          }
          p = 0;

          if (gtlt === '>') {
            // >1 => >=2.0.0
            // >1.2 => >=1.3.0
            gtlt = '>=';
            if (xm) {
              M = +M + 1;
              m = 0;
              p = 0;
            } else {
              m = +m + 1;
              p = 0;
            }
          } else if (gtlt === '<=') {
            // <=0.7.x is actually <0.8.0, since any 0.7.x should
            // pass.  Similarly, <=7.x is actually <8.0.0, etc.
            gtlt = '<';
            if (xm) {
              M = +M + 1;
            } else {
              m = +m + 1;
            }
          }

          if (gtlt === '<')
            pr = '-0';

          ret = `${gtlt + M}.${m}.${p}${pr}`;
        } else if (xm) {
          ret = `>=${M}.0.0${pr} <${+M + 1}.0.0-0`;
        } else if (xp) {
          ret = `>=${M}.${m}.0${pr
      } <${M}.${+m + 1}.0-0`;
        }

        debug$2('xRange return', ret);

        return ret
      })
    };

    // Because * is AND-ed with everything else in the comparator,
    // and '' means "any version", just remove the *s entirely.
    const replaceStars = (comp, options) => {
      debug$2('replaceStars', comp, options);
      // Looseness is ignored here.  star is always as loose as it gets!
      return comp.trim().replace(re$1[t$1.STAR], '')
    };

    const replaceGTE0 = (comp, options) => {
      debug$2('replaceGTE0', comp, options);
      return comp.trim()
        .replace(re$1[options.includePrerelease ? t$1.GTE0PRE : t$1.GTE0], '')
    };

    // This function is passed to string.replace(re[t.HYPHENRANGE])
    // M, m, patch, prerelease, build
    // 1.2 - 3.4.5 => >=1.2.0 <=3.4.5
    // 1.2.3 - 3.4 => >=1.2.0 <3.5.0-0 Any 3.4.x will do
    // 1.2 - 3.4 => >=1.2.0 <3.5.0-0
    const hyphenReplace = incPr => ($0,
      from, fM, fm, fp, fpr, fb,
      to, tM, tm, tp, tpr, tb) => {
      if (isX(fM)) {
        from = '';
      } else if (isX(fm)) {
        from = `>=${fM}.0.0${incPr ? '-0' : ''}`;
      } else if (isX(fp)) {
        from = `>=${fM}.${fm}.0${incPr ? '-0' : ''}`;
      } else if (fpr) {
        from = `>=${from}`;
      } else {
        from = `>=${from}${incPr ? '-0' : ''}`;
      }

      if (isX(tM)) {
        to = '';
      } else if (isX(tm)) {
        to = `<${+tM + 1}.0.0-0`;
      } else if (isX(tp)) {
        to = `<${tM}.${+tm + 1}.0-0`;
      } else if (tpr) {
        to = `<=${tM}.${tm}.${tp}-${tpr}`;
      } else if (incPr) {
        to = `<${tM}.${tm}.${+tp + 1}-0`;
      } else {
        to = `<=${to}`;
      }

      return (`${from} ${to}`).trim()
    };

    const testSet = (set, version, options) => {
      for (let i = 0; i < set.length; i++) {
        if (!set[i].test(version)) {
          return false
        }
      }

      if (version.prerelease.length && !options.includePrerelease) {
        // Find the set of versions that are allowed to have prereleases
        // For example, ^1.2.3-pr.1 desugars to >=1.2.3-pr.1 <2.0.0
        // That should allow `1.2.3-pr.2` to pass.
        // However, `1.2.4-alpha.notready` should NOT be allowed,
        // even though it's within the range set by the comparators.
        for (let i = 0; i < set.length; i++) {
          debug$2(set[i].semver);
          if (set[i].semver === Comparator$3.ANY) {
            continue
          }

          if (set[i].semver.prerelease.length > 0) {
            const allowed = set[i].semver;
            if (allowed.major === version.major &&
                allowed.minor === version.minor &&
                allowed.patch === version.patch) {
              return true
            }
          }
        }

        // Version has a -pre, but it's not one of the ones we like.
        return false
      }

      return true
    };

    const ANY$2 = Symbol('SemVer ANY');
    // hoisted class for cyclic dependency
    class Comparator$2 {
      static get ANY () {
        return ANY$2
      }
      constructor (comp, options) {
        options = parseOptions(options);

        if (comp instanceof Comparator$2) {
          if (comp.loose === !!options.loose) {
            return comp
          } else {
            comp = comp.value;
          }
        }

        debug$1('comparator', comp, options);
        this.options = options;
        this.loose = !!options.loose;
        this.parse(comp);

        if (this.semver === ANY$2) {
          this.value = '';
        } else {
          this.value = this.operator + this.semver.version;
        }

        debug$1('comp', this);
      }

      parse (comp) {
        const r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR];
        const m = comp.match(r);

        if (!m) {
          throw new TypeError(`Invalid comparator: ${comp}`)
        }

        this.operator = m[1] !== undefined ? m[1] : '';
        if (this.operator === '=') {
          this.operator = '';
        }

        // if it literally is just '>' or '' then allow anything.
        if (!m[2]) {
          this.semver = ANY$2;
        } else {
          this.semver = new SemVer$4(m[2], this.options.loose);
        }
      }

      toString () {
        return this.value
      }

      test (version) {
        debug$1('Comparator.test', version, this.options.loose);

        if (this.semver === ANY$2 || version === ANY$2) {
          return true
        }

        if (typeof version === 'string') {
          try {
            version = new SemVer$4(version, this.options);
          } catch (er) {
            return false
          }
        }

        return cmp(version, this.operator, this.semver, this.options)
      }

      intersects (comp, options) {
        if (!(comp instanceof Comparator$2)) {
          throw new TypeError('a Comparator is required')
        }

        if (!options || typeof options !== 'object') {
          options = {
            loose: !!options,
            includePrerelease: false
          };
        }

        if (this.operator === '') {
          if (this.value === '') {
            return true
          }
          return new Range$9(comp.value, options).test(this.value)
        } else if (comp.operator === '') {
          if (comp.value === '') {
            return true
          }
          return new Range$9(this.value, options).test(comp.semver)
        }

        const sameDirectionIncreasing =
          (this.operator === '>=' || this.operator === '>') &&
          (comp.operator === '>=' || comp.operator === '>');
        const sameDirectionDecreasing =
          (this.operator === '<=' || this.operator === '<') &&
          (comp.operator === '<=' || comp.operator === '<');
        const sameSemVer = this.semver.version === comp.semver.version;
        const differentDirectionsInclusive =
          (this.operator === '>=' || this.operator === '<=') &&
          (comp.operator === '>=' || comp.operator === '<=');
        const oppositeDirectionsLessThan =
          cmp(this.semver, '<', comp.semver, options) &&
          (this.operator === '>=' || this.operator === '>') &&
            (comp.operator === '<=' || comp.operator === '<');
        const oppositeDirectionsGreaterThan =
          cmp(this.semver, '>', comp.semver, options) &&
          (this.operator === '<=' || this.operator === '<') &&
            (comp.operator === '>=' || comp.operator === '>');

        return (
          sameDirectionIncreasing ||
          sameDirectionDecreasing ||
          (sameSemVer && differentDirectionsInclusive) ||
          oppositeDirectionsLessThan ||
          oppositeDirectionsGreaterThan
        )
      }
    }

    var comparator = Comparator$2;

    const parseOptions = parseOptions_1;
    const {re, t} = re$5.exports;
    const cmp = cmp_1;
    const debug$1 = debug_1;
    const SemVer$4 = semver$3;
    const Range$9 = range$2;

    const Range$8 = range$2;
    const satisfies$3 = (version, range, options) => {
      try {
        range = new Range$8(range, options);
      } catch (er) {
        return false
      }
      return range.test(version)
    };
    var satisfies_1 = satisfies$3;

    const Range$7 = range$2;

    // Mostly just for testing and legacy API reasons
    const toComparators = (range, options) =>
      new Range$7(range, options).set
        .map(comp => comp.map(c => c.value).join(' ').trim().split(' '));

    var toComparators_1 = toComparators;

    const SemVer$3 = semver$3;
    const Range$6 = range$2;

    const maxSatisfying = (versions, range, options) => {
      let max = null;
      let maxSV = null;
      let rangeObj = null;
      try {
        rangeObj = new Range$6(range, options);
      } catch (er) {
        return null
      }
      versions.forEach((v) => {
        if (rangeObj.test(v)) {
          // satisfies(v, range, options)
          if (!max || maxSV.compare(v) === -1) {
            // compare(max, v, true)
            max = v;
            maxSV = new SemVer$3(max, options);
          }
        }
      });
      return max
    };
    var maxSatisfying_1 = maxSatisfying;

    const SemVer$2 = semver$3;
    const Range$5 = range$2;
    const minSatisfying = (versions, range, options) => {
      let min = null;
      let minSV = null;
      let rangeObj = null;
      try {
        rangeObj = new Range$5(range, options);
      } catch (er) {
        return null
      }
      versions.forEach((v) => {
        if (rangeObj.test(v)) {
          // satisfies(v, range, options)
          if (!min || minSV.compare(v) === 1) {
            // compare(min, v, true)
            min = v;
            minSV = new SemVer$2(min, options);
          }
        }
      });
      return min
    };
    var minSatisfying_1 = minSatisfying;

    const SemVer$1 = semver$3;
    const Range$4 = range$2;
    const gt$1 = gt_1;

    const minVersion = (range, loose) => {
      range = new Range$4(range, loose);

      let minver = new SemVer$1('0.0.0');
      if (range.test(minver)) {
        return minver
      }

      minver = new SemVer$1('0.0.0-0');
      if (range.test(minver)) {
        return minver
      }

      minver = null;
      for (let i = 0; i < range.set.length; ++i) {
        const comparators = range.set[i];

        let setMin = null;
        comparators.forEach((comparator) => {
          // Clone to avoid manipulating the comparator's semver object.
          const compver = new SemVer$1(comparator.semver.version);
          switch (comparator.operator) {
            case '>':
              if (compver.prerelease.length === 0) {
                compver.patch++;
              } else {
                compver.prerelease.push(0);
              }
              compver.raw = compver.format();
              /* fallthrough */
            case '':
            case '>=':
              if (!setMin || gt$1(compver, setMin)) {
                setMin = compver;
              }
              break
            case '<':
            case '<=':
              /* Ignore maximum versions */
              break
            /* istanbul ignore next */
            default:
              throw new Error(`Unexpected operation: ${comparator.operator}`)
          }
        });
        if (setMin && (!minver || gt$1(minver, setMin)))
          minver = setMin;
      }

      if (minver && range.test(minver)) {
        return minver
      }

      return null
    };
    var minVersion_1 = minVersion;

    const Range$3 = range$2;
    const validRange = (range, options) => {
      try {
        // Return '*' instead of '' so that truthiness works.
        // This will throw if it's invalid anyway
        return new Range$3(range, options).range || '*'
      } catch (er) {
        return null
      }
    };
    var valid = validRange;

    const SemVer = semver$3;
    const Comparator$1 = comparator;
    const {ANY: ANY$1} = Comparator$1;
    const Range$2 = range$2;
    const satisfies$2 = satisfies_1;
    const gt = gt_1;
    const lt = lt_1;
    const lte$1 = lte_1;
    const gte$1 = gte_1;

    const outside$2 = (version, range, hilo, options) => {
      version = new SemVer(version, options);
      range = new Range$2(range, options);

      let gtfn, ltefn, ltfn, comp, ecomp;
      switch (hilo) {
        case '>':
          gtfn = gt;
          ltefn = lte$1;
          ltfn = lt;
          comp = '>';
          ecomp = '>=';
          break
        case '<':
          gtfn = lt;
          ltefn = gte$1;
          ltfn = gt;
          comp = '<';
          ecomp = '<=';
          break
        default:
          throw new TypeError('Must provide a hilo val of "<" or ">"')
      }

      // If it satisfies the range it is not outside
      if (satisfies$2(version, range, options)) {
        return false
      }

      // From now on, variable terms are as if we're in "gtr" mode.
      // but note that everything is flipped for the "ltr" function.

      for (let i = 0; i < range.set.length; ++i) {
        const comparators = range.set[i];

        let high = null;
        let low = null;

        comparators.forEach((comparator) => {
          if (comparator.semver === ANY$1) {
            comparator = new Comparator$1('>=0.0.0');
          }
          high = high || comparator;
          low = low || comparator;
          if (gtfn(comparator.semver, high.semver, options)) {
            high = comparator;
          } else if (ltfn(comparator.semver, low.semver, options)) {
            low = comparator;
          }
        });

        // If the edge version comparator has a operator then our version
        // isn't outside it
        if (high.operator === comp || high.operator === ecomp) {
          return false
        }

        // If the lowest version comparator has an operator and our version
        // is less than it then it isn't higher than the range
        if ((!low.operator || low.operator === comp) &&
            ltefn(version, low.semver)) {
          return false
        } else if (low.operator === ecomp && ltfn(version, low.semver)) {
          return false
        }
      }
      return true
    };

    var outside_1 = outside$2;

    // Determine if version is greater than all the versions possible in the range.
    const outside$1 = outside_1;
    const gtr = (version, range, options) => outside$1(version, range, '>', options);
    var gtr_1 = gtr;

    const outside = outside_1;
    // Determine if version is less than all the versions possible in the range
    const ltr = (version, range, options) => outside(version, range, '<', options);
    var ltr_1 = ltr;

    const Range$1 = range$2;
    const intersects = (r1, r2, options) => {
      r1 = new Range$1(r1, options);
      r2 = new Range$1(r2, options);
      return r1.intersects(r2)
    };
    var intersects_1 = intersects;

    // given a set of versions and a range, create a "simplified" range
    // that includes the same versions that the original range does
    // If the original range is shorter than the simplified one, return that.
    const satisfies$1 = satisfies_1;
    const compare$1 = compare_1;
    var simplify = (versions, range, options) => {
      const set = [];
      let min = null;
      let prev = null;
      const v = versions.sort((a, b) => compare$1(a, b, options));
      for (const version of v) {
        const included = satisfies$1(version, range, options);
        if (included) {
          prev = version;
          if (!min)
            min = version;
        } else {
          if (prev) {
            set.push([min, prev]);
          }
          prev = null;
          min = null;
        }
      }
      if (min)
        set.push([min, null]);

      const ranges = [];
      for (const [min, max] of set) {
        if (min === max)
          ranges.push(min);
        else if (!max && min === v[0])
          ranges.push('*');
        else if (!max)
          ranges.push(`>=${min}`);
        else if (min === v[0])
          ranges.push(`<=${max}`);
        else
          ranges.push(`${min} - ${max}`);
      }
      const simplified = ranges.join(' || ');
      const original = typeof range.raw === 'string' ? range.raw : String(range);
      return simplified.length < original.length ? simplified : range
    };

    const Range = range$2;
    const Comparator = comparator;
    const { ANY } = Comparator;
    const satisfies = satisfies_1;
    const compare = compare_1;

    // Complex range `r1 || r2 || ...` is a subset of `R1 || R2 || ...` iff:
    // - Every simple range `r1, r2, ...` is a null set, OR
    // - Every simple range `r1, r2, ...` which is not a null set is a subset of
    //   some `R1, R2, ...`
    //
    // Simple range `c1 c2 ...` is a subset of simple range `C1 C2 ...` iff:
    // - If c is only the ANY comparator
    //   - If C is only the ANY comparator, return true
    //   - Else if in prerelease mode, return false
    //   - else replace c with `[>=0.0.0]`
    // - If C is only the ANY comparator
    //   - if in prerelease mode, return true
    //   - else replace C with `[>=0.0.0]`
    // - Let EQ be the set of = comparators in c
    // - If EQ is more than one, return true (null set)
    // - Let GT be the highest > or >= comparator in c
    // - Let LT be the lowest < or <= comparator in c
    // - If GT and LT, and GT.semver > LT.semver, return true (null set)
    // - If any C is a = range, and GT or LT are set, return false
    // - If EQ
    //   - If GT, and EQ does not satisfy GT, return true (null set)
    //   - If LT, and EQ does not satisfy LT, return true (null set)
    //   - If EQ satisfies every C, return true
    //   - Else return false
    // - If GT
    //   - If GT.semver is lower than any > or >= comp in C, return false
    //   - If GT is >=, and GT.semver does not satisfy every C, return false
    //   - If GT.semver has a prerelease, and not in prerelease mode
    //     - If no C has a prerelease and the GT.semver tuple, return false
    // - If LT
    //   - If LT.semver is greater than any < or <= comp in C, return false
    //   - If LT is <=, and LT.semver does not satisfy every C, return false
    //   - If GT.semver has a prerelease, and not in prerelease mode
    //     - If no C has a prerelease and the LT.semver tuple, return false
    // - Else return true

    const subset = (sub, dom, options = {}) => {
      if (sub === dom)
        return true

      sub = new Range(sub, options);
      dom = new Range(dom, options);
      let sawNonNull = false;

      OUTER: for (const simpleSub of sub.set) {
        for (const simpleDom of dom.set) {
          const isSub = simpleSubset(simpleSub, simpleDom, options);
          sawNonNull = sawNonNull || isSub !== null;
          if (isSub)
            continue OUTER
        }
        // the null set is a subset of everything, but null simple ranges in
        // a complex range should be ignored.  so if we saw a non-null range,
        // then we know this isn't a subset, but if EVERY simple range was null,
        // then it is a subset.
        if (sawNonNull)
          return false
      }
      return true
    };

    const simpleSubset = (sub, dom, options) => {
      if (sub === dom)
        return true

      if (sub.length === 1 && sub[0].semver === ANY) {
        if (dom.length === 1 && dom[0].semver === ANY)
          return true
        else if (options.includePrerelease)
          sub = [ new Comparator('>=0.0.0-0') ];
        else
          sub = [ new Comparator('>=0.0.0') ];
      }

      if (dom.length === 1 && dom[0].semver === ANY) {
        if (options.includePrerelease)
          return true
        else
          dom = [ new Comparator('>=0.0.0') ];
      }

      const eqSet = new Set();
      let gt, lt;
      for (const c of sub) {
        if (c.operator === '>' || c.operator === '>=')
          gt = higherGT(gt, c, options);
        else if (c.operator === '<' || c.operator === '<=')
          lt = lowerLT(lt, c, options);
        else
          eqSet.add(c.semver);
      }

      if (eqSet.size > 1)
        return null

      let gtltComp;
      if (gt && lt) {
        gtltComp = compare(gt.semver, lt.semver, options);
        if (gtltComp > 0)
          return null
        else if (gtltComp === 0 && (gt.operator !== '>=' || lt.operator !== '<='))
          return null
      }

      // will iterate one or zero times
      for (const eq of eqSet) {
        if (gt && !satisfies(eq, String(gt), options))
          return null

        if (lt && !satisfies(eq, String(lt), options))
          return null

        for (const c of dom) {
          if (!satisfies(eq, String(c), options))
            return false
        }

        return true
      }

      let higher, lower;
      let hasDomLT, hasDomGT;
      // if the subset has a prerelease, we need a comparator in the superset
      // with the same tuple and a prerelease, or it's not a subset
      let needDomLTPre = lt &&
        !options.includePrerelease &&
        lt.semver.prerelease.length ? lt.semver : false;
      let needDomGTPre = gt &&
        !options.includePrerelease &&
        gt.semver.prerelease.length ? gt.semver : false;
      // exception: <1.2.3-0 is the same as <1.2.3
      if (needDomLTPre && needDomLTPre.prerelease.length === 1 &&
          lt.operator === '<' && needDomLTPre.prerelease[0] === 0) {
        needDomLTPre = false;
      }

      for (const c of dom) {
        hasDomGT = hasDomGT || c.operator === '>' || c.operator === '>=';
        hasDomLT = hasDomLT || c.operator === '<' || c.operator === '<=';
        if (gt) {
          if (needDomGTPre) {
            if (c.semver.prerelease && c.semver.prerelease.length &&
                c.semver.major === needDomGTPre.major &&
                c.semver.minor === needDomGTPre.minor &&
                c.semver.patch === needDomGTPre.patch) {
              needDomGTPre = false;
            }
          }
          if (c.operator === '>' || c.operator === '>=') {
            higher = higherGT(gt, c, options);
            if (higher === c && higher !== gt)
              return false
          } else if (gt.operator === '>=' && !satisfies(gt.semver, String(c), options))
            return false
        }
        if (lt) {
          if (needDomLTPre) {
            if (c.semver.prerelease && c.semver.prerelease.length &&
                c.semver.major === needDomLTPre.major &&
                c.semver.minor === needDomLTPre.minor &&
                c.semver.patch === needDomLTPre.patch) {
              needDomLTPre = false;
            }
          }
          if (c.operator === '<' || c.operator === '<=') {
            lower = lowerLT(lt, c, options);
            if (lower === c && lower !== lt)
              return false
          } else if (lt.operator === '<=' && !satisfies(lt.semver, String(c), options))
            return false
        }
        if (!c.operator && (lt || gt) && gtltComp !== 0)
          return false
      }

      // if there was a < or >, and nothing in the dom, then must be false
      // UNLESS it was limited by another range in the other direction.
      // Eg, >1.0.0 <1.0.1 is still a subset of <2.0.0
      if (gt && hasDomLT && !lt && gtltComp !== 0)
        return false

      if (lt && hasDomGT && !gt && gtltComp !== 0)
        return false

      // we needed a prerelease range in a specific tuple, but didn't get one
      // then this isn't a subset.  eg >=1.2.3-pre is not a subset of >=1.0.0,
      // because it includes prereleases in the 1.2.3 tuple
      if (needDomGTPre || needDomLTPre)
        return false

      return true
    };

    // >=1.2.3 is lower than >1.2.3
    const higherGT = (a, b, options) => {
      if (!a)
        return b
      const comp = compare(a.semver, b.semver, options);
      return comp > 0 ? a
        : comp < 0 ? b
        : b.operator === '>' && a.operator === '>=' ? b
        : a
    };

    // <=1.2.3 is higher than <1.2.3
    const lowerLT = (a, b, options) => {
      if (!a)
        return b
      const comp = compare(a.semver, b.semver, options);
      return comp < 0 ? a
        : comp > 0 ? b
        : b.operator === '<' && a.operator === '<=' ? b
        : a
    };

    var subset_1 = subset;

    // just pre-load all the stuff that index.js lazily exports
    const internalRe = re$5.exports;
    var semver$2 = {
      re: internalRe.re,
      src: internalRe.src,
      tokens: internalRe.t,
      SEMVER_SPEC_VERSION: constants$1.SEMVER_SPEC_VERSION,
      SemVer: semver$3,
      compareIdentifiers: identifiers.compareIdentifiers,
      rcompareIdentifiers: identifiers.rcompareIdentifiers,
      parse: parse_1,
      valid: valid_1,
      clean: clean_1,
      inc: inc_1,
      diff: diff_1,
      major: major_1,
      minor: minor_1,
      patch: patch_1,
      prerelease: prerelease_1,
      compare: compare_1,
      rcompare: rcompare_1,
      compareLoose: compareLoose_1,
      compareBuild: compareBuild_1,
      sort: sort_1,
      rsort: rsort_1,
      gt: gt_1,
      lt: lt_1,
      eq: eq_1$1,
      neq: neq_1,
      gte: gte_1,
      lte: lte_1,
      cmp: cmp_1,
      coerce: coerce_1,
      Comparator: comparator,
      Range: range$2,
      satisfies: satisfies_1,
      toComparators: toComparators_1,
      maxSatisfying: maxSatisfying_1,
      minSatisfying: minSatisfying_1,
      minVersion: minVersion_1,
      validRange: valid,
      outside: outside_1,
      gtr: gtr_1,
      ltr: ltr_1,
      intersects: intersects_1,
      simplifyRange: simplify,
      subset: subset_1,
    };

    var semver$1 = {exports: {}};

    (function (module, exports) {
    exports = module.exports = SemVer;

    var debug;
    /* istanbul ignore next */
    if (typeof process === 'object' &&
        process.env &&
        process.env.NODE_DEBUG &&
        /\bsemver\b/i.test(process.env.NODE_DEBUG)) {
      debug = function () {
        var args = Array.prototype.slice.call(arguments, 0);
        args.unshift('SEMVER');
        console.log.apply(console, args);
      };
    } else {
      debug = function () {};
    }

    // Note: this is the semver.org version of the spec that it implements
    // Not necessarily the package version of this code.
    exports.SEMVER_SPEC_VERSION = '2.0.0';

    var MAX_LENGTH = 256;
    var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER ||
      /* istanbul ignore next */ 9007199254740991;

    // Max safe segment length for coercion.
    var MAX_SAFE_COMPONENT_LENGTH = 16;

    // The actual regexps go on exports.re
    var re = exports.re = [];
    var src = exports.src = [];
    var R = 0;

    // The following Regular Expressions can be used for tokenizing,
    // validating, and parsing SemVer version strings.

    // ## Numeric Identifier
    // A single `0`, or a non-zero digit followed by zero or more digits.

    var NUMERICIDENTIFIER = R++;
    src[NUMERICIDENTIFIER] = '0|[1-9]\\d*';
    var NUMERICIDENTIFIERLOOSE = R++;
    src[NUMERICIDENTIFIERLOOSE] = '[0-9]+';

    // ## Non-numeric Identifier
    // Zero or more digits, followed by a letter or hyphen, and then zero or
    // more letters, digits, or hyphens.

    var NONNUMERICIDENTIFIER = R++;
    src[NONNUMERICIDENTIFIER] = '\\d*[a-zA-Z-][a-zA-Z0-9-]*';

    // ## Main Version
    // Three dot-separated numeric identifiers.

    var MAINVERSION = R++;
    src[MAINVERSION] = '(' + src[NUMERICIDENTIFIER] + ')\\.' +
                       '(' + src[NUMERICIDENTIFIER] + ')\\.' +
                       '(' + src[NUMERICIDENTIFIER] + ')';

    var MAINVERSIONLOOSE = R++;
    src[MAINVERSIONLOOSE] = '(' + src[NUMERICIDENTIFIERLOOSE] + ')\\.' +
                            '(' + src[NUMERICIDENTIFIERLOOSE] + ')\\.' +
                            '(' + src[NUMERICIDENTIFIERLOOSE] + ')';

    // ## Pre-release Version Identifier
    // A numeric identifier, or a non-numeric identifier.

    var PRERELEASEIDENTIFIER = R++;
    src[PRERELEASEIDENTIFIER] = '(?:' + src[NUMERICIDENTIFIER] +
                                '|' + src[NONNUMERICIDENTIFIER] + ')';

    var PRERELEASEIDENTIFIERLOOSE = R++;
    src[PRERELEASEIDENTIFIERLOOSE] = '(?:' + src[NUMERICIDENTIFIERLOOSE] +
                                     '|' + src[NONNUMERICIDENTIFIER] + ')';

    // ## Pre-release Version
    // Hyphen, followed by one or more dot-separated pre-release version
    // identifiers.

    var PRERELEASE = R++;
    src[PRERELEASE] = '(?:-(' + src[PRERELEASEIDENTIFIER] +
                      '(?:\\.' + src[PRERELEASEIDENTIFIER] + ')*))';

    var PRERELEASELOOSE = R++;
    src[PRERELEASELOOSE] = '(?:-?(' + src[PRERELEASEIDENTIFIERLOOSE] +
                           '(?:\\.' + src[PRERELEASEIDENTIFIERLOOSE] + ')*))';

    // ## Build Metadata Identifier
    // Any combination of digits, letters, or hyphens.

    var BUILDIDENTIFIER = R++;
    src[BUILDIDENTIFIER] = '[0-9A-Za-z-]+';

    // ## Build Metadata
    // Plus sign, followed by one or more period-separated build metadata
    // identifiers.

    var BUILD = R++;
    src[BUILD] = '(?:\\+(' + src[BUILDIDENTIFIER] +
                 '(?:\\.' + src[BUILDIDENTIFIER] + ')*))';

    // ## Full Version String
    // A main version, followed optionally by a pre-release version and
    // build metadata.

    // Note that the only major, minor, patch, and pre-release sections of
    // the version string are capturing groups.  The build metadata is not a
    // capturing group, because it should not ever be used in version
    // comparison.

    var FULL = R++;
    var FULLPLAIN = 'v?' + src[MAINVERSION] +
                    src[PRERELEASE] + '?' +
                    src[BUILD] + '?';

    src[FULL] = '^' + FULLPLAIN + '$';

    // like full, but allows v1.2.3 and =1.2.3, which people do sometimes.
    // also, 1.0.0alpha1 (prerelease without the hyphen) which is pretty
    // common in the npm registry.
    var LOOSEPLAIN = '[v=\\s]*' + src[MAINVERSIONLOOSE] +
                     src[PRERELEASELOOSE] + '?' +
                     src[BUILD] + '?';

    var LOOSE = R++;
    src[LOOSE] = '^' + LOOSEPLAIN + '$';

    var GTLT = R++;
    src[GTLT] = '((?:<|>)?=?)';

    // Something like "2.*" or "1.2.x".
    // Note that "x.x" is a valid xRange identifer, meaning "any version"
    // Only the first item is strictly required.
    var XRANGEIDENTIFIERLOOSE = R++;
    src[XRANGEIDENTIFIERLOOSE] = src[NUMERICIDENTIFIERLOOSE] + '|x|X|\\*';
    var XRANGEIDENTIFIER = R++;
    src[XRANGEIDENTIFIER] = src[NUMERICIDENTIFIER] + '|x|X|\\*';

    var XRANGEPLAIN = R++;
    src[XRANGEPLAIN] = '[v=\\s]*(' + src[XRANGEIDENTIFIER] + ')' +
                       '(?:\\.(' + src[XRANGEIDENTIFIER] + ')' +
                       '(?:\\.(' + src[XRANGEIDENTIFIER] + ')' +
                       '(?:' + src[PRERELEASE] + ')?' +
                       src[BUILD] + '?' +
                       ')?)?';

    var XRANGEPLAINLOOSE = R++;
    src[XRANGEPLAINLOOSE] = '[v=\\s]*(' + src[XRANGEIDENTIFIERLOOSE] + ')' +
                            '(?:\\.(' + src[XRANGEIDENTIFIERLOOSE] + ')' +
                            '(?:\\.(' + src[XRANGEIDENTIFIERLOOSE] + ')' +
                            '(?:' + src[PRERELEASELOOSE] + ')?' +
                            src[BUILD] + '?' +
                            ')?)?';

    var XRANGE = R++;
    src[XRANGE] = '^' + src[GTLT] + '\\s*' + src[XRANGEPLAIN] + '$';
    var XRANGELOOSE = R++;
    src[XRANGELOOSE] = '^' + src[GTLT] + '\\s*' + src[XRANGEPLAINLOOSE] + '$';

    // Coercion.
    // Extract anything that could conceivably be a part of a valid semver
    var COERCE = R++;
    src[COERCE] = '(?:^|[^\\d])' +
                  '(\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '})' +
                  '(?:\\.(\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '}))?' +
                  '(?:\\.(\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '}))?' +
                  '(?:$|[^\\d])';

    // Tilde ranges.
    // Meaning is "reasonably at or greater than"
    var LONETILDE = R++;
    src[LONETILDE] = '(?:~>?)';

    var TILDETRIM = R++;
    src[TILDETRIM] = '(\\s*)' + src[LONETILDE] + '\\s+';
    re[TILDETRIM] = new RegExp(src[TILDETRIM], 'g');
    var tildeTrimReplace = '$1~';

    var TILDE = R++;
    src[TILDE] = '^' + src[LONETILDE] + src[XRANGEPLAIN] + '$';
    var TILDELOOSE = R++;
    src[TILDELOOSE] = '^' + src[LONETILDE] + src[XRANGEPLAINLOOSE] + '$';

    // Caret ranges.
    // Meaning is "at least and backwards compatible with"
    var LONECARET = R++;
    src[LONECARET] = '(?:\\^)';

    var CARETTRIM = R++;
    src[CARETTRIM] = '(\\s*)' + src[LONECARET] + '\\s+';
    re[CARETTRIM] = new RegExp(src[CARETTRIM], 'g');
    var caretTrimReplace = '$1^';

    var CARET = R++;
    src[CARET] = '^' + src[LONECARET] + src[XRANGEPLAIN] + '$';
    var CARETLOOSE = R++;
    src[CARETLOOSE] = '^' + src[LONECARET] + src[XRANGEPLAINLOOSE] + '$';

    // A simple gt/lt/eq thing, or just "" to indicate "any version"
    var COMPARATORLOOSE = R++;
    src[COMPARATORLOOSE] = '^' + src[GTLT] + '\\s*(' + LOOSEPLAIN + ')$|^$';
    var COMPARATOR = R++;
    src[COMPARATOR] = '^' + src[GTLT] + '\\s*(' + FULLPLAIN + ')$|^$';

    // An expression to strip any whitespace between the gtlt and the thing
    // it modifies, so that `> 1.2.3` ==> `>1.2.3`
    var COMPARATORTRIM = R++;
    src[COMPARATORTRIM] = '(\\s*)' + src[GTLT] +
                          '\\s*(' + LOOSEPLAIN + '|' + src[XRANGEPLAIN] + ')';

    // this one has to use the /g flag
    re[COMPARATORTRIM] = new RegExp(src[COMPARATORTRIM], 'g');
    var comparatorTrimReplace = '$1$2$3';

    // Something like `1.2.3 - 1.2.4`
    // Note that these all use the loose form, because they'll be
    // checked against either the strict or loose comparator form
    // later.
    var HYPHENRANGE = R++;
    src[HYPHENRANGE] = '^\\s*(' + src[XRANGEPLAIN] + ')' +
                       '\\s+-\\s+' +
                       '(' + src[XRANGEPLAIN] + ')' +
                       '\\s*$';

    var HYPHENRANGELOOSE = R++;
    src[HYPHENRANGELOOSE] = '^\\s*(' + src[XRANGEPLAINLOOSE] + ')' +
                            '\\s+-\\s+' +
                            '(' + src[XRANGEPLAINLOOSE] + ')' +
                            '\\s*$';

    // Star ranges basically just allow anything at all.
    var STAR = R++;
    src[STAR] = '(<|>)?=?\\s*\\*';

    // Compile to actual regexp objects.
    // All are flag-free, unless they were created above with a flag.
    for (var i = 0; i < R; i++) {
      debug(i, src[i]);
      if (!re[i]) {
        re[i] = new RegExp(src[i]);
      }
    }

    exports.parse = parse;
    function parse (version, options) {
      if (!options || typeof options !== 'object') {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }

      if (version instanceof SemVer) {
        return version
      }

      if (typeof version !== 'string') {
        return null
      }

      if (version.length > MAX_LENGTH) {
        return null
      }

      var r = options.loose ? re[LOOSE] : re[FULL];
      if (!r.test(version)) {
        return null
      }

      try {
        return new SemVer(version, options)
      } catch (er) {
        return null
      }
    }

    exports.valid = valid;
    function valid (version, options) {
      var v = parse(version, options);
      return v ? v.version : null
    }

    exports.clean = clean;
    function clean (version, options) {
      var s = parse(version.trim().replace(/^[=v]+/, ''), options);
      return s ? s.version : null
    }

    exports.SemVer = SemVer;

    function SemVer (version, options) {
      if (!options || typeof options !== 'object') {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }
      if (version instanceof SemVer) {
        if (version.loose === options.loose) {
          return version
        } else {
          version = version.version;
        }
      } else if (typeof version !== 'string') {
        throw new TypeError('Invalid Version: ' + version)
      }

      if (version.length > MAX_LENGTH) {
        throw new TypeError('version is longer than ' + MAX_LENGTH + ' characters')
      }

      if (!(this instanceof SemVer)) {
        return new SemVer(version, options)
      }

      debug('SemVer', version, options);
      this.options = options;
      this.loose = !!options.loose;

      var m = version.trim().match(options.loose ? re[LOOSE] : re[FULL]);

      if (!m) {
        throw new TypeError('Invalid Version: ' + version)
      }

      this.raw = version;

      // these are actually numbers
      this.major = +m[1];
      this.minor = +m[2];
      this.patch = +m[3];

      if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
        throw new TypeError('Invalid major version')
      }

      if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
        throw new TypeError('Invalid minor version')
      }

      if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
        throw new TypeError('Invalid patch version')
      }

      // numberify any prerelease numeric ids
      if (!m[4]) {
        this.prerelease = [];
      } else {
        this.prerelease = m[4].split('.').map(function (id) {
          if (/^[0-9]+$/.test(id)) {
            var num = +id;
            if (num >= 0 && num < MAX_SAFE_INTEGER) {
              return num
            }
          }
          return id
        });
      }

      this.build = m[5] ? m[5].split('.') : [];
      this.format();
    }

    SemVer.prototype.format = function () {
      this.version = this.major + '.' + this.minor + '.' + this.patch;
      if (this.prerelease.length) {
        this.version += '-' + this.prerelease.join('.');
      }
      return this.version
    };

    SemVer.prototype.toString = function () {
      return this.version
    };

    SemVer.prototype.compare = function (other) {
      debug('SemVer.compare', this.version, this.options, other);
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }

      return this.compareMain(other) || this.comparePre(other)
    };

    SemVer.prototype.compareMain = function (other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }

      return compareIdentifiers(this.major, other.major) ||
             compareIdentifiers(this.minor, other.minor) ||
             compareIdentifiers(this.patch, other.patch)
    };

    SemVer.prototype.comparePre = function (other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }

      // NOT having a prerelease is > having one
      if (this.prerelease.length && !other.prerelease.length) {
        return -1
      } else if (!this.prerelease.length && other.prerelease.length) {
        return 1
      } else if (!this.prerelease.length && !other.prerelease.length) {
        return 0
      }

      var i = 0;
      do {
        var a = this.prerelease[i];
        var b = other.prerelease[i];
        debug('prerelease compare', i, a, b);
        if (a === undefined && b === undefined) {
          return 0
        } else if (b === undefined) {
          return 1
        } else if (a === undefined) {
          return -1
        } else if (a === b) {
          continue
        } else {
          return compareIdentifiers(a, b)
        }
      } while (++i)
    };

    // preminor will bump the version up to the next minor release, and immediately
    // down to pre-release. premajor and prepatch work the same way.
    SemVer.prototype.inc = function (release, identifier) {
      switch (release) {
        case 'premajor':
          this.prerelease.length = 0;
          this.patch = 0;
          this.minor = 0;
          this.major++;
          this.inc('pre', identifier);
          break
        case 'preminor':
          this.prerelease.length = 0;
          this.patch = 0;
          this.minor++;
          this.inc('pre', identifier);
          break
        case 'prepatch':
          // If this is already a prerelease, it will bump to the next version
          // drop any prereleases that might already exist, since they are not
          // relevant at this point.
          this.prerelease.length = 0;
          this.inc('patch', identifier);
          this.inc('pre', identifier);
          break
        // If the input is a non-prerelease version, this acts the same as
        // prepatch.
        case 'prerelease':
          if (this.prerelease.length === 0) {
            this.inc('patch', identifier);
          }
          this.inc('pre', identifier);
          break

        case 'major':
          // If this is a pre-major version, bump up to the same major version.
          // Otherwise increment major.
          // 1.0.0-5 bumps to 1.0.0
          // 1.1.0 bumps to 2.0.0
          if (this.minor !== 0 ||
              this.patch !== 0 ||
              this.prerelease.length === 0) {
            this.major++;
          }
          this.minor = 0;
          this.patch = 0;
          this.prerelease = [];
          break
        case 'minor':
          // If this is a pre-minor version, bump up to the same minor version.
          // Otherwise increment minor.
          // 1.2.0-5 bumps to 1.2.0
          // 1.2.1 bumps to 1.3.0
          if (this.patch !== 0 || this.prerelease.length === 0) {
            this.minor++;
          }
          this.patch = 0;
          this.prerelease = [];
          break
        case 'patch':
          // If this is not a pre-release version, it will increment the patch.
          // If it is a pre-release it will bump up to the same patch version.
          // 1.2.0-5 patches to 1.2.0
          // 1.2.0 patches to 1.2.1
          if (this.prerelease.length === 0) {
            this.patch++;
          }
          this.prerelease = [];
          break
        // This probably shouldn't be used publicly.
        // 1.0.0 "pre" would become 1.0.0-0 which is the wrong direction.
        case 'pre':
          if (this.prerelease.length === 0) {
            this.prerelease = [0];
          } else {
            var i = this.prerelease.length;
            while (--i >= 0) {
              if (typeof this.prerelease[i] === 'number') {
                this.prerelease[i]++;
                i = -2;
              }
            }
            if (i === -1) {
              // didn't increment anything
              this.prerelease.push(0);
            }
          }
          if (identifier) {
            // 1.2.0-beta.1 bumps to 1.2.0-beta.2,
            // 1.2.0-beta.fooblz or 1.2.0-beta bumps to 1.2.0-beta.0
            if (this.prerelease[0] === identifier) {
              if (isNaN(this.prerelease[1])) {
                this.prerelease = [identifier, 0];
              }
            } else {
              this.prerelease = [identifier, 0];
            }
          }
          break

        default:
          throw new Error('invalid increment argument: ' + release)
      }
      this.format();
      this.raw = this.version;
      return this
    };

    exports.inc = inc;
    function inc (version, release, loose, identifier) {
      if (typeof (loose) === 'string') {
        identifier = loose;
        loose = undefined;
      }

      try {
        return new SemVer(version, loose).inc(release, identifier).version
      } catch (er) {
        return null
      }
    }

    exports.diff = diff;
    function diff (version1, version2) {
      if (eq(version1, version2)) {
        return null
      } else {
        var v1 = parse(version1);
        var v2 = parse(version2);
        var prefix = '';
        if (v1.prerelease.length || v2.prerelease.length) {
          prefix = 'pre';
          var defaultResult = 'prerelease';
        }
        for (var key in v1) {
          if (key === 'major' || key === 'minor' || key === 'patch') {
            if (v1[key] !== v2[key]) {
              return prefix + key
            }
          }
        }
        return defaultResult // may be undefined
      }
    }

    exports.compareIdentifiers = compareIdentifiers;

    var numeric = /^[0-9]+$/;
    function compareIdentifiers (a, b) {
      var anum = numeric.test(a);
      var bnum = numeric.test(b);

      if (anum && bnum) {
        a = +a;
        b = +b;
      }

      return a === b ? 0
        : (anum && !bnum) ? -1
        : (bnum && !anum) ? 1
        : a < b ? -1
        : 1
    }

    exports.rcompareIdentifiers = rcompareIdentifiers;
    function rcompareIdentifiers (a, b) {
      return compareIdentifiers(b, a)
    }

    exports.major = major;
    function major (a, loose) {
      return new SemVer(a, loose).major
    }

    exports.minor = minor;
    function minor (a, loose) {
      return new SemVer(a, loose).minor
    }

    exports.patch = patch;
    function patch (a, loose) {
      return new SemVer(a, loose).patch
    }

    exports.compare = compare;
    function compare (a, b, loose) {
      return new SemVer(a, loose).compare(new SemVer(b, loose))
    }

    exports.compareLoose = compareLoose;
    function compareLoose (a, b) {
      return compare(a, b, true)
    }

    exports.rcompare = rcompare;
    function rcompare (a, b, loose) {
      return compare(b, a, loose)
    }

    exports.sort = sort;
    function sort (list, loose) {
      return list.sort(function (a, b) {
        return exports.compare(a, b, loose)
      })
    }

    exports.rsort = rsort;
    function rsort (list, loose) {
      return list.sort(function (a, b) {
        return exports.rcompare(a, b, loose)
      })
    }

    exports.gt = gt;
    function gt (a, b, loose) {
      return compare(a, b, loose) > 0
    }

    exports.lt = lt;
    function lt (a, b, loose) {
      return compare(a, b, loose) < 0
    }

    exports.eq = eq;
    function eq (a, b, loose) {
      return compare(a, b, loose) === 0
    }

    exports.neq = neq;
    function neq (a, b, loose) {
      return compare(a, b, loose) !== 0
    }

    exports.gte = gte;
    function gte (a, b, loose) {
      return compare(a, b, loose) >= 0
    }

    exports.lte = lte;
    function lte (a, b, loose) {
      return compare(a, b, loose) <= 0
    }

    exports.cmp = cmp;
    function cmp (a, op, b, loose) {
      switch (op) {
        case '===':
          if (typeof a === 'object')
            a = a.version;
          if (typeof b === 'object')
            b = b.version;
          return a === b

        case '!==':
          if (typeof a === 'object')
            a = a.version;
          if (typeof b === 'object')
            b = b.version;
          return a !== b

        case '':
        case '=':
        case '==':
          return eq(a, b, loose)

        case '!=':
          return neq(a, b, loose)

        case '>':
          return gt(a, b, loose)

        case '>=':
          return gte(a, b, loose)

        case '<':
          return lt(a, b, loose)

        case '<=':
          return lte(a, b, loose)

        default:
          throw new TypeError('Invalid operator: ' + op)
      }
    }

    exports.Comparator = Comparator;
    function Comparator (comp, options) {
      if (!options || typeof options !== 'object') {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }

      if (comp instanceof Comparator) {
        if (comp.loose === !!options.loose) {
          return comp
        } else {
          comp = comp.value;
        }
      }

      if (!(this instanceof Comparator)) {
        return new Comparator(comp, options)
      }

      debug('comparator', comp, options);
      this.options = options;
      this.loose = !!options.loose;
      this.parse(comp);

      if (this.semver === ANY) {
        this.value = '';
      } else {
        this.value = this.operator + this.semver.version;
      }

      debug('comp', this);
    }

    var ANY = {};
    Comparator.prototype.parse = function (comp) {
      var r = this.options.loose ? re[COMPARATORLOOSE] : re[COMPARATOR];
      var m = comp.match(r);

      if (!m) {
        throw new TypeError('Invalid comparator: ' + comp)
      }

      this.operator = m[1];
      if (this.operator === '=') {
        this.operator = '';
      }

      // if it literally is just '>' or '' then allow anything.
      if (!m[2]) {
        this.semver = ANY;
      } else {
        this.semver = new SemVer(m[2], this.options.loose);
      }
    };

    Comparator.prototype.toString = function () {
      return this.value
    };

    Comparator.prototype.test = function (version) {
      debug('Comparator.test', version, this.options.loose);

      if (this.semver === ANY) {
        return true
      }

      if (typeof version === 'string') {
        version = new SemVer(version, this.options);
      }

      return cmp(version, this.operator, this.semver, this.options)
    };

    Comparator.prototype.intersects = function (comp, options) {
      if (!(comp instanceof Comparator)) {
        throw new TypeError('a Comparator is required')
      }

      if (!options || typeof options !== 'object') {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }

      var rangeTmp;

      if (this.operator === '') {
        rangeTmp = new Range(comp.value, options);
        return satisfies(this.value, rangeTmp, options)
      } else if (comp.operator === '') {
        rangeTmp = new Range(this.value, options);
        return satisfies(comp.semver, rangeTmp, options)
      }

      var sameDirectionIncreasing =
        (this.operator === '>=' || this.operator === '>') &&
        (comp.operator === '>=' || comp.operator === '>');
      var sameDirectionDecreasing =
        (this.operator === '<=' || this.operator === '<') &&
        (comp.operator === '<=' || comp.operator === '<');
      var sameSemVer = this.semver.version === comp.semver.version;
      var differentDirectionsInclusive =
        (this.operator === '>=' || this.operator === '<=') &&
        (comp.operator === '>=' || comp.operator === '<=');
      var oppositeDirectionsLessThan =
        cmp(this.semver, '<', comp.semver, options) &&
        ((this.operator === '>=' || this.operator === '>') &&
        (comp.operator === '<=' || comp.operator === '<'));
      var oppositeDirectionsGreaterThan =
        cmp(this.semver, '>', comp.semver, options) &&
        ((this.operator === '<=' || this.operator === '<') &&
        (comp.operator === '>=' || comp.operator === '>'));

      return sameDirectionIncreasing || sameDirectionDecreasing ||
        (sameSemVer && differentDirectionsInclusive) ||
        oppositeDirectionsLessThan || oppositeDirectionsGreaterThan
    };

    exports.Range = Range;
    function Range (range, options) {
      if (!options || typeof options !== 'object') {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }

      if (range instanceof Range) {
        if (range.loose === !!options.loose &&
            range.includePrerelease === !!options.includePrerelease) {
          return range
        } else {
          return new Range(range.raw, options)
        }
      }

      if (range instanceof Comparator) {
        return new Range(range.value, options)
      }

      if (!(this instanceof Range)) {
        return new Range(range, options)
      }

      this.options = options;
      this.loose = !!options.loose;
      this.includePrerelease = !!options.includePrerelease;

      // First, split based on boolean or ||
      this.raw = range;
      this.set = range.split(/\s*\|\|\s*/).map(function (range) {
        return this.parseRange(range.trim())
      }, this).filter(function (c) {
        // throw out any that are not relevant for whatever reason
        return c.length
      });

      if (!this.set.length) {
        throw new TypeError('Invalid SemVer Range: ' + range)
      }

      this.format();
    }

    Range.prototype.format = function () {
      this.range = this.set.map(function (comps) {
        return comps.join(' ').trim()
      }).join('||').trim();
      return this.range
    };

    Range.prototype.toString = function () {
      return this.range
    };

    Range.prototype.parseRange = function (range) {
      var loose = this.options.loose;
      range = range.trim();
      // `1.2.3 - 1.2.4` => `>=1.2.3 <=1.2.4`
      var hr = loose ? re[HYPHENRANGELOOSE] : re[HYPHENRANGE];
      range = range.replace(hr, hyphenReplace);
      debug('hyphen replace', range);
      // `> 1.2.3 < 1.2.5` => `>1.2.3 <1.2.5`
      range = range.replace(re[COMPARATORTRIM], comparatorTrimReplace);
      debug('comparator trim', range, re[COMPARATORTRIM]);

      // `~ 1.2.3` => `~1.2.3`
      range = range.replace(re[TILDETRIM], tildeTrimReplace);

      // `^ 1.2.3` => `^1.2.3`
      range = range.replace(re[CARETTRIM], caretTrimReplace);

      // normalize spaces
      range = range.split(/\s+/).join(' ');

      // At this point, the range is completely trimmed and
      // ready to be split into comparators.

      var compRe = loose ? re[COMPARATORLOOSE] : re[COMPARATOR];
      var set = range.split(' ').map(function (comp) {
        return parseComparator(comp, this.options)
      }, this).join(' ').split(/\s+/);
      if (this.options.loose) {
        // in loose mode, throw out any that are not valid comparators
        set = set.filter(function (comp) {
          return !!comp.match(compRe)
        });
      }
      set = set.map(function (comp) {
        return new Comparator(comp, this.options)
      }, this);

      return set
    };

    Range.prototype.intersects = function (range, options) {
      if (!(range instanceof Range)) {
        throw new TypeError('a Range is required')
      }

      return this.set.some(function (thisComparators) {
        return thisComparators.every(function (thisComparator) {
          return range.set.some(function (rangeComparators) {
            return rangeComparators.every(function (rangeComparator) {
              return thisComparator.intersects(rangeComparator, options)
            })
          })
        })
      })
    };

    // Mostly just for testing and legacy API reasons
    exports.toComparators = toComparators;
    function toComparators (range, options) {
      return new Range(range, options).set.map(function (comp) {
        return comp.map(function (c) {
          return c.value
        }).join(' ').trim().split(' ')
      })
    }

    // comprised of xranges, tildes, stars, and gtlt's at this point.
    // already replaced the hyphen ranges
    // turn into a set of JUST comparators.
    function parseComparator (comp, options) {
      debug('comp', comp, options);
      comp = replaceCarets(comp, options);
      debug('caret', comp);
      comp = replaceTildes(comp, options);
      debug('tildes', comp);
      comp = replaceXRanges(comp, options);
      debug('xrange', comp);
      comp = replaceStars(comp, options);
      debug('stars', comp);
      return comp
    }

    function isX (id) {
      return !id || id.toLowerCase() === 'x' || id === '*'
    }

    // ~, ~> --> * (any, kinda silly)
    // ~2, ~2.x, ~2.x.x, ~>2, ~>2.x ~>2.x.x --> >=2.0.0 <3.0.0
    // ~2.0, ~2.0.x, ~>2.0, ~>2.0.x --> >=2.0.0 <2.1.0
    // ~1.2, ~1.2.x, ~>1.2, ~>1.2.x --> >=1.2.0 <1.3.0
    // ~1.2.3, ~>1.2.3 --> >=1.2.3 <1.3.0
    // ~1.2.0, ~>1.2.0 --> >=1.2.0 <1.3.0
    function replaceTildes (comp, options) {
      return comp.trim().split(/\s+/).map(function (comp) {
        return replaceTilde(comp, options)
      }).join(' ')
    }

    function replaceTilde (comp, options) {
      var r = options.loose ? re[TILDELOOSE] : re[TILDE];
      return comp.replace(r, function (_, M, m, p, pr) {
        debug('tilde', comp, _, M, m, p, pr);
        var ret;

        if (isX(M)) {
          ret = '';
        } else if (isX(m)) {
          ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0';
        } else if (isX(p)) {
          // ~1.2 == >=1.2.0 <1.3.0
          ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0';
        } else if (pr) {
          debug('replaceTilde pr', pr);
          ret = '>=' + M + '.' + m + '.' + p + '-' + pr +
                ' <' + M + '.' + (+m + 1) + '.0';
        } else {
          // ~1.2.3 == >=1.2.3 <1.3.0
          ret = '>=' + M + '.' + m + '.' + p +
                ' <' + M + '.' + (+m + 1) + '.0';
        }

        debug('tilde return', ret);
        return ret
      })
    }

    // ^ --> * (any, kinda silly)
    // ^2, ^2.x, ^2.x.x --> >=2.0.0 <3.0.0
    // ^2.0, ^2.0.x --> >=2.0.0 <3.0.0
    // ^1.2, ^1.2.x --> >=1.2.0 <2.0.0
    // ^1.2.3 --> >=1.2.3 <2.0.0
    // ^1.2.0 --> >=1.2.0 <2.0.0
    function replaceCarets (comp, options) {
      return comp.trim().split(/\s+/).map(function (comp) {
        return replaceCaret(comp, options)
      }).join(' ')
    }

    function replaceCaret (comp, options) {
      debug('caret', comp, options);
      var r = options.loose ? re[CARETLOOSE] : re[CARET];
      return comp.replace(r, function (_, M, m, p, pr) {
        debug('caret', comp, _, M, m, p, pr);
        var ret;

        if (isX(M)) {
          ret = '';
        } else if (isX(m)) {
          ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0';
        } else if (isX(p)) {
          if (M === '0') {
            ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0';
          } else {
            ret = '>=' + M + '.' + m + '.0 <' + (+M + 1) + '.0.0';
          }
        } else if (pr) {
          debug('replaceCaret pr', pr);
          if (M === '0') {
            if (m === '0') {
              ret = '>=' + M + '.' + m + '.' + p + '-' + pr +
                    ' <' + M + '.' + m + '.' + (+p + 1);
            } else {
              ret = '>=' + M + '.' + m + '.' + p + '-' + pr +
                    ' <' + M + '.' + (+m + 1) + '.0';
            }
          } else {
            ret = '>=' + M + '.' + m + '.' + p + '-' + pr +
                  ' <' + (+M + 1) + '.0.0';
          }
        } else {
          debug('no pr');
          if (M === '0') {
            if (m === '0') {
              ret = '>=' + M + '.' + m + '.' + p +
                    ' <' + M + '.' + m + '.' + (+p + 1);
            } else {
              ret = '>=' + M + '.' + m + '.' + p +
                    ' <' + M + '.' + (+m + 1) + '.0';
            }
          } else {
            ret = '>=' + M + '.' + m + '.' + p +
                  ' <' + (+M + 1) + '.0.0';
          }
        }

        debug('caret return', ret);
        return ret
      })
    }

    function replaceXRanges (comp, options) {
      debug('replaceXRanges', comp, options);
      return comp.split(/\s+/).map(function (comp) {
        return replaceXRange(comp, options)
      }).join(' ')
    }

    function replaceXRange (comp, options) {
      comp = comp.trim();
      var r = options.loose ? re[XRANGELOOSE] : re[XRANGE];
      return comp.replace(r, function (ret, gtlt, M, m, p, pr) {
        debug('xRange', comp, ret, gtlt, M, m, p, pr);
        var xM = isX(M);
        var xm = xM || isX(m);
        var xp = xm || isX(p);
        var anyX = xp;

        if (gtlt === '=' && anyX) {
          gtlt = '';
        }

        if (xM) {
          if (gtlt === '>' || gtlt === '<') {
            // nothing is allowed
            ret = '<0.0.0';
          } else {
            // nothing is forbidden
            ret = '*';
          }
        } else if (gtlt && anyX) {
          // we know patch is an x, because we have any x at all.
          // replace X with 0
          if (xm) {
            m = 0;
          }
          p = 0;

          if (gtlt === '>') {
            // >1 => >=2.0.0
            // >1.2 => >=1.3.0
            // >1.2.3 => >= 1.2.4
            gtlt = '>=';
            if (xm) {
              M = +M + 1;
              m = 0;
              p = 0;
            } else {
              m = +m + 1;
              p = 0;
            }
          } else if (gtlt === '<=') {
            // <=0.7.x is actually <0.8.0, since any 0.7.x should
            // pass.  Similarly, <=7.x is actually <8.0.0, etc.
            gtlt = '<';
            if (xm) {
              M = +M + 1;
            } else {
              m = +m + 1;
            }
          }

          ret = gtlt + M + '.' + m + '.' + p;
        } else if (xm) {
          ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0';
        } else if (xp) {
          ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0';
        }

        debug('xRange return', ret);

        return ret
      })
    }

    // Because * is AND-ed with everything else in the comparator,
    // and '' means "any version", just remove the *s entirely.
    function replaceStars (comp, options) {
      debug('replaceStars', comp, options);
      // Looseness is ignored here.  star is always as loose as it gets!
      return comp.trim().replace(re[STAR], '')
    }

    // This function is passed to string.replace(re[HYPHENRANGE])
    // M, m, patch, prerelease, build
    // 1.2 - 3.4.5 => >=1.2.0 <=3.4.5
    // 1.2.3 - 3.4 => >=1.2.0 <3.5.0 Any 3.4.x will do
    // 1.2 - 3.4 => >=1.2.0 <3.5.0
    function hyphenReplace ($0,
      from, fM, fm, fp, fpr, fb,
      to, tM, tm, tp, tpr, tb) {
      if (isX(fM)) {
        from = '';
      } else if (isX(fm)) {
        from = '>=' + fM + '.0.0';
      } else if (isX(fp)) {
        from = '>=' + fM + '.' + fm + '.0';
      } else {
        from = '>=' + from;
      }

      if (isX(tM)) {
        to = '';
      } else if (isX(tm)) {
        to = '<' + (+tM + 1) + '.0.0';
      } else if (isX(tp)) {
        to = '<' + tM + '.' + (+tm + 1) + '.0';
      } else if (tpr) {
        to = '<=' + tM + '.' + tm + '.' + tp + '-' + tpr;
      } else {
        to = '<=' + to;
      }

      return (from + ' ' + to).trim()
    }

    // if ANY of the sets match ALL of its comparators, then pass
    Range.prototype.test = function (version) {
      if (!version) {
        return false
      }

      if (typeof version === 'string') {
        version = new SemVer(version, this.options);
      }

      for (var i = 0; i < this.set.length; i++) {
        if (testSet(this.set[i], version, this.options)) {
          return true
        }
      }
      return false
    };

    function testSet (set, version, options) {
      for (var i = 0; i < set.length; i++) {
        if (!set[i].test(version)) {
          return false
        }
      }

      if (version.prerelease.length && !options.includePrerelease) {
        // Find the set of versions that are allowed to have prereleases
        // For example, ^1.2.3-pr.1 desugars to >=1.2.3-pr.1 <2.0.0
        // That should allow `1.2.3-pr.2` to pass.
        // However, `1.2.4-alpha.notready` should NOT be allowed,
        // even though it's within the range set by the comparators.
        for (i = 0; i < set.length; i++) {
          debug(set[i].semver);
          if (set[i].semver === ANY) {
            continue
          }

          if (set[i].semver.prerelease.length > 0) {
            var allowed = set[i].semver;
            if (allowed.major === version.major &&
                allowed.minor === version.minor &&
                allowed.patch === version.patch) {
              return true
            }
          }
        }

        // Version has a -pre, but it's not one of the ones we like.
        return false
      }

      return true
    }

    exports.satisfies = satisfies;
    function satisfies (version, range, options) {
      try {
        range = new Range(range, options);
      } catch (er) {
        return false
      }
      return range.test(version)
    }

    exports.maxSatisfying = maxSatisfying;
    function maxSatisfying (versions, range, options) {
      var max = null;
      var maxSV = null;
      try {
        var rangeObj = new Range(range, options);
      } catch (er) {
        return null
      }
      versions.forEach(function (v) {
        if (rangeObj.test(v)) {
          // satisfies(v, range, options)
          if (!max || maxSV.compare(v) === -1) {
            // compare(max, v, true)
            max = v;
            maxSV = new SemVer(max, options);
          }
        }
      });
      return max
    }

    exports.minSatisfying = minSatisfying;
    function minSatisfying (versions, range, options) {
      var min = null;
      var minSV = null;
      try {
        var rangeObj = new Range(range, options);
      } catch (er) {
        return null
      }
      versions.forEach(function (v) {
        if (rangeObj.test(v)) {
          // satisfies(v, range, options)
          if (!min || minSV.compare(v) === 1) {
            // compare(min, v, true)
            min = v;
            minSV = new SemVer(min, options);
          }
        }
      });
      return min
    }

    exports.minVersion = minVersion;
    function minVersion (range, loose) {
      range = new Range(range, loose);

      var minver = new SemVer('0.0.0');
      if (range.test(minver)) {
        return minver
      }

      minver = new SemVer('0.0.0-0');
      if (range.test(minver)) {
        return minver
      }

      minver = null;
      for (var i = 0; i < range.set.length; ++i) {
        var comparators = range.set[i];

        comparators.forEach(function (comparator) {
          // Clone to avoid manipulating the comparator's semver object.
          var compver = new SemVer(comparator.semver.version);
          switch (comparator.operator) {
            case '>':
              if (compver.prerelease.length === 0) {
                compver.patch++;
              } else {
                compver.prerelease.push(0);
              }
              compver.raw = compver.format();
              /* fallthrough */
            case '':
            case '>=':
              if (!minver || gt(minver, compver)) {
                minver = compver;
              }
              break
            case '<':
            case '<=':
              /* Ignore maximum versions */
              break
            /* istanbul ignore next */
            default:
              throw new Error('Unexpected operation: ' + comparator.operator)
          }
        });
      }

      if (minver && range.test(minver)) {
        return minver
      }

      return null
    }

    exports.validRange = validRange;
    function validRange (range, options) {
      try {
        // Return '*' instead of '' so that truthiness works.
        // This will throw if it's invalid anyway
        return new Range(range, options).range || '*'
      } catch (er) {
        return null
      }
    }

    // Determine if version is less than all the versions possible in the range
    exports.ltr = ltr;
    function ltr (version, range, options) {
      return outside(version, range, '<', options)
    }

    // Determine if version is greater than all the versions possible in the range.
    exports.gtr = gtr;
    function gtr (version, range, options) {
      return outside(version, range, '>', options)
    }

    exports.outside = outside;
    function outside (version, range, hilo, options) {
      version = new SemVer(version, options);
      range = new Range(range, options);

      var gtfn, ltefn, ltfn, comp, ecomp;
      switch (hilo) {
        case '>':
          gtfn = gt;
          ltefn = lte;
          ltfn = lt;
          comp = '>';
          ecomp = '>=';
          break
        case '<':
          gtfn = lt;
          ltefn = gte;
          ltfn = gt;
          comp = '<';
          ecomp = '<=';
          break
        default:
          throw new TypeError('Must provide a hilo val of "<" or ">"')
      }

      // If it satisifes the range it is not outside
      if (satisfies(version, range, options)) {
        return false
      }

      // From now on, variable terms are as if we're in "gtr" mode.
      // but note that everything is flipped for the "ltr" function.

      for (var i = 0; i < range.set.length; ++i) {
        var comparators = range.set[i];

        var high = null;
        var low = null;

        comparators.forEach(function (comparator) {
          if (comparator.semver === ANY) {
            comparator = new Comparator('>=0.0.0');
          }
          high = high || comparator;
          low = low || comparator;
          if (gtfn(comparator.semver, high.semver, options)) {
            high = comparator;
          } else if (ltfn(comparator.semver, low.semver, options)) {
            low = comparator;
          }
        });

        // If the edge version comparator has a operator then our version
        // isn't outside it
        if (high.operator === comp || high.operator === ecomp) {
          return false
        }

        // If the lowest version comparator has an operator and our version
        // is less than it then it isn't higher than the range
        if ((!low.operator || low.operator === comp) &&
            ltefn(version, low.semver)) {
          return false
        } else if (low.operator === ecomp && ltfn(version, low.semver)) {
          return false
        }
      }
      return true
    }

    exports.prerelease = prerelease;
    function prerelease (version, options) {
      var parsed = parse(version, options);
      return (parsed && parsed.prerelease.length) ? parsed.prerelease : null
    }

    exports.intersects = intersects;
    function intersects (r1, r2, options) {
      r1 = new Range(r1, options);
      r2 = new Range(r2, options);
      return r1.intersects(r2)
    }

    exports.coerce = coerce;
    function coerce (version) {
      if (version instanceof SemVer) {
        return version
      }

      if (typeof version !== 'string') {
        return null
      }

      var match = version.match(re[COERCE]);

      if (match == null) {
        return null
      }

      return parse(match[1] +
        '.' + (match[2] || '0') +
        '.' + (match[3] || '0'))
    }
    }(semver$1, semver$1.exports));

    var semverRegex$1 = function () {
    	return /\bv?(?:0|[1-9][0-9]*)\.(?:0|[1-9][0-9]*)\.(?:0|[1-9][0-9]*)(?:-[\da-z\-]+(?:\.[\da-z\-]+)*)?(?:\+[\da-z\-]+(?:\.[\da-z\-]+)*)?\b/ig;
    };

    var semver = semver$1.exports;
    var semverRegex = semverRegex$1;

    function sort(semvers, compare) {
    	if (!semvers instanceof Array) {
    		throw new Error('It is not an array');
    	}

    	return semvers.sort(function (v1, v2) {
    		var sv1 = semverRegex().exec(v1)[0] || v1;
    		var sv2 = semverRegex().exec(v2)[0] || v2;

    		return compare(sv1, sv2);
    	});
    }

    var semverSort = {
    	asc: function (semvers) {
    		return sort(semvers, semver.compare);
    	},

    	desc: function (semvers) {
    		return sort(semvers, semver.rcompare);
    	}
    };

    log.level = process.env.LOG_LEVEL ? process.env.LOG_LEVEL : 'info';
    log.heading = 'js-cli';
    log.addLevel('success', 2000, { fg: 'green', bold: true });

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */

    function __awaiter$2(thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }

    const getNpmInfo = (npmName, registry) => {
        if (!npmName) {
            return null;
        }
        const registryUrl = registry || getDefaultRegistry();
        const npmInfoUrl = urlJoin(registryUrl, npmName);
        return axios.get(npmInfoUrl).then(response => {
            if (response.status === 200) {
                return response.data;
            }
        }).catch((err) => {
            return Promise.reject(err);
        });
    };
    const getDefaultRegistry = (isOriginal = false) => {
        return isOriginal ? 'https://registry.npm.taobao.org' : 'https://registry.npmjs.org';
    };
    const getNpmVersions = (appName, registry = '') => __awaiter$2(void 0, void 0, void 0, function* () {
        const data = yield getNpmInfo(appName, registry);
        if (data) {
            return Object.keys(data.versions);
        }
        else {
            return [];
        }
    });
    const getNpmSemverVersion = (baseVersion, npmName, registry = '') => __awaiter$2(void 0, void 0, void 0, function* () {
        const versions = yield getNpmVersions(npmName, registry);
        const newVersions = getSemverVersions(baseVersion, versions);
        if (newVersions && newVersions.length > 0) {
            return newVersions[0];
        }
        return null;
    });
    const getSemverVersions = (baseVersion, versions) => {
        return semverSort.desc(versions.filter(version => semver$2.satisfies(version, `^${baseVersion}`)));
    };
    const getNpmLatestVersion = (npmName, registry = '') => __awaiter$2(void 0, void 0, void 0, function* () {
        const versions = yield getNpmVersions(npmName);
        if (versions) {
            return semverSort.desc(versions)[0];
        }
        return '';
    });

    var getNpmInfo$1 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        getDefaultRegistry: getDefaultRegistry,
        getNpmSemverVersion: getNpmSemverVersion,
        getNpmLatestVersion: getNpmLatestVersion
    });

    const BASE_URL = process.env.JS_CLI_BASE_URL ? process.env.JS_CLI_BASE_URL : 'http://1.116.156.44:8085';
    const request = axios.create({
        baseURL: BASE_URL,
        timeout: 30000,
    });
    request.interceptors.response.use((response) => {
        if (response.status === 200) {
            return response.data;
        }
    }, (error) => {
        return Promise.reject(error);
    });

    var KEBAB_REGEX = /[A-Z\u00C0-\u00D6\u00D8-\u00DE]/g;
    const isObject$a = (o) => {
        return Object.prototype.toString.call(o) === '[object Object]';
    };
    const spawn = (command, args, options = {}) => {
        const win32 = process.platform === 'win32';
        const cmd = win32 ? 'cmd' : command;
        const cmdArgs = win32 ? ['/c'].concat(command, args) : args;
        return cp__default["default"].spawn(cmd, cmdArgs, options || {});
    };
    const execSpawn = (command, args, options = {}) => {
        return new Promise(((resolve, reject) => {
            const p = spawn(command, args, options);
            p.on('error', e => {
                reject(e);
            });
            p.on('exit', c => {
                resolve(c);
            });
        }));
    };
    const spinnerStart = (msg = 'loading', spinnerString = '|/-\\') => {
        const Spinner = require('cli-spinner').Spinner;
        const spinner = new Spinner(msg + '%s');
        spinner.setSpinnerString(spinnerString);
        spinner.start();
        return spinner;
    };
    const sleep = () => {
        new Promise(resolve => setTimeout(resolve, 1000));
    };
    const kebabCase = (str) => {
        return str.replace(KEBAB_REGEX, function (match) {
            return '-' + match.toLowerCase();
        });
    };

    var pkgDir$2 = {exports: {}};

    var findUp$1 = {exports: {}};

    var locatePath = {exports: {}};

    class Node {
    	/// value;
    	/// next;

    	constructor(value) {
    		this.value = value;

    		// TODO: Remove this when targeting Node.js 12.
    		this.next = undefined;
    	}
    }

    class Queue$1 {
    	// TODO: Use private class fields when targeting Node.js 12.
    	// #_head;
    	// #_tail;
    	// #_size;

    	constructor() {
    		this.clear();
    	}

    	enqueue(value) {
    		const node = new Node(value);

    		if (this._head) {
    			this._tail.next = node;
    			this._tail = node;
    		} else {
    			this._head = node;
    			this._tail = node;
    		}

    		this._size++;
    	}

    	dequeue() {
    		const current = this._head;
    		if (!current) {
    			return;
    		}

    		this._head = this._head.next;
    		this._size--;
    		return current.value;
    	}

    	clear() {
    		this._head = undefined;
    		this._tail = undefined;
    		this._size = 0;
    	}

    	get size() {
    		return this._size;
    	}

    	* [Symbol.iterator]() {
    		let current = this._head;

    		while (current) {
    			yield current.value;
    			current = current.next;
    		}
    	}
    }

    var yoctoQueue = Queue$1;

    const Queue = yoctoQueue;

    const pLimit$1 = concurrency => {
    	if (!((Number.isInteger(concurrency) || concurrency === Infinity) && concurrency > 0)) {
    		throw new TypeError('Expected `concurrency` to be a number from 1 and up');
    	}

    	const queue = new Queue();
    	let activeCount = 0;

    	const next = () => {
    		activeCount--;

    		if (queue.size > 0) {
    			queue.dequeue()();
    		}
    	};

    	const run = async (fn, resolve, ...args) => {
    		activeCount++;

    		const result = (async () => fn(...args))();

    		resolve(result);

    		try {
    			await result;
    		} catch {}

    		next();
    	};

    	const enqueue = (fn, resolve, ...args) => {
    		queue.enqueue(run.bind(null, fn, resolve, ...args));

    		(async () => {
    			// This function needs to wait until the next microtask before comparing
    			// `activeCount` to `concurrency`, because `activeCount` is updated asynchronously
    			// when the run function is dequeued and called. The comparison in the if-statement
    			// needs to happen asynchronously as well to get an up-to-date value for `activeCount`.
    			await Promise.resolve();

    			if (activeCount < concurrency && queue.size > 0) {
    				queue.dequeue()();
    			}
    		})();
    	};

    	const generator = (fn, ...args) => new Promise(resolve => {
    		enqueue(fn, resolve, ...args);
    	});

    	Object.defineProperties(generator, {
    		activeCount: {
    			get: () => activeCount
    		},
    		pendingCount: {
    			get: () => queue.size
    		},
    		clearQueue: {
    			value: () => {
    				queue.clear();
    			}
    		}
    	});

    	return generator;
    };

    var pLimit_1 = pLimit$1;

    const pLimit = pLimit_1;

    class EndError extends Error {
    	constructor(value) {
    		super();
    		this.value = value;
    	}
    }

    // The input can also be a promise, so we await it
    const testElement = async (element, tester) => tester(await element);

    // The input can also be a promise, so we `Promise.all()` them both
    const finder = async element => {
    	const values = await Promise.all(element);
    	if (values[1] === true) {
    		throw new EndError(values[0]);
    	}

    	return false;
    };

    const pLocate$1 = async (iterable, tester, options) => {
    	options = {
    		concurrency: Infinity,
    		preserveOrder: true,
    		...options
    	};

    	const limit = pLimit(options.concurrency);

    	// Start all the promises concurrently with optional limit
    	const items = [...iterable].map(element => [element, limit(testElement, element, tester)]);

    	// Check the promises either serially or concurrently
    	const checkLimit = pLimit(options.preserveOrder ? 1 : Infinity);

    	try {
    		await Promise.all(items.map(element => checkLimit(finder, element)));
    	} catch (error) {
    		if (error instanceof EndError) {
    			return error.value;
    		}

    		throw error;
    	}
    };

    var pLocate_1 = pLocate$1;

    const path$j = require$$1__default$1["default"];
    const fs$p = require$$0__default$6["default"];
    const {promisify: promisify$1} = require$$0__default$1["default"];
    const pLocate = pLocate_1;

    const fsStat = promisify$1(fs$p.stat);
    const fsLStat = promisify$1(fs$p.lstat);

    const typeMappings = {
    	directory: 'isDirectory',
    	file: 'isFile'
    };

    function checkType({type}) {
    	if (type in typeMappings) {
    		return;
    	}

    	throw new Error(`Invalid type specified: ${type}`);
    }

    const matchType = (type, stat) => type === undefined || stat[typeMappings[type]]();

    locatePath.exports = async (paths, options) => {
    	options = {
    		cwd: process.cwd(),
    		type: 'file',
    		allowSymlinks: true,
    		...options
    	};

    	checkType(options);

    	const statFn = options.allowSymlinks ? fsStat : fsLStat;

    	return pLocate(paths, async path_ => {
    		try {
    			const stat = await statFn(path$j.resolve(options.cwd, path_));
    			return matchType(options.type, stat);
    		} catch {
    			return false;
    		}
    	}, options);
    };

    locatePath.exports.sync = (paths, options) => {
    	options = {
    		cwd: process.cwd(),
    		allowSymlinks: true,
    		type: 'file',
    		...options
    	};

    	checkType(options);

    	const statFn = options.allowSymlinks ? fs$p.statSync : fs$p.lstatSync;

    	for (const path_ of paths) {
    		try {
    			const stat = statFn(path$j.resolve(options.cwd, path_));

    			if (matchType(options.type, stat)) {
    				return path_;
    			}
    		} catch {}
    	}
    };

    var pathExists$8 = {exports: {}};

    const fs$o = require$$0__default$6["default"];
    const {promisify} = require$$0__default$1["default"];

    const pAccess = promisify(fs$o.access);

    pathExists$8.exports = async path => {
    	try {
    		await pAccess(path);
    		return true;
    	} catch (_) {
    		return false;
    	}
    };

    pathExists$8.exports.sync = path => {
    	try {
    		fs$o.accessSync(path);
    		return true;
    	} catch (_) {
    		return false;
    	}
    };

    var _pathExists = pathExists$8.exports;

    (function (module) {
    const path = require$$1__default$1["default"];
    const locatePath$1 = locatePath.exports;
    const pathExists = pathExists$8.exports;

    const stop = Symbol('findUp.stop');

    module.exports = async (name, options = {}) => {
    	let directory = path.resolve(options.cwd || '');
    	const {root} = path.parse(directory);
    	const paths = [].concat(name);

    	const runMatcher = async locateOptions => {
    		if (typeof name !== 'function') {
    			return locatePath$1(paths, locateOptions);
    		}

    		const foundPath = await name(locateOptions.cwd);
    		if (typeof foundPath === 'string') {
    			return locatePath$1([foundPath], locateOptions);
    		}

    		return foundPath;
    	};

    	// eslint-disable-next-line no-constant-condition
    	while (true) {
    		// eslint-disable-next-line no-await-in-loop
    		const foundPath = await runMatcher({...options, cwd: directory});

    		if (foundPath === stop) {
    			return;
    		}

    		if (foundPath) {
    			return path.resolve(directory, foundPath);
    		}

    		if (directory === root) {
    			return;
    		}

    		directory = path.dirname(directory);
    	}
    };

    module.exports.sync = (name, options = {}) => {
    	let directory = path.resolve(options.cwd || '');
    	const {root} = path.parse(directory);
    	const paths = [].concat(name);

    	const runMatcher = locateOptions => {
    		if (typeof name !== 'function') {
    			return locatePath$1.sync(paths, locateOptions);
    		}

    		const foundPath = name(locateOptions.cwd);
    		if (typeof foundPath === 'string') {
    			return locatePath$1.sync([foundPath], locateOptions);
    		}

    		return foundPath;
    	};

    	// eslint-disable-next-line no-constant-condition
    	while (true) {
    		const foundPath = runMatcher({...options, cwd: directory});

    		if (foundPath === stop) {
    			return;
    		}

    		if (foundPath) {
    			return path.resolve(directory, foundPath);
    		}

    		if (directory === root) {
    			return;
    		}

    		directory = path.dirname(directory);
    	}
    };

    module.exports.exists = pathExists;

    module.exports.sync.exists = pathExists.sync;

    module.exports.stop = stop;
    }(findUp$1));

    const path$i = require$$1__default$1["default"];
    const findUp = findUp$1.exports;

    const pkgDir = async cwd => {
    	const filePath = await findUp('package.json', {cwd});
    	return filePath && path$i.dirname(filePath);
    };

    pkgDir$2.exports = pkgDir;

    pkgDir$2.exports.sync = cwd => {
    	const filePath = findUp.sync('package.json', {cwd});
    	return filePath && path$i.dirname(filePath);
    };

    var pkgDir$1 = pkgDir$2.exports;

    var fs$n = {};

    var universalify$1 = {};

    universalify$1.fromCallback = function (fn) {
      return Object.defineProperty(function (...args) {
        if (typeof args[args.length - 1] === 'function') fn.apply(this, args);
        else {
          return new Promise((resolve, reject) => {
            fn.call(
              this,
              ...args,
              (err, res) => (err != null) ? reject(err) : resolve(res)
            );
          })
        }
      }, 'name', { value: fn.name })
    };

    universalify$1.fromPromise = function (fn) {
      return Object.defineProperty(function (...args) {
        const cb = args[args.length - 1];
        if (typeof cb !== 'function') return fn.apply(this, args)
        else fn.apply(this, args.slice(0, -1)).then(r => cb(null, r), cb);
      }, 'name', { value: fn.name })
    };

    var constants = require$$0__default$7["default"];

    var origCwd = process.cwd;
    var cwd = null;

    var platform$1 = process.env.GRACEFUL_FS_PLATFORM || process.platform;

    process.cwd = function() {
      if (!cwd)
        cwd = origCwd.call(process);
      return cwd
    };
    try {
      process.cwd();
    } catch (er) {}

    // This check is needed until node.js 12 is required
    if (typeof process.chdir === 'function') {
      var chdir = process.chdir;
      process.chdir = function (d) {
        cwd = null;
        chdir.call(process, d);
      };
      if (Object.setPrototypeOf) Object.setPrototypeOf(process.chdir, chdir);
    }

    var polyfills$1 = patch$1;

    function patch$1 (fs) {
      // (re-)implement some things that are known busted or missing.

      // lchmod, broken prior to 0.6.2
      // back-port the fix here.
      if (constants.hasOwnProperty('O_SYMLINK') &&
          process.version.match(/^v0\.6\.[0-2]|^v0\.5\./)) {
        patchLchmod(fs);
      }

      // lutimes implementation, or no-op
      if (!fs.lutimes) {
        patchLutimes(fs);
      }

      // https://github.com/isaacs/node-graceful-fs/issues/4
      // Chown should not fail on einval or eperm if non-root.
      // It should not fail on enosys ever, as this just indicates
      // that a fs doesn't support the intended operation.

      fs.chown = chownFix(fs.chown);
      fs.fchown = chownFix(fs.fchown);
      fs.lchown = chownFix(fs.lchown);

      fs.chmod = chmodFix(fs.chmod);
      fs.fchmod = chmodFix(fs.fchmod);
      fs.lchmod = chmodFix(fs.lchmod);

      fs.chownSync = chownFixSync(fs.chownSync);
      fs.fchownSync = chownFixSync(fs.fchownSync);
      fs.lchownSync = chownFixSync(fs.lchownSync);

      fs.chmodSync = chmodFixSync(fs.chmodSync);
      fs.fchmodSync = chmodFixSync(fs.fchmodSync);
      fs.lchmodSync = chmodFixSync(fs.lchmodSync);

      fs.stat = statFix(fs.stat);
      fs.fstat = statFix(fs.fstat);
      fs.lstat = statFix(fs.lstat);

      fs.statSync = statFixSync(fs.statSync);
      fs.fstatSync = statFixSync(fs.fstatSync);
      fs.lstatSync = statFixSync(fs.lstatSync);

      // if lchmod/lchown do not exist, then make them no-ops
      if (!fs.lchmod) {
        fs.lchmod = function (path, mode, cb) {
          if (cb) process.nextTick(cb);
        };
        fs.lchmodSync = function () {};
      }
      if (!fs.lchown) {
        fs.lchown = function (path, uid, gid, cb) {
          if (cb) process.nextTick(cb);
        };
        fs.lchownSync = function () {};
      }

      // on Windows, A/V software can lock the directory, causing this
      // to fail with an EACCES or EPERM if the directory contains newly
      // created files.  Try again on failure, for up to 60 seconds.

      // Set the timeout this long because some Windows Anti-Virus, such as Parity
      // bit9, may lock files for up to a minute, causing npm package install
      // failures. Also, take care to yield the scheduler. Windows scheduling gives
      // CPU to a busy looping process, which can cause the program causing the lock
      // contention to be starved of CPU by node, so the contention doesn't resolve.
      if (platform$1 === "win32") {
        fs.rename = (function (fs$rename) { return function (from, to, cb) {
          var start = Date.now();
          var backoff = 0;
          fs$rename(from, to, function CB (er) {
            if (er
                && (er.code === "EACCES" || er.code === "EPERM")
                && Date.now() - start < 60000) {
              setTimeout(function() {
                fs.stat(to, function (stater, st) {
                  if (stater && stater.code === "ENOENT")
                    fs$rename(from, to, CB);
                  else
                    cb(er);
                });
              }, backoff);
              if (backoff < 100)
                backoff += 10;
              return;
            }
            if (cb) cb(er);
          });
        }})(fs.rename);
      }

      // if read() returns EAGAIN, then just try it again.
      fs.read = (function (fs$read) {
        function read (fd, buffer, offset, length, position, callback_) {
          var callback;
          if (callback_ && typeof callback_ === 'function') {
            var eagCounter = 0;
            callback = function (er, _, __) {
              if (er && er.code === 'EAGAIN' && eagCounter < 10) {
                eagCounter ++;
                return fs$read.call(fs, fd, buffer, offset, length, position, callback)
              }
              callback_.apply(this, arguments);
            };
          }
          return fs$read.call(fs, fd, buffer, offset, length, position, callback)
        }

        // This ensures `util.promisify` works as it does for native `fs.read`.
        if (Object.setPrototypeOf) Object.setPrototypeOf(read, fs$read);
        return read
      })(fs.read);

      fs.readSync = (function (fs$readSync) { return function (fd, buffer, offset, length, position) {
        var eagCounter = 0;
        while (true) {
          try {
            return fs$readSync.call(fs, fd, buffer, offset, length, position)
          } catch (er) {
            if (er.code === 'EAGAIN' && eagCounter < 10) {
              eagCounter ++;
              continue
            }
            throw er
          }
        }
      }})(fs.readSync);

      function patchLchmod (fs) {
        fs.lchmod = function (path, mode, callback) {
          fs.open( path
                 , constants.O_WRONLY | constants.O_SYMLINK
                 , mode
                 , function (err, fd) {
            if (err) {
              if (callback) callback(err);
              return
            }
            // prefer to return the chmod error, if one occurs,
            // but still try to close, and report closing errors if they occur.
            fs.fchmod(fd, mode, function (err) {
              fs.close(fd, function(err2) {
                if (callback) callback(err || err2);
              });
            });
          });
        };

        fs.lchmodSync = function (path, mode) {
          var fd = fs.openSync(path, constants.O_WRONLY | constants.O_SYMLINK, mode);

          // prefer to return the chmod error, if one occurs,
          // but still try to close, and report closing errors if they occur.
          var threw = true;
          var ret;
          try {
            ret = fs.fchmodSync(fd, mode);
            threw = false;
          } finally {
            if (threw) {
              try {
                fs.closeSync(fd);
              } catch (er) {}
            } else {
              fs.closeSync(fd);
            }
          }
          return ret
        };
      }

      function patchLutimes (fs) {
        if (constants.hasOwnProperty("O_SYMLINK")) {
          fs.lutimes = function (path, at, mt, cb) {
            fs.open(path, constants.O_SYMLINK, function (er, fd) {
              if (er) {
                if (cb) cb(er);
                return
              }
              fs.futimes(fd, at, mt, function (er) {
                fs.close(fd, function (er2) {
                  if (cb) cb(er || er2);
                });
              });
            });
          };

          fs.lutimesSync = function (path, at, mt) {
            var fd = fs.openSync(path, constants.O_SYMLINK);
            var ret;
            var threw = true;
            try {
              ret = fs.futimesSync(fd, at, mt);
              threw = false;
            } finally {
              if (threw) {
                try {
                  fs.closeSync(fd);
                } catch (er) {}
              } else {
                fs.closeSync(fd);
              }
            }
            return ret
          };

        } else {
          fs.lutimes = function (_a, _b, _c, cb) { if (cb) process.nextTick(cb); };
          fs.lutimesSync = function () {};
        }
      }

      function chmodFix (orig) {
        if (!orig) return orig
        return function (target, mode, cb) {
          return orig.call(fs, target, mode, function (er) {
            if (chownErOk(er)) er = null;
            if (cb) cb.apply(this, arguments);
          })
        }
      }

      function chmodFixSync (orig) {
        if (!orig) return orig
        return function (target, mode) {
          try {
            return orig.call(fs, target, mode)
          } catch (er) {
            if (!chownErOk(er)) throw er
          }
        }
      }


      function chownFix (orig) {
        if (!orig) return orig
        return function (target, uid, gid, cb) {
          return orig.call(fs, target, uid, gid, function (er) {
            if (chownErOk(er)) er = null;
            if (cb) cb.apply(this, arguments);
          })
        }
      }

      function chownFixSync (orig) {
        if (!orig) return orig
        return function (target, uid, gid) {
          try {
            return orig.call(fs, target, uid, gid)
          } catch (er) {
            if (!chownErOk(er)) throw er
          }
        }
      }

      function statFix (orig) {
        if (!orig) return orig
        // Older versions of Node erroneously returned signed integers for
        // uid + gid.
        return function (target, options, cb) {
          if (typeof options === 'function') {
            cb = options;
            options = null;
          }
          function callback (er, stats) {
            if (stats) {
              if (stats.uid < 0) stats.uid += 0x100000000;
              if (stats.gid < 0) stats.gid += 0x100000000;
            }
            if (cb) cb.apply(this, arguments);
          }
          return options ? orig.call(fs, target, options, callback)
            : orig.call(fs, target, callback)
        }
      }

      function statFixSync (orig) {
        if (!orig) return orig
        // Older versions of Node erroneously returned signed integers for
        // uid + gid.
        return function (target, options) {
          var stats = options ? orig.call(fs, target, options)
            : orig.call(fs, target);
          if (stats.uid < 0) stats.uid += 0x100000000;
          if (stats.gid < 0) stats.gid += 0x100000000;
          return stats;
        }
      }

      // ENOSYS means that the fs doesn't support the op. Just ignore
      // that, because it doesn't matter.
      //
      // if there's no getuid, or if getuid() is something other
      // than 0, and the error is EINVAL or EPERM, then just ignore
      // it.
      //
      // This specific case is a silent failure in cp, install, tar,
      // and most other unix tools that manage permissions.
      //
      // When running as root, or if other types of errors are
      // encountered, then it's strict.
      function chownErOk (er) {
        if (!er)
          return true

        if (er.code === "ENOSYS")
          return true

        var nonroot = !process.getuid || process.getuid() !== 0;
        if (nonroot) {
          if (er.code === "EINVAL" || er.code === "EPERM")
            return true
        }

        return false
      }
    }

    var Stream$1 = require$$0__default$2["default"].Stream;

    var legacyStreams = legacy$1;

    function legacy$1 (fs) {
      return {
        ReadStream: ReadStream,
        WriteStream: WriteStream
      }

      function ReadStream (path, options) {
        if (!(this instanceof ReadStream)) return new ReadStream(path, options);

        Stream$1.call(this);

        var self = this;

        this.path = path;
        this.fd = null;
        this.readable = true;
        this.paused = false;

        this.flags = 'r';
        this.mode = 438; /*=0666*/
        this.bufferSize = 64 * 1024;

        options = options || {};

        // Mixin options into this
        var keys = Object.keys(options);
        for (var index = 0, length = keys.length; index < length; index++) {
          var key = keys[index];
          this[key] = options[key];
        }

        if (this.encoding) this.setEncoding(this.encoding);

        if (this.start !== undefined) {
          if ('number' !== typeof this.start) {
            throw TypeError('start must be a Number');
          }
          if (this.end === undefined) {
            this.end = Infinity;
          } else if ('number' !== typeof this.end) {
            throw TypeError('end must be a Number');
          }

          if (this.start > this.end) {
            throw new Error('start must be <= end');
          }

          this.pos = this.start;
        }

        if (this.fd !== null) {
          process.nextTick(function() {
            self._read();
          });
          return;
        }

        fs.open(this.path, this.flags, this.mode, function (err, fd) {
          if (err) {
            self.emit('error', err);
            self.readable = false;
            return;
          }

          self.fd = fd;
          self.emit('open', fd);
          self._read();
        });
      }

      function WriteStream (path, options) {
        if (!(this instanceof WriteStream)) return new WriteStream(path, options);

        Stream$1.call(this);

        this.path = path;
        this.fd = null;
        this.writable = true;

        this.flags = 'w';
        this.encoding = 'binary';
        this.mode = 438; /*=0666*/
        this.bytesWritten = 0;

        options = options || {};

        // Mixin options into this
        var keys = Object.keys(options);
        for (var index = 0, length = keys.length; index < length; index++) {
          var key = keys[index];
          this[key] = options[key];
        }

        if (this.start !== undefined) {
          if ('number' !== typeof this.start) {
            throw TypeError('start must be a Number');
          }
          if (this.start < 0) {
            throw new Error('start must be >= zero');
          }

          this.pos = this.start;
        }

        this.busy = false;
        this._queue = [];

        if (this.fd === null) {
          this._open = fs.open;
          this._queue.push([this._open, this.path, this.flags, this.mode, undefined]);
          this.flush();
        }
      }
    }

    var clone_1$1 = clone$4;

    var getPrototypeOf$1 = Object.getPrototypeOf || function (obj) {
      return obj.__proto__
    };

    function clone$4 (obj) {
      if (obj === null || typeof obj !== 'object')
        return obj

      if (obj instanceof Object)
        var copy = { __proto__: getPrototypeOf$1(obj) };
      else
        var copy = Object.create(null);

      Object.getOwnPropertyNames(obj).forEach(function (key) {
        Object.defineProperty(copy, key, Object.getOwnPropertyDescriptor(obj, key));
      });

      return copy
    }

    var fs$m = require$$0__default$6["default"];
    var polyfills = polyfills$1;
    var legacy = legacyStreams;
    var clone$3 = clone_1$1;

    var util$3 = require$$0__default$1["default"];

    /* istanbul ignore next - node 0.x polyfill */
    var gracefulQueue;
    var previousSymbol;

    /* istanbul ignore else - node 0.x polyfill */
    if (typeof Symbol === 'function' && typeof Symbol.for === 'function') {
      gracefulQueue = Symbol.for('graceful-fs.queue');
      // This is used in testing by future versions
      previousSymbol = Symbol.for('graceful-fs.previous');
    } else {
      gracefulQueue = '___graceful-fs.queue';
      previousSymbol = '___graceful-fs.previous';
    }

    function noop$3 () {}

    function publishQueue(context, queue) {
      Object.defineProperty(context, gracefulQueue, {
        get: function() {
          return queue
        }
      });
    }

    var debug = noop$3;
    if (util$3.debuglog)
      debug = util$3.debuglog('gfs4');
    else if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || ''))
      debug = function() {
        var m = util$3.format.apply(util$3, arguments);
        m = 'GFS4: ' + m.split(/\n/).join('\nGFS4: ');
        console.error(m);
      };

    // Once time initialization
    if (!fs$m[gracefulQueue]) {
      // This queue can be shared by multiple loaded instances
      var queue$1 = commonjsGlobal[gracefulQueue] || [];
      publishQueue(fs$m, queue$1);

      // Patch fs.close/closeSync to shared queue version, because we need
      // to retry() whenever a close happens *anywhere* in the program.
      // This is essential when multiple graceful-fs instances are
      // in play at the same time.
      fs$m.close = (function (fs$close) {
        function close (fd, cb) {
          return fs$close.call(fs$m, fd, function (err) {
            // This function uses the graceful-fs shared queue
            if (!err) {
              resetQueue();
            }

            if (typeof cb === 'function')
              cb.apply(this, arguments);
          })
        }

        Object.defineProperty(close, previousSymbol, {
          value: fs$close
        });
        return close
      })(fs$m.close);

      fs$m.closeSync = (function (fs$closeSync) {
        function closeSync (fd) {
          // This function uses the graceful-fs shared queue
          fs$closeSync.apply(fs$m, arguments);
          resetQueue();
        }

        Object.defineProperty(closeSync, previousSymbol, {
          value: fs$closeSync
        });
        return closeSync
      })(fs$m.closeSync);

      if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || '')) {
        process.on('exit', function() {
          debug(fs$m[gracefulQueue]);
          require$$5__default["default"].equal(fs$m[gracefulQueue].length, 0);
        });
      }
    }

    if (!commonjsGlobal[gracefulQueue]) {
      publishQueue(commonjsGlobal, fs$m[gracefulQueue]);
    }

    var gracefulFs = patch(clone$3(fs$m));
    if (process.env.TEST_GRACEFUL_FS_GLOBAL_PATCH && !fs$m.__patched) {
        gracefulFs = patch(fs$m);
        fs$m.__patched = true;
    }

    function patch (fs) {
      // Everything that references the open() function needs to be in here
      polyfills(fs);
      fs.gracefulify = patch;

      fs.createReadStream = createReadStream;
      fs.createWriteStream = createWriteStream;
      var fs$readFile = fs.readFile;
      fs.readFile = readFile;
      function readFile (path, options, cb) {
        if (typeof options === 'function')
          cb = options, options = null;

        return go$readFile(path, options, cb)

        function go$readFile (path, options, cb, startTime) {
          return fs$readFile(path, options, function (err) {
            if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))
              enqueue([go$readFile, [path, options, cb], err, startTime || Date.now(), Date.now()]);
            else {
              if (typeof cb === 'function')
                cb.apply(this, arguments);
            }
          })
        }
      }

      var fs$writeFile = fs.writeFile;
      fs.writeFile = writeFile;
      function writeFile (path, data, options, cb) {
        if (typeof options === 'function')
          cb = options, options = null;

        return go$writeFile(path, data, options, cb)

        function go$writeFile (path, data, options, cb, startTime) {
          return fs$writeFile(path, data, options, function (err) {
            if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))
              enqueue([go$writeFile, [path, data, options, cb], err, startTime || Date.now(), Date.now()]);
            else {
              if (typeof cb === 'function')
                cb.apply(this, arguments);
            }
          })
        }
      }

      var fs$appendFile = fs.appendFile;
      if (fs$appendFile)
        fs.appendFile = appendFile;
      function appendFile (path, data, options, cb) {
        if (typeof options === 'function')
          cb = options, options = null;

        return go$appendFile(path, data, options, cb)

        function go$appendFile (path, data, options, cb, startTime) {
          return fs$appendFile(path, data, options, function (err) {
            if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))
              enqueue([go$appendFile, [path, data, options, cb], err, startTime || Date.now(), Date.now()]);
            else {
              if (typeof cb === 'function')
                cb.apply(this, arguments);
            }
          })
        }
      }

      var fs$copyFile = fs.copyFile;
      if (fs$copyFile)
        fs.copyFile = copyFile;
      function copyFile (src, dest, flags, cb) {
        if (typeof flags === 'function') {
          cb = flags;
          flags = 0;
        }
        return go$copyFile(src, dest, flags, cb)

        function go$copyFile (src, dest, flags, cb, startTime) {
          return fs$copyFile(src, dest, flags, function (err) {
            if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))
              enqueue([go$copyFile, [src, dest, flags, cb], err, startTime || Date.now(), Date.now()]);
            else {
              if (typeof cb === 'function')
                cb.apply(this, arguments);
            }
          })
        }
      }

      var fs$readdir = fs.readdir;
      fs.readdir = readdir;
      function readdir (path, options, cb) {
        if (typeof options === 'function')
          cb = options, options = null;

        return go$readdir(path, options, cb)

        function go$readdir (path, options, cb, startTime) {
          return fs$readdir(path, options, function (err, files) {
            if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))
              enqueue([go$readdir, [path, options, cb], err, startTime || Date.now(), Date.now()]);
            else {
              if (files && files.sort)
                files.sort();

              if (typeof cb === 'function')
                cb.call(this, err, files);
            }
          })
        }
      }

      if (process.version.substr(0, 4) === 'v0.8') {
        var legStreams = legacy(fs);
        ReadStream = legStreams.ReadStream;
        WriteStream = legStreams.WriteStream;
      }

      var fs$ReadStream = fs.ReadStream;
      if (fs$ReadStream) {
        ReadStream.prototype = Object.create(fs$ReadStream.prototype);
        ReadStream.prototype.open = ReadStream$open;
      }

      var fs$WriteStream = fs.WriteStream;
      if (fs$WriteStream) {
        WriteStream.prototype = Object.create(fs$WriteStream.prototype);
        WriteStream.prototype.open = WriteStream$open;
      }

      Object.defineProperty(fs, 'ReadStream', {
        get: function () {
          return ReadStream
        },
        set: function (val) {
          ReadStream = val;
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(fs, 'WriteStream', {
        get: function () {
          return WriteStream
        },
        set: function (val) {
          WriteStream = val;
        },
        enumerable: true,
        configurable: true
      });

      // legacy names
      var FileReadStream = ReadStream;
      Object.defineProperty(fs, 'FileReadStream', {
        get: function () {
          return FileReadStream
        },
        set: function (val) {
          FileReadStream = val;
        },
        enumerable: true,
        configurable: true
      });
      var FileWriteStream = WriteStream;
      Object.defineProperty(fs, 'FileWriteStream', {
        get: function () {
          return FileWriteStream
        },
        set: function (val) {
          FileWriteStream = val;
        },
        enumerable: true,
        configurable: true
      });

      function ReadStream (path, options) {
        if (this instanceof ReadStream)
          return fs$ReadStream.apply(this, arguments), this
        else
          return ReadStream.apply(Object.create(ReadStream.prototype), arguments)
      }

      function ReadStream$open () {
        var that = this;
        open(that.path, that.flags, that.mode, function (err, fd) {
          if (err) {
            if (that.autoClose)
              that.destroy();

            that.emit('error', err);
          } else {
            that.fd = fd;
            that.emit('open', fd);
            that.read();
          }
        });
      }

      function WriteStream (path, options) {
        if (this instanceof WriteStream)
          return fs$WriteStream.apply(this, arguments), this
        else
          return WriteStream.apply(Object.create(WriteStream.prototype), arguments)
      }

      function WriteStream$open () {
        var that = this;
        open(that.path, that.flags, that.mode, function (err, fd) {
          if (err) {
            that.destroy();
            that.emit('error', err);
          } else {
            that.fd = fd;
            that.emit('open', fd);
          }
        });
      }

      function createReadStream (path, options) {
        return new fs.ReadStream(path, options)
      }

      function createWriteStream (path, options) {
        return new fs.WriteStream(path, options)
      }

      var fs$open = fs.open;
      fs.open = open;
      function open (path, flags, mode, cb) {
        if (typeof mode === 'function')
          cb = mode, mode = null;

        return go$open(path, flags, mode, cb)

        function go$open (path, flags, mode, cb, startTime) {
          return fs$open(path, flags, mode, function (err, fd) {
            if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))
              enqueue([go$open, [path, flags, mode, cb], err, startTime || Date.now(), Date.now()]);
            else {
              if (typeof cb === 'function')
                cb.apply(this, arguments);
            }
          })
        }
      }

      return fs
    }

    function enqueue (elem) {
      debug('ENQUEUE', elem[0].name, elem[1]);
      fs$m[gracefulQueue].push(elem);
      retry$1();
    }

    // keep track of the timeout between retry() calls
    var retryTimer;

    // reset the startTime and lastTime to now
    // this resets the start of the 60 second overall timeout as well as the
    // delay between attempts so that we'll retry these jobs sooner
    function resetQueue () {
      var now = Date.now();
      for (var i = 0; i < fs$m[gracefulQueue].length; ++i) {
        // entries that are only a length of 2 are from an older version, don't
        // bother modifying those since they'll be retried anyway.
        if (fs$m[gracefulQueue][i].length > 2) {
          fs$m[gracefulQueue][i][3] = now; // startTime
          fs$m[gracefulQueue][i][4] = now; // lastTime
        }
      }
      // call retry to make sure we're actively processing the queue
      retry$1();
    }

    function retry$1 () {
      // clear the timer and remove it to help prevent unintended concurrency
      clearTimeout(retryTimer);
      retryTimer = undefined;

      if (fs$m[gracefulQueue].length === 0)
        return

      var elem = fs$m[gracefulQueue].shift();
      var fn = elem[0];
      var args = elem[1];
      // these items may be unset if they were added by an older graceful-fs
      var err = elem[2];
      var startTime = elem[3];
      var lastTime = elem[4];

      // if we don't have a startTime we have no way of knowing if we've waited
      // long enough, so go ahead and retry this item now
      if (startTime === undefined) {
        debug('RETRY', fn.name, args);
        fn.apply(null, args);
      } else if (Date.now() - startTime >= 60000) {
        // it's been more than 60 seconds total, bail now
        debug('TIMEOUT', fn.name, args);
        var cb = args.pop();
        if (typeof cb === 'function')
          cb.call(null, err);
      } else {
        // the amount of time between the last attempt and right now
        var sinceAttempt = Date.now() - lastTime;
        // the amount of time between when we first tried, and when we last tried
        // rounded up to at least 1
        var sinceStart = Math.max(lastTime - startTime, 1);
        // backoff. wait longer than the total time we've been retrying, but only
        // up to a maximum of 100ms
        var desiredDelay = Math.min(sinceStart * 1.2, 100);
        // it's been long enough since the last retry, do it again
        if (sinceAttempt >= desiredDelay) {
          debug('RETRY', fn.name, args);
          fn.apply(null, args.concat([startTime]));
        } else {
          // if we can't do this job yet, push it to the end of the queue
          // and let the next iteration check again
          fs$m[gracefulQueue].push(elem);
        }
      }

      // schedule our next run if one isn't already scheduled
      if (retryTimer === undefined) {
        retryTimer = setTimeout(retry$1, 0);
      }
    }

    (function (exports) {
    // This is adapted from https://github.com/normalize/mz
    // Copyright (c) 2014-2016 Jonathan Ong me@jongleberry.com and Contributors
    const u = universalify$1.fromCallback;
    const fs = gracefulFs;

    const api = [
      'access',
      'appendFile',
      'chmod',
      'chown',
      'close',
      'copyFile',
      'fchmod',
      'fchown',
      'fdatasync',
      'fstat',
      'fsync',
      'ftruncate',
      'futimes',
      'lchmod',
      'lchown',
      'link',
      'lstat',
      'mkdir',
      'mkdtemp',
      'open',
      'opendir',
      'readdir',
      'readFile',
      'readlink',
      'realpath',
      'rename',
      'rm',
      'rmdir',
      'stat',
      'symlink',
      'truncate',
      'unlink',
      'utimes',
      'writeFile'
    ].filter(key => {
      // Some commands are not available on some systems. Ex:
      // fs.opendir was added in Node.js v12.12.0
      // fs.rm was added in Node.js v14.14.0
      // fs.lchown is not available on at least some Linux
      return typeof fs[key] === 'function'
    });

    // Export cloned fs:
    Object.assign(exports, fs);

    // Universalify async methods:
    api.forEach(method => {
      exports[method] = u(fs[method]);
    });
    exports.realpath.native = u(fs.realpath.native);

    // We differ from mz/fs in that we still ship the old, broken, fs.exists()
    // since we are a drop-in replacement for the native module
    exports.exists = function (filename, callback) {
      if (typeof callback === 'function') {
        return fs.exists(filename, callback)
      }
      return new Promise(resolve => {
        return fs.exists(filename, resolve)
      })
    };

    // fs.read(), fs.write(), & fs.writev() need special treatment due to multiple callback args

    exports.read = function (fd, buffer, offset, length, position, callback) {
      if (typeof callback === 'function') {
        return fs.read(fd, buffer, offset, length, position, callback)
      }
      return new Promise((resolve, reject) => {
        fs.read(fd, buffer, offset, length, position, (err, bytesRead, buffer) => {
          if (err) return reject(err)
          resolve({ bytesRead, buffer });
        });
      })
    };

    // Function signature can be
    // fs.write(fd, buffer[, offset[, length[, position]]], callback)
    // OR
    // fs.write(fd, string[, position[, encoding]], callback)
    // We need to handle both cases, so we use ...args
    exports.write = function (fd, buffer, ...args) {
      if (typeof args[args.length - 1] === 'function') {
        return fs.write(fd, buffer, ...args)
      }

      return new Promise((resolve, reject) => {
        fs.write(fd, buffer, ...args, (err, bytesWritten, buffer) => {
          if (err) return reject(err)
          resolve({ bytesWritten, buffer });
        });
      })
    };

    // fs.writev only available in Node v12.9.0+
    if (typeof fs.writev === 'function') {
      // Function signature is
      // s.writev(fd, buffers[, position], callback)
      // We need to handle the optional arg, so we use ...args
      exports.writev = function (fd, buffers, ...args) {
        if (typeof args[args.length - 1] === 'function') {
          return fs.writev(fd, buffers, ...args)
        }

        return new Promise((resolve, reject) => {
          fs.writev(fd, buffers, ...args, (err, bytesWritten, buffers) => {
            if (err) return reject(err)
            resolve({ bytesWritten, buffers });
          });
        })
      };
    }
    }(fs$n));

    var makeDir$1 = {};

    var utils$4 = {};

    const path$h = require$$1__default$1["default"];

    // https://github.com/nodejs/node/issues/8987
    // https://github.com/libuv/libuv/pull/1088
    utils$4.checkPath = function checkPath (pth) {
      if (process.platform === 'win32') {
        const pathHasInvalidWinCharacters = /[<>:"|?*]/.test(pth.replace(path$h.parse(pth).root, ''));

        if (pathHasInvalidWinCharacters) {
          const error = new Error(`Path contains invalid characters: ${pth}`);
          error.code = 'EINVAL';
          throw error
        }
      }
    };

    const fs$l = fs$n;
    const { checkPath } = utils$4;

    const getMode = options => {
      const defaults = { mode: 0o777 };
      if (typeof options === 'number') return options
      return ({ ...defaults, ...options }).mode
    };

    makeDir$1.makeDir = async (dir, options) => {
      checkPath(dir);

      return fs$l.mkdir(dir, {
        mode: getMode(options),
        recursive: true
      })
    };

    makeDir$1.makeDirSync = (dir, options) => {
      checkPath(dir);

      return fs$l.mkdirSync(dir, {
        mode: getMode(options),
        recursive: true
      })
    };

    const u$a = universalify$1.fromPromise;
    const { makeDir: _makeDir, makeDirSync } = makeDir$1;
    const makeDir = u$a(_makeDir);

    var mkdirs$2 = {
      mkdirs: makeDir,
      mkdirsSync: makeDirSync,
      // alias
      mkdirp: makeDir,
      mkdirpSync: makeDirSync,
      ensureDir: makeDir,
      ensureDirSync: makeDirSync
    };

    const fs$k = gracefulFs;

    function utimesMillis$1 (path, atime, mtime, callback) {
      // if (!HAS_MILLIS_RES) return fs.utimes(path, atime, mtime, callback)
      fs$k.open(path, 'r+', (err, fd) => {
        if (err) return callback(err)
        fs$k.futimes(fd, atime, mtime, futimesErr => {
          fs$k.close(fd, closeErr => {
            if (callback) callback(futimesErr || closeErr);
          });
        });
      });
    }

    function utimesMillisSync$1 (path, atime, mtime) {
      const fd = fs$k.openSync(path, 'r+');
      fs$k.futimesSync(fd, atime, mtime);
      return fs$k.closeSync(fd)
    }

    var utimes = {
      utimesMillis: utimesMillis$1,
      utimesMillisSync: utimesMillisSync$1
    };

    const fs$j = fs$n;
    const path$g = require$$1__default$1["default"];
    const util$2 = require$$0__default$1["default"];

    function getStats$2 (src, dest, opts) {
      const statFunc = opts.dereference
        ? (file) => fs$j.stat(file, { bigint: true })
        : (file) => fs$j.lstat(file, { bigint: true });
      return Promise.all([
        statFunc(src),
        statFunc(dest).catch(err => {
          if (err.code === 'ENOENT') return null
          throw err
        })
      ]).then(([srcStat, destStat]) => ({ srcStat, destStat }))
    }

    function getStatsSync (src, dest, opts) {
      let destStat;
      const statFunc = opts.dereference
        ? (file) => fs$j.statSync(file, { bigint: true })
        : (file) => fs$j.lstatSync(file, { bigint: true });
      const srcStat = statFunc(src);
      try {
        destStat = statFunc(dest);
      } catch (err) {
        if (err.code === 'ENOENT') return { srcStat, destStat: null }
        throw err
      }
      return { srcStat, destStat }
    }

    function checkPaths (src, dest, funcName, opts, cb) {
      util$2.callbackify(getStats$2)(src, dest, opts, (err, stats) => {
        if (err) return cb(err)
        const { srcStat, destStat } = stats;

        if (destStat) {
          if (areIdentical$2(srcStat, destStat)) {
            const srcBaseName = path$g.basename(src);
            const destBaseName = path$g.basename(dest);
            if (funcName === 'move' &&
              srcBaseName !== destBaseName &&
              srcBaseName.toLowerCase() === destBaseName.toLowerCase()) {
              return cb(null, { srcStat, destStat, isChangingCase: true })
            }
            return cb(new Error('Source and destination must not be the same.'))
          }
          if (srcStat.isDirectory() && !destStat.isDirectory()) {
            return cb(new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`))
          }
          if (!srcStat.isDirectory() && destStat.isDirectory()) {
            return cb(new Error(`Cannot overwrite directory '${dest}' with non-directory '${src}'.`))
          }
        }

        if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {
          return cb(new Error(errMsg(src, dest, funcName)))
        }
        return cb(null, { srcStat, destStat })
      });
    }

    function checkPathsSync (src, dest, funcName, opts) {
      const { srcStat, destStat } = getStatsSync(src, dest, opts);

      if (destStat) {
        if (areIdentical$2(srcStat, destStat)) {
          const srcBaseName = path$g.basename(src);
          const destBaseName = path$g.basename(dest);
          if (funcName === 'move' &&
            srcBaseName !== destBaseName &&
            srcBaseName.toLowerCase() === destBaseName.toLowerCase()) {
            return { srcStat, destStat, isChangingCase: true }
          }
          throw new Error('Source and destination must not be the same.')
        }
        if (srcStat.isDirectory() && !destStat.isDirectory()) {
          throw new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`)
        }
        if (!srcStat.isDirectory() && destStat.isDirectory()) {
          throw new Error(`Cannot overwrite directory '${dest}' with non-directory '${src}'.`)
        }
      }

      if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {
        throw new Error(errMsg(src, dest, funcName))
      }
      return { srcStat, destStat }
    }

    // recursively check if dest parent is a subdirectory of src.
    // It works for all file types including symlinks since it
    // checks the src and dest inodes. It starts from the deepest
    // parent and stops once it reaches the src parent or the root path.
    function checkParentPaths (src, srcStat, dest, funcName, cb) {
      const srcParent = path$g.resolve(path$g.dirname(src));
      const destParent = path$g.resolve(path$g.dirname(dest));
      if (destParent === srcParent || destParent === path$g.parse(destParent).root) return cb()
      fs$j.stat(destParent, { bigint: true }, (err, destStat) => {
        if (err) {
          if (err.code === 'ENOENT') return cb()
          return cb(err)
        }
        if (areIdentical$2(srcStat, destStat)) {
          return cb(new Error(errMsg(src, dest, funcName)))
        }
        return checkParentPaths(src, srcStat, destParent, funcName, cb)
      });
    }

    function checkParentPathsSync (src, srcStat, dest, funcName) {
      const srcParent = path$g.resolve(path$g.dirname(src));
      const destParent = path$g.resolve(path$g.dirname(dest));
      if (destParent === srcParent || destParent === path$g.parse(destParent).root) return
      let destStat;
      try {
        destStat = fs$j.statSync(destParent, { bigint: true });
      } catch (err) {
        if (err.code === 'ENOENT') return
        throw err
      }
      if (areIdentical$2(srcStat, destStat)) {
        throw new Error(errMsg(src, dest, funcName))
      }
      return checkParentPathsSync(src, srcStat, destParent, funcName)
    }

    function areIdentical$2 (srcStat, destStat) {
      return destStat.ino && destStat.dev && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev
    }

    // return true if dest is a subdir of src, otherwise false.
    // It only checks the path strings.
    function isSrcSubdir (src, dest) {
      const srcArr = path$g.resolve(src).split(path$g.sep).filter(i => i);
      const destArr = path$g.resolve(dest).split(path$g.sep).filter(i => i);
      return srcArr.reduce((acc, cur, i) => acc && destArr[i] === cur, true)
    }

    function errMsg (src, dest, funcName) {
      return `Cannot ${funcName} '${src}' to a subdirectory of itself, '${dest}'.`
    }

    var stat$4 = {
      checkPaths,
      checkPathsSync,
      checkParentPaths,
      checkParentPathsSync,
      isSrcSubdir,
      areIdentical: areIdentical$2
    };

    const fs$i = gracefulFs;
    const path$f = require$$1__default$1["default"];
    const mkdirsSync$1 = mkdirs$2.mkdirsSync;
    const utimesMillisSync = utimes.utimesMillisSync;
    const stat$3 = stat$4;

    function copySync$2 (src, dest, opts) {
      if (typeof opts === 'function') {
        opts = { filter: opts };
      }

      opts = opts || {};
      opts.clobber = 'clobber' in opts ? !!opts.clobber : true; // default to true for now
      opts.overwrite = 'overwrite' in opts ? !!opts.overwrite : opts.clobber; // overwrite falls back to clobber

      // Warn about using preserveTimestamps on 32-bit node
      if (opts.preserveTimestamps && process.arch === 'ia32') {
        console.warn(`fs-extra: Using the preserveTimestamps option in 32-bit node is not recommended;\n
    see https://github.com/jprichardson/node-fs-extra/issues/269`);
      }

      const { srcStat, destStat } = stat$3.checkPathsSync(src, dest, 'copy', opts);
      stat$3.checkParentPathsSync(src, srcStat, dest, 'copy');
      return handleFilterAndCopy(destStat, src, dest, opts)
    }

    function handleFilterAndCopy (destStat, src, dest, opts) {
      if (opts.filter && !opts.filter(src, dest)) return
      const destParent = path$f.dirname(dest);
      if (!fs$i.existsSync(destParent)) mkdirsSync$1(destParent);
      return getStats$1(destStat, src, dest, opts)
    }

    function startCopy$1 (destStat, src, dest, opts) {
      if (opts.filter && !opts.filter(src, dest)) return
      return getStats$1(destStat, src, dest, opts)
    }

    function getStats$1 (destStat, src, dest, opts) {
      const statSync = opts.dereference ? fs$i.statSync : fs$i.lstatSync;
      const srcStat = statSync(src);

      if (srcStat.isDirectory()) return onDir$1(srcStat, destStat, src, dest, opts)
      else if (srcStat.isFile() ||
               srcStat.isCharacterDevice() ||
               srcStat.isBlockDevice()) return onFile$1(srcStat, destStat, src, dest, opts)
      else if (srcStat.isSymbolicLink()) return onLink$1(destStat, src, dest, opts)
      else if (srcStat.isSocket()) throw new Error(`Cannot copy a socket file: ${src}`)
      else if (srcStat.isFIFO()) throw new Error(`Cannot copy a FIFO pipe: ${src}`)
      throw new Error(`Unknown file: ${src}`)
    }

    function onFile$1 (srcStat, destStat, src, dest, opts) {
      if (!destStat) return copyFile$1(srcStat, src, dest, opts)
      return mayCopyFile$1(srcStat, src, dest, opts)
    }

    function mayCopyFile$1 (srcStat, src, dest, opts) {
      if (opts.overwrite) {
        fs$i.unlinkSync(dest);
        return copyFile$1(srcStat, src, dest, opts)
      } else if (opts.errorOnExist) {
        throw new Error(`'${dest}' already exists`)
      }
    }

    function copyFile$1 (srcStat, src, dest, opts) {
      fs$i.copyFileSync(src, dest);
      if (opts.preserveTimestamps) handleTimestamps(srcStat.mode, src, dest);
      return setDestMode$1(dest, srcStat.mode)
    }

    function handleTimestamps (srcMode, src, dest) {
      // Make sure the file is writable before setting the timestamp
      // otherwise open fails with EPERM when invoked with 'r+'
      // (through utimes call)
      if (fileIsNotWritable$1(srcMode)) makeFileWritable$1(dest, srcMode);
      return setDestTimestamps$1(src, dest)
    }

    function fileIsNotWritable$1 (srcMode) {
      return (srcMode & 0o200) === 0
    }

    function makeFileWritable$1 (dest, srcMode) {
      return setDestMode$1(dest, srcMode | 0o200)
    }

    function setDestMode$1 (dest, srcMode) {
      return fs$i.chmodSync(dest, srcMode)
    }

    function setDestTimestamps$1 (src, dest) {
      // The initial srcStat.atime cannot be trusted
      // because it is modified by the read(2) system call
      // (See https://nodejs.org/api/fs.html#fs_stat_time_values)
      const updatedSrcStat = fs$i.statSync(src);
      return utimesMillisSync(dest, updatedSrcStat.atime, updatedSrcStat.mtime)
    }

    function onDir$1 (srcStat, destStat, src, dest, opts) {
      if (!destStat) return mkDirAndCopy$1(srcStat.mode, src, dest, opts)
      return copyDir$1(src, dest, opts)
    }

    function mkDirAndCopy$1 (srcMode, src, dest, opts) {
      fs$i.mkdirSync(dest);
      copyDir$1(src, dest, opts);
      return setDestMode$1(dest, srcMode)
    }

    function copyDir$1 (src, dest, opts) {
      fs$i.readdirSync(src).forEach(item => copyDirItem$1(item, src, dest, opts));
    }

    function copyDirItem$1 (item, src, dest, opts) {
      const srcItem = path$f.join(src, item);
      const destItem = path$f.join(dest, item);
      const { destStat } = stat$3.checkPathsSync(srcItem, destItem, 'copy', opts);
      return startCopy$1(destStat, srcItem, destItem, opts)
    }

    function onLink$1 (destStat, src, dest, opts) {
      let resolvedSrc = fs$i.readlinkSync(src);
      if (opts.dereference) {
        resolvedSrc = path$f.resolve(process.cwd(), resolvedSrc);
      }

      if (!destStat) {
        return fs$i.symlinkSync(resolvedSrc, dest)
      } else {
        let resolvedDest;
        try {
          resolvedDest = fs$i.readlinkSync(dest);
        } catch (err) {
          // dest exists and is a regular file or directory,
          // Windows may throw UNKNOWN error. If dest already exists,
          // fs throws error anyway, so no need to guard against it here.
          if (err.code === 'EINVAL' || err.code === 'UNKNOWN') return fs$i.symlinkSync(resolvedSrc, dest)
          throw err
        }
        if (opts.dereference) {
          resolvedDest = path$f.resolve(process.cwd(), resolvedDest);
        }
        if (stat$3.isSrcSubdir(resolvedSrc, resolvedDest)) {
          throw new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`)
        }

        // prevent copy if src is a subdir of dest since unlinking
        // dest in this case would result in removing src contents
        // and therefore a broken symlink would be created.
        if (fs$i.statSync(dest).isDirectory() && stat$3.isSrcSubdir(resolvedDest, resolvedSrc)) {
          throw new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`)
        }
        return copyLink$1(resolvedSrc, dest)
      }
    }

    function copyLink$1 (resolvedSrc, dest) {
      fs$i.unlinkSync(dest);
      return fs$i.symlinkSync(resolvedSrc, dest)
    }

    var copySync_1 = copySync$2;

    var copySync$1 = {
      copySync: copySync_1
    };

    const u$9 = universalify$1.fromPromise;
    const fs$h = fs$n;

    function pathExists$7 (path) {
      return fs$h.access(path).then(() => true).catch(() => false)
    }

    var pathExists_1 = {
      pathExists: u$9(pathExists$7),
      pathExistsSync: fs$h.existsSync
    };

    const fs$g = gracefulFs;
    const path$e = require$$1__default$1["default"];
    const mkdirs$1 = mkdirs$2.mkdirs;
    const pathExists$6 = pathExists_1.pathExists;
    const utimesMillis = utimes.utimesMillis;
    const stat$2 = stat$4;

    function copy$2 (src, dest, opts, cb) {
      if (typeof opts === 'function' && !cb) {
        cb = opts;
        opts = {};
      } else if (typeof opts === 'function') {
        opts = { filter: opts };
      }

      cb = cb || function () {};
      opts = opts || {};

      opts.clobber = 'clobber' in opts ? !!opts.clobber : true; // default to true for now
      opts.overwrite = 'overwrite' in opts ? !!opts.overwrite : opts.clobber; // overwrite falls back to clobber

      // Warn about using preserveTimestamps on 32-bit node
      if (opts.preserveTimestamps && process.arch === 'ia32') {
        console.warn(`fs-extra: Using the preserveTimestamps option in 32-bit node is not recommended;\n
    see https://github.com/jprichardson/node-fs-extra/issues/269`);
      }

      stat$2.checkPaths(src, dest, 'copy', opts, (err, stats) => {
        if (err) return cb(err)
        const { srcStat, destStat } = stats;
        stat$2.checkParentPaths(src, srcStat, dest, 'copy', err => {
          if (err) return cb(err)
          if (opts.filter) return handleFilter(checkParentDir, destStat, src, dest, opts, cb)
          return checkParentDir(destStat, src, dest, opts, cb)
        });
      });
    }

    function checkParentDir (destStat, src, dest, opts, cb) {
      const destParent = path$e.dirname(dest);
      pathExists$6(destParent, (err, dirExists) => {
        if (err) return cb(err)
        if (dirExists) return getStats(destStat, src, dest, opts, cb)
        mkdirs$1(destParent, err => {
          if (err) return cb(err)
          return getStats(destStat, src, dest, opts, cb)
        });
      });
    }

    function handleFilter (onInclude, destStat, src, dest, opts, cb) {
      Promise.resolve(opts.filter(src, dest)).then(include => {
        if (include) return onInclude(destStat, src, dest, opts, cb)
        return cb()
      }, error => cb(error));
    }

    function startCopy (destStat, src, dest, opts, cb) {
      if (opts.filter) return handleFilter(getStats, destStat, src, dest, opts, cb)
      return getStats(destStat, src, dest, opts, cb)
    }

    function getStats (destStat, src, dest, opts, cb) {
      const stat = opts.dereference ? fs$g.stat : fs$g.lstat;
      stat(src, (err, srcStat) => {
        if (err) return cb(err)

        if (srcStat.isDirectory()) return onDir(srcStat, destStat, src, dest, opts, cb)
        else if (srcStat.isFile() ||
                 srcStat.isCharacterDevice() ||
                 srcStat.isBlockDevice()) return onFile(srcStat, destStat, src, dest, opts, cb)
        else if (srcStat.isSymbolicLink()) return onLink(destStat, src, dest, opts, cb)
        else if (srcStat.isSocket()) return cb(new Error(`Cannot copy a socket file: ${src}`))
        else if (srcStat.isFIFO()) return cb(new Error(`Cannot copy a FIFO pipe: ${src}`))
        return cb(new Error(`Unknown file: ${src}`))
      });
    }

    function onFile (srcStat, destStat, src, dest, opts, cb) {
      if (!destStat) return copyFile(srcStat, src, dest, opts, cb)
      return mayCopyFile(srcStat, src, dest, opts, cb)
    }

    function mayCopyFile (srcStat, src, dest, opts, cb) {
      if (opts.overwrite) {
        fs$g.unlink(dest, err => {
          if (err) return cb(err)
          return copyFile(srcStat, src, dest, opts, cb)
        });
      } else if (opts.errorOnExist) {
        return cb(new Error(`'${dest}' already exists`))
      } else return cb()
    }

    function copyFile (srcStat, src, dest, opts, cb) {
      fs$g.copyFile(src, dest, err => {
        if (err) return cb(err)
        if (opts.preserveTimestamps) return handleTimestampsAndMode(srcStat.mode, src, dest, cb)
        return setDestMode(dest, srcStat.mode, cb)
      });
    }

    function handleTimestampsAndMode (srcMode, src, dest, cb) {
      // Make sure the file is writable before setting the timestamp
      // otherwise open fails with EPERM when invoked with 'r+'
      // (through utimes call)
      if (fileIsNotWritable(srcMode)) {
        return makeFileWritable(dest, srcMode, err => {
          if (err) return cb(err)
          return setDestTimestampsAndMode(srcMode, src, dest, cb)
        })
      }
      return setDestTimestampsAndMode(srcMode, src, dest, cb)
    }

    function fileIsNotWritable (srcMode) {
      return (srcMode & 0o200) === 0
    }

    function makeFileWritable (dest, srcMode, cb) {
      return setDestMode(dest, srcMode | 0o200, cb)
    }

    function setDestTimestampsAndMode (srcMode, src, dest, cb) {
      setDestTimestamps(src, dest, err => {
        if (err) return cb(err)
        return setDestMode(dest, srcMode, cb)
      });
    }

    function setDestMode (dest, srcMode, cb) {
      return fs$g.chmod(dest, srcMode, cb)
    }

    function setDestTimestamps (src, dest, cb) {
      // The initial srcStat.atime cannot be trusted
      // because it is modified by the read(2) system call
      // (See https://nodejs.org/api/fs.html#fs_stat_time_values)
      fs$g.stat(src, (err, updatedSrcStat) => {
        if (err) return cb(err)
        return utimesMillis(dest, updatedSrcStat.atime, updatedSrcStat.mtime, cb)
      });
    }

    function onDir (srcStat, destStat, src, dest, opts, cb) {
      if (!destStat) return mkDirAndCopy(srcStat.mode, src, dest, opts, cb)
      return copyDir(src, dest, opts, cb)
    }

    function mkDirAndCopy (srcMode, src, dest, opts, cb) {
      fs$g.mkdir(dest, err => {
        if (err) return cb(err)
        copyDir(src, dest, opts, err => {
          if (err) return cb(err)
          return setDestMode(dest, srcMode, cb)
        });
      });
    }

    function copyDir (src, dest, opts, cb) {
      fs$g.readdir(src, (err, items) => {
        if (err) return cb(err)
        return copyDirItems(items, src, dest, opts, cb)
      });
    }

    function copyDirItems (items, src, dest, opts, cb) {
      const item = items.pop();
      if (!item) return cb()
      return copyDirItem(items, item, src, dest, opts, cb)
    }

    function copyDirItem (items, item, src, dest, opts, cb) {
      const srcItem = path$e.join(src, item);
      const destItem = path$e.join(dest, item);
      stat$2.checkPaths(srcItem, destItem, 'copy', opts, (err, stats) => {
        if (err) return cb(err)
        const { destStat } = stats;
        startCopy(destStat, srcItem, destItem, opts, err => {
          if (err) return cb(err)
          return copyDirItems(items, src, dest, opts, cb)
        });
      });
    }

    function onLink (destStat, src, dest, opts, cb) {
      fs$g.readlink(src, (err, resolvedSrc) => {
        if (err) return cb(err)
        if (opts.dereference) {
          resolvedSrc = path$e.resolve(process.cwd(), resolvedSrc);
        }

        if (!destStat) {
          return fs$g.symlink(resolvedSrc, dest, cb)
        } else {
          fs$g.readlink(dest, (err, resolvedDest) => {
            if (err) {
              // dest exists and is a regular file or directory,
              // Windows may throw UNKNOWN error. If dest already exists,
              // fs throws error anyway, so no need to guard against it here.
              if (err.code === 'EINVAL' || err.code === 'UNKNOWN') return fs$g.symlink(resolvedSrc, dest, cb)
              return cb(err)
            }
            if (opts.dereference) {
              resolvedDest = path$e.resolve(process.cwd(), resolvedDest);
            }
            if (stat$2.isSrcSubdir(resolvedSrc, resolvedDest)) {
              return cb(new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`))
            }

            // do not copy if src is a subdir of dest since unlinking
            // dest in this case would result in removing src contents
            // and therefore a broken symlink would be created.
            if (destStat.isDirectory() && stat$2.isSrcSubdir(resolvedDest, resolvedSrc)) {
              return cb(new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`))
            }
            return copyLink(resolvedSrc, dest, cb)
          });
        }
      });
    }

    function copyLink (resolvedSrc, dest, cb) {
      fs$g.unlink(dest, err => {
        if (err) return cb(err)
        return fs$g.symlink(resolvedSrc, dest, cb)
      });
    }

    var copy_1 = copy$2;

    const u$8 = universalify$1.fromCallback;
    var copy$1 = {
      copy: u$8(copy_1)
    };

    const fs$f = gracefulFs;
    const path$d = require$$1__default$1["default"];
    const assert$3 = require$$5__default["default"];

    const isWindows$2 = (process.platform === 'win32');

    function defaults$3 (options) {
      const methods = [
        'unlink',
        'chmod',
        'stat',
        'lstat',
        'rmdir',
        'readdir'
      ];
      methods.forEach(m => {
        options[m] = options[m] || fs$f[m];
        m = m + 'Sync';
        options[m] = options[m] || fs$f[m];
      });

      options.maxBusyTries = options.maxBusyTries || 3;
    }

    function rimraf$1 (p, options, cb) {
      let busyTries = 0;

      if (typeof options === 'function') {
        cb = options;
        options = {};
      }

      assert$3(p, 'rimraf: missing path');
      assert$3.strictEqual(typeof p, 'string', 'rimraf: path should be a string');
      assert$3.strictEqual(typeof cb, 'function', 'rimraf: callback function required');
      assert$3(options, 'rimraf: invalid options argument provided');
      assert$3.strictEqual(typeof options, 'object', 'rimraf: options should be object');

      defaults$3(options);

      rimraf_(p, options, function CB (er) {
        if (er) {
          if ((er.code === 'EBUSY' || er.code === 'ENOTEMPTY' || er.code === 'EPERM') &&
              busyTries < options.maxBusyTries) {
            busyTries++;
            const time = busyTries * 100;
            // try again, with the same exact callback as this one.
            return setTimeout(() => rimraf_(p, options, CB), time)
          }

          // already gone
          if (er.code === 'ENOENT') er = null;
        }

        cb(er);
      });
    }

    // Two possible strategies.
    // 1. Assume it's a file.  unlink it, then do the dir stuff on EPERM or EISDIR
    // 2. Assume it's a directory.  readdir, then do the file stuff on ENOTDIR
    //
    // Both result in an extra syscall when you guess wrong.  However, there
    // are likely far more normal files in the world than directories.  This
    // is based on the assumption that a the average number of files per
    // directory is >= 1.
    //
    // If anyone ever complains about this, then I guess the strategy could
    // be made configurable somehow.  But until then, YAGNI.
    function rimraf_ (p, options, cb) {
      assert$3(p);
      assert$3(options);
      assert$3(typeof cb === 'function');

      // sunos lets the root user unlink directories, which is... weird.
      // so we have to lstat here and make sure it's not a dir.
      options.lstat(p, (er, st) => {
        if (er && er.code === 'ENOENT') {
          return cb(null)
        }

        // Windows can EPERM on stat.  Life is suffering.
        if (er && er.code === 'EPERM' && isWindows$2) {
          return fixWinEPERM(p, options, er, cb)
        }

        if (st && st.isDirectory()) {
          return rmdir(p, options, er, cb)
        }

        options.unlink(p, er => {
          if (er) {
            if (er.code === 'ENOENT') {
              return cb(null)
            }
            if (er.code === 'EPERM') {
              return (isWindows$2)
                ? fixWinEPERM(p, options, er, cb)
                : rmdir(p, options, er, cb)
            }
            if (er.code === 'EISDIR') {
              return rmdir(p, options, er, cb)
            }
          }
          return cb(er)
        });
      });
    }

    function fixWinEPERM (p, options, er, cb) {
      assert$3(p);
      assert$3(options);
      assert$3(typeof cb === 'function');

      options.chmod(p, 0o666, er2 => {
        if (er2) {
          cb(er2.code === 'ENOENT' ? null : er);
        } else {
          options.stat(p, (er3, stats) => {
            if (er3) {
              cb(er3.code === 'ENOENT' ? null : er);
            } else if (stats.isDirectory()) {
              rmdir(p, options, er, cb);
            } else {
              options.unlink(p, cb);
            }
          });
        }
      });
    }

    function fixWinEPERMSync (p, options, er) {
      let stats;

      assert$3(p);
      assert$3(options);

      try {
        options.chmodSync(p, 0o666);
      } catch (er2) {
        if (er2.code === 'ENOENT') {
          return
        } else {
          throw er
        }
      }

      try {
        stats = options.statSync(p);
      } catch (er3) {
        if (er3.code === 'ENOENT') {
          return
        } else {
          throw er
        }
      }

      if (stats.isDirectory()) {
        rmdirSync(p, options, er);
      } else {
        options.unlinkSync(p);
      }
    }

    function rmdir (p, options, originalEr, cb) {
      assert$3(p);
      assert$3(options);
      assert$3(typeof cb === 'function');

      // try to rmdir first, and only readdir on ENOTEMPTY or EEXIST (SunOS)
      // if we guessed wrong, and it's not a directory, then
      // raise the original error.
      options.rmdir(p, er => {
        if (er && (er.code === 'ENOTEMPTY' || er.code === 'EEXIST' || er.code === 'EPERM')) {
          rmkids(p, options, cb);
        } else if (er && er.code === 'ENOTDIR') {
          cb(originalEr);
        } else {
          cb(er);
        }
      });
    }

    function rmkids (p, options, cb) {
      assert$3(p);
      assert$3(options);
      assert$3(typeof cb === 'function');

      options.readdir(p, (er, files) => {
        if (er) return cb(er)

        let n = files.length;
        let errState;

        if (n === 0) return options.rmdir(p, cb)

        files.forEach(f => {
          rimraf$1(path$d.join(p, f), options, er => {
            if (errState) {
              return
            }
            if (er) return cb(errState = er)
            if (--n === 0) {
              options.rmdir(p, cb);
            }
          });
        });
      });
    }

    // this looks simpler, and is strictly *faster*, but will
    // tie up the JavaScript thread and fail on excessively
    // deep directory trees.
    function rimrafSync (p, options) {
      let st;

      options = options || {};
      defaults$3(options);

      assert$3(p, 'rimraf: missing path');
      assert$3.strictEqual(typeof p, 'string', 'rimraf: path should be a string');
      assert$3(options, 'rimraf: missing options');
      assert$3.strictEqual(typeof options, 'object', 'rimraf: options should be object');

      try {
        st = options.lstatSync(p);
      } catch (er) {
        if (er.code === 'ENOENT') {
          return
        }

        // Windows can EPERM on stat.  Life is suffering.
        if (er.code === 'EPERM' && isWindows$2) {
          fixWinEPERMSync(p, options, er);
        }
      }

      try {
        // sunos lets the root user unlink directories, which is... weird.
        if (st && st.isDirectory()) {
          rmdirSync(p, options, null);
        } else {
          options.unlinkSync(p);
        }
      } catch (er) {
        if (er.code === 'ENOENT') {
          return
        } else if (er.code === 'EPERM') {
          return isWindows$2 ? fixWinEPERMSync(p, options, er) : rmdirSync(p, options, er)
        } else if (er.code !== 'EISDIR') {
          throw er
        }
        rmdirSync(p, options, er);
      }
    }

    function rmdirSync (p, options, originalEr) {
      assert$3(p);
      assert$3(options);

      try {
        options.rmdirSync(p);
      } catch (er) {
        if (er.code === 'ENOTDIR') {
          throw originalEr
        } else if (er.code === 'ENOTEMPTY' || er.code === 'EEXIST' || er.code === 'EPERM') {
          rmkidsSync(p, options);
        } else if (er.code !== 'ENOENT') {
          throw er
        }
      }
    }

    function rmkidsSync (p, options) {
      assert$3(p);
      assert$3(options);
      options.readdirSync(p).forEach(f => rimrafSync(path$d.join(p, f), options));

      if (isWindows$2) {
        // We only end up here once we got ENOTEMPTY at least once, and
        // at this point, we are guaranteed to have removed all the kids.
        // So, we know that it won't be ENOENT or ENOTDIR or anything else.
        // try really hard to delete stuff on windows, because it has a
        // PROFOUNDLY annoying habit of not closing handles promptly when
        // files are deleted, resulting in spurious ENOTEMPTY errors.
        const startTime = Date.now();
        do {
          try {
            const ret = options.rmdirSync(p, options);
            return ret
          } catch {}
        } while (Date.now() - startTime < 500) // give up after 500ms
      } else {
        const ret = options.rmdirSync(p, options);
        return ret
      }
    }

    var rimraf_1 = rimraf$1;
    rimraf$1.sync = rimrafSync;

    const fs$e = gracefulFs;
    const u$7 = universalify$1.fromCallback;
    const rimraf = rimraf_1;

    function remove$2 (path, callback) {
      // Node 14.14.0+
      if (fs$e.rm) return fs$e.rm(path, { recursive: true, force: true }, callback)
      rimraf(path, callback);
    }

    function removeSync$1 (path) {
      // Node 14.14.0+
      if (fs$e.rmSync) return fs$e.rmSync(path, { recursive: true, force: true })
      rimraf.sync(path);
    }

    var remove_1 = {
      remove: u$7(remove$2),
      removeSync: removeSync$1
    };

    const u$6 = universalify$1.fromPromise;
    const fs$d = fs$n;
    const path$c = require$$1__default$1["default"];
    const mkdir$3 = mkdirs$2;
    const remove$1 = remove_1;

    const emptyDir = u$6(async function emptyDir (dir) {
      let items;
      try {
        items = await fs$d.readdir(dir);
      } catch {
        return mkdir$3.mkdirs(dir)
      }

      return Promise.all(items.map(item => remove$1.remove(path$c.join(dir, item))))
    });

    function emptyDirSync (dir) {
      let items;
      try {
        items = fs$d.readdirSync(dir);
      } catch {
        return mkdir$3.mkdirsSync(dir)
      }

      items.forEach(item => {
        item = path$c.join(dir, item);
        remove$1.removeSync(item);
      });
    }

    var empty$2 = {
      emptyDirSync,
      emptydirSync: emptyDirSync,
      emptyDir,
      emptydir: emptyDir
    };

    const u$5 = universalify$1.fromCallback;
    const path$b = require$$1__default$1["default"];
    const fs$c = gracefulFs;
    const mkdir$2 = mkdirs$2;

    function createFile (file, callback) {
      function makeFile () {
        fs$c.writeFile(file, '', err => {
          if (err) return callback(err)
          callback();
        });
      }

      fs$c.stat(file, (err, stats) => { // eslint-disable-line handle-callback-err
        if (!err && stats.isFile()) return callback()
        const dir = path$b.dirname(file);
        fs$c.stat(dir, (err, stats) => {
          if (err) {
            // if the directory doesn't exist, make it
            if (err.code === 'ENOENT') {
              return mkdir$2.mkdirs(dir, err => {
                if (err) return callback(err)
                makeFile();
              })
            }
            return callback(err)
          }

          if (stats.isDirectory()) makeFile();
          else {
            // parent is not a directory
            // This is just to cause an internal ENOTDIR error to be thrown
            fs$c.readdir(dir, err => {
              if (err) return callback(err)
            });
          }
        });
      });
    }

    function createFileSync (file) {
      let stats;
      try {
        stats = fs$c.statSync(file);
      } catch {}
      if (stats && stats.isFile()) return

      const dir = path$b.dirname(file);
      try {
        if (!fs$c.statSync(dir).isDirectory()) {
          // parent is not a directory
          // This is just to cause an internal ENOTDIR error to be thrown
          fs$c.readdirSync(dir);
        }
      } catch (err) {
        // If the stat call above failed because the directory doesn't exist, create it
        if (err && err.code === 'ENOENT') mkdir$2.mkdirsSync(dir);
        else throw err
      }

      fs$c.writeFileSync(file, '');
    }

    var file$2 = {
      createFile: u$5(createFile),
      createFileSync
    };

    const u$4 = universalify$1.fromCallback;
    const path$a = require$$1__default$1["default"];
    const fs$b = gracefulFs;
    const mkdir$1 = mkdirs$2;
    const pathExists$5 = pathExists_1.pathExists;
    const { areIdentical: areIdentical$1 } = stat$4;

    function createLink (srcpath, dstpath, callback) {
      function makeLink (srcpath, dstpath) {
        fs$b.link(srcpath, dstpath, err => {
          if (err) return callback(err)
          callback(null);
        });
      }

      fs$b.lstat(dstpath, (_, dstStat) => {
        fs$b.lstat(srcpath, (err, srcStat) => {
          if (err) {
            err.message = err.message.replace('lstat', 'ensureLink');
            return callback(err)
          }
          if (dstStat && areIdentical$1(srcStat, dstStat)) return callback(null)

          const dir = path$a.dirname(dstpath);
          pathExists$5(dir, (err, dirExists) => {
            if (err) return callback(err)
            if (dirExists) return makeLink(srcpath, dstpath)
            mkdir$1.mkdirs(dir, err => {
              if (err) return callback(err)
              makeLink(srcpath, dstpath);
            });
          });
        });
      });
    }

    function createLinkSync (srcpath, dstpath) {
      let dstStat;
      try {
        dstStat = fs$b.lstatSync(dstpath);
      } catch {}

      try {
        const srcStat = fs$b.lstatSync(srcpath);
        if (dstStat && areIdentical$1(srcStat, dstStat)) return
      } catch (err) {
        err.message = err.message.replace('lstat', 'ensureLink');
        throw err
      }

      const dir = path$a.dirname(dstpath);
      const dirExists = fs$b.existsSync(dir);
      if (dirExists) return fs$b.linkSync(srcpath, dstpath)
      mkdir$1.mkdirsSync(dir);

      return fs$b.linkSync(srcpath, dstpath)
    }

    var link$2 = {
      createLink: u$4(createLink),
      createLinkSync
    };

    const path$9 = require$$1__default$1["default"];
    const fs$a = gracefulFs;
    const pathExists$4 = pathExists_1.pathExists;

    /**
     * Function that returns two types of paths, one relative to symlink, and one
     * relative to the current working directory. Checks if path is absolute or
     * relative. If the path is relative, this function checks if the path is
     * relative to symlink or relative to current working directory. This is an
     * initiative to find a smarter `srcpath` to supply when building symlinks.
     * This allows you to determine which path to use out of one of three possible
     * types of source paths. The first is an absolute path. This is detected by
     * `path.isAbsolute()`. When an absolute path is provided, it is checked to
     * see if it exists. If it does it's used, if not an error is returned
     * (callback)/ thrown (sync). The other two options for `srcpath` are a
     * relative url. By default Node's `fs.symlink` works by creating a symlink
     * using `dstpath` and expects the `srcpath` to be relative to the newly
     * created symlink. If you provide a `srcpath` that does not exist on the file
     * system it results in a broken symlink. To minimize this, the function
     * checks to see if the 'relative to symlink' source file exists, and if it
     * does it will use it. If it does not, it checks if there's a file that
     * exists that is relative to the current working directory, if does its used.
     * This preserves the expectations of the original fs.symlink spec and adds
     * the ability to pass in `relative to current working direcotry` paths.
     */

    function symlinkPaths$1 (srcpath, dstpath, callback) {
      if (path$9.isAbsolute(srcpath)) {
        return fs$a.lstat(srcpath, (err) => {
          if (err) {
            err.message = err.message.replace('lstat', 'ensureSymlink');
            return callback(err)
          }
          return callback(null, {
            toCwd: srcpath,
            toDst: srcpath
          })
        })
      } else {
        const dstdir = path$9.dirname(dstpath);
        const relativeToDst = path$9.join(dstdir, srcpath);
        return pathExists$4(relativeToDst, (err, exists) => {
          if (err) return callback(err)
          if (exists) {
            return callback(null, {
              toCwd: relativeToDst,
              toDst: srcpath
            })
          } else {
            return fs$a.lstat(srcpath, (err) => {
              if (err) {
                err.message = err.message.replace('lstat', 'ensureSymlink');
                return callback(err)
              }
              return callback(null, {
                toCwd: srcpath,
                toDst: path$9.relative(dstdir, srcpath)
              })
            })
          }
        })
      }
    }

    function symlinkPathsSync$1 (srcpath, dstpath) {
      let exists;
      if (path$9.isAbsolute(srcpath)) {
        exists = fs$a.existsSync(srcpath);
        if (!exists) throw new Error('absolute srcpath does not exist')
        return {
          toCwd: srcpath,
          toDst: srcpath
        }
      } else {
        const dstdir = path$9.dirname(dstpath);
        const relativeToDst = path$9.join(dstdir, srcpath);
        exists = fs$a.existsSync(relativeToDst);
        if (exists) {
          return {
            toCwd: relativeToDst,
            toDst: srcpath
          }
        } else {
          exists = fs$a.existsSync(srcpath);
          if (!exists) throw new Error('relative srcpath does not exist')
          return {
            toCwd: srcpath,
            toDst: path$9.relative(dstdir, srcpath)
          }
        }
      }
    }

    var symlinkPaths_1 = {
      symlinkPaths: symlinkPaths$1,
      symlinkPathsSync: symlinkPathsSync$1
    };

    const fs$9 = gracefulFs;

    function symlinkType$1 (srcpath, type, callback) {
      callback = (typeof type === 'function') ? type : callback;
      type = (typeof type === 'function') ? false : type;
      if (type) return callback(null, type)
      fs$9.lstat(srcpath, (err, stats) => {
        if (err) return callback(null, 'file')
        type = (stats && stats.isDirectory()) ? 'dir' : 'file';
        callback(null, type);
      });
    }

    function symlinkTypeSync$1 (srcpath, type) {
      let stats;

      if (type) return type
      try {
        stats = fs$9.lstatSync(srcpath);
      } catch {
        return 'file'
      }
      return (stats && stats.isDirectory()) ? 'dir' : 'file'
    }

    var symlinkType_1 = {
      symlinkType: symlinkType$1,
      symlinkTypeSync: symlinkTypeSync$1
    };

    const u$3 = universalify$1.fromCallback;
    const path$8 = require$$1__default$1["default"];
    const fs$8 = fs$n;
    const _mkdirs = mkdirs$2;
    const mkdirs = _mkdirs.mkdirs;
    const mkdirsSync = _mkdirs.mkdirsSync;

    const _symlinkPaths = symlinkPaths_1;
    const symlinkPaths = _symlinkPaths.symlinkPaths;
    const symlinkPathsSync = _symlinkPaths.symlinkPathsSync;

    const _symlinkType = symlinkType_1;
    const symlinkType = _symlinkType.symlinkType;
    const symlinkTypeSync = _symlinkType.symlinkTypeSync;

    const pathExists$3 = pathExists_1.pathExists;

    const { areIdentical } = stat$4;

    function createSymlink (srcpath, dstpath, type, callback) {
      callback = (typeof type === 'function') ? type : callback;
      type = (typeof type === 'function') ? false : type;

      fs$8.lstat(dstpath, (err, stats) => {
        if (!err && stats.isSymbolicLink()) {
          Promise.all([
            fs$8.stat(srcpath),
            fs$8.stat(dstpath)
          ]).then(([srcStat, dstStat]) => {
            if (areIdentical(srcStat, dstStat)) return callback(null)
            _createSymlink(srcpath, dstpath, type, callback);
          });
        } else _createSymlink(srcpath, dstpath, type, callback);
      });
    }

    function _createSymlink (srcpath, dstpath, type, callback) {
      symlinkPaths(srcpath, dstpath, (err, relative) => {
        if (err) return callback(err)
        srcpath = relative.toDst;
        symlinkType(relative.toCwd, type, (err, type) => {
          if (err) return callback(err)
          const dir = path$8.dirname(dstpath);
          pathExists$3(dir, (err, dirExists) => {
            if (err) return callback(err)
            if (dirExists) return fs$8.symlink(srcpath, dstpath, type, callback)
            mkdirs(dir, err => {
              if (err) return callback(err)
              fs$8.symlink(srcpath, dstpath, type, callback);
            });
          });
        });
      });
    }

    function createSymlinkSync (srcpath, dstpath, type) {
      let stats;
      try {
        stats = fs$8.lstatSync(dstpath);
      } catch {}
      if (stats && stats.isSymbolicLink()) {
        const srcStat = fs$8.statSync(srcpath);
        const dstStat = fs$8.statSync(dstpath);
        if (areIdentical(srcStat, dstStat)) return
      }

      const relative = symlinkPathsSync(srcpath, dstpath);
      srcpath = relative.toDst;
      type = symlinkTypeSync(relative.toCwd, type);
      const dir = path$8.dirname(dstpath);
      const exists = fs$8.existsSync(dir);
      if (exists) return fs$8.symlinkSync(srcpath, dstpath, type)
      mkdirsSync(dir);
      return fs$8.symlinkSync(srcpath, dstpath, type)
    }

    var symlink$1 = {
      createSymlink: u$3(createSymlink),
      createSymlinkSync
    };

    const file$1 = file$2;
    const link$1 = link$2;
    const symlink = symlink$1;

    var ensure = {
      // file
      createFile: file$1.createFile,
      createFileSync: file$1.createFileSync,
      ensureFile: file$1.createFile,
      ensureFileSync: file$1.createFileSync,
      // link
      createLink: link$1.createLink,
      createLinkSync: link$1.createLinkSync,
      ensureLink: link$1.createLink,
      ensureLinkSync: link$1.createLinkSync,
      // symlink
      createSymlink: symlink.createSymlink,
      createSymlinkSync: symlink.createSymlinkSync,
      ensureSymlink: symlink.createSymlink,
      ensureSymlinkSync: symlink.createSymlinkSync
    };

    function stringify$3 (obj, { EOL = '\n', finalEOL = true, replacer = null, spaces } = {}) {
      const EOF = finalEOL ? EOL : '';
      const str = JSON.stringify(obj, replacer, spaces);

      return str.replace(/\n/g, EOL) + EOF
    }

    function stripBom$1 (content) {
      // we do this because JSON.parse would convert it to a utf8 string if encoding wasn't specified
      if (Buffer.isBuffer(content)) content = content.toString('utf8');
      return content.replace(/^\uFEFF/, '')
    }

    var utils$3 = { stringify: stringify$3, stripBom: stripBom$1 };

    let _fs;
    try {
      _fs = require('graceful-fs');
    } catch (_) {
      _fs = require$$0__default$6["default"];
    }
    const universalify = universalify$1;
    const { stringify: stringify$2, stripBom } = utils$3;

    async function _readFile (file, options = {}) {
      if (typeof options === 'string') {
        options = { encoding: options };
      }

      const fs = options.fs || _fs;

      const shouldThrow = 'throws' in options ? options.throws : true;

      let data = await universalify.fromCallback(fs.readFile)(file, options);

      data = stripBom(data);

      let obj;
      try {
        obj = JSON.parse(data, options ? options.reviver : null);
      } catch (err) {
        if (shouldThrow) {
          err.message = `${file}: ${err.message}`;
          throw err
        } else {
          return null
        }
      }

      return obj
    }

    const readFile = universalify.fromPromise(_readFile);

    function readFileSync (file, options = {}) {
      if (typeof options === 'string') {
        options = { encoding: options };
      }

      const fs = options.fs || _fs;

      const shouldThrow = 'throws' in options ? options.throws : true;

      try {
        let content = fs.readFileSync(file, options);
        content = stripBom(content);
        return JSON.parse(content, options.reviver)
      } catch (err) {
        if (shouldThrow) {
          err.message = `${file}: ${err.message}`;
          throw err
        } else {
          return null
        }
      }
    }

    async function _writeFile (file, obj, options = {}) {
      const fs = options.fs || _fs;

      const str = stringify$2(obj, options);

      await universalify.fromCallback(fs.writeFile)(file, str, options);
    }

    const writeFile = universalify.fromPromise(_writeFile);

    function writeFileSync (file, obj, options = {}) {
      const fs = options.fs || _fs;

      const str = stringify$2(obj, options);
      // not sure if fs.writeFileSync returns anything, but just in case
      return fs.writeFileSync(file, str, options)
    }

    const jsonfile$1 = {
      readFile,
      readFileSync,
      writeFile,
      writeFileSync
    };

    var jsonfile_1 = jsonfile$1;

    const jsonFile$1 = jsonfile_1;

    var jsonfile = {
      // jsonfile exports
      readJson: jsonFile$1.readFile,
      readJsonSync: jsonFile$1.readFileSync,
      writeJson: jsonFile$1.writeFile,
      writeJsonSync: jsonFile$1.writeFileSync
    };

    const u$2 = universalify$1.fromCallback;
    const fs$7 = gracefulFs;
    const path$7 = require$$1__default$1["default"];
    const mkdir = mkdirs$2;
    const pathExists$2 = pathExists_1.pathExists;

    function outputFile$1 (file, data, encoding, callback) {
      if (typeof encoding === 'function') {
        callback = encoding;
        encoding = 'utf8';
      }

      const dir = path$7.dirname(file);
      pathExists$2(dir, (err, itDoes) => {
        if (err) return callback(err)
        if (itDoes) return fs$7.writeFile(file, data, encoding, callback)

        mkdir.mkdirs(dir, err => {
          if (err) return callback(err)

          fs$7.writeFile(file, data, encoding, callback);
        });
      });
    }

    function outputFileSync$1 (file, ...args) {
      const dir = path$7.dirname(file);
      if (fs$7.existsSync(dir)) {
        return fs$7.writeFileSync(file, ...args)
      }
      mkdir.mkdirsSync(dir);
      fs$7.writeFileSync(file, ...args);
    }

    var output = {
      outputFile: u$2(outputFile$1),
      outputFileSync: outputFileSync$1
    };

    const { stringify: stringify$1 } = utils$3;
    const { outputFile } = output;

    async function outputJson (file, data, options = {}) {
      const str = stringify$1(data, options);

      await outputFile(file, str, options);
    }

    var outputJson_1 = outputJson;

    const { stringify } = utils$3;
    const { outputFileSync } = output;

    function outputJsonSync (file, data, options) {
      const str = stringify(data, options);

      outputFileSync(file, str, options);
    }

    var outputJsonSync_1 = outputJsonSync;

    const u$1 = universalify$1.fromPromise;
    const jsonFile = jsonfile;

    jsonFile.outputJson = u$1(outputJson_1);
    jsonFile.outputJsonSync = outputJsonSync_1;
    // aliases
    jsonFile.outputJSON = jsonFile.outputJson;
    jsonFile.outputJSONSync = jsonFile.outputJsonSync;
    jsonFile.writeJSON = jsonFile.writeJson;
    jsonFile.writeJSONSync = jsonFile.writeJsonSync;
    jsonFile.readJSON = jsonFile.readJson;
    jsonFile.readJSONSync = jsonFile.readJsonSync;

    var json = jsonFile;

    const fs$6 = gracefulFs;
    const path$6 = require$$1__default$1["default"];
    const copySync = copySync$1.copySync;
    const removeSync = remove_1.removeSync;
    const mkdirpSync = mkdirs$2.mkdirpSync;
    const stat$1 = stat$4;

    function moveSync$1 (src, dest, opts) {
      opts = opts || {};
      const overwrite = opts.overwrite || opts.clobber || false;

      const { srcStat, isChangingCase = false } = stat$1.checkPathsSync(src, dest, 'move', opts);
      stat$1.checkParentPathsSync(src, srcStat, dest, 'move');
      if (!isParentRoot$1(dest)) mkdirpSync(path$6.dirname(dest));
      return doRename$1(src, dest, overwrite, isChangingCase)
    }

    function isParentRoot$1 (dest) {
      const parent = path$6.dirname(dest);
      const parsedPath = path$6.parse(parent);
      return parsedPath.root === parent
    }

    function doRename$1 (src, dest, overwrite, isChangingCase) {
      if (isChangingCase) return rename$1(src, dest, overwrite)
      if (overwrite) {
        removeSync(dest);
        return rename$1(src, dest, overwrite)
      }
      if (fs$6.existsSync(dest)) throw new Error('dest already exists.')
      return rename$1(src, dest, overwrite)
    }

    function rename$1 (src, dest, overwrite) {
      try {
        fs$6.renameSync(src, dest);
      } catch (err) {
        if (err.code !== 'EXDEV') throw err
        return moveAcrossDevice$1(src, dest, overwrite)
      }
    }

    function moveAcrossDevice$1 (src, dest, overwrite) {
      const opts = {
        overwrite,
        errorOnExist: true
      };
      copySync(src, dest, opts);
      return removeSync(src)
    }

    var moveSync_1 = moveSync$1;

    var moveSync = {
      moveSync: moveSync_1
    };

    const fs$5 = gracefulFs;
    const path$5 = require$$1__default$1["default"];
    const copy = copy$1.copy;
    const remove = remove_1.remove;
    const mkdirp = mkdirs$2.mkdirp;
    const pathExists$1 = pathExists_1.pathExists;
    const stat = stat$4;

    function move$1 (src, dest, opts, cb) {
      if (typeof opts === 'function') {
        cb = opts;
        opts = {};
      }

      const overwrite = opts.overwrite || opts.clobber || false;

      stat.checkPaths(src, dest, 'move', opts, (err, stats) => {
        if (err) return cb(err)
        const { srcStat, isChangingCase = false } = stats;
        stat.checkParentPaths(src, srcStat, dest, 'move', err => {
          if (err) return cb(err)
          if (isParentRoot(dest)) return doRename(src, dest, overwrite, isChangingCase, cb)
          mkdirp(path$5.dirname(dest), err => {
            if (err) return cb(err)
            return doRename(src, dest, overwrite, isChangingCase, cb)
          });
        });
      });
    }

    function isParentRoot (dest) {
      const parent = path$5.dirname(dest);
      const parsedPath = path$5.parse(parent);
      return parsedPath.root === parent
    }

    function doRename (src, dest, overwrite, isChangingCase, cb) {
      if (isChangingCase) return rename(src, dest, overwrite, cb)
      if (overwrite) {
        return remove(dest, err => {
          if (err) return cb(err)
          return rename(src, dest, overwrite, cb)
        })
      }
      pathExists$1(dest, (err, destExists) => {
        if (err) return cb(err)
        if (destExists) return cb(new Error('dest already exists.'))
        return rename(src, dest, overwrite, cb)
      });
    }

    function rename (src, dest, overwrite, cb) {
      fs$5.rename(src, dest, err => {
        if (!err) return cb()
        if (err.code !== 'EXDEV') return cb(err)
        return moveAcrossDevice(src, dest, overwrite, cb)
      });
    }

    function moveAcrossDevice (src, dest, overwrite, cb) {
      const opts = {
        overwrite,
        errorOnExist: true
      };
      copy(src, dest, opts, err => {
        if (err) return cb(err)
        return remove(src, cb)
      });
    }

    var move_1 = move$1;

    const u = universalify$1.fromCallback;
    var move = {
      move: u(move_1)
    };

    var lib$1 = {
      // Export promiseified graceful-fs:
      ...fs$n,
      // Export extra methods:
      ...copySync$1,
      ...copy$1,
      ...empty$2,
      ...ensure,
      ...json,
      ...mkdirs$2,
      ...moveSync,
      ...move,
      ...output,
      ...pathExists_1,
      ...remove_1
    };

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */

    function __awaiter$1(thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }

    const npminstall = require('npminstall');
    const pathExists = _pathExists.sync;
    class Package {
        constructor(options) {
            if (!options) {
                throw new Error('Package  options ');
            }
            if (!isObject$a(options)) {
                throw new Error('Package  options ');
            }
            this.targetPath = options.targetPath;
            this.storeDir = options.storeDir;
            this.packageName = options.packageName;
            this.packageVersion = options.packageVersion;
            this.cacheFilePathPrefix = this.packageName.replace('/', '_');
        }
        exists() {
            return __awaiter$1(this, void 0, void 0, function* () {
                if (this.storeDir) {
                    yield this.prepare();
                    return pathExists(this.cacheFilePath);
                }
                else {
                    return pathExists(this.targetPath);
                }
            });
        }
        prepare() {
            return __awaiter$1(this, void 0, void 0, function* () {
                if (this.storeDir && !pathExists(this.storeDir)) {
                    lib$1.mkdirpSync(this.storeDir);
                }
                if (this.packageVersion === 'latest') {
                    this.packageVersion = yield getNpmInfo$1.getNpmLatestVersion(this.packageName);
                }
            });
        }
        getSpecificCacheFilePath(packageVersion) {
            return require$$1__default$1["default"].resolve(this.storeDir, `_${this.cacheFilePathPrefix}@${packageVersion}@${this.packageName}`);
        }
        install() {
            return npminstall({
                root: this.targetPath,
                storeDir: this.storeDir,
                registry: getNpmInfo$1.getDefaultRegistry(),
                pkgs: [
                    { name: this.packageName, version: this.packageVersion }
                ]
            });
        }
        update() {
            return __awaiter$1(this, void 0, void 0, function* () {
                yield this.prepare();
                const latestPackageVersion = yield getNpmInfo$1.getNpmLatestVersion(this.packageName);
                const latestFilePath = this.getSpecificCacheFilePath(latestPackageVersion);
                if (!pathExists(latestFilePath)) {
                    yield npminstall({
                        root: this.targetPath,
                        storeDir: this.storeDir,
                        registry: getNpmInfo$1.getDefaultRegistry(),
                        pkgs: [
                            { name: this.packageName, version: latestPackageVersion }
                        ]
                    });
                    this.packageVersion = latestPackageVersion;
                }
                else {
                    this.packageVersion = latestPackageVersion;
                }
            });
        }
        get cacheFilePath() {
            return require$$1__default$1["default"].resolve(this.storeDir, `_${this.cacheFilePathPrefix}@${this.packageVersion}@${this.packageName}`);
        }
        _getRootFilePath(targetPath) {
            const dir = pkgDir$1.sync(targetPath);
            if (dir) {
                const pkgFile = require(require$$1__default$1["default"].resolve(dir, 'package.json'));
                if (pkgFile && pkgFile.main) {
                    return require$$1__default$1["default"].resolve(dir, pkgFile.main);
                }
            }
            return null;
        }
        getRootFilePath() {
            if (this.storeDir) {
                return this._getRootFilePath(this.cacheFilePath);
            }
            else {
                return this._getRootFilePath(this.targetPath);
            }
        }
    }

    const LOWEST_NODE_VERSION = '12.0.0';
    class Command {
        constructor(argv) {
            this._cmd = '';
            if (!argv) {
                throw new Error('');
            }
            if (!Array.isArray(argv)) {
                throw new Error('');
            }
            if (argv.length < 1) {
                throw new Error('');
            }
            this._argv = argv;
            new Promise((resolve, reject) => {
                let chain = Promise.resolve();
                chain = chain.then(() => { this.checkNodeVersion(); });
                chain = chain.then(() => this.initArgs());
                chain = chain.then(() => this.init());
                chain = chain.then(() => this.exec());
                chain.catch(err => log.error('command constructor', err.message));
            });
        }
        initArgs() {
            this._cmd = this._argv[this._argv.length - 1];
            this._argv = this._argv.slice(0, this._argv.length - 1);
        }
        checkNodeVersion() {
            const currentVersion = process.version;
            const lowestVersion = LOWEST_NODE_VERSION;
            if (!semver$2.gte(currentVersion, lowestVersion)) {
                throw new Error(log.warn('checkNodeVersion', `js-cli  v${lowestVersion}  node `));
            }
            console.log(process.version);
        }
    }

    var inquirer$1 = {exports: {}};

    var ansiStyles$1 = {exports: {}};

    var colorName = {
    	"aliceblue": [240, 248, 255],
    	"antiquewhite": [250, 235, 215],
    	"aqua": [0, 255, 255],
    	"aquamarine": [127, 255, 212],
    	"azure": [240, 255, 255],
    	"beige": [245, 245, 220],
    	"bisque": [255, 228, 196],
    	"black": [0, 0, 0],
    	"blanchedalmond": [255, 235, 205],
    	"blue": [0, 0, 255],
    	"blueviolet": [138, 43, 226],
    	"brown": [165, 42, 42],
    	"burlywood": [222, 184, 135],
    	"cadetblue": [95, 158, 160],
    	"chartreuse": [127, 255, 0],
    	"chocolate": [210, 105, 30],
    	"coral": [255, 127, 80],
    	"cornflowerblue": [100, 149, 237],
    	"cornsilk": [255, 248, 220],
    	"crimson": [220, 20, 60],
    	"cyan": [0, 255, 255],
    	"darkblue": [0, 0, 139],
    	"darkcyan": [0, 139, 139],
    	"darkgoldenrod": [184, 134, 11],
    	"darkgray": [169, 169, 169],
    	"darkgreen": [0, 100, 0],
    	"darkgrey": [169, 169, 169],
    	"darkkhaki": [189, 183, 107],
    	"darkmagenta": [139, 0, 139],
    	"darkolivegreen": [85, 107, 47],
    	"darkorange": [255, 140, 0],
    	"darkorchid": [153, 50, 204],
    	"darkred": [139, 0, 0],
    	"darksalmon": [233, 150, 122],
    	"darkseagreen": [143, 188, 143],
    	"darkslateblue": [72, 61, 139],
    	"darkslategray": [47, 79, 79],
    	"darkslategrey": [47, 79, 79],
    	"darkturquoise": [0, 206, 209],
    	"darkviolet": [148, 0, 211],
    	"deeppink": [255, 20, 147],
    	"deepskyblue": [0, 191, 255],
    	"dimgray": [105, 105, 105],
    	"dimgrey": [105, 105, 105],
    	"dodgerblue": [30, 144, 255],
    	"firebrick": [178, 34, 34],
    	"floralwhite": [255, 250, 240],
    	"forestgreen": [34, 139, 34],
    	"fuchsia": [255, 0, 255],
    	"gainsboro": [220, 220, 220],
    	"ghostwhite": [248, 248, 255],
    	"gold": [255, 215, 0],
    	"goldenrod": [218, 165, 32],
    	"gray": [128, 128, 128],
    	"green": [0, 128, 0],
    	"greenyellow": [173, 255, 47],
    	"grey": [128, 128, 128],
    	"honeydew": [240, 255, 240],
    	"hotpink": [255, 105, 180],
    	"indianred": [205, 92, 92],
    	"indigo": [75, 0, 130],
    	"ivory": [255, 255, 240],
    	"khaki": [240, 230, 140],
    	"lavender": [230, 230, 250],
    	"lavenderblush": [255, 240, 245],
    	"lawngreen": [124, 252, 0],
    	"lemonchiffon": [255, 250, 205],
    	"lightblue": [173, 216, 230],
    	"lightcoral": [240, 128, 128],
    	"lightcyan": [224, 255, 255],
    	"lightgoldenrodyellow": [250, 250, 210],
    	"lightgray": [211, 211, 211],
    	"lightgreen": [144, 238, 144],
    	"lightgrey": [211, 211, 211],
    	"lightpink": [255, 182, 193],
    	"lightsalmon": [255, 160, 122],
    	"lightseagreen": [32, 178, 170],
    	"lightskyblue": [135, 206, 250],
    	"lightslategray": [119, 136, 153],
    	"lightslategrey": [119, 136, 153],
    	"lightsteelblue": [176, 196, 222],
    	"lightyellow": [255, 255, 224],
    	"lime": [0, 255, 0],
    	"limegreen": [50, 205, 50],
    	"linen": [250, 240, 230],
    	"magenta": [255, 0, 255],
    	"maroon": [128, 0, 0],
    	"mediumaquamarine": [102, 205, 170],
    	"mediumblue": [0, 0, 205],
    	"mediumorchid": [186, 85, 211],
    	"mediumpurple": [147, 112, 219],
    	"mediumseagreen": [60, 179, 113],
    	"mediumslateblue": [123, 104, 238],
    	"mediumspringgreen": [0, 250, 154],
    	"mediumturquoise": [72, 209, 204],
    	"mediumvioletred": [199, 21, 133],
    	"midnightblue": [25, 25, 112],
    	"mintcream": [245, 255, 250],
    	"mistyrose": [255, 228, 225],
    	"moccasin": [255, 228, 181],
    	"navajowhite": [255, 222, 173],
    	"navy": [0, 0, 128],
    	"oldlace": [253, 245, 230],
    	"olive": [128, 128, 0],
    	"olivedrab": [107, 142, 35],
    	"orange": [255, 165, 0],
    	"orangered": [255, 69, 0],
    	"orchid": [218, 112, 214],
    	"palegoldenrod": [238, 232, 170],
    	"palegreen": [152, 251, 152],
    	"paleturquoise": [175, 238, 238],
    	"palevioletred": [219, 112, 147],
    	"papayawhip": [255, 239, 213],
    	"peachpuff": [255, 218, 185],
    	"peru": [205, 133, 63],
    	"pink": [255, 192, 203],
    	"plum": [221, 160, 221],
    	"powderblue": [176, 224, 230],
    	"purple": [128, 0, 128],
    	"rebeccapurple": [102, 51, 153],
    	"red": [255, 0, 0],
    	"rosybrown": [188, 143, 143],
    	"royalblue": [65, 105, 225],
    	"saddlebrown": [139, 69, 19],
    	"salmon": [250, 128, 114],
    	"sandybrown": [244, 164, 96],
    	"seagreen": [46, 139, 87],
    	"seashell": [255, 245, 238],
    	"sienna": [160, 82, 45],
    	"silver": [192, 192, 192],
    	"skyblue": [135, 206, 235],
    	"slateblue": [106, 90, 205],
    	"slategray": [112, 128, 144],
    	"slategrey": [112, 128, 144],
    	"snow": [255, 250, 250],
    	"springgreen": [0, 255, 127],
    	"steelblue": [70, 130, 180],
    	"tan": [210, 180, 140],
    	"teal": [0, 128, 128],
    	"thistle": [216, 191, 216],
    	"tomato": [255, 99, 71],
    	"turquoise": [64, 224, 208],
    	"violet": [238, 130, 238],
    	"wheat": [245, 222, 179],
    	"white": [255, 255, 255],
    	"whitesmoke": [245, 245, 245],
    	"yellow": [255, 255, 0],
    	"yellowgreen": [154, 205, 50]
    };

    /* MIT license */

    /* eslint-disable no-mixed-operators */
    const cssKeywords = colorName;

    // NOTE: conversions should only return primitive values (i.e. arrays, or
    //       values that give correct `typeof` results).
    //       do not use box values types (i.e. Number(), String(), etc.)

    const reverseKeywords = {};
    for (const key of Object.keys(cssKeywords)) {
    	reverseKeywords[cssKeywords[key]] = key;
    }

    const convert$1 = {
    	rgb: {channels: 3, labels: 'rgb'},
    	hsl: {channels: 3, labels: 'hsl'},
    	hsv: {channels: 3, labels: 'hsv'},
    	hwb: {channels: 3, labels: 'hwb'},
    	cmyk: {channels: 4, labels: 'cmyk'},
    	xyz: {channels: 3, labels: 'xyz'},
    	lab: {channels: 3, labels: 'lab'},
    	lch: {channels: 3, labels: 'lch'},
    	hex: {channels: 1, labels: ['hex']},
    	keyword: {channels: 1, labels: ['keyword']},
    	ansi16: {channels: 1, labels: ['ansi16']},
    	ansi256: {channels: 1, labels: ['ansi256']},
    	hcg: {channels: 3, labels: ['h', 'c', 'g']},
    	apple: {channels: 3, labels: ['r16', 'g16', 'b16']},
    	gray: {channels: 1, labels: ['gray']}
    };

    var conversions$2 = convert$1;

    // Hide .channels and .labels properties
    for (const model of Object.keys(convert$1)) {
    	if (!('channels' in convert$1[model])) {
    		throw new Error('missing channels property: ' + model);
    	}

    	if (!('labels' in convert$1[model])) {
    		throw new Error('missing channel labels property: ' + model);
    	}

    	if (convert$1[model].labels.length !== convert$1[model].channels) {
    		throw new Error('channel and label counts mismatch: ' + model);
    	}

    	const {channels, labels} = convert$1[model];
    	delete convert$1[model].channels;
    	delete convert$1[model].labels;
    	Object.defineProperty(convert$1[model], 'channels', {value: channels});
    	Object.defineProperty(convert$1[model], 'labels', {value: labels});
    }

    convert$1.rgb.hsl = function (rgb) {
    	const r = rgb[0] / 255;
    	const g = rgb[1] / 255;
    	const b = rgb[2] / 255;
    	const min = Math.min(r, g, b);
    	const max = Math.max(r, g, b);
    	const delta = max - min;
    	let h;
    	let s;

    	if (max === min) {
    		h = 0;
    	} else if (r === max) {
    		h = (g - b) / delta;
    	} else if (g === max) {
    		h = 2 + (b - r) / delta;
    	} else if (b === max) {
    		h = 4 + (r - g) / delta;
    	}

    	h = Math.min(h * 60, 360);

    	if (h < 0) {
    		h += 360;
    	}

    	const l = (min + max) / 2;

    	if (max === min) {
    		s = 0;
    	} else if (l <= 0.5) {
    		s = delta / (max + min);
    	} else {
    		s = delta / (2 - max - min);
    	}

    	return [h, s * 100, l * 100];
    };

    convert$1.rgb.hsv = function (rgb) {
    	let rdif;
    	let gdif;
    	let bdif;
    	let h;
    	let s;

    	const r = rgb[0] / 255;
    	const g = rgb[1] / 255;
    	const b = rgb[2] / 255;
    	const v = Math.max(r, g, b);
    	const diff = v - Math.min(r, g, b);
    	const diffc = function (c) {
    		return (v - c) / 6 / diff + 1 / 2;
    	};

    	if (diff === 0) {
    		h = 0;
    		s = 0;
    	} else {
    		s = diff / v;
    		rdif = diffc(r);
    		gdif = diffc(g);
    		bdif = diffc(b);

    		if (r === v) {
    			h = bdif - gdif;
    		} else if (g === v) {
    			h = (1 / 3) + rdif - bdif;
    		} else if (b === v) {
    			h = (2 / 3) + gdif - rdif;
    		}

    		if (h < 0) {
    			h += 1;
    		} else if (h > 1) {
    			h -= 1;
    		}
    	}

    	return [
    		h * 360,
    		s * 100,
    		v * 100
    	];
    };

    convert$1.rgb.hwb = function (rgb) {
    	const r = rgb[0];
    	const g = rgb[1];
    	let b = rgb[2];
    	const h = convert$1.rgb.hsl(rgb)[0];
    	const w = 1 / 255 * Math.min(r, Math.min(g, b));

    	b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));

    	return [h, w * 100, b * 100];
    };

    convert$1.rgb.cmyk = function (rgb) {
    	const r = rgb[0] / 255;
    	const g = rgb[1] / 255;
    	const b = rgb[2] / 255;

    	const k = Math.min(1 - r, 1 - g, 1 - b);
    	const c = (1 - r - k) / (1 - k) || 0;
    	const m = (1 - g - k) / (1 - k) || 0;
    	const y = (1 - b - k) / (1 - k) || 0;

    	return [c * 100, m * 100, y * 100, k * 100];
    };

    function comparativeDistance(x, y) {
    	/*
    		See https://en.m.wikipedia.org/wiki/Euclidean_distance#Squared_Euclidean_distance
    	*/
    	return (
    		((x[0] - y[0]) ** 2) +
    		((x[1] - y[1]) ** 2) +
    		((x[2] - y[2]) ** 2)
    	);
    }

    convert$1.rgb.keyword = function (rgb) {
    	const reversed = reverseKeywords[rgb];
    	if (reversed) {
    		return reversed;
    	}

    	let currentClosestDistance = Infinity;
    	let currentClosestKeyword;

    	for (const keyword of Object.keys(cssKeywords)) {
    		const value = cssKeywords[keyword];

    		// Compute comparative distance
    		const distance = comparativeDistance(rgb, value);

    		// Check if its less, if so set as closest
    		if (distance < currentClosestDistance) {
    			currentClosestDistance = distance;
    			currentClosestKeyword = keyword;
    		}
    	}

    	return currentClosestKeyword;
    };

    convert$1.keyword.rgb = function (keyword) {
    	return cssKeywords[keyword];
    };

    convert$1.rgb.xyz = function (rgb) {
    	let r = rgb[0] / 255;
    	let g = rgb[1] / 255;
    	let b = rgb[2] / 255;

    	// Assume sRGB
    	r = r > 0.04045 ? (((r + 0.055) / 1.055) ** 2.4) : (r / 12.92);
    	g = g > 0.04045 ? (((g + 0.055) / 1.055) ** 2.4) : (g / 12.92);
    	b = b > 0.04045 ? (((b + 0.055) / 1.055) ** 2.4) : (b / 12.92);

    	const x = (r * 0.4124) + (g * 0.3576) + (b * 0.1805);
    	const y = (r * 0.2126) + (g * 0.7152) + (b * 0.0722);
    	const z = (r * 0.0193) + (g * 0.1192) + (b * 0.9505);

    	return [x * 100, y * 100, z * 100];
    };

    convert$1.rgb.lab = function (rgb) {
    	const xyz = convert$1.rgb.xyz(rgb);
    	let x = xyz[0];
    	let y = xyz[1];
    	let z = xyz[2];

    	x /= 95.047;
    	y /= 100;
    	z /= 108.883;

    	x = x > 0.008856 ? (x ** (1 / 3)) : (7.787 * x) + (16 / 116);
    	y = y > 0.008856 ? (y ** (1 / 3)) : (7.787 * y) + (16 / 116);
    	z = z > 0.008856 ? (z ** (1 / 3)) : (7.787 * z) + (16 / 116);

    	const l = (116 * y) - 16;
    	const a = 500 * (x - y);
    	const b = 200 * (y - z);

    	return [l, a, b];
    };

    convert$1.hsl.rgb = function (hsl) {
    	const h = hsl[0] / 360;
    	const s = hsl[1] / 100;
    	const l = hsl[2] / 100;
    	let t2;
    	let t3;
    	let val;

    	if (s === 0) {
    		val = l * 255;
    		return [val, val, val];
    	}

    	if (l < 0.5) {
    		t2 = l * (1 + s);
    	} else {
    		t2 = l + s - l * s;
    	}

    	const t1 = 2 * l - t2;

    	const rgb = [0, 0, 0];
    	for (let i = 0; i < 3; i++) {
    		t3 = h + 1 / 3 * -(i - 1);
    		if (t3 < 0) {
    			t3++;
    		}

    		if (t3 > 1) {
    			t3--;
    		}

    		if (6 * t3 < 1) {
    			val = t1 + (t2 - t1) * 6 * t3;
    		} else if (2 * t3 < 1) {
    			val = t2;
    		} else if (3 * t3 < 2) {
    			val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
    		} else {
    			val = t1;
    		}

    		rgb[i] = val * 255;
    	}

    	return rgb;
    };

    convert$1.hsl.hsv = function (hsl) {
    	const h = hsl[0];
    	let s = hsl[1] / 100;
    	let l = hsl[2] / 100;
    	let smin = s;
    	const lmin = Math.max(l, 0.01);

    	l *= 2;
    	s *= (l <= 1) ? l : 2 - l;
    	smin *= lmin <= 1 ? lmin : 2 - lmin;
    	const v = (l + s) / 2;
    	const sv = l === 0 ? (2 * smin) / (lmin + smin) : (2 * s) / (l + s);

    	return [h, sv * 100, v * 100];
    };

    convert$1.hsv.rgb = function (hsv) {
    	const h = hsv[0] / 60;
    	const s = hsv[1] / 100;
    	let v = hsv[2] / 100;
    	const hi = Math.floor(h) % 6;

    	const f = h - Math.floor(h);
    	const p = 255 * v * (1 - s);
    	const q = 255 * v * (1 - (s * f));
    	const t = 255 * v * (1 - (s * (1 - f)));
    	v *= 255;

    	switch (hi) {
    		case 0:
    			return [v, t, p];
    		case 1:
    			return [q, v, p];
    		case 2:
    			return [p, v, t];
    		case 3:
    			return [p, q, v];
    		case 4:
    			return [t, p, v];
    		case 5:
    			return [v, p, q];
    	}
    };

    convert$1.hsv.hsl = function (hsv) {
    	const h = hsv[0];
    	const s = hsv[1] / 100;
    	const v = hsv[2] / 100;
    	const vmin = Math.max(v, 0.01);
    	let sl;
    	let l;

    	l = (2 - s) * v;
    	const lmin = (2 - s) * vmin;
    	sl = s * vmin;
    	sl /= (lmin <= 1) ? lmin : 2 - lmin;
    	sl = sl || 0;
    	l /= 2;

    	return [h, sl * 100, l * 100];
    };

    // http://dev.w3.org/csswg/css-color/#hwb-to-rgb
    convert$1.hwb.rgb = function (hwb) {
    	const h = hwb[0] / 360;
    	let wh = hwb[1] / 100;
    	let bl = hwb[2] / 100;
    	const ratio = wh + bl;
    	let f;

    	// Wh + bl cant be > 1
    	if (ratio > 1) {
    		wh /= ratio;
    		bl /= ratio;
    	}

    	const i = Math.floor(6 * h);
    	const v = 1 - bl;
    	f = 6 * h - i;

    	if ((i & 0x01) !== 0) {
    		f = 1 - f;
    	}

    	const n = wh + f * (v - wh); // Linear interpolation

    	let r;
    	let g;
    	let b;
    	/* eslint-disable max-statements-per-line,no-multi-spaces */
    	switch (i) {
    		default:
    		case 6:
    		case 0: r = v;  g = n;  b = wh; break;
    		case 1: r = n;  g = v;  b = wh; break;
    		case 2: r = wh; g = v;  b = n; break;
    		case 3: r = wh; g = n;  b = v; break;
    		case 4: r = n;  g = wh; b = v; break;
    		case 5: r = v;  g = wh; b = n; break;
    	}
    	/* eslint-enable max-statements-per-line,no-multi-spaces */

    	return [r * 255, g * 255, b * 255];
    };

    convert$1.cmyk.rgb = function (cmyk) {
    	const c = cmyk[0] / 100;
    	const m = cmyk[1] / 100;
    	const y = cmyk[2] / 100;
    	const k = cmyk[3] / 100;

    	const r = 1 - Math.min(1, c * (1 - k) + k);
    	const g = 1 - Math.min(1, m * (1 - k) + k);
    	const b = 1 - Math.min(1, y * (1 - k) + k);

    	return [r * 255, g * 255, b * 255];
    };

    convert$1.xyz.rgb = function (xyz) {
    	const x = xyz[0] / 100;
    	const y = xyz[1] / 100;
    	const z = xyz[2] / 100;
    	let r;
    	let g;
    	let b;

    	r = (x * 3.2406) + (y * -1.5372) + (z * -0.4986);
    	g = (x * -0.9689) + (y * 1.8758) + (z * 0.0415);
    	b = (x * 0.0557) + (y * -0.2040) + (z * 1.0570);

    	// Assume sRGB
    	r = r > 0.0031308
    		? ((1.055 * (r ** (1.0 / 2.4))) - 0.055)
    		: r * 12.92;

    	g = g > 0.0031308
    		? ((1.055 * (g ** (1.0 / 2.4))) - 0.055)
    		: g * 12.92;

    	b = b > 0.0031308
    		? ((1.055 * (b ** (1.0 / 2.4))) - 0.055)
    		: b * 12.92;

    	r = Math.min(Math.max(0, r), 1);
    	g = Math.min(Math.max(0, g), 1);
    	b = Math.min(Math.max(0, b), 1);

    	return [r * 255, g * 255, b * 255];
    };

    convert$1.xyz.lab = function (xyz) {
    	let x = xyz[0];
    	let y = xyz[1];
    	let z = xyz[2];

    	x /= 95.047;
    	y /= 100;
    	z /= 108.883;

    	x = x > 0.008856 ? (x ** (1 / 3)) : (7.787 * x) + (16 / 116);
    	y = y > 0.008856 ? (y ** (1 / 3)) : (7.787 * y) + (16 / 116);
    	z = z > 0.008856 ? (z ** (1 / 3)) : (7.787 * z) + (16 / 116);

    	const l = (116 * y) - 16;
    	const a = 500 * (x - y);
    	const b = 200 * (y - z);

    	return [l, a, b];
    };

    convert$1.lab.xyz = function (lab) {
    	const l = lab[0];
    	const a = lab[1];
    	const b = lab[2];
    	let x;
    	let y;
    	let z;

    	y = (l + 16) / 116;
    	x = a / 500 + y;
    	z = y - b / 200;

    	const y2 = y ** 3;
    	const x2 = x ** 3;
    	const z2 = z ** 3;
    	y = y2 > 0.008856 ? y2 : (y - 16 / 116) / 7.787;
    	x = x2 > 0.008856 ? x2 : (x - 16 / 116) / 7.787;
    	z = z2 > 0.008856 ? z2 : (z - 16 / 116) / 7.787;

    	x *= 95.047;
    	y *= 100;
    	z *= 108.883;

    	return [x, y, z];
    };

    convert$1.lab.lch = function (lab) {
    	const l = lab[0];
    	const a = lab[1];
    	const b = lab[2];
    	let h;

    	const hr = Math.atan2(b, a);
    	h = hr * 360 / 2 / Math.PI;

    	if (h < 0) {
    		h += 360;
    	}

    	const c = Math.sqrt(a * a + b * b);

    	return [l, c, h];
    };

    convert$1.lch.lab = function (lch) {
    	const l = lch[0];
    	const c = lch[1];
    	const h = lch[2];

    	const hr = h / 360 * 2 * Math.PI;
    	const a = c * Math.cos(hr);
    	const b = c * Math.sin(hr);

    	return [l, a, b];
    };

    convert$1.rgb.ansi16 = function (args, saturation = null) {
    	const [r, g, b] = args;
    	let value = saturation === null ? convert$1.rgb.hsv(args)[2] : saturation; // Hsv -> ansi16 optimization

    	value = Math.round(value / 50);

    	if (value === 0) {
    		return 30;
    	}

    	let ansi = 30
    		+ ((Math.round(b / 255) << 2)
    		| (Math.round(g / 255) << 1)
    		| Math.round(r / 255));

    	if (value === 2) {
    		ansi += 60;
    	}

    	return ansi;
    };

    convert$1.hsv.ansi16 = function (args) {
    	// Optimization here; we already know the value and don't need to get
    	// it converted for us.
    	return convert$1.rgb.ansi16(convert$1.hsv.rgb(args), args[2]);
    };

    convert$1.rgb.ansi256 = function (args) {
    	const r = args[0];
    	const g = args[1];
    	const b = args[2];

    	// We use the extended greyscale palette here, with the exception of
    	// black and white. normal palette only has 4 greyscale shades.
    	if (r === g && g === b) {
    		if (r < 8) {
    			return 16;
    		}

    		if (r > 248) {
    			return 231;
    		}

    		return Math.round(((r - 8) / 247) * 24) + 232;
    	}

    	const ansi = 16
    		+ (36 * Math.round(r / 255 * 5))
    		+ (6 * Math.round(g / 255 * 5))
    		+ Math.round(b / 255 * 5);

    	return ansi;
    };

    convert$1.ansi16.rgb = function (args) {
    	let color = args % 10;

    	// Handle greyscale
    	if (color === 0 || color === 7) {
    		if (args > 50) {
    			color += 3.5;
    		}

    		color = color / 10.5 * 255;

    		return [color, color, color];
    	}

    	const mult = (~~(args > 50) + 1) * 0.5;
    	const r = ((color & 1) * mult) * 255;
    	const g = (((color >> 1) & 1) * mult) * 255;
    	const b = (((color >> 2) & 1) * mult) * 255;

    	return [r, g, b];
    };

    convert$1.ansi256.rgb = function (args) {
    	// Handle greyscale
    	if (args >= 232) {
    		const c = (args - 232) * 10 + 8;
    		return [c, c, c];
    	}

    	args -= 16;

    	let rem;
    	const r = Math.floor(args / 36) / 5 * 255;
    	const g = Math.floor((rem = args % 36) / 6) / 5 * 255;
    	const b = (rem % 6) / 5 * 255;

    	return [r, g, b];
    };

    convert$1.rgb.hex = function (args) {
    	const integer = ((Math.round(args[0]) & 0xFF) << 16)
    		+ ((Math.round(args[1]) & 0xFF) << 8)
    		+ (Math.round(args[2]) & 0xFF);

    	const string = integer.toString(16).toUpperCase();
    	return '000000'.substring(string.length) + string;
    };

    convert$1.hex.rgb = function (args) {
    	const match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
    	if (!match) {
    		return [0, 0, 0];
    	}

    	let colorString = match[0];

    	if (match[0].length === 3) {
    		colorString = colorString.split('').map(char => {
    			return char + char;
    		}).join('');
    	}

    	const integer = parseInt(colorString, 16);
    	const r = (integer >> 16) & 0xFF;
    	const g = (integer >> 8) & 0xFF;
    	const b = integer & 0xFF;

    	return [r, g, b];
    };

    convert$1.rgb.hcg = function (rgb) {
    	const r = rgb[0] / 255;
    	const g = rgb[1] / 255;
    	const b = rgb[2] / 255;
    	const max = Math.max(Math.max(r, g), b);
    	const min = Math.min(Math.min(r, g), b);
    	const chroma = (max - min);
    	let grayscale;
    	let hue;

    	if (chroma < 1) {
    		grayscale = min / (1 - chroma);
    	} else {
    		grayscale = 0;
    	}

    	if (chroma <= 0) {
    		hue = 0;
    	} else
    	if (max === r) {
    		hue = ((g - b) / chroma) % 6;
    	} else
    	if (max === g) {
    		hue = 2 + (b - r) / chroma;
    	} else {
    		hue = 4 + (r - g) / chroma;
    	}

    	hue /= 6;
    	hue %= 1;

    	return [hue * 360, chroma * 100, grayscale * 100];
    };

    convert$1.hsl.hcg = function (hsl) {
    	const s = hsl[1] / 100;
    	const l = hsl[2] / 100;

    	const c = l < 0.5 ? (2.0 * s * l) : (2.0 * s * (1.0 - l));

    	let f = 0;
    	if (c < 1.0) {
    		f = (l - 0.5 * c) / (1.0 - c);
    	}

    	return [hsl[0], c * 100, f * 100];
    };

    convert$1.hsv.hcg = function (hsv) {
    	const s = hsv[1] / 100;
    	const v = hsv[2] / 100;

    	const c = s * v;
    	let f = 0;

    	if (c < 1.0) {
    		f = (v - c) / (1 - c);
    	}

    	return [hsv[0], c * 100, f * 100];
    };

    convert$1.hcg.rgb = function (hcg) {
    	const h = hcg[0] / 360;
    	const c = hcg[1] / 100;
    	const g = hcg[2] / 100;

    	if (c === 0.0) {
    		return [g * 255, g * 255, g * 255];
    	}

    	const pure = [0, 0, 0];
    	const hi = (h % 1) * 6;
    	const v = hi % 1;
    	const w = 1 - v;
    	let mg = 0;

    	/* eslint-disable max-statements-per-line */
    	switch (Math.floor(hi)) {
    		case 0:
    			pure[0] = 1; pure[1] = v; pure[2] = 0; break;
    		case 1:
    			pure[0] = w; pure[1] = 1; pure[2] = 0; break;
    		case 2:
    			pure[0] = 0; pure[1] = 1; pure[2] = v; break;
    		case 3:
    			pure[0] = 0; pure[1] = w; pure[2] = 1; break;
    		case 4:
    			pure[0] = v; pure[1] = 0; pure[2] = 1; break;
    		default:
    			pure[0] = 1; pure[1] = 0; pure[2] = w;
    	}
    	/* eslint-enable max-statements-per-line */

    	mg = (1.0 - c) * g;

    	return [
    		(c * pure[0] + mg) * 255,
    		(c * pure[1] + mg) * 255,
    		(c * pure[2] + mg) * 255
    	];
    };

    convert$1.hcg.hsv = function (hcg) {
    	const c = hcg[1] / 100;
    	const g = hcg[2] / 100;

    	const v = c + g * (1.0 - c);
    	let f = 0;

    	if (v > 0.0) {
    		f = c / v;
    	}

    	return [hcg[0], f * 100, v * 100];
    };

    convert$1.hcg.hsl = function (hcg) {
    	const c = hcg[1] / 100;
    	const g = hcg[2] / 100;

    	const l = g * (1.0 - c) + 0.5 * c;
    	let s = 0;

    	if (l > 0.0 && l < 0.5) {
    		s = c / (2 * l);
    	} else
    	if (l >= 0.5 && l < 1.0) {
    		s = c / (2 * (1 - l));
    	}

    	return [hcg[0], s * 100, l * 100];
    };

    convert$1.hcg.hwb = function (hcg) {
    	const c = hcg[1] / 100;
    	const g = hcg[2] / 100;
    	const v = c + g * (1.0 - c);
    	return [hcg[0], (v - c) * 100, (1 - v) * 100];
    };

    convert$1.hwb.hcg = function (hwb) {
    	const w = hwb[1] / 100;
    	const b = hwb[2] / 100;
    	const v = 1 - b;
    	const c = v - w;
    	let g = 0;

    	if (c < 1) {
    		g = (v - c) / (1 - c);
    	}

    	return [hwb[0], c * 100, g * 100];
    };

    convert$1.apple.rgb = function (apple) {
    	return [(apple[0] / 65535) * 255, (apple[1] / 65535) * 255, (apple[2] / 65535) * 255];
    };

    convert$1.rgb.apple = function (rgb) {
    	return [(rgb[0] / 255) * 65535, (rgb[1] / 255) * 65535, (rgb[2] / 255) * 65535];
    };

    convert$1.gray.rgb = function (args) {
    	return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
    };

    convert$1.gray.hsl = function (args) {
    	return [0, 0, args[0]];
    };

    convert$1.gray.hsv = convert$1.gray.hsl;

    convert$1.gray.hwb = function (gray) {
    	return [0, 100, gray[0]];
    };

    convert$1.gray.cmyk = function (gray) {
    	return [0, 0, 0, gray[0]];
    };

    convert$1.gray.lab = function (gray) {
    	return [gray[0], 0, 0];
    };

    convert$1.gray.hex = function (gray) {
    	const val = Math.round(gray[0] / 100 * 255) & 0xFF;
    	const integer = (val << 16) + (val << 8) + val;

    	const string = integer.toString(16).toUpperCase();
    	return '000000'.substring(string.length) + string;
    };

    convert$1.rgb.gray = function (rgb) {
    	const val = (rgb[0] + rgb[1] + rgb[2]) / 3;
    	return [val / 255 * 100];
    };

    const conversions$1 = conversions$2;

    /*
    	This function routes a model to all other models.

    	all functions that are routed have a property `.conversion` attached
    	to the returned synthetic function. This property is an array
    	of strings, each with the steps in between the 'from' and 'to'
    	color models (inclusive).

    	conversions that are not possible simply are not included.
    */

    function buildGraph() {
    	const graph = {};
    	// https://jsperf.com/object-keys-vs-for-in-with-closure/3
    	const models = Object.keys(conversions$1);

    	for (let len = models.length, i = 0; i < len; i++) {
    		graph[models[i]] = {
    			// http://jsperf.com/1-vs-infinity
    			// micro-opt, but this is simple.
    			distance: -1,
    			parent: null
    		};
    	}

    	return graph;
    }

    // https://en.wikipedia.org/wiki/Breadth-first_search
    function deriveBFS(fromModel) {
    	const graph = buildGraph();
    	const queue = [fromModel]; // Unshift -> queue -> pop

    	graph[fromModel].distance = 0;

    	while (queue.length) {
    		const current = queue.pop();
    		const adjacents = Object.keys(conversions$1[current]);

    		for (let len = adjacents.length, i = 0; i < len; i++) {
    			const adjacent = adjacents[i];
    			const node = graph[adjacent];

    			if (node.distance === -1) {
    				node.distance = graph[current].distance + 1;
    				node.parent = current;
    				queue.unshift(adjacent);
    			}
    		}
    	}

    	return graph;
    }

    function link(from, to) {
    	return function (args) {
    		return to(from(args));
    	};
    }

    function wrapConversion(toModel, graph) {
    	const path = [graph[toModel].parent, toModel];
    	let fn = conversions$1[graph[toModel].parent][toModel];

    	let cur = graph[toModel].parent;
    	while (graph[cur].parent) {
    		path.unshift(graph[cur].parent);
    		fn = link(conversions$1[graph[cur].parent][cur], fn);
    		cur = graph[cur].parent;
    	}

    	fn.conversion = path;
    	return fn;
    }

    var route$1 = function (fromModel) {
    	const graph = deriveBFS(fromModel);
    	const conversion = {};

    	const models = Object.keys(graph);
    	for (let len = models.length, i = 0; i < len; i++) {
    		const toModel = models[i];
    		const node = graph[toModel];

    		if (node.parent === null) {
    			// No possible conversion, or this node is the source model.
    			continue;
    		}

    		conversion[toModel] = wrapConversion(toModel, graph);
    	}

    	return conversion;
    };

    const conversions = conversions$2;
    const route = route$1;

    const convert = {};

    const models = Object.keys(conversions);

    function wrapRaw(fn) {
    	const wrappedFn = function (...args) {
    		const arg0 = args[0];
    		if (arg0 === undefined || arg0 === null) {
    			return arg0;
    		}

    		if (arg0.length > 1) {
    			args = arg0;
    		}

    		return fn(args);
    	};

    	// Preserve .conversion property if there is one
    	if ('conversion' in fn) {
    		wrappedFn.conversion = fn.conversion;
    	}

    	return wrappedFn;
    }

    function wrapRounded(fn) {
    	const wrappedFn = function (...args) {
    		const arg0 = args[0];

    		if (arg0 === undefined || arg0 === null) {
    			return arg0;
    		}

    		if (arg0.length > 1) {
    			args = arg0;
    		}

    		const result = fn(args);

    		// We're assuming the result is an array here.
    		// see notice in conversions.js; don't use box types
    		// in conversion functions.
    		if (typeof result === 'object') {
    			for (let len = result.length, i = 0; i < len; i++) {
    				result[i] = Math.round(result[i]);
    			}
    		}

    		return result;
    	};

    	// Preserve .conversion property if there is one
    	if ('conversion' in fn) {
    		wrappedFn.conversion = fn.conversion;
    	}

    	return wrappedFn;
    }

    models.forEach(fromModel => {
    	convert[fromModel] = {};

    	Object.defineProperty(convert[fromModel], 'channels', {value: conversions[fromModel].channels});
    	Object.defineProperty(convert[fromModel], 'labels', {value: conversions[fromModel].labels});

    	const routes = route(fromModel);
    	const routeModels = Object.keys(routes);

    	routeModels.forEach(toModel => {
    		const fn = routes[toModel];

    		convert[fromModel][toModel] = wrapRounded(fn);
    		convert[fromModel][toModel].raw = wrapRaw(fn);
    	});
    });

    var colorConvert = convert;

    (function (module) {

    const wrapAnsi16 = (fn, offset) => (...args) => {
    	const code = fn(...args);
    	return `\u001B[${code + offset}m`;
    };

    const wrapAnsi256 = (fn, offset) => (...args) => {
    	const code = fn(...args);
    	return `\u001B[${38 + offset};5;${code}m`;
    };

    const wrapAnsi16m = (fn, offset) => (...args) => {
    	const rgb = fn(...args);
    	return `\u001B[${38 + offset};2;${rgb[0]};${rgb[1]};${rgb[2]}m`;
    };

    const ansi2ansi = n => n;
    const rgb2rgb = (r, g, b) => [r, g, b];

    const setLazyProperty = (object, property, get) => {
    	Object.defineProperty(object, property, {
    		get: () => {
    			const value = get();

    			Object.defineProperty(object, property, {
    				value,
    				enumerable: true,
    				configurable: true
    			});

    			return value;
    		},
    		enumerable: true,
    		configurable: true
    	});
    };

    /** @type {typeof import('color-convert')} */
    let colorConvert$1;
    const makeDynamicStyles = (wrap, targetSpace, identity, isBackground) => {
    	if (colorConvert$1 === undefined) {
    		colorConvert$1 = colorConvert;
    	}

    	const offset = isBackground ? 10 : 0;
    	const styles = {};

    	for (const [sourceSpace, suite] of Object.entries(colorConvert$1)) {
    		const name = sourceSpace === 'ansi16' ? 'ansi' : sourceSpace;
    		if (sourceSpace === targetSpace) {
    			styles[name] = wrap(identity, offset);
    		} else if (typeof suite === 'object') {
    			styles[name] = wrap(suite[targetSpace], offset);
    		}
    	}

    	return styles;
    };

    function assembleStyles() {
    	const codes = new Map();
    	const styles = {
    		modifier: {
    			reset: [0, 0],
    			// 21 isn't widely supported and 22 does the same thing
    			bold: [1, 22],
    			dim: [2, 22],
    			italic: [3, 23],
    			underline: [4, 24],
    			inverse: [7, 27],
    			hidden: [8, 28],
    			strikethrough: [9, 29]
    		},
    		color: {
    			black: [30, 39],
    			red: [31, 39],
    			green: [32, 39],
    			yellow: [33, 39],
    			blue: [34, 39],
    			magenta: [35, 39],
    			cyan: [36, 39],
    			white: [37, 39],

    			// Bright color
    			blackBright: [90, 39],
    			redBright: [91, 39],
    			greenBright: [92, 39],
    			yellowBright: [93, 39],
    			blueBright: [94, 39],
    			magentaBright: [95, 39],
    			cyanBright: [96, 39],
    			whiteBright: [97, 39]
    		},
    		bgColor: {
    			bgBlack: [40, 49],
    			bgRed: [41, 49],
    			bgGreen: [42, 49],
    			bgYellow: [43, 49],
    			bgBlue: [44, 49],
    			bgMagenta: [45, 49],
    			bgCyan: [46, 49],
    			bgWhite: [47, 49],

    			// Bright color
    			bgBlackBright: [100, 49],
    			bgRedBright: [101, 49],
    			bgGreenBright: [102, 49],
    			bgYellowBright: [103, 49],
    			bgBlueBright: [104, 49],
    			bgMagentaBright: [105, 49],
    			bgCyanBright: [106, 49],
    			bgWhiteBright: [107, 49]
    		}
    	};

    	// Alias bright black as gray (and grey)
    	styles.color.gray = styles.color.blackBright;
    	styles.bgColor.bgGray = styles.bgColor.bgBlackBright;
    	styles.color.grey = styles.color.blackBright;
    	styles.bgColor.bgGrey = styles.bgColor.bgBlackBright;

    	for (const [groupName, group] of Object.entries(styles)) {
    		for (const [styleName, style] of Object.entries(group)) {
    			styles[styleName] = {
    				open: `\u001B[${style[0]}m`,
    				close: `\u001B[${style[1]}m`
    			};

    			group[styleName] = styles[styleName];

    			codes.set(style[0], style[1]);
    		}

    		Object.defineProperty(styles, groupName, {
    			value: group,
    			enumerable: false
    		});
    	}

    	Object.defineProperty(styles, 'codes', {
    		value: codes,
    		enumerable: false
    	});

    	styles.color.close = '\u001B[39m';
    	styles.bgColor.close = '\u001B[49m';

    	setLazyProperty(styles.color, 'ansi', () => makeDynamicStyles(wrapAnsi16, 'ansi16', ansi2ansi, false));
    	setLazyProperty(styles.color, 'ansi256', () => makeDynamicStyles(wrapAnsi256, 'ansi256', ansi2ansi, false));
    	setLazyProperty(styles.color, 'ansi16m', () => makeDynamicStyles(wrapAnsi16m, 'rgb', rgb2rgb, false));
    	setLazyProperty(styles.bgColor, 'ansi', () => makeDynamicStyles(wrapAnsi16, 'ansi16', ansi2ansi, true));
    	setLazyProperty(styles.bgColor, 'ansi256', () => makeDynamicStyles(wrapAnsi256, 'ansi256', ansi2ansi, true));
    	setLazyProperty(styles.bgColor, 'ansi16m', () => makeDynamicStyles(wrapAnsi16m, 'rgb', rgb2rgb, true));

    	return styles;
    }

    // Make the export immutable
    Object.defineProperty(module, 'exports', {
    	enumerable: true,
    	get: assembleStyles
    });
    }(ansiStyles$1));

    var hasFlag$1 = (flag, argv = process.argv) => {
    	const prefix = flag.startsWith('-') ? '' : (flag.length === 1 ? '-' : '--');
    	const position = argv.indexOf(prefix + flag);
    	const terminatorPosition = argv.indexOf('--');
    	return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
    };

    const os = require$$0__default$4["default"];
    const tty = require$$1__default$2["default"];
    const hasFlag = hasFlag$1;

    const {env} = process;

    let forceColor;
    if (hasFlag('no-color') ||
    	hasFlag('no-colors') ||
    	hasFlag('color=false') ||
    	hasFlag('color=never')) {
    	forceColor = 0;
    } else if (hasFlag('color') ||
    	hasFlag('colors') ||
    	hasFlag('color=true') ||
    	hasFlag('color=always')) {
    	forceColor = 1;
    }

    if ('FORCE_COLOR' in env) {
    	if (env.FORCE_COLOR === 'true') {
    		forceColor = 1;
    	} else if (env.FORCE_COLOR === 'false') {
    		forceColor = 0;
    	} else {
    		forceColor = env.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env.FORCE_COLOR, 10), 3);
    	}
    }

    function translateLevel(level) {
    	if (level === 0) {
    		return false;
    	}

    	return {
    		level,
    		hasBasic: true,
    		has256: level >= 2,
    		has16m: level >= 3
    	};
    }

    function supportsColor(haveStream, streamIsTTY) {
    	if (forceColor === 0) {
    		return 0;
    	}

    	if (hasFlag('color=16m') ||
    		hasFlag('color=full') ||
    		hasFlag('color=truecolor')) {
    		return 3;
    	}

    	if (hasFlag('color=256')) {
    		return 2;
    	}

    	if (haveStream && !streamIsTTY && forceColor === undefined) {
    		return 0;
    	}

    	const min = forceColor || 0;

    	if (env.TERM === 'dumb') {
    		return min;
    	}

    	if (process.platform === 'win32') {
    		// Windows 10 build 10586 is the first Windows release that supports 256 colors.
    		// Windows 10 build 14931 is the first release that supports 16m/TrueColor.
    		const osRelease = os.release().split('.');
    		if (
    			Number(osRelease[0]) >= 10 &&
    			Number(osRelease[2]) >= 10586
    		) {
    			return Number(osRelease[2]) >= 14931 ? 3 : 2;
    		}

    		return 1;
    	}

    	if ('CI' in env) {
    		if (['TRAVIS', 'CIRCLECI', 'APPVEYOR', 'GITLAB_CI', 'GITHUB_ACTIONS', 'BUILDKITE'].some(sign => sign in env) || env.CI_NAME === 'codeship') {
    			return 1;
    		}

    		return min;
    	}

    	if ('TEAMCITY_VERSION' in env) {
    		return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
    	}

    	if (env.COLORTERM === 'truecolor') {
    		return 3;
    	}

    	if ('TERM_PROGRAM' in env) {
    		const version = parseInt((env.TERM_PROGRAM_VERSION || '').split('.')[0], 10);

    		switch (env.TERM_PROGRAM) {
    			case 'iTerm.app':
    				return version >= 3 ? 3 : 2;
    			case 'Apple_Terminal':
    				return 2;
    			// No default
    		}
    	}

    	if (/-256(color)?$/i.test(env.TERM)) {
    		return 2;
    	}

    	if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
    		return 1;
    	}

    	if ('COLORTERM' in env) {
    		return 1;
    	}

    	return min;
    }

    function getSupportLevel(stream) {
    	const level = supportsColor(stream, stream && stream.isTTY);
    	return translateLevel(level);
    }

    var supportsColor_1 = {
    	supportsColor: getSupportLevel,
    	stdout: translateLevel(supportsColor(true, tty.isatty(1))),
    	stderr: translateLevel(supportsColor(true, tty.isatty(2)))
    };

    const stringReplaceAll$1 = (string, substring, replacer) => {
    	let index = string.indexOf(substring);
    	if (index === -1) {
    		return string;
    	}

    	const substringLength = substring.length;
    	let endIndex = 0;
    	let returnValue = '';
    	do {
    		returnValue += string.substr(endIndex, index - endIndex) + substring + replacer;
    		endIndex = index + substringLength;
    		index = string.indexOf(substring, endIndex);
    	} while (index !== -1);

    	returnValue += string.substr(endIndex);
    	return returnValue;
    };

    const stringEncaseCRLFWithFirstIndex$1 = (string, prefix, postfix, index) => {
    	let endIndex = 0;
    	let returnValue = '';
    	do {
    		const gotCR = string[index - 1] === '\r';
    		returnValue += string.substr(endIndex, (gotCR ? index - 1 : index) - endIndex) + prefix + (gotCR ? '\r\n' : '\n') + postfix;
    		endIndex = index + 1;
    		index = string.indexOf('\n', endIndex);
    	} while (index !== -1);

    	returnValue += string.substr(endIndex);
    	return returnValue;
    };

    var util$1 = {
    	stringReplaceAll: stringReplaceAll$1,
    	stringEncaseCRLFWithFirstIndex: stringEncaseCRLFWithFirstIndex$1
    };

    const TEMPLATE_REGEX = /(?:\\(u(?:[a-f\d]{4}|\{[a-f\d]{1,6}\})|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi;
    const STYLE_REGEX = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g;
    const STRING_REGEX = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/;
    const ESCAPE_REGEX = /\\(u(?:[a-f\d]{4}|{[a-f\d]{1,6}})|x[a-f\d]{2}|.)|([^\\])/gi;

    const ESCAPES = new Map([
    	['n', '\n'],
    	['r', '\r'],
    	['t', '\t'],
    	['b', '\b'],
    	['f', '\f'],
    	['v', '\v'],
    	['0', '\0'],
    	['\\', '\\'],
    	['e', '\u001B'],
    	['a', '\u0007']
    ]);

    function unescape$1(c) {
    	const u = c[0] === 'u';
    	const bracket = c[1] === '{';

    	if ((u && !bracket && c.length === 5) || (c[0] === 'x' && c.length === 3)) {
    		return String.fromCharCode(parseInt(c.slice(1), 16));
    	}

    	if (u && bracket) {
    		return String.fromCodePoint(parseInt(c.slice(2, -1), 16));
    	}

    	return ESCAPES.get(c) || c;
    }

    function parseArguments(name, arguments_) {
    	const results = [];
    	const chunks = arguments_.trim().split(/\s*,\s*/g);
    	let matches;

    	for (const chunk of chunks) {
    		const number = Number(chunk);
    		if (!Number.isNaN(number)) {
    			results.push(number);
    		} else if ((matches = chunk.match(STRING_REGEX))) {
    			results.push(matches[2].replace(ESCAPE_REGEX, (m, escape, character) => escape ? unescape$1(escape) : character));
    		} else {
    			throw new Error(`Invalid Chalk template style argument: ${chunk} (in style '${name}')`);
    		}
    	}

    	return results;
    }

    function parseStyle(style) {
    	STYLE_REGEX.lastIndex = 0;

    	const results = [];
    	let matches;

    	while ((matches = STYLE_REGEX.exec(style)) !== null) {
    		const name = matches[1];

    		if (matches[2]) {
    			const args = parseArguments(name, matches[2]);
    			results.push([name].concat(args));
    		} else {
    			results.push([name]);
    		}
    	}

    	return results;
    }

    function buildStyle(chalk, styles) {
    	const enabled = {};

    	for (const layer of styles) {
    		for (const style of layer.styles) {
    			enabled[style[0]] = layer.inverse ? null : style.slice(1);
    		}
    	}

    	let current = chalk;
    	for (const [styleName, styles] of Object.entries(enabled)) {
    		if (!Array.isArray(styles)) {
    			continue;
    		}

    		if (!(styleName in current)) {
    			throw new Error(`Unknown Chalk style: ${styleName}`);
    		}

    		current = styles.length > 0 ? current[styleName](...styles) : current[styleName];
    	}

    	return current;
    }

    var templates = (chalk, temporary) => {
    	const styles = [];
    	const chunks = [];
    	let chunk = [];

    	// eslint-disable-next-line max-params
    	temporary.replace(TEMPLATE_REGEX, (m, escapeCharacter, inverse, style, close, character) => {
    		if (escapeCharacter) {
    			chunk.push(unescape$1(escapeCharacter));
    		} else if (style) {
    			const string = chunk.join('');
    			chunk = [];
    			chunks.push(styles.length === 0 ? string : buildStyle(chalk, styles)(string));
    			styles.push({inverse, styles: parseStyle(style)});
    		} else if (close) {
    			if (styles.length === 0) {
    				throw new Error('Found extraneous } in Chalk template literal');
    			}

    			chunks.push(buildStyle(chalk, styles)(chunk.join('')));
    			chunk = [];
    			styles.pop();
    		} else {
    			chunk.push(character);
    		}
    	});

    	chunks.push(chunk.join(''));

    	if (styles.length > 0) {
    		const errMessage = `Chalk template literal is missing ${styles.length} closing bracket${styles.length === 1 ? '' : 's'} (\`}\`)`;
    		throw new Error(errMessage);
    	}

    	return chunks.join('');
    };

    const ansiStyles = ansiStyles$1.exports;
    const {stdout: stdoutColor, stderr: stderrColor} = supportsColor_1;
    const {
    	stringReplaceAll,
    	stringEncaseCRLFWithFirstIndex
    } = util$1;

    const {isArray: isArray$i} = Array;

    // `supportsColor.level`  `ansiStyles.color[name]` mapping
    const levelMapping = [
    	'ansi',
    	'ansi',
    	'ansi256',
    	'ansi16m'
    ];

    const styles = Object.create(null);

    const applyOptions = (object, options = {}) => {
    	if (options.level && !(Number.isInteger(options.level) && options.level >= 0 && options.level <= 3)) {
    		throw new Error('The `level` option should be an integer from 0 to 3');
    	}

    	// Detect level if not set manually
    	const colorLevel = stdoutColor ? stdoutColor.level : 0;
    	object.level = options.level === undefined ? colorLevel : options.level;
    };

    class ChalkClass {
    	constructor(options) {
    		// eslint-disable-next-line no-constructor-return
    		return chalkFactory(options);
    	}
    }

    const chalkFactory = options => {
    	const chalk = {};
    	applyOptions(chalk, options);

    	chalk.template = (...arguments_) => chalkTag(chalk.template, ...arguments_);

    	Object.setPrototypeOf(chalk, Chalk.prototype);
    	Object.setPrototypeOf(chalk.template, chalk);

    	chalk.template.constructor = () => {
    		throw new Error('`chalk.constructor()` is deprecated. Use `new chalk.Instance()` instead.');
    	};

    	chalk.template.Instance = ChalkClass;

    	return chalk.template;
    };

    function Chalk(options) {
    	return chalkFactory(options);
    }

    for (const [styleName, style] of Object.entries(ansiStyles)) {
    	styles[styleName] = {
    		get() {
    			const builder = createBuilder(this, createStyler(style.open, style.close, this._styler), this._isEmpty);
    			Object.defineProperty(this, styleName, {value: builder});
    			return builder;
    		}
    	};
    }

    styles.visible = {
    	get() {
    		const builder = createBuilder(this, this._styler, true);
    		Object.defineProperty(this, 'visible', {value: builder});
    		return builder;
    	}
    };

    const usedModels = ['rgb', 'hex', 'keyword', 'hsl', 'hsv', 'hwb', 'ansi', 'ansi256'];

    for (const model of usedModels) {
    	styles[model] = {
    		get() {
    			const {level} = this;
    			return function (...arguments_) {
    				const styler = createStyler(ansiStyles.color[levelMapping[level]][model](...arguments_), ansiStyles.color.close, this._styler);
    				return createBuilder(this, styler, this._isEmpty);
    			};
    		}
    	};
    }

    for (const model of usedModels) {
    	const bgModel = 'bg' + model[0].toUpperCase() + model.slice(1);
    	styles[bgModel] = {
    		get() {
    			const {level} = this;
    			return function (...arguments_) {
    				const styler = createStyler(ansiStyles.bgColor[levelMapping[level]][model](...arguments_), ansiStyles.bgColor.close, this._styler);
    				return createBuilder(this, styler, this._isEmpty);
    			};
    		}
    	};
    }

    const proto = Object.defineProperties(() => {}, {
    	...styles,
    	level: {
    		enumerable: true,
    		get() {
    			return this._generator.level;
    		},
    		set(level) {
    			this._generator.level = level;
    		}
    	}
    });

    const createStyler = (open, close, parent) => {
    	let openAll;
    	let closeAll;
    	if (parent === undefined) {
    		openAll = open;
    		closeAll = close;
    	} else {
    		openAll = parent.openAll + open;
    		closeAll = close + parent.closeAll;
    	}

    	return {
    		open,
    		close,
    		openAll,
    		closeAll,
    		parent
    	};
    };

    const createBuilder = (self, _styler, _isEmpty) => {
    	const builder = (...arguments_) => {
    		if (isArray$i(arguments_[0]) && isArray$i(arguments_[0].raw)) {
    			// Called as a template literal, for example: chalk.red`2 + 3 = {bold ${2+3}}`
    			return applyStyle(builder, chalkTag(builder, ...arguments_));
    		}

    		// Single argument is hot path, implicit coercion is faster than anything
    		// eslint-disable-next-line no-implicit-coercion
    		return applyStyle(builder, (arguments_.length === 1) ? ('' + arguments_[0]) : arguments_.join(' '));
    	};

    	// We alter the prototype because we must return a function, but there is
    	// no way to create a function with a different prototype
    	Object.setPrototypeOf(builder, proto);

    	builder._generator = self;
    	builder._styler = _styler;
    	builder._isEmpty = _isEmpty;

    	return builder;
    };

    const applyStyle = (self, string) => {
    	if (self.level <= 0 || !string) {
    		return self._isEmpty ? '' : string;
    	}

    	let styler = self._styler;

    	if (styler === undefined) {
    		return string;
    	}

    	const {openAll, closeAll} = styler;
    	if (string.indexOf('\u001B') !== -1) {
    		while (styler !== undefined) {
    			// Replace any instances already present with a re-opening code
    			// otherwise only the part of the string until said closing code
    			// will be colored, and the rest will simply be 'plain'.
    			string = stringReplaceAll(string, styler.close, styler.open);

    			styler = styler.parent;
    		}
    	}

    	// We can move both next actions out of loop, because remaining actions in loop won't have
    	// any/visible effect on parts we add here. Close the styling before a linebreak and reopen
    	// after next line to fix a bleed issue on macOS: https://github.com/chalk/chalk/pull/92
    	const lfIndex = string.indexOf('\n');
    	if (lfIndex !== -1) {
    		string = stringEncaseCRLFWithFirstIndex(string, closeAll, openAll, lfIndex);
    	}

    	return openAll + string + closeAll;
    };

    let template;
    const chalkTag = (chalk, ...strings) => {
    	const [firstString] = strings;

    	if (!isArray$i(firstString) || !isArray$i(firstString.raw)) {
    		// If chalk() was called by itself or with a string,
    		// return the string itself as a string.
    		return strings.join(' ');
    	}

    	const arguments_ = strings.slice(1);
    	const parts = [firstString.raw[0]];

    	for (let i = 1; i < firstString.length; i++) {
    		parts.push(
    			String(arguments_[i - 1]).replace(/[{}\\]/g, '\\$&'),
    			String(firstString.raw[i])
    		);
    	}

    	if (template === undefined) {
    		template = templates;
    	}

    	return template(chalk, parts.join(''));
    };

    Object.defineProperties(Chalk.prototype, styles);

    const chalk$d = Chalk(); // eslint-disable-line new-cap
    chalk$d.supportsColor = stdoutColor;
    chalk$d.stderr = Chalk({level: stderrColor ? stderrColor.level : 0}); // eslint-disable-line new-cap
    chalk$d.stderr.supportsColor = stderrColor;

    var source = chalk$d;

    var figures$4 = {exports: {}};

    var matchOperatorsRe = /[|\\{}()[\]^$+*?.]/g;

    var escapeStringRegexp$1 = function (str) {
    	if (typeof str !== 'string') {
    		throw new TypeError('Expected a string');
    	}

    	return str.replace(matchOperatorsRe, '\\$&');
    };

    const escapeStringRegexp = escapeStringRegexp$1;

    const {platform} = process;

    const main$3 = {
    	tick: '',
    	cross: '',
    	star: '',
    	square: '',
    	squareSmall: '',
    	squareSmallFilled: '',
    	play: '',
    	circle: '',
    	circleFilled: '',
    	circleDotted: '',
    	circleDouble: '',
    	circleCircle: '',
    	circleCross: '',
    	circlePipe: '',
    	circleQuestionMark: '?',
    	bullet: '',
    	dot: '',
    	line: '',
    	ellipsis: '',
    	pointer: '',
    	pointerSmall: '',
    	info: '',
    	warning: '',
    	hamburger: '',
    	smiley: '',
    	mustache: '',
    	heart: '',
    	nodejs: '',
    	arrowUp: '',
    	arrowDown: '',
    	arrowLeft: '',
    	arrowRight: '',
    	radioOn: '',
    	radioOff: '',
    	checkboxOn: '',
    	checkboxOff: '',
    	checkboxCircleOn: '',
    	checkboxCircleOff: '',
    	questionMarkPrefix: '?',
    	oneHalf: '',
    	oneThird: '',
    	oneQuarter: '',
    	oneFifth: '',
    	oneSixth: '',
    	oneSeventh: '',
    	oneEighth: '',
    	oneNinth: '',
    	oneTenth: '',
    	twoThirds: '',
    	twoFifths: '',
    	threeQuarters: '',
    	threeFifths: '',
    	threeEighths: '',
    	fourFifths: '',
    	fiveSixths: '',
    	fiveEighths: '',
    	sevenEighths: ''
    };

    const windows = {
    	tick: '',
    	cross: '',
    	star: '*',
    	square: '',
    	squareSmall: '[ ]',
    	squareSmallFilled: '[]',
    	play: '',
    	circle: '( )',
    	circleFilled: '(*)',
    	circleDotted: '( )',
    	circleDouble: '( )',
    	circleCircle: '()',
    	circleCross: '()',
    	circlePipe: '()',
    	circleQuestionMark: '(?)',
    	bullet: '*',
    	dot: '.',
    	line: '',
    	ellipsis: '...',
    	pointer: '>',
    	pointerSmall: '',
    	info: 'i',
    	warning: '',
    	hamburger: '',
    	smiley: '',
    	mustache: '',
    	heart: main$3.heart,
    	nodejs: '',
    	arrowUp: main$3.arrowUp,
    	arrowDown: main$3.arrowDown,
    	arrowLeft: main$3.arrowLeft,
    	arrowRight: main$3.arrowRight,
    	radioOn: '(*)',
    	radioOff: '( )',
    	checkboxOn: '[]',
    	checkboxOff: '[ ]',
    	checkboxCircleOn: '()',
    	checkboxCircleOff: '( )',
    	questionMarkPrefix: '',
    	oneHalf: '1/2',
    	oneThird: '1/3',
    	oneQuarter: '1/4',
    	oneFifth: '1/5',
    	oneSixth: '1/6',
    	oneSeventh: '1/7',
    	oneEighth: '1/8',
    	oneNinth: '1/9',
    	oneTenth: '1/10',
    	twoThirds: '2/3',
    	twoFifths: '2/5',
    	threeQuarters: '3/4',
    	threeFifths: '3/5',
    	threeEighths: '3/8',
    	fourFifths: '4/5',
    	fiveSixths: '5/6',
    	fiveEighths: '5/8',
    	sevenEighths: '7/8'
    };

    if (platform === 'linux') {
    	// The main one doesn't look that good on Ubuntu.
    	main$3.questionMarkPrefix = '?';
    }

    const figures$3 = platform === 'win32' ? windows : main$3;

    const fn = string => {
    	if (figures$3 === main$3) {
    		return string;
    	}

    	for (const [key, value] of Object.entries(main$3)) {
    		if (value === figures$3[key]) {
    			continue;
    		}

    		string = string.replace(new RegExp(escapeStringRegexp(value), 'g'), figures$3[key]);
    	}

    	return string;
    };

    figures$4.exports = Object.assign(fn, figures$3);
    figures$4.exports.main = main$3;
    figures$4.exports.windows = windows;

    const chalk$c = source;
    const figures$2 = figures$4.exports;

    /**
     * Separator object
     * Used to space/separate choices group
     * @constructor
     * @param {String} line   Separation line content (facultative)
     */

    class Separator$3 {
      constructor(line) {
        this.type = 'separator';
        this.line = chalk$c.dim(line || new Array(15).join(figures$2.line));
      }

      /**
       * Stringify separator
       * @return {String} the separator display string
       */
      toString() {
        return this.line;
      }
    }

    /**
     * Helper function returning false if object is a separator
     * @param  {Object} obj object to test against
     * @return {Boolean}    `false` if object is a separator
     */

    Separator$3.exclude = function (obj) {
      return obj.type !== 'separator';
    };

    var separator = Separator$3;

    var through$1 = {exports: {}};

    (function (module, exports) {
    var Stream = require$$0__default$2["default"];

    // through
    //
    // a stream that does nothing but re-emit the input.
    // useful for aggregating a series of changing but not ending streams into one stream)

    module.exports = through;
    through.through = through;

    //create a readable writable stream.

    function through (write, end, opts) {
      write = write || function (data) { this.queue(data); };
      end = end || function () { this.queue(null); };

      var ended = false, destroyed = false, buffer = [], _ended = false;
      var stream = new Stream();
      stream.readable = stream.writable = true;
      stream.paused = false;

    //  stream.autoPause   = !(opts && opts.autoPause   === false)
      stream.autoDestroy = !(opts && opts.autoDestroy === false);

      stream.write = function (data) {
        write.call(this, data);
        return !stream.paused
      };

      function drain() {
        while(buffer.length && !stream.paused) {
          var data = buffer.shift();
          if(null === data)
            return stream.emit('end')
          else
            stream.emit('data', data);
        }
      }

      stream.queue = stream.push = function (data) {
    //    console.error(ended)
        if(_ended) return stream
        if(data === null) _ended = true;
        buffer.push(data);
        drain();
        return stream
      };

      //this will be registered as the first 'end' listener
      //must call destroy next tick, to make sure we're after any
      //stream piped from here.
      //this is only a problem if end is not emitted synchronously.
      //a nicer way to do this is to make sure this is the last listener for 'end'

      stream.on('end', function () {
        stream.readable = false;
        if(!stream.writable && stream.autoDestroy)
          process.nextTick(function () {
            stream.destroy();
          });
      });

      function _end () {
        stream.writable = false;
        end.call(stream);
        if(!stream.readable && stream.autoDestroy)
          stream.destroy();
      }

      stream.end = function (data) {
        if(ended) return
        ended = true;
        if(arguments.length) stream.write(data);
        _end(); // will emit or queue
        return stream
      };

      stream.destroy = function () {
        if(destroyed) return
        destroyed = true;
        ended = true;
        buffer.length = 0;
        stream.writable = stream.readable = false;
        stream.emit('close');
        return stream
      };

      stream.pause = function () {
        if(stream.paused) return
        stream.paused = true;
        return stream
      };

      stream.resume = function () {
        if(stream.paused) {
          stream.paused = false;
          stream.emit('resume');
        }
        drain();
        //may have become paused again,
        //as drain emits 'data'.
        if(!stream.paused)
          stream.emit('drain');
        return stream
      };
      return stream
    }
    }(through$1));

    /** Detect free variable `global` from Node.js. */

    var freeGlobal$1 = typeof commonjsGlobal == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;

    var _freeGlobal = freeGlobal$1;

    var freeGlobal = _freeGlobal;

    /** Detect free variable `self`. */
    var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

    /** Used as a reference to the global object. */
    var root$8 = freeGlobal || freeSelf || Function('return this')();

    var _root = root$8;

    var root$7 = _root;

    /** Built-in value references. */
    var Symbol$7 = root$7.Symbol;

    var _Symbol = Symbol$7;

    var Symbol$6 = _Symbol;

    /** Used for built-in method references. */
    var objectProto$i = Object.prototype;

    /** Used to check objects for own properties. */
    var hasOwnProperty$e = objectProto$i.hasOwnProperty;

    /**
     * Used to resolve the
     * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
     * of values.
     */
    var nativeObjectToString$1 = objectProto$i.toString;

    /** Built-in value references. */
    var symToStringTag$1 = Symbol$6 ? Symbol$6.toStringTag : undefined;

    /**
     * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the raw `toStringTag`.
     */
    function getRawTag$1(value) {
      var isOwn = hasOwnProperty$e.call(value, symToStringTag$1),
          tag = value[symToStringTag$1];

      try {
        value[symToStringTag$1] = undefined;
        var unmasked = true;
      } catch (e) {}

      var result = nativeObjectToString$1.call(value);
      if (unmasked) {
        if (isOwn) {
          value[symToStringTag$1] = tag;
        } else {
          delete value[symToStringTag$1];
        }
      }
      return result;
    }

    var _getRawTag = getRawTag$1;

    /** Used for built-in method references. */

    var objectProto$h = Object.prototype;

    /**
     * Used to resolve the
     * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
     * of values.
     */
    var nativeObjectToString = objectProto$h.toString;

    /**
     * Converts `value` to a string using `Object.prototype.toString`.
     *
     * @private
     * @param {*} value The value to convert.
     * @returns {string} Returns the converted string.
     */
    function objectToString$1(value) {
      return nativeObjectToString.call(value);
    }

    var _objectToString = objectToString$1;

    var Symbol$5 = _Symbol,
        getRawTag = _getRawTag,
        objectToString = _objectToString;

    /** `Object#toString` result references. */
    var nullTag = '[object Null]',
        undefinedTag = '[object Undefined]';

    /** Built-in value references. */
    var symToStringTag = Symbol$5 ? Symbol$5.toStringTag : undefined;

    /**
     * The base implementation of `getTag` without fallbacks for buggy environments.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the `toStringTag`.
     */
    function baseGetTag$9(value) {
      if (value == null) {
        return value === undefined ? undefinedTag : nullTag;
      }
      return (symToStringTag && symToStringTag in Object(value))
        ? getRawTag(value)
        : objectToString(value);
    }

    var _baseGetTag = baseGetTag$9;

    /**
     * Checks if `value` is the
     * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
     * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an object, else `false`.
     * @example
     *
     * _.isObject({});
     * // => true
     *
     * _.isObject([1, 2, 3]);
     * // => true
     *
     * _.isObject(_.noop);
     * // => true
     *
     * _.isObject(null);
     * // => false
     */

    function isObject$9(value) {
      var type = typeof value;
      return value != null && (type == 'object' || type == 'function');
    }

    var isObject_1 = isObject$9;

    var baseGetTag$8 = _baseGetTag,
        isObject$8 = isObject_1;

    /** `Object#toString` result references. */
    var asyncTag = '[object AsyncFunction]',
        funcTag$2 = '[object Function]',
        genTag$1 = '[object GeneratorFunction]',
        proxyTag = '[object Proxy]';

    /**
     * Checks if `value` is classified as a `Function` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a function, else `false`.
     * @example
     *
     * _.isFunction(_);
     * // => true
     *
     * _.isFunction(/abc/);
     * // => false
     */
    function isFunction$3(value) {
      if (!isObject$8(value)) {
        return false;
      }
      // The use of `Object#toString` avoids issues with the `typeof` operator
      // in Safari 9 which returns 'object' for typed arrays and other constructors.
      var tag = baseGetTag$8(value);
      return tag == funcTag$2 || tag == genTag$1 || tag == asyncTag || tag == proxyTag;
    }

    var isFunction_1 = isFunction$3;

    var root$6 = _root;

    /** Used to detect overreaching core-js shims. */
    var coreJsData$1 = root$6['__core-js_shared__'];

    var _coreJsData = coreJsData$1;

    var coreJsData = _coreJsData;

    /** Used to detect methods masquerading as native. */
    var maskSrcKey = (function() {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
      return uid ? ('Symbol(src)_1.' + uid) : '';
    }());

    /**
     * Checks if `func` has its source masked.
     *
     * @private
     * @param {Function} func The function to check.
     * @returns {boolean} Returns `true` if `func` is masked, else `false`.
     */
    function isMasked$1(func) {
      return !!maskSrcKey && (maskSrcKey in func);
    }

    var _isMasked = isMasked$1;

    /** Used for built-in method references. */

    var funcProto$2 = Function.prototype;

    /** Used to resolve the decompiled source of functions. */
    var funcToString$2 = funcProto$2.toString;

    /**
     * Converts `func` to its source code.
     *
     * @private
     * @param {Function} func The function to convert.
     * @returns {string} Returns the source code.
     */
    function toSource$2(func) {
      if (func != null) {
        try {
          return funcToString$2.call(func);
        } catch (e) {}
        try {
          return (func + '');
        } catch (e) {}
      }
      return '';
    }

    var _toSource = toSource$2;

    var isFunction$2 = isFunction_1,
        isMasked = _isMasked,
        isObject$7 = isObject_1,
        toSource$1 = _toSource;

    /**
     * Used to match `RegExp`
     * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
     */
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

    /** Used to detect host constructors (Safari). */
    var reIsHostCtor = /^\[object .+?Constructor\]$/;

    /** Used for built-in method references. */
    var funcProto$1 = Function.prototype,
        objectProto$g = Object.prototype;

    /** Used to resolve the decompiled source of functions. */
    var funcToString$1 = funcProto$1.toString;

    /** Used to check objects for own properties. */
    var hasOwnProperty$d = objectProto$g.hasOwnProperty;

    /** Used to detect if a method is native. */
    var reIsNative = RegExp('^' +
      funcToString$1.call(hasOwnProperty$d).replace(reRegExpChar, '\\$&')
      .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
    );

    /**
     * The base implementation of `_.isNative` without bad shim checks.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a native function,
     *  else `false`.
     */
    function baseIsNative$1(value) {
      if (!isObject$7(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction$2(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource$1(value));
    }

    var _baseIsNative = baseIsNative$1;

    /**
     * Gets the value at `key` of `object`.
     *
     * @private
     * @param {Object} [object] The object to query.
     * @param {string} key The key of the property to get.
     * @returns {*} Returns the property value.
     */

    function getValue$1(object, key) {
      return object == null ? undefined : object[key];
    }

    var _getValue = getValue$1;

    var baseIsNative = _baseIsNative,
        getValue = _getValue;

    /**
     * Gets the native function at `key` of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {string} key The key of the method to get.
     * @returns {*} Returns the function if it's native, else `undefined`.
     */
    function getNative$7(object, key) {
      var value = getValue(object, key);
      return baseIsNative(value) ? value : undefined;
    }

    var _getNative = getNative$7;

    var getNative$6 = _getNative;

    var defineProperty$2 = (function() {
      try {
        var func = getNative$6(Object, 'defineProperty');
        func({}, '', {});
        return func;
      } catch (e) {}
    }());

    var _defineProperty = defineProperty$2;

    var defineProperty$1 = _defineProperty;

    /**
     * The base implementation of `assignValue` and `assignMergeValue` without
     * value checks.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {string} key The key of the property to assign.
     * @param {*} value The value to assign.
     */
    function baseAssignValue$2(object, key, value) {
      if (key == '__proto__' && defineProperty$1) {
        defineProperty$1(object, key, {
          'configurable': true,
          'enumerable': true,
          'value': value,
          'writable': true
        });
      } else {
        object[key] = value;
      }
    }

    var _baseAssignValue = baseAssignValue$2;

    /**
     * Performs a
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * comparison between two values to determine if they are equivalent.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * var object = { 'a': 1 };
     * var other = { 'a': 1 };
     *
     * _.eq(object, object);
     * // => true
     *
     * _.eq(object, other);
     * // => false
     *
     * _.eq('a', 'a');
     * // => true
     *
     * _.eq('a', Object('a'));
     * // => false
     *
     * _.eq(NaN, NaN);
     * // => true
     */

    function eq$5(value, other) {
      return value === other || (value !== value && other !== other);
    }

    var eq_1 = eq$5;

    var baseAssignValue$1 = _baseAssignValue,
        eq$4 = eq_1;

    /** Used for built-in method references. */
    var objectProto$f = Object.prototype;

    /** Used to check objects for own properties. */
    var hasOwnProperty$c = objectProto$f.hasOwnProperty;

    /**
     * Assigns `value` to `key` of `object` if the existing value is not equivalent
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {string} key The key of the property to assign.
     * @param {*} value The value to assign.
     */
    function assignValue$4(object, key, value) {
      var objValue = object[key];
      if (!(hasOwnProperty$c.call(object, key) && eq$4(objValue, value)) ||
          (value === undefined && !(key in object))) {
        baseAssignValue$1(object, key, value);
      }
    }

    var _assignValue = assignValue$4;

    var assignValue$3 = _assignValue,
        baseAssignValue = _baseAssignValue;

    /**
     * Copies properties of `source` to `object`.
     *
     * @private
     * @param {Object} source The object to copy properties from.
     * @param {Array} props The property identifiers to copy.
     * @param {Object} [object={}] The object to copy properties to.
     * @param {Function} [customizer] The function to customize copied values.
     * @returns {Object} Returns `object`.
     */
    function copyObject$7(source, props, object, customizer) {
      var isNew = !object;
      object || (object = {});

      var index = -1,
          length = props.length;

      while (++index < length) {
        var key = props[index];

        var newValue = customizer
          ? customizer(object[key], source[key], key, object, source)
          : undefined;

        if (newValue === undefined) {
          newValue = source[key];
        }
        if (isNew) {
          baseAssignValue(object, key, newValue);
        } else {
          assignValue$3(object, key, newValue);
        }
      }
      return object;
    }

    var _copyObject = copyObject$7;

    /**
     * This method returns the first argument it receives.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {*} value Any value.
     * @returns {*} Returns `value`.
     * @example
     *
     * var object = { 'a': 1 };
     *
     * console.log(_.identity(object) === object);
     * // => true
     */

    function identity$5(value) {
      return value;
    }

    var identity_1 = identity$5;

    /**
     * A faster alternative to `Function#apply`, this function invokes `func`
     * with the `this` binding of `thisArg` and the arguments of `args`.
     *
     * @private
     * @param {Function} func The function to invoke.
     * @param {*} thisArg The `this` binding of `func`.
     * @param {Array} args The arguments to invoke `func` with.
     * @returns {*} Returns the result of `func`.
     */

    function apply$1(func, thisArg, args) {
      switch (args.length) {
        case 0: return func.call(thisArg);
        case 1: return func.call(thisArg, args[0]);
        case 2: return func.call(thisArg, args[0], args[1]);
        case 3: return func.call(thisArg, args[0], args[1], args[2]);
      }
      return func.apply(thisArg, args);
    }

    var _apply = apply$1;

    var apply = _apply;

    /* Built-in method references for those with the same name as other `lodash` methods. */
    var nativeMax$1 = Math.max;

    /**
     * A specialized version of `baseRest` which transforms the rest array.
     *
     * @private
     * @param {Function} func The function to apply a rest parameter to.
     * @param {number} [start=func.length-1] The start position of the rest parameter.
     * @param {Function} transform The rest array transform.
     * @returns {Function} Returns the new function.
     */
    function overRest$2(func, start, transform) {
      start = nativeMax$1(start === undefined ? (func.length - 1) : start, 0);
      return function() {
        var args = arguments,
            index = -1,
            length = nativeMax$1(args.length - start, 0),
            array = Array(length);

        while (++index < length) {
          array[index] = args[start + index];
        }
        index = -1;
        var otherArgs = Array(start + 1);
        while (++index < start) {
          otherArgs[index] = args[index];
        }
        otherArgs[start] = transform(array);
        return apply(func, this, otherArgs);
      };
    }

    var _overRest = overRest$2;

    /**
     * Creates a function that returns `value`.
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Util
     * @param {*} value The value to return from the new function.
     * @returns {Function} Returns the new constant function.
     * @example
     *
     * var objects = _.times(2, _.constant({ 'a': 1 }));
     *
     * console.log(objects);
     * // => [{ 'a': 1 }, { 'a': 1 }]
     *
     * console.log(objects[0] === objects[1]);
     * // => true
     */

    function constant$1(value) {
      return function() {
        return value;
      };
    }

    var constant_1 = constant$1;

    var constant = constant_1,
        defineProperty = _defineProperty,
        identity$4 = identity_1;

    /**
     * The base implementation of `setToString` without support for hot loop shorting.
     *
     * @private
     * @param {Function} func The function to modify.
     * @param {Function} string The `toString` result.
     * @returns {Function} Returns `func`.
     */
    var baseSetToString$1 = !defineProperty ? identity$4 : function(func, string) {
      return defineProperty(func, 'toString', {
        'configurable': true,
        'enumerable': false,
        'value': constant(string),
        'writable': true
      });
    };

    var _baseSetToString = baseSetToString$1;

    /** Used to detect hot functions by number of calls within a span of milliseconds. */

    var HOT_COUNT = 800,
        HOT_SPAN = 16;

    /* Built-in method references for those with the same name as other `lodash` methods. */
    var nativeNow = Date.now;

    /**
     * Creates a function that'll short out and invoke `identity` instead
     * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
     * milliseconds.
     *
     * @private
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new shortable function.
     */
    function shortOut$1(func) {
      var count = 0,
          lastCalled = 0;

      return function() {
        var stamp = nativeNow(),
            remaining = HOT_SPAN - (stamp - lastCalled);

        lastCalled = stamp;
        if (remaining > 0) {
          if (++count >= HOT_COUNT) {
            return arguments[0];
          }
        } else {
          count = 0;
        }
        return func.apply(undefined, arguments);
      };
    }

    var _shortOut = shortOut$1;

    var baseSetToString = _baseSetToString,
        shortOut = _shortOut;

    /**
     * Sets the `toString` method of `func` to return `string`.
     *
     * @private
     * @param {Function} func The function to modify.
     * @param {Function} string The `toString` result.
     * @returns {Function} Returns `func`.
     */
    var setToString$2 = shortOut(baseSetToString);

    var _setToString = setToString$2;

    var identity$3 = identity_1,
        overRest$1 = _overRest,
        setToString$1 = _setToString;

    /**
     * The base implementation of `_.rest` which doesn't validate or coerce arguments.
     *
     * @private
     * @param {Function} func The function to apply a rest parameter to.
     * @param {number} [start=func.length-1] The start position of the rest parameter.
     * @returns {Function} Returns the new function.
     */
    function baseRest$2(func, start) {
      return setToString$1(overRest$1(func, start, identity$3), func + '');
    }

    var _baseRest = baseRest$2;

    /** Used as references for various `Number` constants. */

    var MAX_SAFE_INTEGER$1 = 9007199254740991;

    /**
     * Checks if `value` is a valid array-like length.
     *
     * **Note:** This method is loosely based on
     * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
     * @example
     *
     * _.isLength(3);
     * // => true
     *
     * _.isLength(Number.MIN_VALUE);
     * // => false
     *
     * _.isLength(Infinity);
     * // => false
     *
     * _.isLength('3');
     * // => false
     */
    function isLength$3(value) {
      return typeof value == 'number' &&
        value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER$1;
    }

    var isLength_1 = isLength$3;

    var isFunction$1 = isFunction_1,
        isLength$2 = isLength_1;

    /**
     * Checks if `value` is array-like. A value is considered array-like if it's
     * not a function and has a `value.length` that's an integer greater than or
     * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
     * @example
     *
     * _.isArrayLike([1, 2, 3]);
     * // => true
     *
     * _.isArrayLike(document.body.children);
     * // => true
     *
     * _.isArrayLike('abc');
     * // => true
     *
     * _.isArrayLike(_.noop);
     * // => false
     */
    function isArrayLike$8(value) {
      return value != null && isLength$2(value.length) && !isFunction$1(value);
    }

    var isArrayLike_1 = isArrayLike$8;

    /** Used as references for various `Number` constants. */

    var MAX_SAFE_INTEGER = 9007199254740991;

    /** Used to detect unsigned integer values. */
    var reIsUint = /^(?:0|[1-9]\d*)$/;

    /**
     * Checks if `value` is a valid array-like index.
     *
     * @private
     * @param {*} value The value to check.
     * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
     * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
     */
    function isIndex$4(value, length) {
      var type = typeof value;
      length = length == null ? MAX_SAFE_INTEGER : length;

      return !!length &&
        (type == 'number' ||
          (type != 'symbol' && reIsUint.test(value))) &&
            (value > -1 && value % 1 == 0 && value < length);
    }

    var _isIndex = isIndex$4;

    var eq$3 = eq_1,
        isArrayLike$7 = isArrayLike_1,
        isIndex$3 = _isIndex,
        isObject$6 = isObject_1;

    /**
     * Checks if the given arguments are from an iteratee call.
     *
     * @private
     * @param {*} value The potential iteratee value argument.
     * @param {*} index The potential iteratee index or key argument.
     * @param {*} object The potential iteratee object argument.
     * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
     *  else `false`.
     */
    function isIterateeCall$2(value, index, object) {
      if (!isObject$6(object)) {
        return false;
      }
      var type = typeof index;
      if (type == 'number'
            ? (isArrayLike$7(object) && isIndex$3(index, object.length))
            : (type == 'string' && index in object)
          ) {
        return eq$3(object[index], value);
      }
      return false;
    }

    var _isIterateeCall = isIterateeCall$2;

    var baseRest$1 = _baseRest,
        isIterateeCall$1 = _isIterateeCall;

    /**
     * Creates a function like `_.assign`.
     *
     * @private
     * @param {Function} assigner The function to assign values.
     * @returns {Function} Returns the new assigner function.
     */
    function createAssigner$2(assigner) {
      return baseRest$1(function(object, sources) {
        var index = -1,
            length = sources.length,
            customizer = length > 1 ? sources[length - 1] : undefined,
            guard = length > 2 ? sources[2] : undefined;

        customizer = (assigner.length > 3 && typeof customizer == 'function')
          ? (length--, customizer)
          : undefined;

        if (guard && isIterateeCall$1(sources[0], sources[1], guard)) {
          customizer = length < 3 ? undefined : customizer;
          length = 1;
        }
        object = Object(object);
        while (++index < length) {
          var source = sources[index];
          if (source) {
            assigner(object, source, index, customizer);
          }
        }
        return object;
      });
    }

    var _createAssigner = createAssigner$2;

    /**
     * The base implementation of `_.times` without support for iteratee shorthands
     * or max array length checks.
     *
     * @private
     * @param {number} n The number of times to invoke `iteratee`.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns the array of results.
     */

    function baseTimes$1(n, iteratee) {
      var index = -1,
          result = Array(n);

      while (++index < n) {
        result[index] = iteratee(index);
      }
      return result;
    }

    var _baseTimes = baseTimes$1;

    /**
     * Checks if `value` is object-like. A value is object-like if it's not `null`
     * and has a `typeof` result of "object".
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
     * @example
     *
     * _.isObjectLike({});
     * // => true
     *
     * _.isObjectLike([1, 2, 3]);
     * // => true
     *
     * _.isObjectLike(_.noop);
     * // => false
     *
     * _.isObjectLike(null);
     * // => false
     */

    function isObjectLike$b(value) {
      return value != null && typeof value == 'object';
    }

    var isObjectLike_1 = isObjectLike$b;

    var baseGetTag$7 = _baseGetTag,
        isObjectLike$a = isObjectLike_1;

    /** `Object#toString` result references. */
    var argsTag$3 = '[object Arguments]';

    /**
     * The base implementation of `_.isArguments`.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an `arguments` object,
     */
    function baseIsArguments$1(value) {
      return isObjectLike$a(value) && baseGetTag$7(value) == argsTag$3;
    }

    var _baseIsArguments = baseIsArguments$1;

    var baseIsArguments = _baseIsArguments,
        isObjectLike$9 = isObjectLike_1;

    /** Used for built-in method references. */
    var objectProto$e = Object.prototype;

    /** Used to check objects for own properties. */
    var hasOwnProperty$b = objectProto$e.hasOwnProperty;

    /** Built-in value references. */
    var propertyIsEnumerable$1 = objectProto$e.propertyIsEnumerable;

    /**
     * Checks if `value` is likely an `arguments` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an `arguments` object,
     *  else `false`.
     * @example
     *
     * _.isArguments(function() { return arguments; }());
     * // => true
     *
     * _.isArguments([1, 2, 3]);
     * // => false
     */
    var isArguments$3 = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
      return isObjectLike$9(value) && hasOwnProperty$b.call(value, 'callee') &&
        !propertyIsEnumerable$1.call(value, 'callee');
    };

    var isArguments_1 = isArguments$3;

    /**
     * Checks if `value` is classified as an `Array` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array, else `false`.
     * @example
     *
     * _.isArray([1, 2, 3]);
     * // => true
     *
     * _.isArray(document.body.children);
     * // => false
     *
     * _.isArray('abc');
     * // => false
     *
     * _.isArray(_.noop);
     * // => false
     */

    var isArray$h = Array.isArray;

    var isArray_1 = isArray$h;

    var isBuffer$3 = {exports: {}};

    /**
     * This method returns `false`.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {boolean} Returns `false`.
     * @example
     *
     * _.times(2, _.stubFalse);
     * // => [false, false]
     */

    function stubFalse() {
      return false;
    }

    var stubFalse_1 = stubFalse;

    (function (module, exports) {
    var root = _root,
        stubFalse = stubFalse_1;

    /** Detect free variable `exports`. */
    var freeExports = exports && !exports.nodeType && exports;

    /** Detect free variable `module`. */
    var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;

    /** Detect the popular CommonJS extension `module.exports`. */
    var moduleExports = freeModule && freeModule.exports === freeExports;

    /** Built-in value references. */
    var Buffer = moduleExports ? root.Buffer : undefined;

    /* Built-in method references for those with the same name as other `lodash` methods. */
    var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;

    /**
     * Checks if `value` is a buffer.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
     * @example
     *
     * _.isBuffer(new Buffer(2));
     * // => true
     *
     * _.isBuffer(new Uint8Array(2));
     * // => false
     */
    var isBuffer = nativeIsBuffer || stubFalse;

    module.exports = isBuffer;
    }(isBuffer$3, isBuffer$3.exports));

    var baseGetTag$6 = _baseGetTag,
        isLength$1 = isLength_1,
        isObjectLike$8 = isObjectLike_1;

    /** `Object#toString` result references. */
    var argsTag$2 = '[object Arguments]',
        arrayTag$2 = '[object Array]',
        boolTag$4 = '[object Boolean]',
        dateTag$3 = '[object Date]',
        errorTag$2 = '[object Error]',
        funcTag$1 = '[object Function]',
        mapTag$5 = '[object Map]',
        numberTag$4 = '[object Number]',
        objectTag$4 = '[object Object]',
        regexpTag$3 = '[object RegExp]',
        setTag$5 = '[object Set]',
        stringTag$4 = '[object String]',
        weakMapTag$2 = '[object WeakMap]';

    var arrayBufferTag$3 = '[object ArrayBuffer]',
        dataViewTag$4 = '[object DataView]',
        float32Tag$2 = '[object Float32Array]',
        float64Tag$2 = '[object Float64Array]',
        int8Tag$2 = '[object Int8Array]',
        int16Tag$2 = '[object Int16Array]',
        int32Tag$2 = '[object Int32Array]',
        uint8Tag$2 = '[object Uint8Array]',
        uint8ClampedTag$2 = '[object Uint8ClampedArray]',
        uint16Tag$2 = '[object Uint16Array]',
        uint32Tag$2 = '[object Uint32Array]';

    /** Used to identify `toStringTag` values of typed arrays. */
    var typedArrayTags = {};
    typedArrayTags[float32Tag$2] = typedArrayTags[float64Tag$2] =
    typedArrayTags[int8Tag$2] = typedArrayTags[int16Tag$2] =
    typedArrayTags[int32Tag$2] = typedArrayTags[uint8Tag$2] =
    typedArrayTags[uint8ClampedTag$2] = typedArrayTags[uint16Tag$2] =
    typedArrayTags[uint32Tag$2] = true;
    typedArrayTags[argsTag$2] = typedArrayTags[arrayTag$2] =
    typedArrayTags[arrayBufferTag$3] = typedArrayTags[boolTag$4] =
    typedArrayTags[dataViewTag$4] = typedArrayTags[dateTag$3] =
    typedArrayTags[errorTag$2] = typedArrayTags[funcTag$1] =
    typedArrayTags[mapTag$5] = typedArrayTags[numberTag$4] =
    typedArrayTags[objectTag$4] = typedArrayTags[regexpTag$3] =
    typedArrayTags[setTag$5] = typedArrayTags[stringTag$4] =
    typedArrayTags[weakMapTag$2] = false;

    /**
     * The base implementation of `_.isTypedArray` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
     */
    function baseIsTypedArray$1(value) {
      return isObjectLike$8(value) &&
        isLength$1(value.length) && !!typedArrayTags[baseGetTag$6(value)];
    }

    var _baseIsTypedArray = baseIsTypedArray$1;

    /**
     * The base implementation of `_.unary` without support for storing metadata.
     *
     * @private
     * @param {Function} func The function to cap arguments for.
     * @returns {Function} Returns the new capped function.
     */

    function baseUnary$3(func) {
      return function(value) {
        return func(value);
      };
    }

    var _baseUnary = baseUnary$3;

    var _nodeUtil = {exports: {}};

    (function (module, exports) {
    var freeGlobal = _freeGlobal;

    /** Detect free variable `exports`. */
    var freeExports = exports && !exports.nodeType && exports;

    /** Detect free variable `module`. */
    var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;

    /** Detect the popular CommonJS extension `module.exports`. */
    var moduleExports = freeModule && freeModule.exports === freeExports;

    /** Detect free variable `process` from Node.js. */
    var freeProcess = moduleExports && freeGlobal.process;

    /** Used to access faster Node.js helpers. */
    var nodeUtil = (function() {
      try {
        // Use `util.types` for Node.js 10+.
        var types = freeModule && freeModule.require && freeModule.require('util').types;

        if (types) {
          return types;
        }

        // Legacy `process.binding('util')` for Node.js < 10.
        return freeProcess && freeProcess.binding && freeProcess.binding('util');
      } catch (e) {}
    }());

    module.exports = nodeUtil;
    }(_nodeUtil, _nodeUtil.exports));

    var baseIsTypedArray = _baseIsTypedArray,
        baseUnary$2 = _baseUnary,
        nodeUtil$2 = _nodeUtil.exports;

    /* Node.js helper references. */
    var nodeIsTypedArray = nodeUtil$2 && nodeUtil$2.isTypedArray;

    /**
     * Checks if `value` is classified as a typed array.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
     * @example
     *
     * _.isTypedArray(new Uint8Array);
     * // => true
     *
     * _.isTypedArray([]);
     * // => false
     */
    var isTypedArray$2 = nodeIsTypedArray ? baseUnary$2(nodeIsTypedArray) : baseIsTypedArray;

    var isTypedArray_1 = isTypedArray$2;

    var baseTimes = _baseTimes,
        isArguments$2 = isArguments_1,
        isArray$g = isArray_1,
        isBuffer$2 = isBuffer$3.exports,
        isIndex$2 = _isIndex,
        isTypedArray$1 = isTypedArray_1;

    /** Used for built-in method references. */
    var objectProto$d = Object.prototype;

    /** Used to check objects for own properties. */
    var hasOwnProperty$a = objectProto$d.hasOwnProperty;

    /**
     * Creates an array of the enumerable property names of the array-like `value`.
     *
     * @private
     * @param {*} value The value to query.
     * @param {boolean} inherited Specify returning inherited property names.
     * @returns {Array} Returns the array of property names.
     */
    function arrayLikeKeys$2(value, inherited) {
      var isArr = isArray$g(value),
          isArg = !isArr && isArguments$2(value),
          isBuff = !isArr && !isArg && isBuffer$2(value),
          isType = !isArr && !isArg && !isBuff && isTypedArray$1(value),
          skipIndexes = isArr || isArg || isBuff || isType,
          result = skipIndexes ? baseTimes(value.length, String) : [],
          length = result.length;

      for (var key in value) {
        if ((inherited || hasOwnProperty$a.call(value, key)) &&
            !(skipIndexes && (
               // Safari 9 has enumerable `arguments.length` in strict mode.
               key == 'length' ||
               // Node.js 0.10 has enumerable non-index properties on buffers.
               (isBuff && (key == 'offset' || key == 'parent')) ||
               // PhantomJS 2 has enumerable non-index properties on typed arrays.
               (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
               // Skip index properties.
               isIndex$2(key, length)
            ))) {
          result.push(key);
        }
      }
      return result;
    }

    var _arrayLikeKeys = arrayLikeKeys$2;

    /** Used for built-in method references. */

    var objectProto$c = Object.prototype;

    /**
     * Checks if `value` is likely a prototype object.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
     */
    function isPrototype$4(value) {
      var Ctor = value && value.constructor,
          proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto$c;

      return value === proto;
    }

    var _isPrototype = isPrototype$4;

    /**
     * This function is like
     * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
     * except that it includes inherited enumerable properties.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     */

    function nativeKeysIn$1(object) {
      var result = [];
      if (object != null) {
        for (var key in Object(object)) {
          result.push(key);
        }
      }
      return result;
    }

    var _nativeKeysIn = nativeKeysIn$1;

    var isObject$5 = isObject_1,
        isPrototype$3 = _isPrototype,
        nativeKeysIn = _nativeKeysIn;

    /** Used for built-in method references. */
    var objectProto$b = Object.prototype;

    /** Used to check objects for own properties. */
    var hasOwnProperty$9 = objectProto$b.hasOwnProperty;

    /**
     * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     */
    function baseKeysIn$1(object) {
      if (!isObject$5(object)) {
        return nativeKeysIn(object);
      }
      var isProto = isPrototype$3(object),
          result = [];

      for (var key in object) {
        if (!(key == 'constructor' && (isProto || !hasOwnProperty$9.call(object, key)))) {
          result.push(key);
        }
      }
      return result;
    }

    var _baseKeysIn = baseKeysIn$1;

    var arrayLikeKeys$1 = _arrayLikeKeys,
        baseKeysIn = _baseKeysIn,
        isArrayLike$6 = isArrayLike_1;

    /**
     * Creates an array of the own and inherited enumerable property names of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.keysIn(new Foo);
     * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
     */
    function keysIn$5(object) {
      return isArrayLike$6(object) ? arrayLikeKeys$1(object, true) : baseKeysIn(object);
    }

    var keysIn_1 = keysIn$5;

    var copyObject$6 = _copyObject,
        createAssigner$1 = _createAssigner,
        keysIn$4 = keysIn_1;

    /**
     * This method is like `_.assign` except that it iterates over own and
     * inherited source properties.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @alias extend
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @see _.assign
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     * }
     *
     * function Bar() {
     *   this.c = 3;
     * }
     *
     * Foo.prototype.b = 2;
     * Bar.prototype.d = 4;
     *
     * _.assignIn({ 'a': 0 }, new Foo, new Bar);
     * // => { 'a': 1, 'b': 2, 'c': 3, 'd': 4 }
     */
    var assignIn = createAssigner$1(function(object, source) {
      copyObject$6(source, keysIn$4(source), object);
    });

    var assignIn_1 = assignIn;

    var extend$1 = assignIn_1;

    /**
     * A specialized version of `_.map` for arrays without support for iteratee
     * shorthands.
     *
     * @private
     * @param {Array} [array] The array to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns the new mapped array.
     */

    function arrayMap$3(array, iteratee) {
      var index = -1,
          length = array == null ? 0 : array.length,
          result = Array(length);

      while (++index < length) {
        result[index] = iteratee(array[index], index, array);
      }
      return result;
    }

    var _arrayMap = arrayMap$3;

    /**
     * Removes all key-value entries from the list cache.
     *
     * @private
     * @name clear
     * @memberOf ListCache
     */

    function listCacheClear$1() {
      this.__data__ = [];
      this.size = 0;
    }

    var _listCacheClear = listCacheClear$1;

    var eq$2 = eq_1;

    /**
     * Gets the index at which the `key` is found in `array` of key-value pairs.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {*} key The key to search for.
     * @returns {number} Returns the index of the matched value, else `-1`.
     */
    function assocIndexOf$4(array, key) {
      var length = array.length;
      while (length--) {
        if (eq$2(array[length][0], key)) {
          return length;
        }
      }
      return -1;
    }

    var _assocIndexOf = assocIndexOf$4;

    var assocIndexOf$3 = _assocIndexOf;

    /** Used for built-in method references. */
    var arrayProto = Array.prototype;

    /** Built-in value references. */
    var splice = arrayProto.splice;

    /**
     * Removes `key` and its value from the list cache.
     *
     * @private
     * @name delete
     * @memberOf ListCache
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */
    function listCacheDelete$1(key) {
      var data = this.__data__,
          index = assocIndexOf$3(data, key);

      if (index < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index, 1);
      }
      --this.size;
      return true;
    }

    var _listCacheDelete = listCacheDelete$1;

    var assocIndexOf$2 = _assocIndexOf;

    /**
     * Gets the list cache value for `key`.
     *
     * @private
     * @name get
     * @memberOf ListCache
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */
    function listCacheGet$1(key) {
      var data = this.__data__,
          index = assocIndexOf$2(data, key);

      return index < 0 ? undefined : data[index][1];
    }

    var _listCacheGet = listCacheGet$1;

    var assocIndexOf$1 = _assocIndexOf;

    /**
     * Checks if a list cache value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf ListCache
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function listCacheHas$1(key) {
      return assocIndexOf$1(this.__data__, key) > -1;
    }

    var _listCacheHas = listCacheHas$1;

    var assocIndexOf = _assocIndexOf;

    /**
     * Sets the list cache `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf ListCache
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the list cache instance.
     */
    function listCacheSet$1(key, value) {
      var data = this.__data__,
          index = assocIndexOf(data, key);

      if (index < 0) {
        ++this.size;
        data.push([key, value]);
      } else {
        data[index][1] = value;
      }
      return this;
    }

    var _listCacheSet = listCacheSet$1;

    var listCacheClear = _listCacheClear,
        listCacheDelete = _listCacheDelete,
        listCacheGet = _listCacheGet,
        listCacheHas = _listCacheHas,
        listCacheSet = _listCacheSet;

    /**
     * Creates an list cache object.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */
    function ListCache$4(entries) {
      var index = -1,
          length = entries == null ? 0 : entries.length;

      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }

    // Add methods to `ListCache`.
    ListCache$4.prototype.clear = listCacheClear;
    ListCache$4.prototype['delete'] = listCacheDelete;
    ListCache$4.prototype.get = listCacheGet;
    ListCache$4.prototype.has = listCacheHas;
    ListCache$4.prototype.set = listCacheSet;

    var _ListCache = ListCache$4;

    var ListCache$3 = _ListCache;

    /**
     * Removes all key-value entries from the stack.
     *
     * @private
     * @name clear
     * @memberOf Stack
     */
    function stackClear$1() {
      this.__data__ = new ListCache$3;
      this.size = 0;
    }

    var _stackClear = stackClear$1;

    /**
     * Removes `key` and its value from the stack.
     *
     * @private
     * @name delete
     * @memberOf Stack
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */

    function stackDelete$1(key) {
      var data = this.__data__,
          result = data['delete'](key);

      this.size = data.size;
      return result;
    }

    var _stackDelete = stackDelete$1;

    /**
     * Gets the stack value for `key`.
     *
     * @private
     * @name get
     * @memberOf Stack
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */

    function stackGet$1(key) {
      return this.__data__.get(key);
    }

    var _stackGet = stackGet$1;

    /**
     * Checks if a stack value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf Stack
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */

    function stackHas$1(key) {
      return this.__data__.has(key);
    }

    var _stackHas = stackHas$1;

    var getNative$5 = _getNative,
        root$5 = _root;

    /* Built-in method references that are verified to be native. */
    var Map$4 = getNative$5(root$5, 'Map');

    var _Map = Map$4;

    var getNative$4 = _getNative;

    /* Built-in method references that are verified to be native. */
    var nativeCreate$4 = getNative$4(Object, 'create');

    var _nativeCreate = nativeCreate$4;

    var nativeCreate$3 = _nativeCreate;

    /**
     * Removes all key-value entries from the hash.
     *
     * @private
     * @name clear
     * @memberOf Hash
     */
    function hashClear$1() {
      this.__data__ = nativeCreate$3 ? nativeCreate$3(null) : {};
      this.size = 0;
    }

    var _hashClear = hashClear$1;

    /**
     * Removes `key` and its value from the hash.
     *
     * @private
     * @name delete
     * @memberOf Hash
     * @param {Object} hash The hash to modify.
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */

    function hashDelete$1(key) {
      var result = this.has(key) && delete this.__data__[key];
      this.size -= result ? 1 : 0;
      return result;
    }

    var _hashDelete = hashDelete$1;

    var nativeCreate$2 = _nativeCreate;

    /** Used to stand-in for `undefined` hash values. */
    var HASH_UNDEFINED$2 = '__lodash_hash_undefined__';

    /** Used for built-in method references. */
    var objectProto$a = Object.prototype;

    /** Used to check objects for own properties. */
    var hasOwnProperty$8 = objectProto$a.hasOwnProperty;

    /**
     * Gets the hash value for `key`.
     *
     * @private
     * @name get
     * @memberOf Hash
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */
    function hashGet$1(key) {
      var data = this.__data__;
      if (nativeCreate$2) {
        var result = data[key];
        return result === HASH_UNDEFINED$2 ? undefined : result;
      }
      return hasOwnProperty$8.call(data, key) ? data[key] : undefined;
    }

    var _hashGet = hashGet$1;

    var nativeCreate$1 = _nativeCreate;

    /** Used for built-in method references. */
    var objectProto$9 = Object.prototype;

    /** Used to check objects for own properties. */
    var hasOwnProperty$7 = objectProto$9.hasOwnProperty;

    /**
     * Checks if a hash value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf Hash
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function hashHas$1(key) {
      var data = this.__data__;
      return nativeCreate$1 ? (data[key] !== undefined) : hasOwnProperty$7.call(data, key);
    }

    var _hashHas = hashHas$1;

    var nativeCreate = _nativeCreate;

    /** Used to stand-in for `undefined` hash values. */
    var HASH_UNDEFINED$1 = '__lodash_hash_undefined__';

    /**
     * Sets the hash `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf Hash
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the hash instance.
     */
    function hashSet$1(key, value) {
      var data = this.__data__;
      this.size += this.has(key) ? 0 : 1;
      data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED$1 : value;
      return this;
    }

    var _hashSet = hashSet$1;

    var hashClear = _hashClear,
        hashDelete = _hashDelete,
        hashGet = _hashGet,
        hashHas = _hashHas,
        hashSet = _hashSet;

    /**
     * Creates a hash object.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */
    function Hash$1(entries) {
      var index = -1,
          length = entries == null ? 0 : entries.length;

      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }

    // Add methods to `Hash`.
    Hash$1.prototype.clear = hashClear;
    Hash$1.prototype['delete'] = hashDelete;
    Hash$1.prototype.get = hashGet;
    Hash$1.prototype.has = hashHas;
    Hash$1.prototype.set = hashSet;

    var _Hash = Hash$1;

    var Hash = _Hash,
        ListCache$2 = _ListCache,
        Map$3 = _Map;

    /**
     * Removes all key-value entries from the map.
     *
     * @private
     * @name clear
     * @memberOf MapCache
     */
    function mapCacheClear$1() {
      this.size = 0;
      this.__data__ = {
        'hash': new Hash,
        'map': new (Map$3 || ListCache$2),
        'string': new Hash
      };
    }

    var _mapCacheClear = mapCacheClear$1;

    /**
     * Checks if `value` is suitable for use as unique object key.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
     */

    function isKeyable$1(value) {
      var type = typeof value;
      return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
        ? (value !== '__proto__')
        : (value === null);
    }

    var _isKeyable = isKeyable$1;

    var isKeyable = _isKeyable;

    /**
     * Gets the data for `map`.
     *
     * @private
     * @param {Object} map The map to query.
     * @param {string} key The reference key.
     * @returns {*} Returns the map data.
     */
    function getMapData$4(map, key) {
      var data = map.__data__;
      return isKeyable(key)
        ? data[typeof key == 'string' ? 'string' : 'hash']
        : data.map;
    }

    var _getMapData = getMapData$4;

    var getMapData$3 = _getMapData;

    /**
     * Removes `key` and its value from the map.
     *
     * @private
     * @name delete
     * @memberOf MapCache
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */
    function mapCacheDelete$1(key) {
      var result = getMapData$3(this, key)['delete'](key);
      this.size -= result ? 1 : 0;
      return result;
    }

    var _mapCacheDelete = mapCacheDelete$1;

    var getMapData$2 = _getMapData;

    /**
     * Gets the map value for `key`.
     *
     * @private
     * @name get
     * @memberOf MapCache
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */
    function mapCacheGet$1(key) {
      return getMapData$2(this, key).get(key);
    }

    var _mapCacheGet = mapCacheGet$1;

    var getMapData$1 = _getMapData;

    /**
     * Checks if a map value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf MapCache
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function mapCacheHas$1(key) {
      return getMapData$1(this, key).has(key);
    }

    var _mapCacheHas = mapCacheHas$1;

    var getMapData = _getMapData;

    /**
     * Sets the map `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf MapCache
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the map cache instance.
     */
    function mapCacheSet$1(key, value) {
      var data = getMapData(this, key),
          size = data.size;

      data.set(key, value);
      this.size += data.size == size ? 0 : 1;
      return this;
    }

    var _mapCacheSet = mapCacheSet$1;

    var mapCacheClear = _mapCacheClear,
        mapCacheDelete = _mapCacheDelete,
        mapCacheGet = _mapCacheGet,
        mapCacheHas = _mapCacheHas,
        mapCacheSet = _mapCacheSet;

    /**
     * Creates a map cache object to store key-value pairs.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */
    function MapCache$3(entries) {
      var index = -1,
          length = entries == null ? 0 : entries.length;

      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }

    // Add methods to `MapCache`.
    MapCache$3.prototype.clear = mapCacheClear;
    MapCache$3.prototype['delete'] = mapCacheDelete;
    MapCache$3.prototype.get = mapCacheGet;
    MapCache$3.prototype.has = mapCacheHas;
    MapCache$3.prototype.set = mapCacheSet;

    var _MapCache = MapCache$3;

    var ListCache$1 = _ListCache,
        Map$2 = _Map,
        MapCache$2 = _MapCache;

    /** Used as the size to enable large array optimizations. */
    var LARGE_ARRAY_SIZE$1 = 200;

    /**
     * Sets the stack `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf Stack
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the stack cache instance.
     */
    function stackSet$1(key, value) {
      var data = this.__data__;
      if (data instanceof ListCache$1) {
        var pairs = data.__data__;
        if (!Map$2 || (pairs.length < LARGE_ARRAY_SIZE$1 - 1)) {
          pairs.push([key, value]);
          this.size = ++data.size;
          return this;
        }
        data = this.__data__ = new MapCache$2(pairs);
      }
      data.set(key, value);
      this.size = data.size;
      return this;
    }

    var _stackSet = stackSet$1;

    var ListCache = _ListCache,
        stackClear = _stackClear,
        stackDelete = _stackDelete,
        stackGet = _stackGet,
        stackHas = _stackHas,
        stackSet = _stackSet;

    /**
     * Creates a stack cache object to store key-value pairs.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */
    function Stack$3(entries) {
      var data = this.__data__ = new ListCache(entries);
      this.size = data.size;
    }

    // Add methods to `Stack`.
    Stack$3.prototype.clear = stackClear;
    Stack$3.prototype['delete'] = stackDelete;
    Stack$3.prototype.get = stackGet;
    Stack$3.prototype.has = stackHas;
    Stack$3.prototype.set = stackSet;

    var _Stack = Stack$3;

    /**
     * A specialized version of `_.forEach` for arrays without support for
     * iteratee shorthands.
     *
     * @private
     * @param {Array} [array] The array to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns `array`.
     */

    function arrayEach$1(array, iteratee) {
      var index = -1,
          length = array == null ? 0 : array.length;

      while (++index < length) {
        if (iteratee(array[index], index, array) === false) {
          break;
        }
      }
      return array;
    }

    var _arrayEach = arrayEach$1;

    /**
     * Creates a unary function that invokes `func` with its argument transformed.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {Function} transform The argument transform.
     * @returns {Function} Returns the new function.
     */

    function overArg$2(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }

    var _overArg = overArg$2;

    var overArg$1 = _overArg;

    /* Built-in method references for those with the same name as other `lodash` methods. */
    var nativeKeys$1 = overArg$1(Object.keys, Object);

    var _nativeKeys = nativeKeys$1;

    var isPrototype$2 = _isPrototype,
        nativeKeys = _nativeKeys;

    /** Used for built-in method references. */
    var objectProto$8 = Object.prototype;

    /** Used to check objects for own properties. */
    var hasOwnProperty$6 = objectProto$8.hasOwnProperty;

    /**
     * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     */
    function baseKeys$1(object) {
      if (!isPrototype$2(object)) {
        return nativeKeys(object);
      }
      var result = [];
      for (var key in Object(object)) {
        if (hasOwnProperty$6.call(object, key) && key != 'constructor') {
          result.push(key);
        }
      }
      return result;
    }

    var _baseKeys = baseKeys$1;

    var arrayLikeKeys = _arrayLikeKeys,
        baseKeys = _baseKeys,
        isArrayLike$5 = isArrayLike_1;

    /**
     * Creates an array of the own enumerable property names of `object`.
     *
     * **Note:** Non-object values are coerced to objects. See the
     * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
     * for more details.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.keys(new Foo);
     * // => ['a', 'b'] (iteration order is not guaranteed)
     *
     * _.keys('hi');
     * // => ['0', '1']
     */
    function keys$7(object) {
      return isArrayLike$5(object) ? arrayLikeKeys(object) : baseKeys(object);
    }

    var keys_1 = keys$7;

    var copyObject$5 = _copyObject,
        keys$6 = keys_1;

    /**
     * The base implementation of `_.assign` without support for multiple sources
     * or `customizer` functions.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @returns {Object} Returns `object`.
     */
    function baseAssign$1(object, source) {
      return object && copyObject$5(source, keys$6(source), object);
    }

    var _baseAssign = baseAssign$1;

    var copyObject$4 = _copyObject,
        keysIn$3 = keysIn_1;

    /**
     * The base implementation of `_.assignIn` without support for multiple sources
     * or `customizer` functions.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @returns {Object} Returns `object`.
     */
    function baseAssignIn$1(object, source) {
      return object && copyObject$4(source, keysIn$3(source), object);
    }

    var _baseAssignIn = baseAssignIn$1;

    var _cloneBuffer = {exports: {}};

    (function (module, exports) {
    var root = _root;

    /** Detect free variable `exports`. */
    var freeExports = exports && !exports.nodeType && exports;

    /** Detect free variable `module`. */
    var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;

    /** Detect the popular CommonJS extension `module.exports`. */
    var moduleExports = freeModule && freeModule.exports === freeExports;

    /** Built-in value references. */
    var Buffer = moduleExports ? root.Buffer : undefined,
        allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined;

    /**
     * Creates a clone of  `buffer`.
     *
     * @private
     * @param {Buffer} buffer The buffer to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Buffer} Returns the cloned buffer.
     */
    function cloneBuffer(buffer, isDeep) {
      if (isDeep) {
        return buffer.slice();
      }
      var length = buffer.length,
          result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);

      buffer.copy(result);
      return result;
    }

    module.exports = cloneBuffer;
    }(_cloneBuffer, _cloneBuffer.exports));

    /**
     * Copies the values of `source` to `array`.
     *
     * @private
     * @param {Array} source The array to copy values from.
     * @param {Array} [array=[]] The array to copy values to.
     * @returns {Array} Returns `array`.
     */

    function copyArray$1(source, array) {
      var index = -1,
          length = source.length;

      array || (array = Array(length));
      while (++index < length) {
        array[index] = source[index];
      }
      return array;
    }

    var _copyArray = copyArray$1;

    /**
     * A specialized version of `_.filter` for arrays without support for
     * iteratee shorthands.
     *
     * @private
     * @param {Array} [array] The array to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {Array} Returns the new filtered array.
     */

    function arrayFilter$2(array, predicate) {
      var index = -1,
          length = array == null ? 0 : array.length,
          resIndex = 0,
          result = [];

      while (++index < length) {
        var value = array[index];
        if (predicate(value, index, array)) {
          result[resIndex++] = value;
        }
      }
      return result;
    }

    var _arrayFilter = arrayFilter$2;

    /**
     * This method returns a new empty array.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {Array} Returns the new empty array.
     * @example
     *
     * var arrays = _.times(2, _.stubArray);
     *
     * console.log(arrays);
     * // => [[], []]
     *
     * console.log(arrays[0] === arrays[1]);
     * // => false
     */

    function stubArray$2() {
      return [];
    }

    var stubArray_1 = stubArray$2;

    var arrayFilter$1 = _arrayFilter,
        stubArray$1 = stubArray_1;

    /** Used for built-in method references. */
    var objectProto$7 = Object.prototype;

    /** Built-in value references. */
    var propertyIsEnumerable = objectProto$7.propertyIsEnumerable;

    /* Built-in method references for those with the same name as other `lodash` methods. */
    var nativeGetSymbols$1 = Object.getOwnPropertySymbols;

    /**
     * Creates an array of the own enumerable symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of symbols.
     */
    var getSymbols$3 = !nativeGetSymbols$1 ? stubArray$1 : function(object) {
      if (object == null) {
        return [];
      }
      object = Object(object);
      return arrayFilter$1(nativeGetSymbols$1(object), function(symbol) {
        return propertyIsEnumerable.call(object, symbol);
      });
    };

    var _getSymbols = getSymbols$3;

    var copyObject$3 = _copyObject,
        getSymbols$2 = _getSymbols;

    /**
     * Copies own symbols of `source` to `object`.
     *
     * @private
     * @param {Object} source The object to copy symbols from.
     * @param {Object} [object={}] The object to copy symbols to.
     * @returns {Object} Returns `object`.
     */
    function copySymbols$1(source, object) {
      return copyObject$3(source, getSymbols$2(source), object);
    }

    var _copySymbols = copySymbols$1;

    /**
     * Appends the elements of `values` to `array`.
     *
     * @private
     * @param {Array} array The array to modify.
     * @param {Array} values The values to append.
     * @returns {Array} Returns `array`.
     */

    function arrayPush$3(array, values) {
      var index = -1,
          length = values.length,
          offset = array.length;

      while (++index < length) {
        array[offset + index] = values[index];
      }
      return array;
    }

    var _arrayPush = arrayPush$3;

    var overArg = _overArg;

    /** Built-in value references. */
    var getPrototype$3 = overArg(Object.getPrototypeOf, Object);

    var _getPrototype = getPrototype$3;

    var arrayPush$2 = _arrayPush,
        getPrototype$2 = _getPrototype,
        getSymbols$1 = _getSymbols,
        stubArray = stubArray_1;

    /* Built-in method references for those with the same name as other `lodash` methods. */
    var nativeGetSymbols = Object.getOwnPropertySymbols;

    /**
     * Creates an array of the own and inherited enumerable symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of symbols.
     */
    var getSymbolsIn$2 = !nativeGetSymbols ? stubArray : function(object) {
      var result = [];
      while (object) {
        arrayPush$2(result, getSymbols$1(object));
        object = getPrototype$2(object);
      }
      return result;
    };

    var _getSymbolsIn = getSymbolsIn$2;

    var copyObject$2 = _copyObject,
        getSymbolsIn$1 = _getSymbolsIn;

    /**
     * Copies own and inherited symbols of `source` to `object`.
     *
     * @private
     * @param {Object} source The object to copy symbols from.
     * @param {Object} [object={}] The object to copy symbols to.
     * @returns {Object} Returns `object`.
     */
    function copySymbolsIn$1(source, object) {
      return copyObject$2(source, getSymbolsIn$1(source), object);
    }

    var _copySymbolsIn = copySymbolsIn$1;

    var arrayPush$1 = _arrayPush,
        isArray$f = isArray_1;

    /**
     * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
     * `keysFunc` and `symbolsFunc` to get the enumerable property names and
     * symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Function} keysFunc The function to get the keys of `object`.
     * @param {Function} symbolsFunc The function to get the symbols of `object`.
     * @returns {Array} Returns the array of property names and symbols.
     */
    function baseGetAllKeys$2(object, keysFunc, symbolsFunc) {
      var result = keysFunc(object);
      return isArray$f(object) ? result : arrayPush$1(result, symbolsFunc(object));
    }

    var _baseGetAllKeys = baseGetAllKeys$2;

    var baseGetAllKeys$1 = _baseGetAllKeys,
        getSymbols = _getSymbols,
        keys$5 = keys_1;

    /**
     * Creates an array of own enumerable property names and symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names and symbols.
     */
    function getAllKeys$2(object) {
      return baseGetAllKeys$1(object, keys$5, getSymbols);
    }

    var _getAllKeys = getAllKeys$2;

    var baseGetAllKeys = _baseGetAllKeys,
        getSymbolsIn = _getSymbolsIn,
        keysIn$2 = keysIn_1;

    /**
     * Creates an array of own and inherited enumerable property names and
     * symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names and symbols.
     */
    function getAllKeysIn$2(object) {
      return baseGetAllKeys(object, keysIn$2, getSymbolsIn);
    }

    var _getAllKeysIn = getAllKeysIn$2;

    var getNative$3 = _getNative,
        root$4 = _root;

    /* Built-in method references that are verified to be native. */
    var DataView$1 = getNative$3(root$4, 'DataView');

    var _DataView = DataView$1;

    var getNative$2 = _getNative,
        root$3 = _root;

    /* Built-in method references that are verified to be native. */
    var Promise$2 = getNative$2(root$3, 'Promise');

    var _Promise = Promise$2;

    var getNative$1 = _getNative,
        root$2 = _root;

    /* Built-in method references that are verified to be native. */
    var Set$3 = getNative$1(root$2, 'Set');

    var _Set = Set$3;

    var getNative = _getNative,
        root$1 = _root;

    /* Built-in method references that are verified to be native. */
    var WeakMap$2 = getNative(root$1, 'WeakMap');

    var _WeakMap = WeakMap$2;

    var DataView = _DataView,
        Map$1 = _Map,
        Promise$1 = _Promise,
        Set$2 = _Set,
        WeakMap$1 = _WeakMap,
        baseGetTag$5 = _baseGetTag,
        toSource = _toSource;

    /** `Object#toString` result references. */
    var mapTag$4 = '[object Map]',
        objectTag$3 = '[object Object]',
        promiseTag = '[object Promise]',
        setTag$4 = '[object Set]',
        weakMapTag$1 = '[object WeakMap]';

    var dataViewTag$3 = '[object DataView]';

    /** Used to detect maps, sets, and weakmaps. */
    var dataViewCtorString = toSource(DataView),
        mapCtorString = toSource(Map$1),
        promiseCtorString = toSource(Promise$1),
        setCtorString = toSource(Set$2),
        weakMapCtorString = toSource(WeakMap$1);

    /**
     * Gets the `toStringTag` of `value`.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the `toStringTag`.
     */
    var getTag$4 = baseGetTag$5;

    // Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
    if ((DataView && getTag$4(new DataView(new ArrayBuffer(1))) != dataViewTag$3) ||
        (Map$1 && getTag$4(new Map$1) != mapTag$4) ||
        (Promise$1 && getTag$4(Promise$1.resolve()) != promiseTag) ||
        (Set$2 && getTag$4(new Set$2) != setTag$4) ||
        (WeakMap$1 && getTag$4(new WeakMap$1) != weakMapTag$1)) {
      getTag$4 = function(value) {
        var result = baseGetTag$5(value),
            Ctor = result == objectTag$3 ? value.constructor : undefined,
            ctorString = Ctor ? toSource(Ctor) : '';

        if (ctorString) {
          switch (ctorString) {
            case dataViewCtorString: return dataViewTag$3;
            case mapCtorString: return mapTag$4;
            case promiseCtorString: return promiseTag;
            case setCtorString: return setTag$4;
            case weakMapCtorString: return weakMapTag$1;
          }
        }
        return result;
      };
    }

    var _getTag = getTag$4;

    /** Used for built-in method references. */

    var objectProto$6 = Object.prototype;

    /** Used to check objects for own properties. */
    var hasOwnProperty$5 = objectProto$6.hasOwnProperty;

    /**
     * Initializes an array clone.
     *
     * @private
     * @param {Array} array The array to clone.
     * @returns {Array} Returns the initialized clone.
     */
    function initCloneArray$1(array) {
      var length = array.length,
          result = new array.constructor(length);

      // Add properties assigned by `RegExp#exec`.
      if (length && typeof array[0] == 'string' && hasOwnProperty$5.call(array, 'index')) {
        result.index = array.index;
        result.input = array.input;
      }
      return result;
    }

    var _initCloneArray = initCloneArray$1;

    var root = _root;

    /** Built-in value references. */
    var Uint8Array$3 = root.Uint8Array;

    var _Uint8Array = Uint8Array$3;

    var Uint8Array$2 = _Uint8Array;

    /**
     * Creates a clone of `arrayBuffer`.
     *
     * @private
     * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
     * @returns {ArrayBuffer} Returns the cloned array buffer.
     */
    function cloneArrayBuffer$3(arrayBuffer) {
      var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
      new Uint8Array$2(result).set(new Uint8Array$2(arrayBuffer));
      return result;
    }

    var _cloneArrayBuffer = cloneArrayBuffer$3;

    var cloneArrayBuffer$2 = _cloneArrayBuffer;

    /**
     * Creates a clone of `dataView`.
     *
     * @private
     * @param {Object} dataView The data view to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Object} Returns the cloned data view.
     */
    function cloneDataView$1(dataView, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer$2(dataView.buffer) : dataView.buffer;
      return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
    }

    var _cloneDataView = cloneDataView$1;

    /** Used to match `RegExp` flags from their coerced string values. */

    var reFlags = /\w*$/;

    /**
     * Creates a clone of `regexp`.
     *
     * @private
     * @param {Object} regexp The regexp to clone.
     * @returns {Object} Returns the cloned regexp.
     */
    function cloneRegExp$1(regexp) {
      var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
      result.lastIndex = regexp.lastIndex;
      return result;
    }

    var _cloneRegExp = cloneRegExp$1;

    var Symbol$4 = _Symbol;

    /** Used to convert symbols to primitives and strings. */
    var symbolProto$2 = Symbol$4 ? Symbol$4.prototype : undefined,
        symbolValueOf$1 = symbolProto$2 ? symbolProto$2.valueOf : undefined;

    /**
     * Creates a clone of the `symbol` object.
     *
     * @private
     * @param {Object} symbol The symbol object to clone.
     * @returns {Object} Returns the cloned symbol object.
     */
    function cloneSymbol$1(symbol) {
      return symbolValueOf$1 ? Object(symbolValueOf$1.call(symbol)) : {};
    }

    var _cloneSymbol = cloneSymbol$1;

    var cloneArrayBuffer$1 = _cloneArrayBuffer;

    /**
     * Creates a clone of `typedArray`.
     *
     * @private
     * @param {Object} typedArray The typed array to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Object} Returns the cloned typed array.
     */
    function cloneTypedArray$1(typedArray, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer$1(typedArray.buffer) : typedArray.buffer;
      return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
    }

    var _cloneTypedArray = cloneTypedArray$1;

    var cloneArrayBuffer = _cloneArrayBuffer,
        cloneDataView = _cloneDataView,
        cloneRegExp = _cloneRegExp,
        cloneSymbol = _cloneSymbol,
        cloneTypedArray = _cloneTypedArray;

    /** `Object#toString` result references. */
    var boolTag$3 = '[object Boolean]',
        dateTag$2 = '[object Date]',
        mapTag$3 = '[object Map]',
        numberTag$3 = '[object Number]',
        regexpTag$2 = '[object RegExp]',
        setTag$3 = '[object Set]',
        stringTag$3 = '[object String]',
        symbolTag$3 = '[object Symbol]';

    var arrayBufferTag$2 = '[object ArrayBuffer]',
        dataViewTag$2 = '[object DataView]',
        float32Tag$1 = '[object Float32Array]',
        float64Tag$1 = '[object Float64Array]',
        int8Tag$1 = '[object Int8Array]',
        int16Tag$1 = '[object Int16Array]',
        int32Tag$1 = '[object Int32Array]',
        uint8Tag$1 = '[object Uint8Array]',
        uint8ClampedTag$1 = '[object Uint8ClampedArray]',
        uint16Tag$1 = '[object Uint16Array]',
        uint32Tag$1 = '[object Uint32Array]';

    /**
     * Initializes an object clone based on its `toStringTag`.
     *
     * **Note:** This function only supports cloning values with tags of
     * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.
     *
     * @private
     * @param {Object} object The object to clone.
     * @param {string} tag The `toStringTag` of the object to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Object} Returns the initialized clone.
     */
    function initCloneByTag$1(object, tag, isDeep) {
      var Ctor = object.constructor;
      switch (tag) {
        case arrayBufferTag$2:
          return cloneArrayBuffer(object);

        case boolTag$3:
        case dateTag$2:
          return new Ctor(+object);

        case dataViewTag$2:
          return cloneDataView(object, isDeep);

        case float32Tag$1: case float64Tag$1:
        case int8Tag$1: case int16Tag$1: case int32Tag$1:
        case uint8Tag$1: case uint8ClampedTag$1: case uint16Tag$1: case uint32Tag$1:
          return cloneTypedArray(object, isDeep);

        case mapTag$3:
          return new Ctor;

        case numberTag$3:
        case stringTag$3:
          return new Ctor(object);

        case regexpTag$2:
          return cloneRegExp(object);

        case setTag$3:
          return new Ctor;

        case symbolTag$3:
          return cloneSymbol(object);
      }
    }

    var _initCloneByTag = initCloneByTag$1;

    var isObject$4 = isObject_1;

    /** Built-in value references. */
    var objectCreate = Object.create;

    /**
     * The base implementation of `_.create` without support for assigning
     * properties to the created object.
     *
     * @private
     * @param {Object} proto The object to inherit from.
     * @returns {Object} Returns the new object.
     */
    var baseCreate$1 = (function() {
      function object() {}
      return function(proto) {
        if (!isObject$4(proto)) {
          return {};
        }
        if (objectCreate) {
          return objectCreate(proto);
        }
        object.prototype = proto;
        var result = new object;
        object.prototype = undefined;
        return result;
      };
    }());

    var _baseCreate = baseCreate$1;

    var baseCreate = _baseCreate,
        getPrototype$1 = _getPrototype,
        isPrototype$1 = _isPrototype;

    /**
     * Initializes an object clone.
     *
     * @private
     * @param {Object} object The object to clone.
     * @returns {Object} Returns the initialized clone.
     */
    function initCloneObject$1(object) {
      return (typeof object.constructor == 'function' && !isPrototype$1(object))
        ? baseCreate(getPrototype$1(object))
        : {};
    }

    var _initCloneObject = initCloneObject$1;

    var getTag$3 = _getTag,
        isObjectLike$7 = isObjectLike_1;

    /** `Object#toString` result references. */
    var mapTag$2 = '[object Map]';

    /**
     * The base implementation of `_.isMap` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a map, else `false`.
     */
    function baseIsMap$1(value) {
      return isObjectLike$7(value) && getTag$3(value) == mapTag$2;
    }

    var _baseIsMap = baseIsMap$1;

    var baseIsMap = _baseIsMap,
        baseUnary$1 = _baseUnary,
        nodeUtil$1 = _nodeUtil.exports;

    /* Node.js helper references. */
    var nodeIsMap = nodeUtil$1 && nodeUtil$1.isMap;

    /**
     * Checks if `value` is classified as a `Map` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a map, else `false`.
     * @example
     *
     * _.isMap(new Map);
     * // => true
     *
     * _.isMap(new WeakMap);
     * // => false
     */
    var isMap$1 = nodeIsMap ? baseUnary$1(nodeIsMap) : baseIsMap;

    var isMap_1 = isMap$1;

    var getTag$2 = _getTag,
        isObjectLike$6 = isObjectLike_1;

    /** `Object#toString` result references. */
    var setTag$2 = '[object Set]';

    /**
     * The base implementation of `_.isSet` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a set, else `false`.
     */
    function baseIsSet$1(value) {
      return isObjectLike$6(value) && getTag$2(value) == setTag$2;
    }

    var _baseIsSet = baseIsSet$1;

    var baseIsSet = _baseIsSet,
        baseUnary = _baseUnary,
        nodeUtil = _nodeUtil.exports;

    /* Node.js helper references. */
    var nodeIsSet = nodeUtil && nodeUtil.isSet;

    /**
     * Checks if `value` is classified as a `Set` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a set, else `false`.
     * @example
     *
     * _.isSet(new Set);
     * // => true
     *
     * _.isSet(new WeakSet);
     * // => false
     */
    var isSet$1 = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;

    var isSet_1 = isSet$1;

    var Stack$2 = _Stack,
        arrayEach = _arrayEach,
        assignValue$2 = _assignValue,
        baseAssign = _baseAssign,
        baseAssignIn = _baseAssignIn,
        cloneBuffer = _cloneBuffer.exports,
        copyArray = _copyArray,
        copySymbols = _copySymbols,
        copySymbolsIn = _copySymbolsIn,
        getAllKeys$1 = _getAllKeys,
        getAllKeysIn$1 = _getAllKeysIn,
        getTag$1 = _getTag,
        initCloneArray = _initCloneArray,
        initCloneByTag = _initCloneByTag,
        initCloneObject = _initCloneObject,
        isArray$e = isArray_1,
        isBuffer$1 = isBuffer$3.exports,
        isMap = isMap_1,
        isObject$3 = isObject_1,
        isSet = isSet_1,
        keys$4 = keys_1,
        keysIn$1 = keysIn_1;

    /** Used to compose bitmasks for cloning. */
    var CLONE_DEEP_FLAG$1 = 1,
        CLONE_FLAT_FLAG$1 = 2,
        CLONE_SYMBOLS_FLAG$2 = 4;

    /** `Object#toString` result references. */
    var argsTag$1 = '[object Arguments]',
        arrayTag$1 = '[object Array]',
        boolTag$2 = '[object Boolean]',
        dateTag$1 = '[object Date]',
        errorTag$1 = '[object Error]',
        funcTag = '[object Function]',
        genTag = '[object GeneratorFunction]',
        mapTag$1 = '[object Map]',
        numberTag$2 = '[object Number]',
        objectTag$2 = '[object Object]',
        regexpTag$1 = '[object RegExp]',
        setTag$1 = '[object Set]',
        stringTag$2 = '[object String]',
        symbolTag$2 = '[object Symbol]',
        weakMapTag = '[object WeakMap]';

    var arrayBufferTag$1 = '[object ArrayBuffer]',
        dataViewTag$1 = '[object DataView]',
        float32Tag = '[object Float32Array]',
        float64Tag = '[object Float64Array]',
        int8Tag = '[object Int8Array]',
        int16Tag = '[object Int16Array]',
        int32Tag = '[object Int32Array]',
        uint8Tag = '[object Uint8Array]',
        uint8ClampedTag = '[object Uint8ClampedArray]',
        uint16Tag = '[object Uint16Array]',
        uint32Tag = '[object Uint32Array]';

    /** Used to identify `toStringTag` values supported by `_.clone`. */
    var cloneableTags = {};
    cloneableTags[argsTag$1] = cloneableTags[arrayTag$1] =
    cloneableTags[arrayBufferTag$1] = cloneableTags[dataViewTag$1] =
    cloneableTags[boolTag$2] = cloneableTags[dateTag$1] =
    cloneableTags[float32Tag] = cloneableTags[float64Tag] =
    cloneableTags[int8Tag] = cloneableTags[int16Tag] =
    cloneableTags[int32Tag] = cloneableTags[mapTag$1] =
    cloneableTags[numberTag$2] = cloneableTags[objectTag$2] =
    cloneableTags[regexpTag$1] = cloneableTags[setTag$1] =
    cloneableTags[stringTag$2] = cloneableTags[symbolTag$2] =
    cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
    cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
    cloneableTags[errorTag$1] = cloneableTags[funcTag] =
    cloneableTags[weakMapTag] = false;

    /**
     * The base implementation of `_.clone` and `_.cloneDeep` which tracks
     * traversed objects.
     *
     * @private
     * @param {*} value The value to clone.
     * @param {boolean} bitmask The bitmask flags.
     *  1 - Deep clone
     *  2 - Flatten inherited properties
     *  4 - Clone symbols
     * @param {Function} [customizer] The function to customize cloning.
     * @param {string} [key] The key of `value`.
     * @param {Object} [object] The parent object of `value`.
     * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
     * @returns {*} Returns the cloned value.
     */
    function baseClone$2(value, bitmask, customizer, key, object, stack) {
      var result,
          isDeep = bitmask & CLONE_DEEP_FLAG$1,
          isFlat = bitmask & CLONE_FLAT_FLAG$1,
          isFull = bitmask & CLONE_SYMBOLS_FLAG$2;

      if (customizer) {
        result = object ? customizer(value, key, object, stack) : customizer(value);
      }
      if (result !== undefined) {
        return result;
      }
      if (!isObject$3(value)) {
        return value;
      }
      var isArr = isArray$e(value);
      if (isArr) {
        result = initCloneArray(value);
        if (!isDeep) {
          return copyArray(value, result);
        }
      } else {
        var tag = getTag$1(value),
            isFunc = tag == funcTag || tag == genTag;

        if (isBuffer$1(value)) {
          return cloneBuffer(value, isDeep);
        }
        if (tag == objectTag$2 || tag == argsTag$1 || (isFunc && !object)) {
          result = (isFlat || isFunc) ? {} : initCloneObject(value);
          if (!isDeep) {
            return isFlat
              ? copySymbolsIn(value, baseAssignIn(result, value))
              : copySymbols(value, baseAssign(result, value));
          }
        } else {
          if (!cloneableTags[tag]) {
            return object ? value : {};
          }
          result = initCloneByTag(value, tag, isDeep);
        }
      }
      // Check for circular references and return its corresponding clone.
      stack || (stack = new Stack$2);
      var stacked = stack.get(value);
      if (stacked) {
        return stacked;
      }
      stack.set(value, result);

      if (isSet(value)) {
        value.forEach(function(subValue) {
          result.add(baseClone$2(subValue, bitmask, customizer, subValue, value, stack));
        });
      } else if (isMap(value)) {
        value.forEach(function(subValue, key) {
          result.set(key, baseClone$2(subValue, bitmask, customizer, key, value, stack));
        });
      }

      var keysFunc = isFull
        ? (isFlat ? getAllKeysIn$1 : getAllKeys$1)
        : (isFlat ? keysIn$1 : keys$4);

      var props = isArr ? undefined : keysFunc(value);
      arrayEach(props || value, function(subValue, key) {
        if (props) {
          key = subValue;
          subValue = value[key];
        }
        // Recursively populate clone (susceptible to call stack limits).
        assignValue$2(result, key, baseClone$2(subValue, bitmask, customizer, key, value, stack));
      });
      return result;
    }

    var _baseClone = baseClone$2;

    var baseGetTag$4 = _baseGetTag,
        isObjectLike$5 = isObjectLike_1;

    /** `Object#toString` result references. */
    var symbolTag$1 = '[object Symbol]';

    /**
     * Checks if `value` is classified as a `Symbol` primitive or object.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
     * @example
     *
     * _.isSymbol(Symbol.iterator);
     * // => true
     *
     * _.isSymbol('abc');
     * // => false
     */
    function isSymbol$4(value) {
      return typeof value == 'symbol' ||
        (isObjectLike$5(value) && baseGetTag$4(value) == symbolTag$1);
    }

    var isSymbol_1 = isSymbol$4;

    var isArray$d = isArray_1,
        isSymbol$3 = isSymbol_1;

    /** Used to match property names within property paths. */
    var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
        reIsPlainProp = /^\w*$/;

    /**
     * Checks if `value` is a property name and not a property path.
     *
     * @private
     * @param {*} value The value to check.
     * @param {Object} [object] The object to query keys on.
     * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
     */
    function isKey$3(value, object) {
      if (isArray$d(value)) {
        return false;
      }
      var type = typeof value;
      if (type == 'number' || type == 'symbol' || type == 'boolean' ||
          value == null || isSymbol$3(value)) {
        return true;
      }
      return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
        (object != null && value in Object(object));
    }

    var _isKey = isKey$3;

    var MapCache$1 = _MapCache;

    /** Error message constants. */
    var FUNC_ERROR_TEXT = 'Expected a function';

    /**
     * Creates a function that memoizes the result of `func`. If `resolver` is
     * provided, it determines the cache key for storing the result based on the
     * arguments provided to the memoized function. By default, the first argument
     * provided to the memoized function is used as the map cache key. The `func`
     * is invoked with the `this` binding of the memoized function.
     *
     * **Note:** The cache is exposed as the `cache` property on the memoized
     * function. Its creation may be customized by replacing the `_.memoize.Cache`
     * constructor with one whose instances implement the
     * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
     * method interface of `clear`, `delete`, `get`, `has`, and `set`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to have its output memoized.
     * @param {Function} [resolver] The function to resolve the cache key.
     * @returns {Function} Returns the new memoized function.
     * @example
     *
     * var object = { 'a': 1, 'b': 2 };
     * var other = { 'c': 3, 'd': 4 };
     *
     * var values = _.memoize(_.values);
     * values(object);
     * // => [1, 2]
     *
     * values(other);
     * // => [3, 4]
     *
     * object.a = 2;
     * values(object);
     * // => [1, 2]
     *
     * // Modify the result cache.
     * values.cache.set(object, ['a', 'b']);
     * values(object);
     * // => ['a', 'b']
     *
     * // Replace `_.memoize.Cache`.
     * _.memoize.Cache = WeakMap;
     */
    function memoize$1(func, resolver) {
      if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      var memoized = function() {
        var args = arguments,
            key = resolver ? resolver.apply(this, args) : args[0],
            cache = memoized.cache;

        if (cache.has(key)) {
          return cache.get(key);
        }
        var result = func.apply(this, args);
        memoized.cache = cache.set(key, result) || cache;
        return result;
      };
      memoized.cache = new (memoize$1.Cache || MapCache$1);
      return memoized;
    }

    // Expose `MapCache`.
    memoize$1.Cache = MapCache$1;

    var memoize_1 = memoize$1;

    var memoize = memoize_1;

    /** Used as the maximum memoize cache size. */
    var MAX_MEMOIZE_SIZE = 500;

    /**
     * A specialized version of `_.memoize` which clears the memoized function's
     * cache when it exceeds `MAX_MEMOIZE_SIZE`.
     *
     * @private
     * @param {Function} func The function to have its output memoized.
     * @returns {Function} Returns the new memoized function.
     */
    function memoizeCapped$1(func) {
      var result = memoize(func, function(key) {
        if (cache.size === MAX_MEMOIZE_SIZE) {
          cache.clear();
        }
        return key;
      });

      var cache = result.cache;
      return result;
    }

    var _memoizeCapped = memoizeCapped$1;

    var memoizeCapped = _memoizeCapped;

    /** Used to match property names within property paths. */
    var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

    /** Used to match backslashes in property paths. */
    var reEscapeChar = /\\(\\)?/g;

    /**
     * Converts `string` to a property path array.
     *
     * @private
     * @param {string} string The string to convert.
     * @returns {Array} Returns the property path array.
     */
    var stringToPath$1 = memoizeCapped(function(string) {
      var result = [];
      if (string.charCodeAt(0) === 46 /* . */) {
        result.push('');
      }
      string.replace(rePropName, function(match, number, quote, subString) {
        result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));
      });
      return result;
    });

    var _stringToPath = stringToPath$1;

    var Symbol$3 = _Symbol,
        arrayMap$2 = _arrayMap,
        isArray$c = isArray_1,
        isSymbol$2 = isSymbol_1;

    /** Used as references for various `Number` constants. */
    var INFINITY$3 = 1 / 0;

    /** Used to convert symbols to primitives and strings. */
    var symbolProto$1 = Symbol$3 ? Symbol$3.prototype : undefined,
        symbolToString = symbolProto$1 ? symbolProto$1.toString : undefined;

    /**
     * The base implementation of `_.toString` which doesn't convert nullish
     * values to empty strings.
     *
     * @private
     * @param {*} value The value to process.
     * @returns {string} Returns the string.
     */
    function baseToString$1(value) {
      // Exit early for strings to avoid a performance hit in some environments.
      if (typeof value == 'string') {
        return value;
      }
      if (isArray$c(value)) {
        // Recursively convert values (susceptible to call stack limits).
        return arrayMap$2(value, baseToString$1) + '';
      }
      if (isSymbol$2(value)) {
        return symbolToString ? symbolToString.call(value) : '';
      }
      var result = (value + '');
      return (result == '0' && (1 / value) == -INFINITY$3) ? '-0' : result;
    }

    var _baseToString = baseToString$1;

    var baseToString = _baseToString;

    /**
     * Converts `value` to a string. An empty string is returned for `null`
     * and `undefined` values. The sign of `-0` is preserved.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {string} Returns the converted string.
     * @example
     *
     * _.toString(null);
     * // => ''
     *
     * _.toString(-0);
     * // => '-0'
     *
     * _.toString([1, 2, 3]);
     * // => '1,2,3'
     */
    function toString$1(value) {
      return value == null ? '' : baseToString(value);
    }

    var toString_1 = toString$1;

    var isArray$b = isArray_1,
        isKey$2 = _isKey,
        stringToPath = _stringToPath,
        toString = toString_1;

    /**
     * Casts `value` to a path array if it's not one.
     *
     * @private
     * @param {*} value The value to inspect.
     * @param {Object} [object] The object to query keys on.
     * @returns {Array} Returns the cast property path array.
     */
    function castPath$5(value, object) {
      if (isArray$b(value)) {
        return value;
      }
      return isKey$2(value, object) ? [value] : stringToPath(toString(value));
    }

    var _castPath = castPath$5;

    /**
     * Gets the last element of `array`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to query.
     * @returns {*} Returns the last element of `array`.
     * @example
     *
     * _.last([1, 2, 3]);
     * // => 3
     */

    function last$3(array) {
      var length = array == null ? 0 : array.length;
      return length ? array[length - 1] : undefined;
    }

    var last_1 = last$3;

    var isSymbol$1 = isSymbol_1;

    /** Used as references for various `Number` constants. */
    var INFINITY$2 = 1 / 0;

    /**
     * Converts `value` to a string key if it's not a string or symbol.
     *
     * @private
     * @param {*} value The value to inspect.
     * @returns {string|symbol} Returns the key.
     */
    function toKey$6(value) {
      if (typeof value == 'string' || isSymbol$1(value)) {
        return value;
      }
      var result = (value + '');
      return (result == '0' && (1 / value) == -INFINITY$2) ? '-0' : result;
    }

    var _toKey = toKey$6;

    var castPath$4 = _castPath,
        toKey$5 = _toKey;

    /**
     * The base implementation of `_.get` without support for default values.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the property to get.
     * @returns {*} Returns the resolved value.
     */
    function baseGet$3(object, path) {
      path = castPath$4(path, object);

      var index = 0,
          length = path.length;

      while (object != null && index < length) {
        object = object[toKey$5(path[index++])];
      }
      return (index && index == length) ? object : undefined;
    }

    var _baseGet = baseGet$3;

    /**
     * The base implementation of `_.slice` without an iteratee call guard.
     *
     * @private
     * @param {Array} array The array to slice.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns the slice of `array`.
     */

    function baseSlice$1(array, start, end) {
      var index = -1,
          length = array.length;

      if (start < 0) {
        start = -start > length ? 0 : (length + start);
      }
      end = end > length ? length : end;
      if (end < 0) {
        end += length;
      }
      length = start > end ? 0 : ((end - start) >>> 0);
      start >>>= 0;

      var result = Array(length);
      while (++index < length) {
        result[index] = array[index + start];
      }
      return result;
    }

    var _baseSlice = baseSlice$1;

    var baseGet$2 = _baseGet,
        baseSlice = _baseSlice;

    /**
     * Gets the parent value at `path` of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array} path The path to get the parent value of.
     * @returns {*} Returns the parent value.
     */
    function parent$1(object, path) {
      return path.length < 2 ? object : baseGet$2(object, baseSlice(path, 0, -1));
    }

    var _parent = parent$1;

    var castPath$3 = _castPath,
        last$2 = last_1,
        parent = _parent,
        toKey$4 = _toKey;

    /**
     * The base implementation of `_.unset`.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {Array|string} path The property path to unset.
     * @returns {boolean} Returns `true` if the property is deleted, else `false`.
     */
    function baseUnset$1(object, path) {
      path = castPath$3(path, object);
      object = parent(object, path);
      return object == null || delete object[toKey$4(last$2(path))];
    }

    var _baseUnset = baseUnset$1;

    var baseGetTag$3 = _baseGetTag,
        getPrototype = _getPrototype,
        isObjectLike$4 = isObjectLike_1;

    /** `Object#toString` result references. */
    var objectTag$1 = '[object Object]';

    /** Used for built-in method references. */
    var funcProto = Function.prototype,
        objectProto$5 = Object.prototype;

    /** Used to resolve the decompiled source of functions. */
    var funcToString = funcProto.toString;

    /** Used to check objects for own properties. */
    var hasOwnProperty$4 = objectProto$5.hasOwnProperty;

    /** Used to infer the `Object` constructor. */
    var objectCtorString = funcToString.call(Object);

    /**
     * Checks if `value` is a plain object, that is, an object created by the
     * `Object` constructor or one with a `[[Prototype]]` of `null`.
     *
     * @static
     * @memberOf _
     * @since 0.8.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     * }
     *
     * _.isPlainObject(new Foo);
     * // => false
     *
     * _.isPlainObject([1, 2, 3]);
     * // => false
     *
     * _.isPlainObject({ 'x': 0, 'y': 0 });
     * // => true
     *
     * _.isPlainObject(Object.create(null));
     * // => true
     */
    function isPlainObject$1(value) {
      if (!isObjectLike$4(value) || baseGetTag$3(value) != objectTag$1) {
        return false;
      }
      var proto = getPrototype(value);
      if (proto === null) {
        return true;
      }
      var Ctor = hasOwnProperty$4.call(proto, 'constructor') && proto.constructor;
      return typeof Ctor == 'function' && Ctor instanceof Ctor &&
        funcToString.call(Ctor) == objectCtorString;
    }

    var isPlainObject_1 = isPlainObject$1;

    var isPlainObject = isPlainObject_1;

    /**
     * Used by `_.omit` to customize its `_.cloneDeep` use to only clone plain
     * objects.
     *
     * @private
     * @param {*} value The value to inspect.
     * @param {string} key The key of the property to inspect.
     * @returns {*} Returns the uncloned value or `undefined` to defer cloning to `_.cloneDeep`.
     */
    function customOmitClone$1(value) {
      return isPlainObject(value) ? undefined : value;
    }

    var _customOmitClone = customOmitClone$1;

    var Symbol$2 = _Symbol,
        isArguments$1 = isArguments_1,
        isArray$a = isArray_1;

    /** Built-in value references. */
    var spreadableSymbol = Symbol$2 ? Symbol$2.isConcatSpreadable : undefined;

    /**
     * Checks if `value` is a flattenable `arguments` object or array.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
     */
    function isFlattenable$1(value) {
      return isArray$a(value) || isArguments$1(value) ||
        !!(spreadableSymbol && value && value[spreadableSymbol]);
    }

    var _isFlattenable = isFlattenable$1;

    var arrayPush = _arrayPush,
        isFlattenable = _isFlattenable;

    /**
     * The base implementation of `_.flatten` with support for restricting flattening.
     *
     * @private
     * @param {Array} array The array to flatten.
     * @param {number} depth The maximum recursion depth.
     * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
     * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
     * @param {Array} [result=[]] The initial result value.
     * @returns {Array} Returns the new flattened array.
     */
    function baseFlatten$1(array, depth, predicate, isStrict, result) {
      var index = -1,
          length = array.length;

      predicate || (predicate = isFlattenable);
      result || (result = []);

      while (++index < length) {
        var value = array[index];
        if (depth > 0 && predicate(value)) {
          if (depth > 1) {
            // Recursively flatten arrays (susceptible to call stack limits).
            baseFlatten$1(value, depth - 1, predicate, isStrict, result);
          } else {
            arrayPush(result, value);
          }
        } else if (!isStrict) {
          result[result.length] = value;
        }
      }
      return result;
    }

    var _baseFlatten = baseFlatten$1;

    var baseFlatten = _baseFlatten;

    /**
     * Flattens `array` a single level deep.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to flatten.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * _.flatten([1, [2, [3, [4]], 5]]);
     * // => [1, 2, [3, [4]], 5]
     */
    function flatten$1(array) {
      var length = array == null ? 0 : array.length;
      return length ? baseFlatten(array, 1) : [];
    }

    var flatten_1 = flatten$1;

    var flatten = flatten_1,
        overRest = _overRest,
        setToString = _setToString;

    /**
     * A specialized version of `baseRest` which flattens the rest array.
     *
     * @private
     * @param {Function} func The function to apply a rest parameter to.
     * @returns {Function} Returns the new function.
     */
    function flatRest$1(func) {
      return setToString(overRest(func, undefined, flatten), func + '');
    }

    var _flatRest = flatRest$1;

    var arrayMap$1 = _arrayMap,
        baseClone$1 = _baseClone,
        baseUnset = _baseUnset,
        castPath$2 = _castPath,
        copyObject$1 = _copyObject,
        customOmitClone = _customOmitClone,
        flatRest = _flatRest,
        getAllKeysIn = _getAllKeysIn;

    /** Used to compose bitmasks for cloning. */
    var CLONE_DEEP_FLAG = 1,
        CLONE_FLAT_FLAG = 2,
        CLONE_SYMBOLS_FLAG$1 = 4;

    /**
     * The opposite of `_.pick`; this method creates an object composed of the
     * own and inherited enumerable property paths of `object` that are not omitted.
     *
     * **Note:** This method is considerably slower than `_.pick`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The source object.
     * @param {...(string|string[])} [paths] The property paths to omit.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'a': 1, 'b': '2', 'c': 3 };
     *
     * _.omit(object, ['a', 'c']);
     * // => { 'b': '2' }
     */
    var omit = flatRest(function(object, paths) {
      var result = {};
      if (object == null) {
        return result;
      }
      var isDeep = false;
      paths = arrayMap$1(paths, function(path) {
        path = castPath$2(path, object);
        isDeep || (isDeep = path.length > 1);
        return path;
      });
      copyObject$1(object, getAllKeysIn(object), result);
      if (isDeep) {
        result = baseClone$1(result, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG$1, customOmitClone);
      }
      var length = paths.length;
      while (length--) {
        baseUnset(result, paths[length]);
      }
      return result;
    });

    var omit_1 = omit;

    var Stream = require$$0__default$2["default"];

    var mute = MuteStream$1;

    // var out = new MuteStream(process.stdout)
    // argument auto-pipes
    function MuteStream$1 (opts) {
      Stream.apply(this);
      opts = opts || {};
      this.writable = this.readable = true;
      this.muted = false;
      this.on('pipe', this._onpipe);
      this.replace = opts.replace;

      // For readline-type situations
      // This much at the start of a line being redrawn after a ctrl char
      // is seen (such as backspace) won't be redrawn as the replacement
      this._prompt = opts.prompt || null;
      this._hadControl = false;
    }

    MuteStream$1.prototype = Object.create(Stream.prototype);

    Object.defineProperty(MuteStream$1.prototype, 'constructor', {
      value: MuteStream$1,
      enumerable: false
    });

    MuteStream$1.prototype.mute = function () {
      this.muted = true;
    };

    MuteStream$1.prototype.unmute = function () {
      this.muted = false;
    };

    Object.defineProperty(MuteStream$1.prototype, '_onpipe', {
      value: onPipe,
      enumerable: false,
      writable: true,
      configurable: true
    });

    function onPipe (src) {
      this._src = src;
    }

    Object.defineProperty(MuteStream$1.prototype, 'isTTY', {
      get: getIsTTY,
      set: setIsTTY,
      enumerable: true,
      configurable: true
    });

    function getIsTTY () {
      return( (this._dest) ? this._dest.isTTY
            : (this._src) ? this._src.isTTY
            : false
            )
    }

    // basically just get replace the getter/setter with a regular value
    function setIsTTY (isTTY) {
      Object.defineProperty(this, 'isTTY', {
        value: isTTY,
        enumerable: true,
        writable: true,
        configurable: true
      });
    }

    Object.defineProperty(MuteStream$1.prototype, 'rows', {
      get: function () {
        return( this._dest ? this._dest.rows
              : this._src ? this._src.rows
              : undefined )
      }, enumerable: true, configurable: true });

    Object.defineProperty(MuteStream$1.prototype, 'columns', {
      get: function () {
        return( this._dest ? this._dest.columns
              : this._src ? this._src.columns
              : undefined )
      }, enumerable: true, configurable: true });


    MuteStream$1.prototype.pipe = function (dest, options) {
      this._dest = dest;
      return Stream.prototype.pipe.call(this, dest, options)
    };

    MuteStream$1.prototype.pause = function () {
      if (this._src) return this._src.pause()
    };

    MuteStream$1.prototype.resume = function () {
      if (this._src) return this._src.resume()
    };

    MuteStream$1.prototype.write = function (c) {
      if (this.muted) {
        if (!this.replace) return true
        if (c.match(/^\u001b/)) {
          if(c.indexOf(this._prompt) === 0) {
            c = c.substr(this._prompt.length);
            c = c.replace(/./g, this.replace);
            c = this._prompt + c;
          }
          this._hadControl = true;
          return this.emit('data', c)
        } else {
          if (this._prompt && this._hadControl &&
              c.indexOf(this._prompt) === 0) {
            this._hadControl = false;
            this.emit('data', this._prompt);
            c = c.substr(this._prompt.length);
          }
          c = c.toString().replace(/./g, this.replace);
        }
      }
      this.emit('data', c);
    };

    MuteStream$1.prototype.end = function (c) {
      if (this.muted) {
        if (c && this.replace) {
          c = c.toString().replace(/./g, this.replace);
        } else {
          c = null;
        }
      }
      if (c) this.emit('data', c);
      this.emit('end');
    };

    function proxy (fn) { return function () {
      var d = this._dest;
      var s = this._src;
      if (d && d[fn]) d[fn].apply(d, arguments);
      if (s && s[fn]) s[fn].apply(s, arguments);
    }}

    MuteStream$1.prototype.destroy = proxy('destroy');
    MuteStream$1.prototype.destroySoon = proxy('destroySoon');
    MuteStream$1.prototype.close = proxy('close');

    const _$d = {
      extend: extend$1,
      omit: omit_1,
    };
    const MuteStream = mute;
    const readline$2 = require$$3__default["default"];

    /**
     * Base interface class other can inherits from
     */

    class UI {
      constructor(opt) {
        // Instantiate the Readline interface
        // @Note: Don't reassign if already present (allow test to override the Stream)
        if (!this.rl) {
          this.rl = readline$2.createInterface(setupReadlineOptions(opt));
        }

        this.rl.resume();

        this.onForceClose = this.onForceClose.bind(this);

        // Make sure new prompt start on a newline when closing
        process.on('exit', this.onForceClose);

        // Terminate process on SIGINT (which will call process.on('exit') in return)
        this.rl.on('SIGINT', this.onForceClose);
      }

      /**
       * Handle the ^C exit
       * @return {null}
       */

      onForceClose() {
        this.close();
        process.kill(process.pid, 'SIGINT');
        console.log('');
      }

      /**
       * Close the interface and cleanup listeners
       */

      close() {
        // Remove events listeners
        this.rl.removeListener('SIGINT', this.onForceClose);
        process.removeListener('exit', this.onForceClose);

        this.rl.output.unmute();

        if (this.activePrompt && typeof this.activePrompt.close === 'function') {
          this.activePrompt.close();
        }

        // Close the readline
        this.rl.output.end();
        this.rl.pause();
        this.rl.close();
      }
    }

    function setupReadlineOptions(opt) {
      opt = opt || {};
      // Inquirer 8.x:
      // opt.skipTTYChecks = opt.skipTTYChecks === undefined ? opt.input !== undefined : opt.skipTTYChecks;
      opt.skipTTYChecks = opt.skipTTYChecks === undefined ? true : opt.skipTTYChecks;

      // Default `input` to stdin
      const input = opt.input || process.stdin;

      // Check if prompt is being called in TTY environment
      // If it isn't return a failed promise
      if (!opt.skipTTYChecks && !input.isTTY) {
        const nonTtyError = new Error(
          'Prompts can not be meaningfully rendered in non-TTY environments'
        );
        nonTtyError.isTtyError = true;
        throw nonTtyError;
      }

      // Add mute capabilities to the output
      const ms = new MuteStream();
      ms.pipe(opt.output || process.stdout);
      const output = ms;

      return _$d.extend(
        {
          terminal: true,
          input,
          output,
        },
        _$d.omit(opt, ['input', 'output'])
      );
    }

    var baseUI = UI;

    var readline$1 = {};

    var ansiEscapes$1 = {exports: {}};

    (function (module) {
    const ansiEscapes = module.exports;
    // TODO: remove this in the next major version
    module.exports.default = ansiEscapes;

    const ESC = '\u001B[';
    const OSC = '\u001B]';
    const BEL = '\u0007';
    const SEP = ';';
    const isTerminalApp = process.env.TERM_PROGRAM === 'Apple_Terminal';

    ansiEscapes.cursorTo = (x, y) => {
    	if (typeof x !== 'number') {
    		throw new TypeError('The `x` argument is required');
    	}

    	if (typeof y !== 'number') {
    		return ESC + (x + 1) + 'G';
    	}

    	return ESC + (y + 1) + ';' + (x + 1) + 'H';
    };

    ansiEscapes.cursorMove = (x, y) => {
    	if (typeof x !== 'number') {
    		throw new TypeError('The `x` argument is required');
    	}

    	let ret = '';

    	if (x < 0) {
    		ret += ESC + (-x) + 'D';
    	} else if (x > 0) {
    		ret += ESC + x + 'C';
    	}

    	if (y < 0) {
    		ret += ESC + (-y) + 'A';
    	} else if (y > 0) {
    		ret += ESC + y + 'B';
    	}

    	return ret;
    };

    ansiEscapes.cursorUp = (count = 1) => ESC + count + 'A';
    ansiEscapes.cursorDown = (count = 1) => ESC + count + 'B';
    ansiEscapes.cursorForward = (count = 1) => ESC + count + 'C';
    ansiEscapes.cursorBackward = (count = 1) => ESC + count + 'D';

    ansiEscapes.cursorLeft = ESC + 'G';
    ansiEscapes.cursorSavePosition = isTerminalApp ? '\u001B7' : ESC + 's';
    ansiEscapes.cursorRestorePosition = isTerminalApp ? '\u001B8' : ESC + 'u';
    ansiEscapes.cursorGetPosition = ESC + '6n';
    ansiEscapes.cursorNextLine = ESC + 'E';
    ansiEscapes.cursorPrevLine = ESC + 'F';
    ansiEscapes.cursorHide = ESC + '?25l';
    ansiEscapes.cursorShow = ESC + '?25h';

    ansiEscapes.eraseLines = count => {
    	let clear = '';

    	for (let i = 0; i < count; i++) {
    		clear += ansiEscapes.eraseLine + (i < count - 1 ? ansiEscapes.cursorUp() : '');
    	}

    	if (count) {
    		clear += ansiEscapes.cursorLeft;
    	}

    	return clear;
    };

    ansiEscapes.eraseEndLine = ESC + 'K';
    ansiEscapes.eraseStartLine = ESC + '1K';
    ansiEscapes.eraseLine = ESC + '2K';
    ansiEscapes.eraseDown = ESC + 'J';
    ansiEscapes.eraseUp = ESC + '1J';
    ansiEscapes.eraseScreen = ESC + '2J';
    ansiEscapes.scrollUp = ESC + 'S';
    ansiEscapes.scrollDown = ESC + 'T';

    ansiEscapes.clearScreen = '\u001Bc';

    ansiEscapes.clearTerminal = process.platform === 'win32' ?
    	`${ansiEscapes.eraseScreen}${ESC}0f` :
    	// 1. Erases the screen (Only done in case `2` is not supported)
    	// 2. Erases the whole screen including scrollback buffer
    	// 3. Moves cursor to the top-left position
    	// More info: https://www.real-world-systems.com/docs/ANSIcode.html
    	`${ansiEscapes.eraseScreen}${ESC}3J${ESC}H`;

    ansiEscapes.beep = BEL;

    ansiEscapes.link = (text, url) => {
    	return [
    		OSC,
    		'8',
    		SEP,
    		SEP,
    		url,
    		BEL,
    		text,
    		OSC,
    		'8',
    		SEP,
    		SEP,
    		BEL
    	].join('');
    };

    ansiEscapes.image = (buffer, options = {}) => {
    	let ret = `${OSC}1337;File=inline=1`;

    	if (options.width) {
    		ret += `;width=${options.width}`;
    	}

    	if (options.height) {
    		ret += `;height=${options.height}`;
    	}

    	if (options.preserveAspectRatio === false) {
    		ret += ';preserveAspectRatio=0';
    	}

    	return ret + ':' + buffer.toString('base64') + BEL;
    };

    ansiEscapes.iTerm = {
    	setCwd: (cwd = process.cwd()) => `${OSC}50;CurrentDir=${cwd}${BEL}`,

    	annotation: (message, options = {}) => {
    		let ret = `${OSC}1337;`;

    		const hasX = typeof options.x !== 'undefined';
    		const hasY = typeof options.y !== 'undefined';
    		if ((hasX || hasY) && !(hasX && hasY && typeof options.length !== 'undefined')) {
    			throw new Error('`x`, `y` and `length` must be defined when `x` or `y` is defined');
    		}

    		message = message.replace(/\|/g, '');

    		ret += options.isHidden ? 'AddHiddenAnnotation=' : 'AddAnnotation=';

    		if (options.length > 0) {
    			ret +=
    					(hasX ?
    						[message, options.length, options.x, options.y] :
    						[options.length, message]).join('|');
    		} else {
    			ret += message;
    		}

    		return ret + BEL;
    	}
    };
    }(ansiEscapes$1));

    const ansiEscapes = ansiEscapes$1.exports;

    /**
     * Move cursor left by `x`
     * @param  {Readline} rl - Readline instance
     * @param  {Number}   x  - How far to go left (default to 1)
     */

    readline$1.left = function (rl, x) {
      rl.output.write(ansiEscapes.cursorBackward(x));
    };

    /**
     * Move cursor right by `x`
     * @param  {Readline} rl - Readline instance
     * @param  {Number}   x  - How far to go left (default to 1)
     */

    readline$1.right = function (rl, x) {
      rl.output.write(ansiEscapes.cursorForward(x));
    };

    /**
     * Move cursor up by `x`
     * @param  {Readline} rl - Readline instance
     * @param  {Number}   x  - How far to go up (default to 1)
     */

    readline$1.up = function (rl, x) {
      rl.output.write(ansiEscapes.cursorUp(x));
    };

    /**
     * Move cursor down by `x`
     * @param  {Readline} rl - Readline instance
     * @param  {Number}   x  - How far to go down (default to 1)
     */

    readline$1.down = function (rl, x) {
      rl.output.write(ansiEscapes.cursorDown(x));
    };

    /**
     * Clear current line
     * @param  {Readline} rl  - Readline instance
     * @param  {Number}   len - number of line to delete
     */
    readline$1.clearLine = function (rl, len) {
      rl.output.write(ansiEscapes.eraseLines(len));
    };

    /**
     * Sticky bottom bar user interface
     */

    const through = through$1.exports;
    const Base$9 = baseUI;
    const rlUtils = readline$1;
    const _$c = {
      last: last_1,
    };

    class BottomBar extends Base$9 {
      constructor(opt) {
        opt = opt || {};

        super(opt);

        this.log = through(this.writeLog.bind(this));
        this.bottomBar = opt.bottomBar || '';
        this.render();
      }

      /**
       * Render the prompt to screen
       * @return {BottomBar} self
       */

      render() {
        this.write(this.bottomBar);
        return this;
      }

      clean() {
        rlUtils.clearLine(this.rl, this.bottomBar.split('\n').length);
        return this;
      }

      /**
       * Update the bottom bar content and rerender
       * @param  {String} bottomBar Bottom bar content
       * @return {BottomBar}           self
       */

      updateBottomBar(bottomBar) {
        rlUtils.clearLine(this.rl, 1);
        this.rl.output.unmute();
        this.clean();
        this.bottomBar = bottomBar;
        this.render();
        this.rl.output.mute();
        return this;
      }

      /**
       * Write out log data
       * @param {String} data - The log data to be output
       * @return {BottomBar} self
       */

      writeLog(data) {
        this.rl.output.unmute();
        this.clean();
        this.rl.output.write(this.enforceLF(data.toString()));
        this.render();
        this.rl.output.mute();
        return this;
      }

      /**
       * Make sure line end on a line feed
       * @param  {String} str Input string
       * @return {String}     The input string with a final line feed
       */

      enforceLF(str) {
        return str.match(/[\r\n]$/) ? str : str + '\n';
      }

      /**
       * Helper for writing message in Prompt
       * @param {BottomBar} prompt  - The Prompt object that extends tty
       * @param {String} message - The message to be output
       */
      write(message) {
        const msgLines = message.split(/\n/);
        this.height = msgLines.length;

        // Write message to screen and setPrompt to control backspace
        this.rl.setPrompt(_$c.last(msgLines));

        if (this.rl.output.rows === 0 && this.rl.output.columns === 0) {
          /* When it's a tty through serial port there's no terminal info and the render will malfunction,
             so we need enforce the cursor to locate to the leftmost position for rendering. */
          rlUtils.left(this.rl, message.length + this.rl.line.length);
        }

        this.rl.output.write(message);
      }
    }

    var bottomBar = BottomBar;

    var baseClone = _baseClone;

    /** Used to compose bitmasks for cloning. */
    var CLONE_SYMBOLS_FLAG = 4;

    /**
     * Creates a shallow clone of `value`.
     *
     * **Note:** This method is loosely based on the
     * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)
     * and supports cloning arrays, array buffers, booleans, date objects, maps,
     * numbers, `Object` objects, regexes, sets, strings, symbols, and typed
     * arrays. The own enumerable properties of `arguments` objects are cloned
     * as plain objects. An empty object is returned for uncloneable values such
     * as error objects, functions, DOM nodes, and WeakMaps.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to clone.
     * @returns {*} Returns the cloned value.
     * @see _.cloneDeep
     * @example
     *
     * var objects = [{ 'a': 1 }, { 'b': 2 }];
     *
     * var shallow = _.clone(objects);
     * console.log(shallow[0] === objects[0]);
     * // => true
     */
    function clone$2(value) {
      return baseClone(value, CLONE_SYMBOLS_FLAG);
    }

    var clone_1 = clone$2;

    var baseGet$1 = _baseGet;

    /**
     * Gets the value at `path` of `object`. If the resolved value is
     * `undefined`, the `defaultValue` is returned in its place.
     *
     * @static
     * @memberOf _
     * @since 3.7.0
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the property to get.
     * @param {*} [defaultValue] The value returned for `undefined` resolved values.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
     *
     * _.get(object, 'a[0].b.c');
     * // => 3
     *
     * _.get(object, ['a', '0', 'b', 'c']);
     * // => 3
     *
     * _.get(object, 'a.b.c', 'default');
     * // => 'default'
     */
    function get$1(object, path, defaultValue) {
      var result = object == null ? undefined : baseGet$1(object, path);
      return result === undefined ? defaultValue : result;
    }

    var get_1 = get$1;

    var assignValue$1 = _assignValue,
        castPath$1 = _castPath,
        isIndex$1 = _isIndex,
        isObject$2 = isObject_1,
        toKey$3 = _toKey;

    /**
     * The base implementation of `_.set`.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {*} value The value to set.
     * @param {Function} [customizer] The function to customize path creation.
     * @returns {Object} Returns `object`.
     */
    function baseSet$1(object, path, value, customizer) {
      if (!isObject$2(object)) {
        return object;
      }
      path = castPath$1(path, object);

      var index = -1,
          length = path.length,
          lastIndex = length - 1,
          nested = object;

      while (nested != null && ++index < length) {
        var key = toKey$3(path[index]),
            newValue = value;

        if (key === '__proto__' || key === 'constructor' || key === 'prototype') {
          return object;
        }

        if (index != lastIndex) {
          var objValue = nested[key];
          newValue = customizer ? customizer(objValue, key, nested) : undefined;
          if (newValue === undefined) {
            newValue = isObject$2(objValue)
              ? objValue
              : (isIndex$1(path[index + 1]) ? [] : {});
          }
        }
        assignValue$1(nested, key, newValue);
        nested = nested[key];
      }
      return object;
    }

    var _baseSet = baseSet$1;

    var baseSet = _baseSet;

    /**
     * Sets the value at `path` of `object`. If a portion of `path` doesn't exist,
     * it's created. Arrays are created for missing index properties while objects
     * are created for all other missing properties. Use `_.setWith` to customize
     * `path` creation.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 3.7.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
     *
     * _.set(object, 'a[0].b.c', 4);
     * console.log(object.a[0].b.c);
     * // => 4
     *
     * _.set(object, ['x', '0', 'y', 'z'], 5);
     * console.log(object.x[0].y.z);
     * // => 5
     */
    function set(object, path, value) {
      return object == null ? object : baseSet(object, path, value);
    }

    var set_1 = set;

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
    /* global Reflect, Promise */

    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };

    function __extends$4(d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }

    function __awaiter(thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }

    function __generator(thisArg, body) {
        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f) throw new TypeError("Generator is already executing.");
            while (_) try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
                if (y = 0, t) op = [op[0] & 2, t.value];
                switch (op[0]) {
                    case 0: case 1: t = op; break;
                    case 4: _.label++; return { value: op[1], done: false };
                    case 5: _.label++; y = op[1]; op = [0]; continue;
                    case 7: op = _.ops.pop(); _.trys.pop(); continue;
                    default:
                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                        if (t[2]) _.ops.pop();
                        _.trys.pop(); continue;
                }
                op = body.call(thisArg, _);
            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
        }
    }

    function __values(o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m) return m.call(o);
        if (o && typeof o.length === "number") return {
            next: function () {
                if (o && i >= o.length) o = void 0;
                return { value: o && o[i++], done: !o };
            }
        };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    }

    function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    }

    function __spreadArray(to, from) {
        for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
            to[j] = from[i];
        return to;
    }

    function __await(v) {
        return this instanceof __await ? (this.v = v, this) : new __await(v);
    }

    function __asyncGenerator(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i, q = [];
        return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
        function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
        function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
        function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
        function fulfill(value) { resume("next", value); }
        function reject(value) { resume("throw", value); }
        function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
    }

    function __asyncValues(o) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator], i;
        return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
        function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
        function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
    }

    function isFunction(value) {
        return typeof value === 'function';
    }

    function createErrorClass(createImpl) {
        var _super = function (instance) {
            Error.call(instance);
            instance.stack = new Error().stack;
        };
        var ctorFunc = createImpl(_super);
        ctorFunc.prototype = Object.create(Error.prototype);
        ctorFunc.prototype.constructor = ctorFunc;
        return ctorFunc;
    }

    var UnsubscriptionError = createErrorClass(function (_super) {
        return function UnsubscriptionErrorImpl(errors) {
            _super(this);
            this.message = errors
                ? errors.length + " errors occurred during unsubscription:\n" + errors.map(function (err, i) { return i + 1 + ") " + err.toString(); }).join('\n  ')
                : '';
            this.name = 'UnsubscriptionError';
            this.errors = errors;
        };
    });

    function arrRemove(arr, item) {
        if (arr) {
            var index = arr.indexOf(item);
            0 <= index && arr.splice(index, 1);
        }
    }

    var Subscription = (function () {
        function Subscription(initialTeardown) {
            this.initialTeardown = initialTeardown;
            this.closed = false;
            this._parentage = null;
            this._teardowns = null;
        }
        Subscription.prototype.unsubscribe = function () {
            var e_1, _a, e_2, _b;
            var errors;
            if (!this.closed) {
                this.closed = true;
                var _parentage = this._parentage;
                if (_parentage) {
                    this._parentage = null;
                    if (Array.isArray(_parentage)) {
                        try {
                            for (var _parentage_1 = __values(_parentage), _parentage_1_1 = _parentage_1.next(); !_parentage_1_1.done; _parentage_1_1 = _parentage_1.next()) {
                                var parent_1 = _parentage_1_1.value;
                                parent_1.remove(this);
                            }
                        }
                        catch (e_1_1) { e_1 = { error: e_1_1 }; }
                        finally {
                            try {
                                if (_parentage_1_1 && !_parentage_1_1.done && (_a = _parentage_1.return)) _a.call(_parentage_1);
                            }
                            finally { if (e_1) throw e_1.error; }
                        }
                    }
                    else {
                        _parentage.remove(this);
                    }
                }
                var initialTeardown = this.initialTeardown;
                if (isFunction(initialTeardown)) {
                    try {
                        initialTeardown();
                    }
                    catch (e) {
                        errors = e instanceof UnsubscriptionError ? e.errors : [e];
                    }
                }
                var _teardowns = this._teardowns;
                if (_teardowns) {
                    this._teardowns = null;
                    try {
                        for (var _teardowns_1 = __values(_teardowns), _teardowns_1_1 = _teardowns_1.next(); !_teardowns_1_1.done; _teardowns_1_1 = _teardowns_1.next()) {
                            var teardown_1 = _teardowns_1_1.value;
                            try {
                                execTeardown(teardown_1);
                            }
                            catch (err) {
                                errors = errors !== null && errors !== void 0 ? errors : [];
                                if (err instanceof UnsubscriptionError) {
                                    errors = __spreadArray(__spreadArray([], __read(errors)), __read(err.errors));
                                }
                                else {
                                    errors.push(err);
                                }
                            }
                        }
                    }
                    catch (e_2_1) { e_2 = { error: e_2_1 }; }
                    finally {
                        try {
                            if (_teardowns_1_1 && !_teardowns_1_1.done && (_b = _teardowns_1.return)) _b.call(_teardowns_1);
                        }
                        finally { if (e_2) throw e_2.error; }
                    }
                }
                if (errors) {
                    throw new UnsubscriptionError(errors);
                }
            }
        };
        Subscription.prototype.add = function (teardown) {
            var _a;
            if (teardown && teardown !== this) {
                if (this.closed) {
                    execTeardown(teardown);
                }
                else {
                    if (teardown instanceof Subscription) {
                        if (teardown.closed || teardown._hasParent(this)) {
                            return;
                        }
                        teardown._addParent(this);
                    }
                    (this._teardowns = (_a = this._teardowns) !== null && _a !== void 0 ? _a : []).push(teardown);
                }
            }
        };
        Subscription.prototype._hasParent = function (parent) {
            var _parentage = this._parentage;
            return _parentage === parent || (Array.isArray(_parentage) && _parentage.includes(parent));
        };
        Subscription.prototype._addParent = function (parent) {
            var _parentage = this._parentage;
            this._parentage = Array.isArray(_parentage) ? (_parentage.push(parent), _parentage) : _parentage ? [_parentage, parent] : parent;
        };
        Subscription.prototype._removeParent = function (parent) {
            var _parentage = this._parentage;
            if (_parentage === parent) {
                this._parentage = null;
            }
            else if (Array.isArray(_parentage)) {
                arrRemove(_parentage, parent);
            }
        };
        Subscription.prototype.remove = function (teardown) {
            var _teardowns = this._teardowns;
            _teardowns && arrRemove(_teardowns, teardown);
            if (teardown instanceof Subscription) {
                teardown._removeParent(this);
            }
        };
        Subscription.EMPTY = (function () {
            var empty = new Subscription();
            empty.closed = true;
            return empty;
        })();
        return Subscription;
    }());
    var EMPTY_SUBSCRIPTION = Subscription.EMPTY;
    function isSubscription(value) {
        return (value instanceof Subscription ||
            (value && 'closed' in value && isFunction(value.remove) && isFunction(value.add) && isFunction(value.unsubscribe)));
    }
    function execTeardown(teardown) {
        if (isFunction(teardown)) {
            teardown();
        }
        else {
            teardown.unsubscribe();
        }
    }

    var config = {
        onUnhandledError: null,
        onStoppedNotification: null,
        Promise: undefined,
        useDeprecatedSynchronousErrorHandling: false,
        useDeprecatedNextContext: false,
    };

    var timeoutProvider = {
        setTimeout: function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            var delegate = timeoutProvider.delegate;
            return ((delegate === null || delegate === void 0 ? void 0 : delegate.setTimeout) || setTimeout).apply(void 0, __spreadArray([], __read(args)));
        },
        clearTimeout: function (handle) {
            var delegate = timeoutProvider.delegate;
            return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearTimeout) || clearTimeout)(handle);
        },
        delegate: undefined,
    };

    function reportUnhandledError(err) {
        timeoutProvider.setTimeout(function () {
            var onUnhandledError = config.onUnhandledError;
            if (onUnhandledError) {
                onUnhandledError(err);
            }
            else {
                throw err;
            }
        });
    }

    function noop$2() { }

    var COMPLETE_NOTIFICATION = (function () { return createNotification('C', undefined, undefined); })();
    function errorNotification(error) {
        return createNotification('E', undefined, error);
    }
    function nextNotification(value) {
        return createNotification('N', value, undefined);
    }
    function createNotification(kind, value, error) {
        return {
            kind: kind,
            value: value,
            error: error,
        };
    }

    var context = null;
    function errorContext(cb) {
        if (config.useDeprecatedSynchronousErrorHandling) {
            var isRoot = !context;
            if (isRoot) {
                context = { errorThrown: false, error: null };
            }
            cb();
            if (isRoot) {
                var _a = context, errorThrown = _a.errorThrown, error = _a.error;
                context = null;
                if (errorThrown) {
                    throw error;
                }
            }
        }
        else {
            cb();
        }
    }
    function captureError(err) {
        if (config.useDeprecatedSynchronousErrorHandling && context) {
            context.errorThrown = true;
            context.error = err;
        }
    }

    var Subscriber = (function (_super) {
        __extends$4(Subscriber, _super);
        function Subscriber(destination) {
            var _this = _super.call(this) || this;
            _this.isStopped = false;
            if (destination) {
                _this.destination = destination;
                if (isSubscription(destination)) {
                    destination.add(_this);
                }
            }
            else {
                _this.destination = EMPTY_OBSERVER;
            }
            return _this;
        }
        Subscriber.create = function (next, error, complete) {
            return new SafeSubscriber(next, error, complete);
        };
        Subscriber.prototype.next = function (value) {
            if (this.isStopped) {
                handleStoppedNotification(nextNotification(value), this);
            }
            else {
                this._next(value);
            }
        };
        Subscriber.prototype.error = function (err) {
            if (this.isStopped) {
                handleStoppedNotification(errorNotification(err), this);
            }
            else {
                this.isStopped = true;
                this._error(err);
            }
        };
        Subscriber.prototype.complete = function () {
            if (this.isStopped) {
                handleStoppedNotification(COMPLETE_NOTIFICATION, this);
            }
            else {
                this.isStopped = true;
                this._complete();
            }
        };
        Subscriber.prototype.unsubscribe = function () {
            if (!this.closed) {
                this.isStopped = true;
                _super.prototype.unsubscribe.call(this);
                this.destination = null;
            }
        };
        Subscriber.prototype._next = function (value) {
            this.destination.next(value);
        };
        Subscriber.prototype._error = function (err) {
            try {
                this.destination.error(err);
            }
            finally {
                this.unsubscribe();
            }
        };
        Subscriber.prototype._complete = function () {
            try {
                this.destination.complete();
            }
            finally {
                this.unsubscribe();
            }
        };
        return Subscriber;
    }(Subscription));
    var SafeSubscriber = (function (_super) {
        __extends$4(SafeSubscriber, _super);
        function SafeSubscriber(observerOrNext, error, complete) {
            var _this = _super.call(this) || this;
            var next;
            if (isFunction(observerOrNext)) {
                next = observerOrNext;
            }
            else if (observerOrNext) {
                (next = observerOrNext.next, error = observerOrNext.error, complete = observerOrNext.complete);
                var context_1;
                if (_this && config.useDeprecatedNextContext) {
                    context_1 = Object.create(observerOrNext);
                    context_1.unsubscribe = function () { return _this.unsubscribe(); };
                }
                else {
                    context_1 = observerOrNext;
                }
                next = next === null || next === void 0 ? void 0 : next.bind(context_1);
                error = error === null || error === void 0 ? void 0 : error.bind(context_1);
                complete = complete === null || complete === void 0 ? void 0 : complete.bind(context_1);
            }
            _this.destination = {
                next: next ? wrapForErrorHandling(next) : noop$2,
                error: wrapForErrorHandling(error !== null && error !== void 0 ? error : defaultErrorHandler),
                complete: complete ? wrapForErrorHandling(complete) : noop$2,
            };
            return _this;
        }
        return SafeSubscriber;
    }(Subscriber));
    function wrapForErrorHandling(handler, instance) {
        return function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            try {
                handler.apply(void 0, __spreadArray([], __read(args)));
            }
            catch (err) {
                if (config.useDeprecatedSynchronousErrorHandling) {
                    captureError(err);
                }
                else {
                    reportUnhandledError(err);
                }
            }
        };
    }
    function defaultErrorHandler(err) {
        throw err;
    }
    function handleStoppedNotification(notification, subscriber) {
        var onStoppedNotification = config.onStoppedNotification;
        onStoppedNotification && timeoutProvider.setTimeout(function () { return onStoppedNotification(notification, subscriber); });
    }
    var EMPTY_OBSERVER = {
        closed: true,
        next: noop$2,
        error: defaultErrorHandler,
        complete: noop$2,
    };

    var observable = (function () { return (typeof Symbol === 'function' && Symbol.observable) || '@@observable'; })();

    function identity$2(x) {
        return x;
    }

    function pipe$1() {
        var fns = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            fns[_i] = arguments[_i];
        }
        return pipeFromArray(fns);
    }
    function pipeFromArray(fns) {
        if (fns.length === 0) {
            return identity$2;
        }
        if (fns.length === 1) {
            return fns[0];
        }
        return function piped(input) {
            return fns.reduce(function (prev, fn) { return fn(prev); }, input);
        };
    }

    var Observable = (function () {
        function Observable(subscribe) {
            if (subscribe) {
                this._subscribe = subscribe;
            }
        }
        Observable.prototype.lift = function (operator) {
            var observable = new Observable();
            observable.source = this;
            observable.operator = operator;
            return observable;
        };
        Observable.prototype.subscribe = function (observerOrNext, error, complete) {
            var _this = this;
            var subscriber = isSubscriber(observerOrNext) ? observerOrNext : new SafeSubscriber(observerOrNext, error, complete);
            errorContext(function () {
                var _a = _this, operator = _a.operator, source = _a.source;
                subscriber.add(operator
                    ?
                        operator.call(subscriber, source)
                    : source
                        ?
                            _this._subscribe(subscriber)
                        :
                            _this._trySubscribe(subscriber));
            });
            return subscriber;
        };
        Observable.prototype._trySubscribe = function (sink) {
            try {
                return this._subscribe(sink);
            }
            catch (err) {
                sink.error(err);
            }
        };
        Observable.prototype.forEach = function (next, promiseCtor) {
            var _this = this;
            promiseCtor = getPromiseCtor(promiseCtor);
            return new promiseCtor(function (resolve, reject) {
                var subscription;
                subscription = _this.subscribe(function (value) {
                    try {
                        next(value);
                    }
                    catch (err) {
                        reject(err);
                        subscription === null || subscription === void 0 ? void 0 : subscription.unsubscribe();
                    }
                }, reject, resolve);
            });
        };
        Observable.prototype._subscribe = function (subscriber) {
            var _a;
            return (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber);
        };
        Observable.prototype[observable] = function () {
            return this;
        };
        Observable.prototype.pipe = function () {
            var operations = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                operations[_i] = arguments[_i];
            }
            return pipeFromArray(operations)(this);
        };
        Observable.prototype.toPromise = function (promiseCtor) {
            var _this = this;
            promiseCtor = getPromiseCtor(promiseCtor);
            return new promiseCtor(function (resolve, reject) {
                var value;
                _this.subscribe(function (x) { return (value = x); }, function (err) { return reject(err); }, function () { return resolve(value); });
            });
        };
        Observable.create = function (subscribe) {
            return new Observable(subscribe);
        };
        return Observable;
    }());
    function getPromiseCtor(promiseCtor) {
        var _a;
        return (_a = promiseCtor !== null && promiseCtor !== void 0 ? promiseCtor : config.Promise) !== null && _a !== void 0 ? _a : Promise;
    }
    function isObserver(value) {
        return value && isFunction(value.next) && isFunction(value.error) && isFunction(value.complete);
    }
    function isSubscriber(value) {
        return (value && value instanceof Subscriber) || (isObserver(value) && isSubscription(value));
    }

    function hasLift(source) {
        return isFunction(source === null || source === void 0 ? void 0 : source.lift);
    }
    function operate(init) {
        return function (source) {
            if (hasLift(source)) {
                return source.lift(function (liftedSource) {
                    try {
                        return init(liftedSource, this);
                    }
                    catch (err) {
                        this.error(err);
                    }
                });
            }
            throw new TypeError('Unable to lift unknown Observable type');
        };
    }

    var OperatorSubscriber = (function (_super) {
        __extends$4(OperatorSubscriber, _super);
        function OperatorSubscriber(destination, onNext, onComplete, onError, onFinalize) {
            var _this = _super.call(this, destination) || this;
            _this.onFinalize = onFinalize;
            _this._next = onNext
                ? function (value) {
                    try {
                        onNext(value);
                    }
                    catch (err) {
                        destination.error(err);
                    }
                }
                : _super.prototype._next;
            _this._error = onError
                ? function (err) {
                    try {
                        onError(err);
                    }
                    catch (err) {
                        destination.error(err);
                    }
                    finally {
                        this.unsubscribe();
                    }
                }
                : _super.prototype._error;
            _this._complete = onComplete
                ? function () {
                    try {
                        onComplete();
                    }
                    catch (err) {
                        destination.error(err);
                    }
                    finally {
                        this.unsubscribe();
                    }
                }
                : _super.prototype._complete;
            return _this;
        }
        OperatorSubscriber.prototype.unsubscribe = function () {
            var _a;
            var closed = this.closed;
            _super.prototype.unsubscribe.call(this);
            !closed && ((_a = this.onFinalize) === null || _a === void 0 ? void 0 : _a.call(this));
        };
        return OperatorSubscriber;
    }(Subscriber));

    function refCount() {
        return operate(function (source, subscriber) {
            var connection = null;
            source._refCount++;
            var refCounter = new OperatorSubscriber(subscriber, undefined, undefined, undefined, function () {
                if (!source || source._refCount <= 0 || 0 < --source._refCount) {
                    connection = null;
                    return;
                }
                var sharedConnection = source._connection;
                var conn = connection;
                connection = null;
                if (sharedConnection && (!conn || sharedConnection === conn)) {
                    sharedConnection.unsubscribe();
                }
                subscriber.unsubscribe();
            });
            source.subscribe(refCounter);
            if (!refCounter.closed) {
                connection = source.connect();
            }
        });
    }

    var ConnectableObservable = (function (_super) {
        __extends$4(ConnectableObservable, _super);
        function ConnectableObservable(source, subjectFactory) {
            var _this = _super.call(this) || this;
            _this.source = source;
            _this.subjectFactory = subjectFactory;
            _this._subject = null;
            _this._refCount = 0;
            _this._connection = null;
            if (hasLift(source)) {
                _this.lift = source.lift;
            }
            return _this;
        }
        ConnectableObservable.prototype._subscribe = function (subscriber) {
            return this.getSubject().subscribe(subscriber);
        };
        ConnectableObservable.prototype.getSubject = function () {
            var subject = this._subject;
            if (!subject || subject.isStopped) {
                this._subject = this.subjectFactory();
            }
            return this._subject;
        };
        ConnectableObservable.prototype._teardown = function () {
            this._refCount = 0;
            var _connection = this._connection;
            this._subject = this._connection = null;
            _connection === null || _connection === void 0 ? void 0 : _connection.unsubscribe();
        };
        ConnectableObservable.prototype.connect = function () {
            var _this = this;
            var connection = this._connection;
            if (!connection) {
                connection = this._connection = new Subscription();
                var subject_1 = this.getSubject();
                connection.add(this.source.subscribe(new OperatorSubscriber(subject_1, undefined, function () {
                    _this._teardown();
                    subject_1.complete();
                }, function (err) {
                    _this._teardown();
                    subject_1.error(err);
                }, function () { return _this._teardown(); })));
                if (connection.closed) {
                    this._connection = null;
                    connection = Subscription.EMPTY;
                }
            }
            return connection;
        };
        ConnectableObservable.prototype.refCount = function () {
            return refCount()(this);
        };
        return ConnectableObservable;
    }(Observable));

    var performanceTimestampProvider = {
        now: function () {
            return (performanceTimestampProvider.delegate || performance).now();
        },
        delegate: undefined,
    };

    var animationFrameProvider = {
        schedule: function (callback) {
            var request = requestAnimationFrame;
            var cancel = cancelAnimationFrame;
            var delegate = animationFrameProvider.delegate;
            if (delegate) {
                request = delegate.requestAnimationFrame;
                cancel = delegate.cancelAnimationFrame;
            }
            var handle = request(function (timestamp) {
                cancel = undefined;
                callback(timestamp);
            });
            return new Subscription(function () { return cancel === null || cancel === void 0 ? void 0 : cancel(handle); });
        },
        requestAnimationFrame: function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            var delegate = animationFrameProvider.delegate;
            return ((delegate === null || delegate === void 0 ? void 0 : delegate.requestAnimationFrame) || requestAnimationFrame).apply(void 0, __spreadArray([], __read(args)));
        },
        cancelAnimationFrame: function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            var delegate = animationFrameProvider.delegate;
            return ((delegate === null || delegate === void 0 ? void 0 : delegate.cancelAnimationFrame) || cancelAnimationFrame).apply(void 0, __spreadArray([], __read(args)));
        },
        delegate: undefined,
    };

    function animationFrames(timestampProvider) {
        return timestampProvider ? animationFramesFactory(timestampProvider) : DEFAULT_ANIMATION_FRAMES;
    }
    function animationFramesFactory(timestampProvider) {
        var schedule = animationFrameProvider.schedule;
        return new Observable(function (subscriber) {
            var subscription = new Subscription();
            var provider = timestampProvider || performanceTimestampProvider;
            var start = provider.now();
            var run = function (timestamp) {
                var now = provider.now();
                subscriber.next({
                    timestamp: timestampProvider ? now : timestamp,
                    elapsed: now - start
                });
                if (!subscriber.closed) {
                    subscription.add(schedule(run));
                }
            };
            subscription.add(schedule(run));
            return subscription;
        });
    }
    var DEFAULT_ANIMATION_FRAMES = animationFramesFactory();

    var ObjectUnsubscribedError = createErrorClass(function (_super) {
        return function ObjectUnsubscribedErrorImpl() {
            _super(this);
            this.name = 'ObjectUnsubscribedError';
            this.message = 'object unsubscribed';
        };
    });

    var Subject$1 = (function (_super) {
        __extends$4(Subject, _super);
        function Subject() {
            var _this = _super.call(this) || this;
            _this.closed = false;
            _this.observers = [];
            _this.isStopped = false;
            _this.hasError = false;
            _this.thrownError = null;
            return _this;
        }
        Subject.prototype.lift = function (operator) {
            var subject = new AnonymousSubject(this, this);
            subject.operator = operator;
            return subject;
        };
        Subject.prototype._throwIfClosed = function () {
            if (this.closed) {
                throw new ObjectUnsubscribedError();
            }
        };
        Subject.prototype.next = function (value) {
            var _this = this;
            errorContext(function () {
                var e_1, _a;
                _this._throwIfClosed();
                if (!_this.isStopped) {
                    var copy = _this.observers.slice();
                    try {
                        for (var copy_1 = __values(copy), copy_1_1 = copy_1.next(); !copy_1_1.done; copy_1_1 = copy_1.next()) {
                            var observer = copy_1_1.value;
                            observer.next(value);
                        }
                    }
                    catch (e_1_1) { e_1 = { error: e_1_1 }; }
                    finally {
                        try {
                            if (copy_1_1 && !copy_1_1.done && (_a = copy_1.return)) _a.call(copy_1);
                        }
                        finally { if (e_1) throw e_1.error; }
                    }
                }
            });
        };
        Subject.prototype.error = function (err) {
            var _this = this;
            errorContext(function () {
                _this._throwIfClosed();
                if (!_this.isStopped) {
                    _this.hasError = _this.isStopped = true;
                    _this.thrownError = err;
                    var observers = _this.observers;
                    while (observers.length) {
                        observers.shift().error(err);
                    }
                }
            });
        };
        Subject.prototype.complete = function () {
            var _this = this;
            errorContext(function () {
                _this._throwIfClosed();
                if (!_this.isStopped) {
                    _this.isStopped = true;
                    var observers = _this.observers;
                    while (observers.length) {
                        observers.shift().complete();
                    }
                }
            });
        };
        Subject.prototype.unsubscribe = function () {
            this.isStopped = this.closed = true;
            this.observers = null;
        };
        Object.defineProperty(Subject.prototype, "observed", {
            get: function () {
                var _a;
                return ((_a = this.observers) === null || _a === void 0 ? void 0 : _a.length) > 0;
            },
            enumerable: false,
            configurable: true
        });
        Subject.prototype._trySubscribe = function (subscriber) {
            this._throwIfClosed();
            return _super.prototype._trySubscribe.call(this, subscriber);
        };
        Subject.prototype._subscribe = function (subscriber) {
            this._throwIfClosed();
            this._checkFinalizedStatuses(subscriber);
            return this._innerSubscribe(subscriber);
        };
        Subject.prototype._innerSubscribe = function (subscriber) {
            var _a = this, hasError = _a.hasError, isStopped = _a.isStopped, observers = _a.observers;
            return hasError || isStopped
                ? EMPTY_SUBSCRIPTION
                : (observers.push(subscriber), new Subscription(function () { return arrRemove(observers, subscriber); }));
        };
        Subject.prototype._checkFinalizedStatuses = function (subscriber) {
            var _a = this, hasError = _a.hasError, thrownError = _a.thrownError, isStopped = _a.isStopped;
            if (hasError) {
                subscriber.error(thrownError);
            }
            else if (isStopped) {
                subscriber.complete();
            }
        };
        Subject.prototype.asObservable = function () {
            var observable = new Observable();
            observable.source = this;
            return observable;
        };
        Subject.create = function (destination, source) {
            return new AnonymousSubject(destination, source);
        };
        return Subject;
    }(Observable));
    var AnonymousSubject = (function (_super) {
        __extends$4(AnonymousSubject, _super);
        function AnonymousSubject(destination, source) {
            var _this = _super.call(this) || this;
            _this.destination = destination;
            _this.source = source;
            return _this;
        }
        AnonymousSubject.prototype.next = function (value) {
            var _a, _b;
            (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.next) === null || _b === void 0 ? void 0 : _b.call(_a, value);
        };
        AnonymousSubject.prototype.error = function (err) {
            var _a, _b;
            (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.error) === null || _b === void 0 ? void 0 : _b.call(_a, err);
        };
        AnonymousSubject.prototype.complete = function () {
            var _a, _b;
            (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.complete) === null || _b === void 0 ? void 0 : _b.call(_a);
        };
        AnonymousSubject.prototype._subscribe = function (subscriber) {
            var _a, _b;
            return (_b = (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber)) !== null && _b !== void 0 ? _b : EMPTY_SUBSCRIPTION;
        };
        return AnonymousSubject;
    }(Subject$1));

    var BehaviorSubject = (function (_super) {
        __extends$4(BehaviorSubject, _super);
        function BehaviorSubject(_value) {
            var _this = _super.call(this) || this;
            _this._value = _value;
            return _this;
        }
        Object.defineProperty(BehaviorSubject.prototype, "value", {
            get: function () {
                return this.getValue();
            },
            enumerable: false,
            configurable: true
        });
        BehaviorSubject.prototype._subscribe = function (subscriber) {
            var subscription = _super.prototype._subscribe.call(this, subscriber);
            !subscription.closed && subscriber.next(this._value);
            return subscription;
        };
        BehaviorSubject.prototype.getValue = function () {
            var _a = this, hasError = _a.hasError, thrownError = _a.thrownError, _value = _a._value;
            if (hasError) {
                throw thrownError;
            }
            this._throwIfClosed();
            return _value;
        };
        BehaviorSubject.prototype.next = function (value) {
            _super.prototype.next.call(this, (this._value = value));
        };
        return BehaviorSubject;
    }(Subject$1));

    var dateTimestampProvider = {
        now: function () {
            return (dateTimestampProvider.delegate || Date).now();
        },
        delegate: undefined,
    };

    var ReplaySubject = (function (_super) {
        __extends$4(ReplaySubject, _super);
        function ReplaySubject(_bufferSize, _windowTime, _timestampProvider) {
            if (_bufferSize === void 0) { _bufferSize = Infinity; }
            if (_windowTime === void 0) { _windowTime = Infinity; }
            if (_timestampProvider === void 0) { _timestampProvider = dateTimestampProvider; }
            var _this = _super.call(this) || this;
            _this._bufferSize = _bufferSize;
            _this._windowTime = _windowTime;
            _this._timestampProvider = _timestampProvider;
            _this._buffer = [];
            _this._infiniteTimeWindow = true;
            _this._infiniteTimeWindow = _windowTime === Infinity;
            _this._bufferSize = Math.max(1, _bufferSize);
            _this._windowTime = Math.max(1, _windowTime);
            return _this;
        }
        ReplaySubject.prototype.next = function (value) {
            var _a = this, isStopped = _a.isStopped, _buffer = _a._buffer, _infiniteTimeWindow = _a._infiniteTimeWindow, _timestampProvider = _a._timestampProvider, _windowTime = _a._windowTime;
            if (!isStopped) {
                _buffer.push(value);
                !_infiniteTimeWindow && _buffer.push(_timestampProvider.now() + _windowTime);
            }
            this._trimBuffer();
            _super.prototype.next.call(this, value);
        };
        ReplaySubject.prototype._subscribe = function (subscriber) {
            this._throwIfClosed();
            this._trimBuffer();
            var subscription = this._innerSubscribe(subscriber);
            var _a = this, _infiniteTimeWindow = _a._infiniteTimeWindow, _buffer = _a._buffer;
            var copy = _buffer.slice();
            for (var i = 0; i < copy.length && !subscriber.closed; i += _infiniteTimeWindow ? 1 : 2) {
                subscriber.next(copy[i]);
            }
            this._checkFinalizedStatuses(subscriber);
            return subscription;
        };
        ReplaySubject.prototype._trimBuffer = function () {
            var _a = this, _bufferSize = _a._bufferSize, _timestampProvider = _a._timestampProvider, _buffer = _a._buffer, _infiniteTimeWindow = _a._infiniteTimeWindow;
            var adjustedBufferSize = (_infiniteTimeWindow ? 1 : 2) * _bufferSize;
            _bufferSize < Infinity && adjustedBufferSize < _buffer.length && _buffer.splice(0, _buffer.length - adjustedBufferSize);
            if (!_infiniteTimeWindow) {
                var now = _timestampProvider.now();
                var last = 0;
                for (var i = 1; i < _buffer.length && _buffer[i] <= now; i += 2) {
                    last = i;
                }
                last && _buffer.splice(0, last + 1);
            }
        };
        return ReplaySubject;
    }(Subject$1));

    var AsyncSubject = (function (_super) {
        __extends$4(AsyncSubject, _super);
        function AsyncSubject() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this._value = null;
            _this._hasValue = false;
            _this._isComplete = false;
            return _this;
        }
        AsyncSubject.prototype._checkFinalizedStatuses = function (subscriber) {
            var _a = this, hasError = _a.hasError, _hasValue = _a._hasValue, _value = _a._value, thrownError = _a.thrownError, isStopped = _a.isStopped, _isComplete = _a._isComplete;
            if (hasError) {
                subscriber.error(thrownError);
            }
            else if (isStopped || _isComplete) {
                _hasValue && subscriber.next(_value);
                subscriber.complete();
            }
        };
        AsyncSubject.prototype.next = function (value) {
            if (!this.isStopped) {
                this._value = value;
                this._hasValue = true;
            }
        };
        AsyncSubject.prototype.complete = function () {
            var _a = this, _hasValue = _a._hasValue, _value = _a._value, _isComplete = _a._isComplete;
            if (!_isComplete) {
                this._isComplete = true;
                _hasValue && _super.prototype.next.call(this, _value);
                _super.prototype.complete.call(this);
            }
        };
        return AsyncSubject;
    }(Subject$1));

    var Action = (function (_super) {
        __extends$4(Action, _super);
        function Action(scheduler, work) {
            return _super.call(this) || this;
        }
        Action.prototype.schedule = function (state, delay) {
            return this;
        };
        return Action;
    }(Subscription));

    var intervalProvider = {
        setInterval: function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            var delegate = intervalProvider.delegate;
            return ((delegate === null || delegate === void 0 ? void 0 : delegate.setInterval) || setInterval).apply(void 0, __spreadArray([], __read(args)));
        },
        clearInterval: function (handle) {
            var delegate = intervalProvider.delegate;
            return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearInterval) || clearInterval)(handle);
        },
        delegate: undefined,
    };

    var AsyncAction = (function (_super) {
        __extends$4(AsyncAction, _super);
        function AsyncAction(scheduler, work) {
            var _this = _super.call(this, scheduler, work) || this;
            _this.scheduler = scheduler;
            _this.work = work;
            _this.pending = false;
            return _this;
        }
        AsyncAction.prototype.schedule = function (state, delay) {
            if (delay === void 0) { delay = 0; }
            if (this.closed) {
                return this;
            }
            this.state = state;
            var id = this.id;
            var scheduler = this.scheduler;
            if (id != null) {
                this.id = this.recycleAsyncId(scheduler, id, delay);
            }
            this.pending = true;
            this.delay = delay;
            this.id = this.id || this.requestAsyncId(scheduler, this.id, delay);
            return this;
        };
        AsyncAction.prototype.requestAsyncId = function (scheduler, _id, delay) {
            if (delay === void 0) { delay = 0; }
            return intervalProvider.setInterval(scheduler.flush.bind(scheduler, this), delay);
        };
        AsyncAction.prototype.recycleAsyncId = function (_scheduler, id, delay) {
            if (delay === void 0) { delay = 0; }
            if (delay != null && this.delay === delay && this.pending === false) {
                return id;
            }
            intervalProvider.clearInterval(id);
            return undefined;
        };
        AsyncAction.prototype.execute = function (state, delay) {
            if (this.closed) {
                return new Error('executing a cancelled action');
            }
            this.pending = false;
            var error = this._execute(state, delay);
            if (error) {
                return error;
            }
            else if (this.pending === false && this.id != null) {
                this.id = this.recycleAsyncId(this.scheduler, this.id, null);
            }
        };
        AsyncAction.prototype._execute = function (state, _delay) {
            var errored = false;
            var errorValue;
            try {
                this.work(state);
            }
            catch (e) {
                errored = true;
                errorValue = e ? e : new Error('Scheduled action threw falsy error');
            }
            if (errored) {
                this.unsubscribe();
                return errorValue;
            }
        };
        AsyncAction.prototype.unsubscribe = function () {
            if (!this.closed) {
                var _a = this, id = _a.id, scheduler = _a.scheduler;
                var actions = scheduler.actions;
                this.work = this.state = this.scheduler = null;
                this.pending = false;
                arrRemove(actions, this);
                if (id != null) {
                    this.id = this.recycleAsyncId(scheduler, id, null);
                }
                this.delay = null;
                _super.prototype.unsubscribe.call(this);
            }
        };
        return AsyncAction;
    }(Action));

    var nextHandle = 1;
    var resolved;
    var activeHandles = {};
    function findAndClearHandle(handle) {
        if (handle in activeHandles) {
            delete activeHandles[handle];
            return true;
        }
        return false;
    }
    var Immediate = {
        setImmediate: function (cb) {
            var handle = nextHandle++;
            activeHandles[handle] = true;
            if (!resolved) {
                resolved = Promise.resolve();
            }
            resolved.then(function () { return findAndClearHandle(handle) && cb(); });
            return handle;
        },
        clearImmediate: function (handle) {
            findAndClearHandle(handle);
        },
    };

    var setImmediate$1 = Immediate.setImmediate, clearImmediate = Immediate.clearImmediate;
    var immediateProvider = {
        setImmediate: function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            var delegate = immediateProvider.delegate;
            return ((delegate === null || delegate === void 0 ? void 0 : delegate.setImmediate) || setImmediate$1).apply(void 0, __spreadArray([], __read(args)));
        },
        clearImmediate: function (handle) {
            var delegate = immediateProvider.delegate;
            return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearImmediate) || clearImmediate)(handle);
        },
        delegate: undefined,
    };

    var AsapAction = (function (_super) {
        __extends$4(AsapAction, _super);
        function AsapAction(scheduler, work) {
            var _this = _super.call(this, scheduler, work) || this;
            _this.scheduler = scheduler;
            _this.work = work;
            return _this;
        }
        AsapAction.prototype.requestAsyncId = function (scheduler, id, delay) {
            if (delay === void 0) { delay = 0; }
            if (delay !== null && delay > 0) {
                return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);
            }
            scheduler.actions.push(this);
            return scheduler._scheduled || (scheduler._scheduled = immediateProvider.setImmediate(scheduler.flush.bind(scheduler, undefined)));
        };
        AsapAction.prototype.recycleAsyncId = function (scheduler, id, delay) {
            if (delay === void 0) { delay = 0; }
            if ((delay != null && delay > 0) || (delay == null && this.delay > 0)) {
                return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay);
            }
            if (scheduler.actions.length === 0) {
                immediateProvider.clearImmediate(id);
                scheduler._scheduled = undefined;
            }
            return undefined;
        };
        return AsapAction;
    }(AsyncAction));

    var Scheduler = (function () {
        function Scheduler(schedulerActionCtor, now) {
            if (now === void 0) { now = Scheduler.now; }
            this.schedulerActionCtor = schedulerActionCtor;
            this.now = now;
        }
        Scheduler.prototype.schedule = function (work, delay, state) {
            if (delay === void 0) { delay = 0; }
            return new this.schedulerActionCtor(this, work).schedule(state, delay);
        };
        Scheduler.now = dateTimestampProvider.now;
        return Scheduler;
    }());

    var AsyncScheduler = (function (_super) {
        __extends$4(AsyncScheduler, _super);
        function AsyncScheduler(SchedulerAction, now) {
            if (now === void 0) { now = Scheduler.now; }
            var _this = _super.call(this, SchedulerAction, now) || this;
            _this.actions = [];
            _this._active = false;
            _this._scheduled = undefined;
            return _this;
        }
        AsyncScheduler.prototype.flush = function (action) {
            var actions = this.actions;
            if (this._active) {
                actions.push(action);
                return;
            }
            var error;
            this._active = true;
            do {
                if ((error = action.execute(action.state, action.delay))) {
                    break;
                }
            } while ((action = actions.shift()));
            this._active = false;
            if (error) {
                while ((action = actions.shift())) {
                    action.unsubscribe();
                }
                throw error;
            }
        };
        return AsyncScheduler;
    }(Scheduler));

    var AsapScheduler = (function (_super) {
        __extends$4(AsapScheduler, _super);
        function AsapScheduler() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        AsapScheduler.prototype.flush = function (action) {
            this._active = true;
            this._scheduled = undefined;
            var actions = this.actions;
            var error;
            var index = -1;
            action = action || actions.shift();
            var count = actions.length;
            do {
                if ((error = action.execute(action.state, action.delay))) {
                    break;
                }
            } while (++index < count && (action = actions.shift()));
            this._active = false;
            if (error) {
                while (++index < count && (action = actions.shift())) {
                    action.unsubscribe();
                }
                throw error;
            }
        };
        return AsapScheduler;
    }(AsyncScheduler));

    var asapScheduler = new AsapScheduler(AsapAction);
    var asap = asapScheduler;

    var asyncScheduler = new AsyncScheduler(AsyncAction);
    var async = asyncScheduler;

    var QueueAction = (function (_super) {
        __extends$4(QueueAction, _super);
        function QueueAction(scheduler, work) {
            var _this = _super.call(this, scheduler, work) || this;
            _this.scheduler = scheduler;
            _this.work = work;
            return _this;
        }
        QueueAction.prototype.schedule = function (state, delay) {
            if (delay === void 0) { delay = 0; }
            if (delay > 0) {
                return _super.prototype.schedule.call(this, state, delay);
            }
            this.delay = delay;
            this.state = state;
            this.scheduler.flush(this);
            return this;
        };
        QueueAction.prototype.execute = function (state, delay) {
            return (delay > 0 || this.closed) ?
                _super.prototype.execute.call(this, state, delay) :
                this._execute(state, delay);
        };
        QueueAction.prototype.requestAsyncId = function (scheduler, id, delay) {
            if (delay === void 0) { delay = 0; }
            if ((delay != null && delay > 0) || (delay == null && this.delay > 0)) {
                return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);
            }
            return scheduler.flush(this);
        };
        return QueueAction;
    }(AsyncAction));

    var QueueScheduler = (function (_super) {
        __extends$4(QueueScheduler, _super);
        function QueueScheduler() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return QueueScheduler;
    }(AsyncScheduler));

    var queueScheduler = new QueueScheduler(QueueAction);
    var queue = queueScheduler;

    var AnimationFrameAction = (function (_super) {
        __extends$4(AnimationFrameAction, _super);
        function AnimationFrameAction(scheduler, work) {
            var _this = _super.call(this, scheduler, work) || this;
            _this.scheduler = scheduler;
            _this.work = work;
            return _this;
        }
        AnimationFrameAction.prototype.requestAsyncId = function (scheduler, id, delay) {
            if (delay === void 0) { delay = 0; }
            if (delay !== null && delay > 0) {
                return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);
            }
            scheduler.actions.push(this);
            return scheduler._scheduled || (scheduler._scheduled = animationFrameProvider.requestAnimationFrame(function () { return scheduler.flush(undefined); }));
        };
        AnimationFrameAction.prototype.recycleAsyncId = function (scheduler, id, delay) {
            if (delay === void 0) { delay = 0; }
            if ((delay != null && delay > 0) || (delay == null && this.delay > 0)) {
                return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay);
            }
            if (scheduler.actions.length === 0) {
                animationFrameProvider.cancelAnimationFrame(id);
                scheduler._scheduled = undefined;
            }
            return undefined;
        };
        return AnimationFrameAction;
    }(AsyncAction));

    var AnimationFrameScheduler = (function (_super) {
        __extends$4(AnimationFrameScheduler, _super);
        function AnimationFrameScheduler() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        AnimationFrameScheduler.prototype.flush = function (action) {
            this._active = true;
            this._scheduled = undefined;
            var actions = this.actions;
            var error;
            var index = -1;
            action = action || actions.shift();
            var count = actions.length;
            do {
                if ((error = action.execute(action.state, action.delay))) {
                    break;
                }
            } while (++index < count && (action = actions.shift()));
            this._active = false;
            if (error) {
                while (++index < count && (action = actions.shift())) {
                    action.unsubscribe();
                }
                throw error;
            }
        };
        return AnimationFrameScheduler;
    }(AsyncScheduler));

    var animationFrameScheduler = new AnimationFrameScheduler(AnimationFrameAction);
    var animationFrame = animationFrameScheduler;

    var VirtualTimeScheduler = (function (_super) {
        __extends$4(VirtualTimeScheduler, _super);
        function VirtualTimeScheduler(schedulerActionCtor, maxFrames) {
            if (schedulerActionCtor === void 0) { schedulerActionCtor = VirtualAction; }
            if (maxFrames === void 0) { maxFrames = Infinity; }
            var _this = _super.call(this, schedulerActionCtor, function () { return _this.frame; }) || this;
            _this.maxFrames = maxFrames;
            _this.frame = 0;
            _this.index = -1;
            return _this;
        }
        VirtualTimeScheduler.prototype.flush = function () {
            var _a = this, actions = _a.actions, maxFrames = _a.maxFrames;
            var error;
            var action;
            while ((action = actions[0]) && action.delay <= maxFrames) {
                actions.shift();
                this.frame = action.delay;
                if ((error = action.execute(action.state, action.delay))) {
                    break;
                }
            }
            if (error) {
                while ((action = actions.shift())) {
                    action.unsubscribe();
                }
                throw error;
            }
        };
        VirtualTimeScheduler.frameTimeFactor = 10;
        return VirtualTimeScheduler;
    }(AsyncScheduler));
    var VirtualAction = (function (_super) {
        __extends$4(VirtualAction, _super);
        function VirtualAction(scheduler, work, index) {
            if (index === void 0) { index = (scheduler.index += 1); }
            var _this = _super.call(this, scheduler, work) || this;
            _this.scheduler = scheduler;
            _this.work = work;
            _this.index = index;
            _this.active = true;
            _this.index = scheduler.index = index;
            return _this;
        }
        VirtualAction.prototype.schedule = function (state, delay) {
            if (delay === void 0) { delay = 0; }
            if (Number.isFinite(delay)) {
                if (!this.id) {
                    return _super.prototype.schedule.call(this, state, delay);
                }
                this.active = false;
                var action = new VirtualAction(this.scheduler, this.work);
                this.add(action);
                return action.schedule(state, delay);
            }
            else {
                return Subscription.EMPTY;
            }
        };
        VirtualAction.prototype.requestAsyncId = function (scheduler, id, delay) {
            if (delay === void 0) { delay = 0; }
            this.delay = scheduler.frame + delay;
            var actions = scheduler.actions;
            actions.push(this);
            actions.sort(VirtualAction.sortActions);
            return true;
        };
        VirtualAction.prototype.recycleAsyncId = function (scheduler, id, delay) {
            return undefined;
        };
        VirtualAction.prototype._execute = function (state, delay) {
            if (this.active === true) {
                return _super.prototype._execute.call(this, state, delay);
            }
        };
        VirtualAction.sortActions = function (a, b) {
            if (a.delay === b.delay) {
                if (a.index === b.index) {
                    return 0;
                }
                else if (a.index > b.index) {
                    return 1;
                }
                else {
                    return -1;
                }
            }
            else if (a.delay > b.delay) {
                return 1;
            }
            else {
                return -1;
            }
        };
        return VirtualAction;
    }(AsyncAction));

    var EMPTY = new Observable(function (subscriber) { return subscriber.complete(); });
    function empty$1(scheduler) {
        return scheduler ? emptyScheduled(scheduler) : EMPTY;
    }
    function emptyScheduled(scheduler) {
        return new Observable(function (subscriber) { return scheduler.schedule(function () { return subscriber.complete(); }); });
    }

    function isScheduler(value) {
        return value && isFunction(value.schedule);
    }

    function last$1(arr) {
        return arr[arr.length - 1];
    }
    function popResultSelector(args) {
        return isFunction(last$1(args)) ? args.pop() : undefined;
    }
    function popScheduler(args) {
        return isScheduler(last$1(args)) ? args.pop() : undefined;
    }
    function popNumber(args, defaultValue) {
        return typeof last$1(args) === 'number' ? args.pop() : defaultValue;
    }

    var isArrayLike$4 = (function (x) { return x && typeof x.length === 'number' && typeof x !== 'function'; });

    function isPromise$1(value) {
        return isFunction(value === null || value === void 0 ? void 0 : value.then);
    }

    function isInteropObservable(input) {
        return isFunction(input[observable]);
    }

    function isAsyncIterable(obj) {
        return Symbol.asyncIterator && isFunction(obj === null || obj === void 0 ? void 0 : obj[Symbol.asyncIterator]);
    }

    function createInvalidObservableTypeError(input) {
        return new TypeError("You provided " + (input !== null && typeof input === 'object' ? 'an invalid object' : "'" + input + "'") + " where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.");
    }

    function getSymbolIterator() {
        if (typeof Symbol !== 'function' || !Symbol.iterator) {
            return '@@iterator';
        }
        return Symbol.iterator;
    }
    var iterator = getSymbolIterator();

    function isIterable(input) {
        return isFunction(input === null || input === void 0 ? void 0 : input[iterator]);
    }

    function readableStreamLikeToAsyncGenerator(readableStream) {
        return __asyncGenerator(this, arguments, function readableStreamLikeToAsyncGenerator_1() {
            var reader, _a, value, done;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        reader = readableStream.getReader();
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, , 9, 10]);
                        _b.label = 2;
                    case 2:
                        return [4, __await(reader.read())];
                    case 3:
                        _a = _b.sent(), value = _a.value, done = _a.done;
                        if (!done) return [3, 5];
                        return [4, __await(void 0)];
                    case 4: return [2, _b.sent()];
                    case 5: return [4, __await(value)];
                    case 6: return [4, _b.sent()];
                    case 7:
                        _b.sent();
                        return [3, 2];
                    case 8: return [3, 10];
                    case 9:
                        reader.releaseLock();
                        return [7];
                    case 10: return [2];
                }
            });
        });
    }
    function isReadableStreamLike(obj) {
        return isFunction(obj === null || obj === void 0 ? void 0 : obj.getReader);
    }

    function innerFrom(input) {
        if (input instanceof Observable) {
            return input;
        }
        if (input != null) {
            if (isInteropObservable(input)) {
                return fromInteropObservable(input);
            }
            if (isArrayLike$4(input)) {
                return fromArrayLike(input);
            }
            if (isPromise$1(input)) {
                return fromPromise(input);
            }
            if (isAsyncIterable(input)) {
                return fromAsyncIterable(input);
            }
            if (isIterable(input)) {
                return fromIterable(input);
            }
            if (isReadableStreamLike(input)) {
                return fromReadableStreamLike(input);
            }
        }
        throw createInvalidObservableTypeError(input);
    }
    function fromInteropObservable(obj) {
        return new Observable(function (subscriber) {
            var obs = obj[observable]();
            if (isFunction(obs.subscribe)) {
                return obs.subscribe(subscriber);
            }
            throw new TypeError('Provided object does not correctly implement Symbol.observable');
        });
    }
    function fromArrayLike(array) {
        return new Observable(function (subscriber) {
            for (var i = 0; i < array.length && !subscriber.closed; i++) {
                subscriber.next(array[i]);
            }
            subscriber.complete();
        });
    }
    function fromPromise(promise) {
        return new Observable(function (subscriber) {
            promise
                .then(function (value) {
                if (!subscriber.closed) {
                    subscriber.next(value);
                    subscriber.complete();
                }
            }, function (err) { return subscriber.error(err); })
                .then(null, reportUnhandledError);
        });
    }
    function fromIterable(iterable) {
        return new Observable(function (subscriber) {
            var e_1, _a;
            try {
                for (var iterable_1 = __values(iterable), iterable_1_1 = iterable_1.next(); !iterable_1_1.done; iterable_1_1 = iterable_1.next()) {
                    var value = iterable_1_1.value;
                    subscriber.next(value);
                    if (subscriber.closed) {
                        return;
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (iterable_1_1 && !iterable_1_1.done && (_a = iterable_1.return)) _a.call(iterable_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
            subscriber.complete();
        });
    }
    function fromAsyncIterable(asyncIterable) {
        return new Observable(function (subscriber) {
            process$1(asyncIterable, subscriber).catch(function (err) { return subscriber.error(err); });
        });
    }
    function fromReadableStreamLike(readableStream) {
        return fromAsyncIterable(readableStreamLikeToAsyncGenerator(readableStream));
    }
    function process$1(asyncIterable, subscriber) {
        var asyncIterable_1, asyncIterable_1_1;
        var e_2, _a;
        return __awaiter(this, void 0, void 0, function () {
            var value, e_2_1;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _b.trys.push([0, 5, 6, 11]);
                        asyncIterable_1 = __asyncValues(asyncIterable);
                        _b.label = 1;
                    case 1: return [4, asyncIterable_1.next()];
                    case 2:
                        if (!(asyncIterable_1_1 = _b.sent(), !asyncIterable_1_1.done)) return [3, 4];
                        value = asyncIterable_1_1.value;
                        subscriber.next(value);
                        if (subscriber.closed) {
                            return [2];
                        }
                        _b.label = 3;
                    case 3: return [3, 1];
                    case 4: return [3, 11];
                    case 5:
                        e_2_1 = _b.sent();
                        e_2 = { error: e_2_1 };
                        return [3, 11];
                    case 6:
                        _b.trys.push([6, , 9, 10]);
                        if (!(asyncIterable_1_1 && !asyncIterable_1_1.done && (_a = asyncIterable_1.return))) return [3, 8];
                        return [4, _a.call(asyncIterable_1)];
                    case 7:
                        _b.sent();
                        _b.label = 8;
                    case 8: return [3, 10];
                    case 9:
                        if (e_2) throw e_2.error;
                        return [7];
                    case 10: return [7];
                    case 11:
                        subscriber.complete();
                        return [2];
                }
            });
        });
    }

    function executeSchedule(parentSubscription, scheduler, work, delay, repeat) {
        if (delay === void 0) { delay = 0; }
        if (repeat === void 0) { repeat = false; }
        var scheduleSubscription = scheduler.schedule(function () {
            work();
            if (repeat) {
                parentSubscription.add(this.schedule(null, delay));
            }
            else {
                this.unsubscribe();
            }
        }, delay);
        parentSubscription.add(scheduleSubscription);
        if (!repeat) {
            return scheduleSubscription;
        }
    }

    function observeOn(scheduler, delay) {
        if (delay === void 0) { delay = 0; }
        return operate(function (source, subscriber) {
            source.subscribe(new OperatorSubscriber(subscriber, function (value) { return executeSchedule(subscriber, scheduler, function () { return subscriber.next(value); }, delay); }, function () { return executeSchedule(subscriber, scheduler, function () { return subscriber.complete(); }, delay); }, function (err) { return executeSchedule(subscriber, scheduler, function () { return subscriber.error(err); }, delay); }));
        });
    }

    function subscribeOn(scheduler, delay) {
        if (delay === void 0) { delay = 0; }
        return operate(function (source, subscriber) {
            subscriber.add(scheduler.schedule(function () { return source.subscribe(subscriber); }, delay));
        });
    }

    function scheduleObservable(input, scheduler) {
        return innerFrom(input).pipe(subscribeOn(scheduler), observeOn(scheduler));
    }

    function schedulePromise(input, scheduler) {
        return innerFrom(input).pipe(subscribeOn(scheduler), observeOn(scheduler));
    }

    function scheduleArray(input, scheduler) {
        return new Observable(function (subscriber) {
            var i = 0;
            return scheduler.schedule(function () {
                if (i === input.length) {
                    subscriber.complete();
                }
                else {
                    subscriber.next(input[i++]);
                    if (!subscriber.closed) {
                        this.schedule();
                    }
                }
            });
        });
    }

    function scheduleIterable(input, scheduler) {
        return new Observable(function (subscriber) {
            var iterator$1;
            executeSchedule(subscriber, scheduler, function () {
                iterator$1 = input[iterator]();
                executeSchedule(subscriber, scheduler, function () {
                    var _a;
                    var value;
                    var done;
                    try {
                        (_a = iterator$1.next(), value = _a.value, done = _a.done);
                    }
                    catch (err) {
                        subscriber.error(err);
                        return;
                    }
                    if (done) {
                        subscriber.complete();
                    }
                    else {
                        subscriber.next(value);
                    }
                }, 0, true);
            });
            return function () { return isFunction(iterator$1 === null || iterator$1 === void 0 ? void 0 : iterator$1.return) && iterator$1.return(); };
        });
    }

    function scheduleAsyncIterable(input, scheduler) {
        if (!input) {
            throw new Error('Iterable cannot be null');
        }
        return new Observable(function (subscriber) {
            executeSchedule(subscriber, scheduler, function () {
                var iterator = input[Symbol.asyncIterator]();
                executeSchedule(subscriber, scheduler, function () {
                    iterator.next().then(function (result) {
                        if (result.done) {
                            subscriber.complete();
                        }
                        else {
                            subscriber.next(result.value);
                        }
                    });
                }, 0, true);
            });
        });
    }

    function scheduleReadableStreamLike(input, scheduler) {
        return scheduleAsyncIterable(readableStreamLikeToAsyncGenerator(input), scheduler);
    }

    function scheduled(input, scheduler) {
        if (input != null) {
            if (isInteropObservable(input)) {
                return scheduleObservable(input, scheduler);
            }
            if (isArrayLike$4(input)) {
                return scheduleArray(input, scheduler);
            }
            if (isPromise$1(input)) {
                return schedulePromise(input, scheduler);
            }
            if (isAsyncIterable(input)) {
                return scheduleAsyncIterable(input, scheduler);
            }
            if (isIterable(input)) {
                return scheduleIterable(input, scheduler);
            }
            if (isReadableStreamLike(input)) {
                return scheduleReadableStreamLike(input, scheduler);
            }
        }
        throw createInvalidObservableTypeError(input);
    }

    function from$2(input, scheduler) {
        return scheduler ? scheduled(input, scheduler) : innerFrom(input);
    }

    function of$2() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var scheduler = popScheduler(args);
        return from$2(args, scheduler);
    }

    function throwError(errorOrErrorFactory, scheduler) {
        var errorFactory = isFunction(errorOrErrorFactory) ? errorOrErrorFactory : function () { return errorOrErrorFactory; };
        var init = function (subscriber) { return subscriber.error(errorFactory()); };
        return new Observable(scheduler ? function (subscriber) { return scheduler.schedule(init, 0, subscriber); } : init);
    }

    var NotificationKind;
    (function (NotificationKind) {
        NotificationKind["NEXT"] = "N";
        NotificationKind["ERROR"] = "E";
        NotificationKind["COMPLETE"] = "C";
    })(NotificationKind || (NotificationKind = {}));
    var Notification = (function () {
        function Notification(kind, value, error) {
            this.kind = kind;
            this.value = value;
            this.error = error;
            this.hasValue = kind === 'N';
        }
        Notification.prototype.observe = function (observer) {
            return observeNotification(this, observer);
        };
        Notification.prototype.do = function (nextHandler, errorHandler, completeHandler) {
            var _a = this, kind = _a.kind, value = _a.value, error = _a.error;
            return kind === 'N' ? nextHandler === null || nextHandler === void 0 ? void 0 : nextHandler(value) : kind === 'E' ? errorHandler === null || errorHandler === void 0 ? void 0 : errorHandler(error) : completeHandler === null || completeHandler === void 0 ? void 0 : completeHandler();
        };
        Notification.prototype.accept = function (nextOrObserver, error, complete) {
            var _a;
            return isFunction((_a = nextOrObserver) === null || _a === void 0 ? void 0 : _a.next)
                ? this.observe(nextOrObserver)
                : this.do(nextOrObserver, error, complete);
        };
        Notification.prototype.toObservable = function () {
            var _a = this, kind = _a.kind, value = _a.value, error = _a.error;
            var result = kind === 'N'
                ?
                    of$2(value)
                :
                    kind === 'E'
                        ?
                            throwError(function () { return error; })
                        :
                            kind === 'C'
                                ?
                                    EMPTY
                                :
                                    0;
            if (!result) {
                throw new TypeError("Unexpected notification kind " + kind);
            }
            return result;
        };
        Notification.createNext = function (value) {
            return new Notification('N', value);
        };
        Notification.createError = function (err) {
            return new Notification('E', undefined, err);
        };
        Notification.createComplete = function () {
            return Notification.completeNotification;
        };
        Notification.completeNotification = new Notification('C');
        return Notification;
    }());
    function observeNotification(notification, observer) {
        var _a, _b, _c;
        var _d = notification, kind = _d.kind, value = _d.value, error = _d.error;
        if (typeof kind !== 'string') {
            throw new TypeError('Invalid notification, missing "kind"');
        }
        kind === 'N' ? (_a = observer.next) === null || _a === void 0 ? void 0 : _a.call(observer, value) : kind === 'E' ? (_b = observer.error) === null || _b === void 0 ? void 0 : _b.call(observer, error) : (_c = observer.complete) === null || _c === void 0 ? void 0 : _c.call(observer);
    }

    function isObservable(obj) {
        return !!obj && (obj instanceof Observable || (isFunction(obj.lift) && isFunction(obj.subscribe)));
    }

    var EmptyError = createErrorClass(function (_super) { return function EmptyErrorImpl() {
        _super(this);
        this.name = 'EmptyError';
        this.message = 'no elements in sequence';
    }; });

    function lastValueFrom(source, config) {
        var hasConfig = typeof config === 'object';
        return new Promise(function (resolve, reject) {
            var _hasValue = false;
            var _value;
            source.subscribe({
                next: function (value) {
                    _value = value;
                    _hasValue = true;
                },
                error: reject,
                complete: function () {
                    if (_hasValue) {
                        resolve(_value);
                    }
                    else if (hasConfig) {
                        resolve(config.defaultValue);
                    }
                    else {
                        reject(new EmptyError());
                    }
                },
            });
        });
    }

    function firstValueFrom(source, config) {
        var hasConfig = typeof config === 'object';
        return new Promise(function (resolve, reject) {
            var subscriber = new SafeSubscriber({
                next: function (value) {
                    resolve(value);
                    subscriber.unsubscribe();
                },
                error: reject,
                complete: function () {
                    if (hasConfig) {
                        resolve(config.defaultValue);
                    }
                    else {
                        reject(new EmptyError());
                    }
                },
            });
            source.subscribe(subscriber);
        });
    }

    var ArgumentOutOfRangeError = createErrorClass(function (_super) {
        return function ArgumentOutOfRangeErrorImpl() {
            _super(this);
            this.name = 'ArgumentOutOfRangeError';
            this.message = 'argument out of range';
        };
    });

    var NotFoundError = createErrorClass(function (_super) {
        return function NotFoundErrorImpl(message) {
            _super(this);
            this.name = 'NotFoundError';
            this.message = message;
        };
    });

    var SequenceError = createErrorClass(function (_super) {
        return function SequenceErrorImpl(message) {
            _super(this);
            this.name = 'SequenceError';
            this.message = message;
        };
    });

    function isValidDate(value) {
        return value instanceof Date && !isNaN(value);
    }

    var TimeoutError = createErrorClass(function (_super) {
        return function TimeoutErrorImpl(info) {
            if (info === void 0) { info = null; }
            _super(this);
            this.message = 'Timeout has occurred';
            this.name = 'TimeoutError';
            this.info = info;
        };
    });
    function timeout(config, schedulerArg) {
        var _a = (isValidDate(config)
            ? { first: config }
            : typeof config === 'number'
                ? { each: config }
                : config), first = _a.first, each = _a.each, _b = _a.with, _with = _b === void 0 ? timeoutErrorFactory : _b, _c = _a.scheduler, scheduler = _c === void 0 ? schedulerArg !== null && schedulerArg !== void 0 ? schedulerArg : asyncScheduler : _c, _d = _a.meta, meta = _d === void 0 ? null : _d;
        if (first == null && each == null) {
            throw new TypeError('No timeout provided.');
        }
        return operate(function (source, subscriber) {
            var originalSourceSubscription;
            var timerSubscription;
            var lastValue = null;
            var seen = 0;
            var startTimer = function (delay) {
                timerSubscription = executeSchedule(subscriber, scheduler, function () {
                    try {
                        originalSourceSubscription.unsubscribe();
                        innerFrom(_with({
                            meta: meta,
                            lastValue: lastValue,
                            seen: seen,
                        })).subscribe(subscriber);
                    }
                    catch (err) {
                        subscriber.error(err);
                    }
                }, delay);
            };
            originalSourceSubscription = source.subscribe(new OperatorSubscriber(subscriber, function (value) {
                timerSubscription === null || timerSubscription === void 0 ? void 0 : timerSubscription.unsubscribe();
                seen++;
                subscriber.next((lastValue = value));
                each > 0 && startTimer(each);
            }, undefined, undefined, function () {
                if (!(timerSubscription === null || timerSubscription === void 0 ? void 0 : timerSubscription.closed)) {
                    timerSubscription === null || timerSubscription === void 0 ? void 0 : timerSubscription.unsubscribe();
                }
                lastValue = null;
            }));
            startTimer(first != null ? (typeof first === 'number' ? first : +first - scheduler.now()) : each);
        });
    }
    function timeoutErrorFactory(info) {
        throw new TimeoutError(info);
    }

    function map$8(project, thisArg) {
        return operate(function (source, subscriber) {
            var index = 0;
            source.subscribe(new OperatorSubscriber(subscriber, function (value) {
                subscriber.next(project.call(thisArg, value, index++));
            }));
        });
    }

    var isArray$9 = Array.isArray;
    function callOrApply(fn, args) {
        return isArray$9(args) ? fn.apply(void 0, __spreadArray([], __read(args))) : fn(args);
    }
    function mapOneOrManyArgs(fn) {
        return map$8(function (args) { return callOrApply(fn, args); });
    }

    function bindCallbackInternals(isNodeStyle, callbackFunc, resultSelector, scheduler) {
        if (resultSelector) {
            if (isScheduler(resultSelector)) {
                scheduler = resultSelector;
            }
            else {
                return function () {
                    var args = [];
                    for (var _i = 0; _i < arguments.length; _i++) {
                        args[_i] = arguments[_i];
                    }
                    return bindCallbackInternals(isNodeStyle, callbackFunc, scheduler)
                        .apply(this, args)
                        .pipe(mapOneOrManyArgs(resultSelector));
                };
            }
        }
        if (scheduler) {
            return function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                return bindCallbackInternals(isNodeStyle, callbackFunc)
                    .apply(this, args)
                    .pipe(subscribeOn(scheduler), observeOn(scheduler));
            };
        }
        return function () {
            var _this = this;
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            var subject = new AsyncSubject();
            var uninitialized = true;
            return new Observable(function (subscriber) {
                var subs = subject.subscribe(subscriber);
                if (uninitialized) {
                    uninitialized = false;
                    var isAsync_1 = false;
                    var isComplete_1 = false;
                    callbackFunc.apply(_this, __spreadArray(__spreadArray([], __read(args)), [
                        function () {
                            var results = [];
                            for (var _i = 0; _i < arguments.length; _i++) {
                                results[_i] = arguments[_i];
                            }
                            if (isNodeStyle) {
                                var err = results.shift();
                                if (err != null) {
                                    subject.error(err);
                                    return;
                                }
                            }
                            subject.next(1 < results.length ? results : results[0]);
                            isComplete_1 = true;
                            if (isAsync_1) {
                                subject.complete();
                            }
                        },
                    ]));
                    if (isComplete_1) {
                        subject.complete();
                    }
                    isAsync_1 = true;
                }
                return subs;
            });
        };
    }

    function bindCallback(callbackFunc, resultSelector, scheduler) {
        return bindCallbackInternals(false, callbackFunc, resultSelector, scheduler);
    }

    function bindNodeCallback(callbackFunc, resultSelector, scheduler) {
        return bindCallbackInternals(true, callbackFunc, resultSelector, scheduler);
    }

    var isArray$8 = Array.isArray;
    var getPrototypeOf = Object.getPrototypeOf, objectProto$4 = Object.prototype, getKeys = Object.keys;
    function argsArgArrayOrObject(args) {
        if (args.length === 1) {
            var first_1 = args[0];
            if (isArray$8(first_1)) {
                return { args: first_1, keys: null };
            }
            if (isPOJO(first_1)) {
                var keys = getKeys(first_1);
                return {
                    args: keys.map(function (key) { return first_1[key]; }),
                    keys: keys,
                };
            }
        }
        return { args: args, keys: null };
    }
    function isPOJO(obj) {
        return obj && typeof obj === 'object' && getPrototypeOf(obj) === objectProto$4;
    }

    function createObject(keys, values) {
        return keys.reduce(function (result, key, i) { return ((result[key] = values[i]), result); }, {});
    }

    function combineLatest$1() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var scheduler = popScheduler(args);
        var resultSelector = popResultSelector(args);
        var _a = argsArgArrayOrObject(args), observables = _a.args, keys = _a.keys;
        if (observables.length === 0) {
            return from$2([], scheduler);
        }
        var result = new Observable(combineLatestInit(observables, scheduler, keys
            ?
                function (values) { return createObject(keys, values); }
            :
                identity$2));
        return resultSelector ? result.pipe(mapOneOrManyArgs(resultSelector)) : result;
    }
    function combineLatestInit(observables, scheduler, valueTransform) {
        if (valueTransform === void 0) { valueTransform = identity$2; }
        return function (subscriber) {
            maybeSchedule(scheduler, function () {
                var length = observables.length;
                var values = new Array(length);
                var active = length;
                var remainingFirstValues = length;
                var _loop_1 = function (i) {
                    maybeSchedule(scheduler, function () {
                        var source = from$2(observables[i], scheduler);
                        var hasFirstValue = false;
                        source.subscribe(new OperatorSubscriber(subscriber, function (value) {
                            values[i] = value;
                            if (!hasFirstValue) {
                                hasFirstValue = true;
                                remainingFirstValues--;
                            }
                            if (!remainingFirstValues) {
                                subscriber.next(valueTransform(values.slice()));
                            }
                        }, function () {
                            if (!--active) {
                                subscriber.complete();
                            }
                        }));
                    }, subscriber);
                };
                for (var i = 0; i < length; i++) {
                    _loop_1(i);
                }
            }, subscriber);
        };
    }
    function maybeSchedule(scheduler, execute, subscription) {
        if (scheduler) {
            executeSchedule(subscription, scheduler, execute);
        }
        else {
            execute();
        }
    }

    function mergeInternals(source, subscriber, project, concurrent, onBeforeNext, expand, innerSubScheduler, additionalTeardown) {
        var buffer = [];
        var active = 0;
        var index = 0;
        var isComplete = false;
        var checkComplete = function () {
            if (isComplete && !buffer.length && !active) {
                subscriber.complete();
            }
        };
        var outerNext = function (value) { return (active < concurrent ? doInnerSub(value) : buffer.push(value)); };
        var doInnerSub = function (value) {
            expand && subscriber.next(value);
            active++;
            var innerComplete = false;
            innerFrom(project(value, index++)).subscribe(new OperatorSubscriber(subscriber, function (innerValue) {
                onBeforeNext === null || onBeforeNext === void 0 ? void 0 : onBeforeNext(innerValue);
                if (expand) {
                    outerNext(innerValue);
                }
                else {
                    subscriber.next(innerValue);
                }
            }, function () {
                innerComplete = true;
            }, undefined, function () {
                if (innerComplete) {
                    try {
                        active--;
                        var _loop_1 = function () {
                            var bufferedValue = buffer.shift();
                            if (innerSubScheduler) {
                                executeSchedule(subscriber, innerSubScheduler, function () { return doInnerSub(bufferedValue); });
                            }
                            else {
                                doInnerSub(bufferedValue);
                            }
                        };
                        while (buffer.length && active < concurrent) {
                            _loop_1();
                        }
                        checkComplete();
                    }
                    catch (err) {
                        subscriber.error(err);
                    }
                }
            }));
        };
        source.subscribe(new OperatorSubscriber(subscriber, outerNext, function () {
            isComplete = true;
            checkComplete();
        }));
        return function () {
            additionalTeardown === null || additionalTeardown === void 0 ? void 0 : additionalTeardown();
        };
    }

    function mergeMap(project, resultSelector, concurrent) {
        if (concurrent === void 0) { concurrent = Infinity; }
        if (isFunction(resultSelector)) {
            return mergeMap(function (a, i) { return map$8(function (b, ii) { return resultSelector(a, b, i, ii); })(innerFrom(project(a, i))); }, concurrent);
        }
        else if (typeof resultSelector === 'number') {
            concurrent = resultSelector;
        }
        return operate(function (source, subscriber) { return mergeInternals(source, subscriber, project, concurrent); });
    }

    function mergeAll(concurrent) {
        if (concurrent === void 0) { concurrent = Infinity; }
        return mergeMap(identity$2, concurrent);
    }

    function concatAll() {
        return mergeAll(1);
    }

    function concat$1() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        return concatAll()(from$2(args, popScheduler(args)));
    }

    function defer$1(observableFactory) {
        return new Observable(function (subscriber) {
            innerFrom(observableFactory()).subscribe(subscriber);
        });
    }

    var DEFAULT_CONFIG$1 = {
        connector: function () { return new Subject$1(); },
        resetOnDisconnect: true,
    };
    function connectable(source, config) {
        if (config === void 0) { config = DEFAULT_CONFIG$1; }
        var connection = null;
        var connector = config.connector, _a = config.resetOnDisconnect, resetOnDisconnect = _a === void 0 ? true : _a;
        var subject = connector();
        var result = new Observable(function (subscriber) {
            return subject.subscribe(subscriber);
        });
        result.connect = function () {
            if (!connection || connection.closed) {
                connection = defer$1(function () { return source; }).subscribe(subject);
                if (resetOnDisconnect) {
                    connection.add(function () { return (subject = connector()); });
                }
            }
            return connection;
        };
        return result;
    }

    function forkJoin() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var resultSelector = popResultSelector(args);
        var _a = argsArgArrayOrObject(args), sources = _a.args, keys = _a.keys;
        var result = new Observable(function (subscriber) {
            var length = sources.length;
            if (!length) {
                subscriber.complete();
                return;
            }
            var values = new Array(length);
            var remainingCompletions = length;
            var remainingEmissions = length;
            var _loop_1 = function (sourceIndex) {
                var hasValue = false;
                innerFrom(sources[sourceIndex]).subscribe(new OperatorSubscriber(subscriber, function (value) {
                    if (!hasValue) {
                        hasValue = true;
                        remainingEmissions--;
                    }
                    values[sourceIndex] = value;
                }, function () { return remainingCompletions--; }, undefined, function () {
                    if (!remainingCompletions || !hasValue) {
                        if (!remainingEmissions) {
                            subscriber.next(keys ? createObject(keys, values) : values);
                        }
                        subscriber.complete();
                    }
                }));
            };
            for (var sourceIndex = 0; sourceIndex < length; sourceIndex++) {
                _loop_1(sourceIndex);
            }
        });
        return resultSelector ? result.pipe(mapOneOrManyArgs(resultSelector)) : result;
    }

    var nodeEventEmitterMethods = ['addListener', 'removeListener'];
    var eventTargetMethods = ['addEventListener', 'removeEventListener'];
    var jqueryMethods = ['on', 'off'];
    function fromEvent$1(target, eventName, options, resultSelector) {
        if (isFunction(options)) {
            resultSelector = options;
            options = undefined;
        }
        if (resultSelector) {
            return fromEvent$1(target, eventName, options).pipe(mapOneOrManyArgs(resultSelector));
        }
        var _a = __read(isEventTarget(target)
            ? eventTargetMethods.map(function (methodName) { return function (handler) { return target[methodName](eventName, handler, options); }; })
            :
                isNodeStyleEventEmitter(target)
                    ? nodeEventEmitterMethods.map(toCommonHandlerRegistry(target, eventName))
                    : isJQueryStyleEventEmitter(target)
                        ? jqueryMethods.map(toCommonHandlerRegistry(target, eventName))
                        : [], 2), add = _a[0], remove = _a[1];
        if (!add) {
            if (isArrayLike$4(target)) {
                return mergeMap(function (subTarget) { return fromEvent$1(subTarget, eventName, options); })(innerFrom(target));
            }
        }
        if (!add) {
            throw new TypeError('Invalid event target');
        }
        return new Observable(function (subscriber) {
            var handler = function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                return subscriber.next(1 < args.length ? args : args[0]);
            };
            add(handler);
            return function () { return remove(handler); };
        });
    }
    function toCommonHandlerRegistry(target, eventName) {
        return function (methodName) { return function (handler) { return target[methodName](eventName, handler); }; };
    }
    function isNodeStyleEventEmitter(target) {
        return isFunction(target.addListener) && isFunction(target.removeListener);
    }
    function isJQueryStyleEventEmitter(target) {
        return isFunction(target.on) && isFunction(target.off);
    }
    function isEventTarget(target) {
        return isFunction(target.addEventListener) && isFunction(target.removeEventListener);
    }

    function fromEventPattern(addHandler, removeHandler, resultSelector) {
        if (resultSelector) {
            return fromEventPattern(addHandler, removeHandler).pipe(mapOneOrManyArgs(resultSelector));
        }
        return new Observable(function (subscriber) {
            var handler = function () {
                var e = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    e[_i] = arguments[_i];
                }
                return subscriber.next(e.length === 1 ? e[0] : e);
            };
            var retValue = addHandler(handler);
            return isFunction(removeHandler) ? function () { return removeHandler(handler, retValue); } : undefined;
        });
    }

    function generate(initialStateOrOptions, condition, iterate, resultSelectorOrScheduler, scheduler) {
        var _a, _b;
        var resultSelector;
        var initialState;
        if (arguments.length === 1) {
            (_a = initialStateOrOptions, initialState = _a.initialState, condition = _a.condition, iterate = _a.iterate, _b = _a.resultSelector, resultSelector = _b === void 0 ? identity$2 : _b, scheduler = _a.scheduler);
        }
        else {
            initialState = initialStateOrOptions;
            if (!resultSelectorOrScheduler || isScheduler(resultSelectorOrScheduler)) {
                resultSelector = identity$2;
                scheduler = resultSelectorOrScheduler;
            }
            else {
                resultSelector = resultSelectorOrScheduler;
            }
        }
        function gen() {
            var state;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        state = initialState;
                        _a.label = 1;
                    case 1:
                        if (!(!condition || condition(state))) return [3, 4];
                        return [4, resultSelector(state)];
                    case 2:
                        _a.sent();
                        _a.label = 3;
                    case 3:
                        state = iterate(state);
                        return [3, 1];
                    case 4: return [2];
                }
            });
        }
        return defer$1((scheduler
            ?
                function () { return scheduleIterable(gen(), scheduler); }
            :
                gen));
    }

    function iif(condition, trueResult, falseResult) {
        return defer$1(function () { return (condition() ? trueResult : falseResult); });
    }

    function timer(dueTime, intervalOrScheduler, scheduler) {
        if (dueTime === void 0) { dueTime = 0; }
        if (scheduler === void 0) { scheduler = async; }
        var intervalDuration = -1;
        if (intervalOrScheduler != null) {
            if (isScheduler(intervalOrScheduler)) {
                scheduler = intervalOrScheduler;
            }
            else {
                intervalDuration = intervalOrScheduler;
            }
        }
        return new Observable(function (subscriber) {
            var due = isValidDate(dueTime) ? +dueTime - scheduler.now() : dueTime;
            if (due < 0) {
                due = 0;
            }
            var n = 0;
            return scheduler.schedule(function () {
                if (!subscriber.closed) {
                    subscriber.next(n++);
                    if (0 <= intervalDuration) {
                        this.schedule(undefined, intervalDuration);
                    }
                    else {
                        subscriber.complete();
                    }
                }
            }, due);
        });
    }

    function interval(period, scheduler) {
        if (period === void 0) { period = 0; }
        if (scheduler === void 0) { scheduler = asyncScheduler; }
        if (period < 0) {
            period = 0;
        }
        return timer(period, period, scheduler);
    }

    function merge$1() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var scheduler = popScheduler(args);
        var concurrent = popNumber(args, Infinity);
        var sources = args;
        return !sources.length
            ?
                EMPTY
            : sources.length === 1
                ?
                    innerFrom(sources[0])
                :
                    mergeAll(concurrent)(from$2(sources, scheduler));
    }

    var NEVER = new Observable(noop$2);
    function never() {
        return NEVER;
    }

    var isArray$7 = Array.isArray;
    function argsOrArgArray(args) {
        return args.length === 1 && isArray$7(args[0]) ? args[0] : args;
    }

    function onErrorResumeNext$1() {
        var sources = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            sources[_i] = arguments[_i];
        }
        var nextSources = argsOrArgArray(sources);
        return operate(function (source, subscriber) {
            var remaining = __spreadArray([source], __read(nextSources));
            var subscribeNext = function () {
                if (!subscriber.closed) {
                    if (remaining.length > 0) {
                        var nextSource = void 0;
                        try {
                            nextSource = innerFrom(remaining.shift());
                        }
                        catch (err) {
                            subscribeNext();
                            return;
                        }
                        var innerSub = new OperatorSubscriber(subscriber, undefined, noop$2, noop$2);
                        subscriber.add(nextSource.subscribe(innerSub));
                        innerSub.add(subscribeNext);
                    }
                    else {
                        subscriber.complete();
                    }
                }
            };
            subscribeNext();
        });
    }

    function onErrorResumeNext() {
        var sources = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            sources[_i] = arguments[_i];
        }
        return onErrorResumeNext$1(argsOrArgArray(sources))(EMPTY);
    }

    function pairs(obj, scheduler) {
        return from$2(Object.entries(obj), scheduler);
    }

    function not(pred, thisArg) {
        return function (value, index) { return !pred.call(thisArg, value, index); };
    }

    function filter$5(predicate, thisArg) {
        return operate(function (source, subscriber) {
            var index = 0;
            source.subscribe(new OperatorSubscriber(subscriber, function (value) { return predicate.call(thisArg, value, index++) && subscriber.next(value); }));
        });
    }

    function partition$1(source, predicate, thisArg) {
        return [filter$5(predicate, thisArg)(innerFrom(source)), filter$5(not(predicate, thisArg))(innerFrom(source))];
    }

    function race$1() {
        var sources = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            sources[_i] = arguments[_i];
        }
        sources = argsOrArgArray(sources);
        return sources.length === 1 ? innerFrom(sources[0]) : new Observable(raceInit(sources));
    }
    function raceInit(sources) {
        return function (subscriber) {
            var subscriptions = [];
            var _loop_1 = function (i) {
                subscriptions.push(innerFrom(sources[i]).subscribe(new OperatorSubscriber(subscriber, function (value) {
                    if (subscriptions) {
                        for (var s = 0; s < subscriptions.length; s++) {
                            s !== i && subscriptions[s].unsubscribe();
                        }
                        subscriptions = null;
                    }
                    subscriber.next(value);
                })));
            };
            for (var i = 0; subscriptions && !subscriber.closed && i < sources.length; i++) {
                _loop_1(i);
            }
        };
    }

    function range$1(start, count, scheduler) {
        if (count == null) {
            count = start;
            start = 0;
        }
        if (count <= 0) {
            return EMPTY;
        }
        var end = count + start;
        return new Observable(scheduler
            ?
                function (subscriber) {
                    var n = start;
                    return scheduler.schedule(function () {
                        if (n < end) {
                            subscriber.next(n++);
                            this.schedule();
                        }
                        else {
                            subscriber.complete();
                        }
                    });
                }
            :
                function (subscriber) {
                    var n = start;
                    while (n < end && !subscriber.closed) {
                        subscriber.next(n++);
                    }
                    subscriber.complete();
                });
    }

    function using(resourceFactory, observableFactory) {
        return new Observable(function (subscriber) {
            var resource = resourceFactory();
            var result = observableFactory(resource);
            var source = result ? innerFrom(result) : EMPTY;
            source.subscribe(subscriber);
            return function () {
                if (resource) {
                    resource.unsubscribe();
                }
            };
        });
    }

    function zip$1() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var resultSelector = popResultSelector(args);
        var sources = argsOrArgArray(args);
        return sources.length
            ? new Observable(function (subscriber) {
                var buffers = sources.map(function () { return []; });
                var completed = sources.map(function () { return false; });
                subscriber.add(function () {
                    buffers = completed = null;
                });
                var _loop_1 = function (sourceIndex) {
                    innerFrom(sources[sourceIndex]).subscribe(new OperatorSubscriber(subscriber, function (value) {
                        buffers[sourceIndex].push(value);
                        if (buffers.every(function (buffer) { return buffer.length; })) {
                            var result = buffers.map(function (buffer) { return buffer.shift(); });
                            subscriber.next(resultSelector ? resultSelector.apply(void 0, __spreadArray([], __read(result))) : result);
                            if (buffers.some(function (buffer, i) { return !buffer.length && completed[i]; })) {
                                subscriber.complete();
                            }
                        }
                    }, function () {
                        completed[sourceIndex] = true;
                        !buffers[sourceIndex].length && subscriber.complete();
                    }));
                };
                for (var sourceIndex = 0; !subscriber.closed && sourceIndex < sources.length; sourceIndex++) {
                    _loop_1(sourceIndex);
                }
                return function () {
                    buffers = completed = null;
                };
            })
            : EMPTY;
    }

    function audit(durationSelector) {
        return operate(function (source, subscriber) {
            var hasValue = false;
            var lastValue = null;
            var durationSubscriber = null;
            var isComplete = false;
            var endDuration = function () {
                durationSubscriber === null || durationSubscriber === void 0 ? void 0 : durationSubscriber.unsubscribe();
                durationSubscriber = null;
                if (hasValue) {
                    hasValue = false;
                    var value = lastValue;
                    lastValue = null;
                    subscriber.next(value);
                }
                isComplete && subscriber.complete();
            };
            var cleanupDuration = function () {
                durationSubscriber = null;
                isComplete && subscriber.complete();
            };
            source.subscribe(new OperatorSubscriber(subscriber, function (value) {
                hasValue = true;
                lastValue = value;
                if (!durationSubscriber) {
                    innerFrom(durationSelector(value)).subscribe((durationSubscriber = new OperatorSubscriber(subscriber, endDuration, cleanupDuration)));
                }
            }, function () {
                isComplete = true;
                (!hasValue || !durationSubscriber || durationSubscriber.closed) && subscriber.complete();
            }));
        });
    }

    function auditTime(duration, scheduler) {
        if (scheduler === void 0) { scheduler = async; }
        return audit(function () { return timer(duration, scheduler); });
    }

    function buffer$1(closingNotifier) {
        return operate(function (source, subscriber) {
            var currentBuffer = [];
            source.subscribe(new OperatorSubscriber(subscriber, function (value) { return currentBuffer.push(value); }, function () {
                subscriber.next(currentBuffer);
                subscriber.complete();
            }));
            closingNotifier.subscribe(new OperatorSubscriber(subscriber, function () {
                var b = currentBuffer;
                currentBuffer = [];
                subscriber.next(b);
            }, noop$2));
            return function () {
                currentBuffer = null;
            };
        });
    }

    function bufferCount(bufferSize, startBufferEvery) {
        if (startBufferEvery === void 0) { startBufferEvery = null; }
        startBufferEvery = startBufferEvery !== null && startBufferEvery !== void 0 ? startBufferEvery : bufferSize;
        return operate(function (source, subscriber) {
            var buffers = [];
            var count = 0;
            source.subscribe(new OperatorSubscriber(subscriber, function (value) {
                var e_1, _a, e_2, _b;
                var toEmit = null;
                if (count++ % startBufferEvery === 0) {
                    buffers.push([]);
                }
                try {
                    for (var buffers_1 = __values(buffers), buffers_1_1 = buffers_1.next(); !buffers_1_1.done; buffers_1_1 = buffers_1.next()) {
                        var buffer = buffers_1_1.value;
                        buffer.push(value);
                        if (bufferSize <= buffer.length) {
                            toEmit = toEmit !== null && toEmit !== void 0 ? toEmit : [];
                            toEmit.push(buffer);
                        }
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (buffers_1_1 && !buffers_1_1.done && (_a = buffers_1.return)) _a.call(buffers_1);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
                if (toEmit) {
                    try {
                        for (var toEmit_1 = __values(toEmit), toEmit_1_1 = toEmit_1.next(); !toEmit_1_1.done; toEmit_1_1 = toEmit_1.next()) {
                            var buffer = toEmit_1_1.value;
                            arrRemove(buffers, buffer);
                            subscriber.next(buffer);
                        }
                    }
                    catch (e_2_1) { e_2 = { error: e_2_1 }; }
                    finally {
                        try {
                            if (toEmit_1_1 && !toEmit_1_1.done && (_b = toEmit_1.return)) _b.call(toEmit_1);
                        }
                        finally { if (e_2) throw e_2.error; }
                    }
                }
            }, function () {
                var e_3, _a;
                try {
                    for (var buffers_2 = __values(buffers), buffers_2_1 = buffers_2.next(); !buffers_2_1.done; buffers_2_1 = buffers_2.next()) {
                        var buffer = buffers_2_1.value;
                        subscriber.next(buffer);
                    }
                }
                catch (e_3_1) { e_3 = { error: e_3_1 }; }
                finally {
                    try {
                        if (buffers_2_1 && !buffers_2_1.done && (_a = buffers_2.return)) _a.call(buffers_2);
                    }
                    finally { if (e_3) throw e_3.error; }
                }
                subscriber.complete();
            }, undefined, function () {
                buffers = null;
            }));
        });
    }

    function bufferTime(bufferTimeSpan) {
        var _a, _b;
        var otherArgs = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            otherArgs[_i - 1] = arguments[_i];
        }
        var scheduler = (_a = popScheduler(otherArgs)) !== null && _a !== void 0 ? _a : asyncScheduler;
        var bufferCreationInterval = (_b = otherArgs[0]) !== null && _b !== void 0 ? _b : null;
        var maxBufferSize = otherArgs[1] || Infinity;
        return operate(function (source, subscriber) {
            var bufferRecords = [];
            var restartOnEmit = false;
            var emit = function (record) {
                var buffer = record.buffer, subs = record.subs;
                subs.unsubscribe();
                arrRemove(bufferRecords, record);
                subscriber.next(buffer);
                restartOnEmit && startBuffer();
            };
            var startBuffer = function () {
                if (bufferRecords) {
                    var subs = new Subscription();
                    subscriber.add(subs);
                    var buffer = [];
                    var record_1 = {
                        buffer: buffer,
                        subs: subs,
                    };
                    bufferRecords.push(record_1);
                    executeSchedule(subs, scheduler, function () { return emit(record_1); }, bufferTimeSpan);
                }
            };
            if (bufferCreationInterval !== null && bufferCreationInterval >= 0) {
                executeSchedule(subscriber, scheduler, startBuffer, bufferCreationInterval, true);
            }
            else {
                restartOnEmit = true;
            }
            startBuffer();
            var bufferTimeSubscriber = new OperatorSubscriber(subscriber, function (value) {
                var e_1, _a;
                var recordsCopy = bufferRecords.slice();
                try {
                    for (var recordsCopy_1 = __values(recordsCopy), recordsCopy_1_1 = recordsCopy_1.next(); !recordsCopy_1_1.done; recordsCopy_1_1 = recordsCopy_1.next()) {
                        var record = recordsCopy_1_1.value;
                        var buffer = record.buffer;
                        buffer.push(value);
                        maxBufferSize <= buffer.length && emit(record);
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (recordsCopy_1_1 && !recordsCopy_1_1.done && (_a = recordsCopy_1.return)) _a.call(recordsCopy_1);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
            }, function () {
                while (bufferRecords === null || bufferRecords === void 0 ? void 0 : bufferRecords.length) {
                    subscriber.next(bufferRecords.shift().buffer);
                }
                bufferTimeSubscriber === null || bufferTimeSubscriber === void 0 ? void 0 : bufferTimeSubscriber.unsubscribe();
                subscriber.complete();
                subscriber.unsubscribe();
            }, undefined, function () { return (bufferRecords = null); });
            source.subscribe(bufferTimeSubscriber);
        });
    }

    function bufferToggle(openings, closingSelector) {
        return operate(function (source, subscriber) {
            var buffers = [];
            innerFrom(openings).subscribe(new OperatorSubscriber(subscriber, function (openValue) {
                var buffer = [];
                buffers.push(buffer);
                var closingSubscription = new Subscription();
                var emitBuffer = function () {
                    arrRemove(buffers, buffer);
                    subscriber.next(buffer);
                    closingSubscription.unsubscribe();
                };
                closingSubscription.add(innerFrom(closingSelector(openValue)).subscribe(new OperatorSubscriber(subscriber, emitBuffer, noop$2)));
            }, noop$2));
            source.subscribe(new OperatorSubscriber(subscriber, function (value) {
                var e_1, _a;
                try {
                    for (var buffers_1 = __values(buffers), buffers_1_1 = buffers_1.next(); !buffers_1_1.done; buffers_1_1 = buffers_1.next()) {
                        var buffer = buffers_1_1.value;
                        buffer.push(value);
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (buffers_1_1 && !buffers_1_1.done && (_a = buffers_1.return)) _a.call(buffers_1);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
            }, function () {
                while (buffers.length > 0) {
                    subscriber.next(buffers.shift());
                }
                subscriber.complete();
            }));
        });
    }

    function bufferWhen(closingSelector) {
        return operate(function (source, subscriber) {
            var buffer = null;
            var closingSubscriber = null;
            var openBuffer = function () {
                closingSubscriber === null || closingSubscriber === void 0 ? void 0 : closingSubscriber.unsubscribe();
                var b = buffer;
                buffer = [];
                b && subscriber.next(b);
                innerFrom(closingSelector()).subscribe((closingSubscriber = new OperatorSubscriber(subscriber, openBuffer, noop$2)));
            };
            openBuffer();
            source.subscribe(new OperatorSubscriber(subscriber, function (value) { return buffer === null || buffer === void 0 ? void 0 : buffer.push(value); }, function () {
                buffer && subscriber.next(buffer);
                subscriber.complete();
            }, undefined, function () { return (buffer = closingSubscriber = null); }));
        });
    }

    function catchError(selector) {
        return operate(function (source, subscriber) {
            var innerSub = null;
            var syncUnsub = false;
            var handledResult;
            innerSub = source.subscribe(new OperatorSubscriber(subscriber, undefined, undefined, function (err) {
                handledResult = innerFrom(selector(err, catchError(selector)(source)));
                if (innerSub) {
                    innerSub.unsubscribe();
                    innerSub = null;
                    handledResult.subscribe(subscriber);
                }
                else {
                    syncUnsub = true;
                }
            }));
            if (syncUnsub) {
                innerSub.unsubscribe();
                innerSub = null;
                handledResult.subscribe(subscriber);
            }
        });
    }

    function scanInternals(accumulator, seed, hasSeed, emitOnNext, emitBeforeComplete) {
        return function (source, subscriber) {
            var hasState = hasSeed;
            var state = seed;
            var index = 0;
            source.subscribe(new OperatorSubscriber(subscriber, function (value) {
                var i = index++;
                state = hasState
                    ?
                        accumulator(state, value, i)
                    :
                        ((hasState = true), value);
                emitOnNext && subscriber.next(state);
            }, emitBeforeComplete &&
                (function () {
                    hasState && subscriber.next(state);
                    subscriber.complete();
                })));
        };
    }

    function reduce$1(accumulator, seed) {
        return operate(scanInternals(accumulator, seed, arguments.length >= 2, false, true));
    }

    var arrReducer = function (arr, value) { return (arr.push(value), arr); };
    function toArray() {
        return operate(function (source, subscriber) {
            reduce$1(arrReducer, [])(source).subscribe(subscriber);
        });
    }

    function joinAllInternals(joinFn, project) {
        return pipe$1(toArray(), mergeMap(function (sources) { return joinFn(sources); }), project ? mapOneOrManyArgs(project) : identity$2);
    }

    function combineLatestAll(project) {
        return joinAllInternals(combineLatest$1, project);
    }

    var combineAll = combineLatestAll;

    function combineLatest() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var resultSelector = popResultSelector(args);
        return resultSelector
            ? pipe$1(combineLatest.apply(void 0, __spreadArray([], __read(args))), mapOneOrManyArgs(resultSelector))
            : operate(function (source, subscriber) {
                combineLatestInit(__spreadArray([source], __read(argsOrArgArray(args))))(subscriber);
            });
    }

    function combineLatestWith() {
        var otherSources = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            otherSources[_i] = arguments[_i];
        }
        return combineLatest.apply(void 0, __spreadArray([], __read(otherSources)));
    }

    function concatMap$3(project, resultSelector) {
        return isFunction(resultSelector) ? mergeMap(project, resultSelector, 1) : mergeMap(project, 1);
    }

    function concatMapTo(innerObservable, resultSelector) {
        return isFunction(resultSelector) ? concatMap$3(function () { return innerObservable; }, resultSelector) : concatMap$3(function () { return innerObservable; });
    }

    function concat() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var scheduler = popScheduler(args);
        return operate(function (source, subscriber) {
            concatAll()(from$2(__spreadArray([source], __read(args)), scheduler)).subscribe(subscriber);
        });
    }

    function concatWith() {
        var otherSources = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            otherSources[_i] = arguments[_i];
        }
        return concat.apply(void 0, __spreadArray([], __read(otherSources)));
    }

    function fromSubscribable(subscribable) {
        return new Observable(function (subscriber) { return subscribable.subscribe(subscriber); });
    }

    var DEFAULT_CONFIG = {
        connector: function () { return new Subject$1(); },
    };
    function connect(selector, config) {
        if (config === void 0) { config = DEFAULT_CONFIG; }
        var connector = config.connector;
        return operate(function (source, subscriber) {
            var subject = connector();
            from$2(selector(fromSubscribable(subject))).subscribe(subscriber);
            subscriber.add(source.subscribe(subject));
        });
    }

    function count(predicate) {
        return reduce$1(function (total, value, i) { return (!predicate || predicate(value, i) ? total + 1 : total); }, 0);
    }

    function debounce(durationSelector) {
        return operate(function (source, subscriber) {
            var hasValue = false;
            var lastValue = null;
            var durationSubscriber = null;
            var emit = function () {
                durationSubscriber === null || durationSubscriber === void 0 ? void 0 : durationSubscriber.unsubscribe();
                durationSubscriber = null;
                if (hasValue) {
                    hasValue = false;
                    var value = lastValue;
                    lastValue = null;
                    subscriber.next(value);
                }
            };
            source.subscribe(new OperatorSubscriber(subscriber, function (value) {
                durationSubscriber === null || durationSubscriber === void 0 ? void 0 : durationSubscriber.unsubscribe();
                hasValue = true;
                lastValue = value;
                durationSubscriber = new OperatorSubscriber(subscriber, emit, noop$2);
                innerFrom(durationSelector(value)).subscribe(durationSubscriber);
            }, function () {
                emit();
                subscriber.complete();
            }, undefined, function () {
                lastValue = durationSubscriber = null;
            }));
        });
    }

    function debounceTime(dueTime, scheduler) {
        if (scheduler === void 0) { scheduler = asyncScheduler; }
        return operate(function (source, subscriber) {
            var activeTask = null;
            var lastValue = null;
            var lastTime = null;
            var emit = function () {
                if (activeTask) {
                    activeTask.unsubscribe();
                    activeTask = null;
                    var value = lastValue;
                    lastValue = null;
                    subscriber.next(value);
                }
            };
            function emitWhenIdle() {
                var targetTime = lastTime + dueTime;
                var now = scheduler.now();
                if (now < targetTime) {
                    activeTask = this.schedule(undefined, targetTime - now);
                    subscriber.add(activeTask);
                    return;
                }
                emit();
            }
            source.subscribe(new OperatorSubscriber(subscriber, function (value) {
                lastValue = value;
                lastTime = scheduler.now();
                if (!activeTask) {
                    activeTask = scheduler.schedule(emitWhenIdle, dueTime);
                    subscriber.add(activeTask);
                }
            }, function () {
                emit();
                subscriber.complete();
            }, undefined, function () {
                lastValue = activeTask = null;
            }));
        });
    }

    function defaultIfEmpty(defaultValue) {
        return operate(function (source, subscriber) {
            var hasValue = false;
            source.subscribe(new OperatorSubscriber(subscriber, function (value) {
                hasValue = true;
                subscriber.next(value);
            }, function () {
                if (!hasValue) {
                    subscriber.next(defaultValue);
                }
                subscriber.complete();
            }));
        });
    }

    function take$3(count) {
        return count <= 0
            ?
                function () { return EMPTY; }
            : operate(function (source, subscriber) {
                var seen = 0;
                source.subscribe(new OperatorSubscriber(subscriber, function (value) {
                    if (++seen <= count) {
                        subscriber.next(value);
                        if (count <= seen) {
                            subscriber.complete();
                        }
                    }
                }));
            });
    }

    function ignoreElements() {
        return operate(function (source, subscriber) {
            source.subscribe(new OperatorSubscriber(subscriber, noop$2));
        });
    }

    function mapTo(value) {
        return map$8(function () { return value; });
    }

    function delayWhen(delayDurationSelector, subscriptionDelay) {
        if (subscriptionDelay) {
            return function (source) {
                return concat$1(subscriptionDelay.pipe(take$3(1), ignoreElements()), source.pipe(delayWhen(delayDurationSelector)));
            };
        }
        return mergeMap(function (value, index) { return delayDurationSelector(value, index).pipe(take$3(1), mapTo(value)); });
    }

    function delay(due, scheduler) {
        if (scheduler === void 0) { scheduler = asyncScheduler; }
        var duration = timer(due, scheduler);
        return delayWhen(function () { return duration; });
    }

    function dematerialize() {
        return operate(function (source, subscriber) {
            source.subscribe(new OperatorSubscriber(subscriber, function (notification) { return observeNotification(notification, subscriber); }));
        });
    }

    function distinct(keySelector, flushes) {
        return operate(function (source, subscriber) {
            var distinctKeys = new Set();
            source.subscribe(new OperatorSubscriber(subscriber, function (value) {
                var key = keySelector ? keySelector(value) : value;
                if (!distinctKeys.has(key)) {
                    distinctKeys.add(key);
                    subscriber.next(value);
                }
            }));
            flushes === null || flushes === void 0 ? void 0 : flushes.subscribe(new OperatorSubscriber(subscriber, function () { return distinctKeys.clear(); }, noop$2));
        });
    }

    function distinctUntilChanged(comparator, keySelector) {
        if (keySelector === void 0) { keySelector = identity$2; }
        comparator = comparator !== null && comparator !== void 0 ? comparator : defaultCompare;
        return operate(function (source, subscriber) {
            var previousKey;
            var first = true;
            source.subscribe(new OperatorSubscriber(subscriber, function (value) {
                var currentKey = keySelector(value);
                if (first || !comparator(previousKey, currentKey)) {
                    first = false;
                    previousKey = currentKey;
                    subscriber.next(value);
                }
            }));
        });
    }
    function defaultCompare(a, b) {
        return a === b;
    }

    function distinctUntilKeyChanged(key, compare) {
        return distinctUntilChanged(function (x, y) { return compare ? compare(x[key], y[key]) : x[key] === y[key]; });
    }

    function throwIfEmpty(errorFactory) {
        if (errorFactory === void 0) { errorFactory = defaultErrorFactory; }
        return operate(function (source, subscriber) {
            var hasValue = false;
            source.subscribe(new OperatorSubscriber(subscriber, function (value) {
                hasValue = true;
                subscriber.next(value);
            }, function () { return (hasValue ? subscriber.complete() : subscriber.error(errorFactory())); }));
        });
    }
    function defaultErrorFactory() {
        return new EmptyError();
    }

    function elementAt(index, defaultValue) {
        if (index < 0) {
            throw new ArgumentOutOfRangeError();
        }
        var hasDefaultValue = arguments.length >= 2;
        return function (source) {
            return source.pipe(filter$5(function (v, i) { return i === index; }), take$3(1), hasDefaultValue ? defaultIfEmpty(defaultValue) : throwIfEmpty(function () { return new ArgumentOutOfRangeError(); }));
        };
    }

    function endWith() {
        var values = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            values[_i] = arguments[_i];
        }
        return function (source) { return concat$1(source, of$2.apply(void 0, __spreadArray([], __read(values)))); };
    }

    function every(predicate, thisArg) {
        return operate(function (source, subscriber) {
            var index = 0;
            source.subscribe(new OperatorSubscriber(subscriber, function (value) {
                if (!predicate.call(thisArg, value, index++, source)) {
                    subscriber.next(false);
                    subscriber.complete();
                }
            }, function () {
                subscriber.next(true);
                subscriber.complete();
            }));
        });
    }

    function exhaustAll() {
        return operate(function (source, subscriber) {
            var isComplete = false;
            var innerSub = null;
            source.subscribe(new OperatorSubscriber(subscriber, function (inner) {
                if (!innerSub) {
                    innerSub = innerFrom(inner).subscribe(new OperatorSubscriber(subscriber, undefined, function () {
                        innerSub = null;
                        isComplete && subscriber.complete();
                    }));
                }
            }, function () {
                isComplete = true;
                !innerSub && subscriber.complete();
            }));
        });
    }

    var exhaust = exhaustAll;

    function exhaustMap(project, resultSelector) {
        if (resultSelector) {
            return function (source) {
                return source.pipe(exhaustMap(function (a, i) { return innerFrom(project(a, i)).pipe(map$8(function (b, ii) { return resultSelector(a, b, i, ii); })); }));
            };
        }
        return operate(function (source, subscriber) {
            var index = 0;
            var innerSub = null;
            var isComplete = false;
            source.subscribe(new OperatorSubscriber(subscriber, function (outerValue) {
                if (!innerSub) {
                    innerSub = new OperatorSubscriber(subscriber, undefined, function () {
                        innerSub = null;
                        isComplete && subscriber.complete();
                    });
                    innerFrom(project(outerValue, index++)).subscribe(innerSub);
                }
            }, function () {
                isComplete = true;
                !innerSub && subscriber.complete();
            }));
        });
    }

    function expand$3(project, concurrent, scheduler) {
        if (concurrent === void 0) { concurrent = Infinity; }
        concurrent = (concurrent || 0) < 1 ? Infinity : concurrent;
        return operate(function (source, subscriber) {
            return mergeInternals(source, subscriber, project, concurrent, undefined, true, scheduler);
        });
    }

    function finalize(callback) {
        return operate(function (source, subscriber) {
            try {
                source.subscribe(subscriber);
            }
            finally {
                subscriber.add(callback);
            }
        });
    }

    function find$1(predicate, thisArg) {
        return operate(createFind$2(predicate, thisArg, 'value'));
    }
    function createFind$2(predicate, thisArg, emit) {
        var findIndex = emit === 'index';
        return function (source, subscriber) {
            var index = 0;
            source.subscribe(new OperatorSubscriber(subscriber, function (value) {
                var i = index++;
                if (predicate.call(thisArg, value, i, source)) {
                    subscriber.next(findIndex ? i : value);
                    subscriber.complete();
                }
            }, function () {
                subscriber.next(findIndex ? -1 : undefined);
                subscriber.complete();
            }));
        };
    }

    function findIndex$2(predicate, thisArg) {
        return operate(createFind$2(predicate, thisArg, 'index'));
    }

    function first(predicate, defaultValue) {
        var hasDefaultValue = arguments.length >= 2;
        return function (source) {
            return source.pipe(predicate ? filter$5(function (v, i) { return predicate(v, i, source); }) : identity$2, take$3(1), hasDefaultValue ? defaultIfEmpty(defaultValue) : throwIfEmpty(function () { return new EmptyError(); }));
        };
    }

    function groupBy(keySelector, elementOrOptions, duration, connector) {
        return operate(function (source, subscriber) {
            var element;
            if (!elementOrOptions || typeof elementOrOptions === 'function') {
                element = elementOrOptions;
            }
            else {
                (duration = elementOrOptions.duration, element = elementOrOptions.element, connector = elementOrOptions.connector);
            }
            var groups = new Map();
            var notify = function (cb) {
                groups.forEach(cb);
                cb(subscriber);
            };
            var handleError = function (err) { return notify(function (consumer) { return consumer.error(err); }); };
            var groupBySourceSubscriber = new GroupBySubscriber(subscriber, function (value) {
                try {
                    var key_1 = keySelector(value);
                    var group_1 = groups.get(key_1);
                    if (!group_1) {
                        groups.set(key_1, (group_1 = connector ? connector() : new Subject$1()));
                        var grouped = createGroupedObservable(key_1, group_1);
                        subscriber.next(grouped);
                        if (duration) {
                            var durationSubscriber_1 = new OperatorSubscriber(group_1, function () {
                                group_1.complete();
                                durationSubscriber_1 === null || durationSubscriber_1 === void 0 ? void 0 : durationSubscriber_1.unsubscribe();
                            }, undefined, undefined, function () { return groups.delete(key_1); });
                            groupBySourceSubscriber.add(innerFrom(duration(grouped)).subscribe(durationSubscriber_1));
                        }
                    }
                    group_1.next(element ? element(value) : value);
                }
                catch (err) {
                    handleError(err);
                }
            }, function () { return notify(function (consumer) { return consumer.complete(); }); }, handleError, function () { return groups.clear(); });
            source.subscribe(groupBySourceSubscriber);
            function createGroupedObservable(key, groupSubject) {
                var result = new Observable(function (groupSubscriber) {
                    groupBySourceSubscriber.activeGroups++;
                    var innerSub = groupSubject.subscribe(groupSubscriber);
                    return function () {
                        innerSub.unsubscribe();
                        --groupBySourceSubscriber.activeGroups === 0 &&
                            groupBySourceSubscriber.teardownAttempted &&
                            groupBySourceSubscriber.unsubscribe();
                    };
                });
                result.key = key;
                return result;
            }
        });
    }
    var GroupBySubscriber = (function (_super) {
        __extends$4(GroupBySubscriber, _super);
        function GroupBySubscriber() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.activeGroups = 0;
            _this.teardownAttempted = false;
            return _this;
        }
        GroupBySubscriber.prototype.unsubscribe = function () {
            this.teardownAttempted = true;
            this.activeGroups === 0 && _super.prototype.unsubscribe.call(this);
        };
        return GroupBySubscriber;
    }(OperatorSubscriber));

    function isEmpty() {
        return operate(function (source, subscriber) {
            source.subscribe(new OperatorSubscriber(subscriber, function () {
                subscriber.next(false);
                subscriber.complete();
            }, function () {
                subscriber.next(true);
                subscriber.complete();
            }));
        });
    }

    function takeLast(count) {
        return count <= 0
            ? function () { return EMPTY; }
            : operate(function (source, subscriber) {
                var buffer = [];
                source.subscribe(new OperatorSubscriber(subscriber, function (value) {
                    buffer.push(value);
                    count < buffer.length && buffer.shift();
                }, function () {
                    var e_1, _a;
                    try {
                        for (var buffer_1 = __values(buffer), buffer_1_1 = buffer_1.next(); !buffer_1_1.done; buffer_1_1 = buffer_1.next()) {
                            var value = buffer_1_1.value;
                            subscriber.next(value);
                        }
                    }
                    catch (e_1_1) { e_1 = { error: e_1_1 }; }
                    finally {
                        try {
                            if (buffer_1_1 && !buffer_1_1.done && (_a = buffer_1.return)) _a.call(buffer_1);
                        }
                        finally { if (e_1) throw e_1.error; }
                    }
                    subscriber.complete();
                }, undefined, function () {
                    buffer = null;
                }));
            });
    }

    function last(predicate, defaultValue) {
        var hasDefaultValue = arguments.length >= 2;
        return function (source) {
            return source.pipe(predicate ? filter$5(function (v, i) { return predicate(v, i, source); }) : identity$2, takeLast(1), hasDefaultValue ? defaultIfEmpty(defaultValue) : throwIfEmpty(function () { return new EmptyError(); }));
        };
    }

    function materialize() {
        return operate(function (source, subscriber) {
            source.subscribe(new OperatorSubscriber(subscriber, function (value) {
                subscriber.next(Notification.createNext(value));
            }, function () {
                subscriber.next(Notification.createComplete());
                subscriber.complete();
            }, function (err) {
                subscriber.next(Notification.createError(err));
                subscriber.complete();
            }));
        });
    }

    function max(comparer) {
        return reduce$1(isFunction(comparer) ? function (x, y) { return (comparer(x, y) > 0 ? x : y); } : function (x, y) { return (x > y ? x : y); });
    }

    var flatMap$2 = mergeMap;

    function mergeMapTo(innerObservable, resultSelector, concurrent) {
        if (concurrent === void 0) { concurrent = Infinity; }
        if (isFunction(resultSelector)) {
            return mergeMap(function () { return innerObservable; }, resultSelector, concurrent);
        }
        if (typeof resultSelector === 'number') {
            concurrent = resultSelector;
        }
        return mergeMap(function () { return innerObservable; }, concurrent);
    }

    function mergeScan(accumulator, seed, concurrent) {
        if (concurrent === void 0) { concurrent = Infinity; }
        return operate(function (source, subscriber) {
            var state = seed;
            return mergeInternals(source, subscriber, function (value, index) { return accumulator(state, value, index); }, concurrent, function (value) {
                state = value;
            }, false, undefined, function () { return (state = null); });
        });
    }

    function merge() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var scheduler = popScheduler(args);
        var concurrent = popNumber(args, Infinity);
        args = argsOrArgArray(args);
        return operate(function (source, subscriber) {
            mergeAll(concurrent)(from$2(__spreadArray([source], __read(args)), scheduler)).subscribe(subscriber);
        });
    }

    function mergeWith() {
        var otherSources = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            otherSources[_i] = arguments[_i];
        }
        return merge.apply(void 0, __spreadArray([], __read(otherSources)));
    }

    function min(comparer) {
        return reduce$1(isFunction(comparer) ? function (x, y) { return (comparer(x, y) < 0 ? x : y); } : function (x, y) { return (x < y ? x : y); });
    }

    function multicast(subjectOrSubjectFactory, selector) {
        var subjectFactory = isFunction(subjectOrSubjectFactory) ? subjectOrSubjectFactory : function () { return subjectOrSubjectFactory; };
        if (isFunction(selector)) {
            return connect(selector, {
                connector: subjectFactory,
            });
        }
        return function (source) { return new ConnectableObservable(source, subjectFactory); };
    }

    function pairwise() {
        return operate(function (source, subscriber) {
            var prev;
            var hasPrev = false;
            source.subscribe(new OperatorSubscriber(subscriber, function (value) {
                var p = prev;
                prev = value;
                hasPrev && subscriber.next([p, value]);
                hasPrev = true;
            }));
        });
    }

    function pluck() {
        var properties = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            properties[_i] = arguments[_i];
        }
        var length = properties.length;
        if (length === 0) {
            throw new Error('list of properties cannot be empty.');
        }
        return map$8(function (x) {
            var currentProp = x;
            for (var i = 0; i < length; i++) {
                var p = currentProp === null || currentProp === void 0 ? void 0 : currentProp[properties[i]];
                if (typeof p !== 'undefined') {
                    currentProp = p;
                }
                else {
                    return undefined;
                }
            }
            return currentProp;
        });
    }

    function publish$1(selector) {
        return selector ? function (source) { return connect(selector)(source); } : function (source) { return multicast(new Subject$1())(source); };
    }

    function publishBehavior(initialValue) {
        return function (source) {
            var subject = new BehaviorSubject(initialValue);
            return new ConnectableObservable(source, function () { return subject; });
        };
    }

    function publishLast() {
        return function (source) {
            var subject = new AsyncSubject();
            return new ConnectableObservable(source, function () { return subject; });
        };
    }

    function publishReplay(bufferSize, windowTime, selectorOrScheduler, timestampProvider) {
        if (selectorOrScheduler && !isFunction(selectorOrScheduler)) {
            timestampProvider = selectorOrScheduler;
        }
        var selector = isFunction(selectorOrScheduler) ? selectorOrScheduler : undefined;
        return function (source) { return multicast(new ReplaySubject(bufferSize, windowTime, timestampProvider), selector)(source); };
    }

    function raceWith() {
        var otherSources = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            otherSources[_i] = arguments[_i];
        }
        return !otherSources.length
            ? identity$2
            : operate(function (source, subscriber) {
                raceInit(__spreadArray([source], __read(otherSources)))(subscriber);
            });
    }

    function repeat(count) {
        if (count === void 0) { count = Infinity; }
        return count <= 0
            ? function () { return EMPTY; }
            : operate(function (source, subscriber) {
                var soFar = 0;
                var innerSub;
                var subscribeForRepeat = function () {
                    var syncUnsub = false;
                    innerSub = source.subscribe(new OperatorSubscriber(subscriber, undefined, function () {
                        if (++soFar < count) {
                            if (innerSub) {
                                innerSub.unsubscribe();
                                innerSub = null;
                                subscribeForRepeat();
                            }
                            else {
                                syncUnsub = true;
                            }
                        }
                        else {
                            subscriber.complete();
                        }
                    }));
                    if (syncUnsub) {
                        innerSub.unsubscribe();
                        innerSub = null;
                        subscribeForRepeat();
                    }
                };
                subscribeForRepeat();
            });
    }

    function repeatWhen(notifier) {
        return operate(function (source, subscriber) {
            var innerSub;
            var syncResub = false;
            var completions$;
            var isNotifierComplete = false;
            var isMainComplete = false;
            var checkComplete = function () { return isMainComplete && isNotifierComplete && (subscriber.complete(), true); };
            var getCompletionSubject = function () {
                if (!completions$) {
                    completions$ = new Subject$1();
                    notifier(completions$).subscribe(new OperatorSubscriber(subscriber, function () {
                        if (innerSub) {
                            subscribeForRepeatWhen();
                        }
                        else {
                            syncResub = true;
                        }
                    }, function () {
                        isNotifierComplete = true;
                        checkComplete();
                    }));
                }
                return completions$;
            };
            var subscribeForRepeatWhen = function () {
                isMainComplete = false;
                innerSub = source.subscribe(new OperatorSubscriber(subscriber, undefined, function () {
                    isMainComplete = true;
                    !checkComplete() && getCompletionSubject().next();
                }));
                if (syncResub) {
                    innerSub.unsubscribe();
                    innerSub = null;
                    syncResub = false;
                    subscribeForRepeatWhen();
                }
            };
            subscribeForRepeatWhen();
        });
    }

    function retry(configOrCount) {
        if (configOrCount === void 0) { configOrCount = Infinity; }
        var config;
        if (configOrCount && typeof configOrCount === 'object') {
            config = configOrCount;
        }
        else {
            config = {
                count: configOrCount,
            };
        }
        var _a = config.count, count = _a === void 0 ? Infinity : _a, delay = config.delay, _b = config.resetOnSuccess, resetOnSuccess = _b === void 0 ? false : _b;
        return count <= 0
            ? identity$2
            : operate(function (source, subscriber) {
                var soFar = 0;
                var innerSub;
                var subscribeForRetry = function () {
                    var syncUnsub = false;
                    innerSub = source.subscribe(new OperatorSubscriber(subscriber, function (value) {
                        if (resetOnSuccess) {
                            soFar = 0;
                        }
                        subscriber.next(value);
                    }, undefined, function (err) {
                        if (soFar++ < count) {
                            var resub_1 = function () {
                                if (innerSub) {
                                    innerSub.unsubscribe();
                                    innerSub = null;
                                    subscribeForRetry();
                                }
                                else {
                                    syncUnsub = true;
                                }
                            };
                            if (delay != null) {
                                var notifier = typeof delay === 'number' ? timer(delay) : innerFrom(delay(err, soFar));
                                var notifierSubscriber_1 = new OperatorSubscriber(subscriber, function () {
                                    notifierSubscriber_1.unsubscribe();
                                    resub_1();
                                }, function () {
                                    subscriber.complete();
                                });
                                notifier.subscribe(notifierSubscriber_1);
                            }
                            else {
                                resub_1();
                            }
                        }
                        else {
                            subscriber.error(err);
                        }
                    }));
                    if (syncUnsub) {
                        innerSub.unsubscribe();
                        innerSub = null;
                        subscribeForRetry();
                    }
                };
                subscribeForRetry();
            });
    }

    function retryWhen(notifier) {
        return operate(function (source, subscriber) {
            var innerSub;
            var syncResub = false;
            var errors$;
            var subscribeForRetryWhen = function () {
                innerSub = source.subscribe(new OperatorSubscriber(subscriber, undefined, undefined, function (err) {
                    if (!errors$) {
                        errors$ = new Subject$1();
                        notifier(errors$).subscribe(new OperatorSubscriber(subscriber, function () {
                            return innerSub ? subscribeForRetryWhen() : (syncResub = true);
                        }));
                    }
                    if (errors$) {
                        errors$.next(err);
                    }
                }));
                if (syncResub) {
                    innerSub.unsubscribe();
                    innerSub = null;
                    syncResub = false;
                    subscribeForRetryWhen();
                }
            };
            subscribeForRetryWhen();
        });
    }

    function sample$1(notifier) {
        return operate(function (source, subscriber) {
            var hasValue = false;
            var lastValue = null;
            source.subscribe(new OperatorSubscriber(subscriber, function (value) {
                hasValue = true;
                lastValue = value;
            }));
            var emit = function () {
                if (hasValue) {
                    hasValue = false;
                    var value = lastValue;
                    lastValue = null;
                    subscriber.next(value);
                }
            };
            notifier.subscribe(new OperatorSubscriber(subscriber, emit, noop$2));
        });
    }

    function sampleTime(period, scheduler) {
        if (scheduler === void 0) { scheduler = asyncScheduler; }
        return sample$1(interval(period, scheduler));
    }

    function scan(accumulator, seed) {
        return operate(scanInternals(accumulator, seed, arguments.length >= 2, true));
    }

    function sequenceEqual(compareTo, comparator) {
        if (comparator === void 0) { comparator = function (a, b) { return a === b; }; }
        return operate(function (source, subscriber) {
            var aState = createState();
            var bState = createState();
            var emit = function (isEqual) {
                subscriber.next(isEqual);
                subscriber.complete();
            };
            var createSubscriber = function (selfState, otherState) {
                var sequenceEqualSubscriber = new OperatorSubscriber(subscriber, function (a) {
                    var buffer = otherState.buffer, complete = otherState.complete;
                    if (buffer.length === 0) {
                        complete ? emit(false) : selfState.buffer.push(a);
                    }
                    else {
                        !comparator(a, buffer.shift()) && emit(false);
                    }
                }, function () {
                    selfState.complete = true;
                    var complete = otherState.complete, buffer = otherState.buffer;
                    complete && emit(buffer.length === 0);
                    sequenceEqualSubscriber === null || sequenceEqualSubscriber === void 0 ? void 0 : sequenceEqualSubscriber.unsubscribe();
                });
                return sequenceEqualSubscriber;
            };
            source.subscribe(createSubscriber(aState, bState));
            compareTo.subscribe(createSubscriber(bState, aState));
        });
    }
    function createState() {
        return {
            buffer: [],
            complete: false,
        };
    }

    function share$2(options) {
        if (options === void 0) { options = {}; }
        var _a = options.connector, connector = _a === void 0 ? function () { return new Subject$1(); } : _a, _b = options.resetOnError, resetOnError = _b === void 0 ? true : _b, _c = options.resetOnComplete, resetOnComplete = _c === void 0 ? true : _c, _d = options.resetOnRefCountZero, resetOnRefCountZero = _d === void 0 ? true : _d;
        return function (wrapperSource) {
            var connection = null;
            var resetConnection = null;
            var subject = null;
            var refCount = 0;
            var hasCompleted = false;
            var hasErrored = false;
            var cancelReset = function () {
                resetConnection === null || resetConnection === void 0 ? void 0 : resetConnection.unsubscribe();
                resetConnection = null;
            };
            var reset = function () {
                cancelReset();
                connection = subject = null;
                hasCompleted = hasErrored = false;
            };
            var resetAndUnsubscribe = function () {
                var conn = connection;
                reset();
                conn === null || conn === void 0 ? void 0 : conn.unsubscribe();
            };
            return operate(function (source, subscriber) {
                refCount++;
                if (!hasErrored && !hasCompleted) {
                    cancelReset();
                }
                var dest = (subject = subject !== null && subject !== void 0 ? subject : connector());
                subscriber.add(function () {
                    refCount--;
                    if (refCount === 0 && !hasErrored && !hasCompleted) {
                        resetConnection = handleReset(resetAndUnsubscribe, resetOnRefCountZero);
                    }
                });
                dest.subscribe(subscriber);
                if (!connection) {
                    connection = new SafeSubscriber({
                        next: function (value) { return dest.next(value); },
                        error: function (err) {
                            hasErrored = true;
                            cancelReset();
                            resetConnection = handleReset(reset, resetOnError, err);
                            dest.error(err);
                        },
                        complete: function () {
                            hasCompleted = true;
                            cancelReset();
                            resetConnection = handleReset(reset, resetOnComplete);
                            dest.complete();
                        },
                    });
                    from$2(source).subscribe(connection);
                }
            })(wrapperSource);
        };
    }
    function handleReset(reset, on) {
        var args = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            args[_i - 2] = arguments[_i];
        }
        if (on === true) {
            reset();
            return null;
        }
        if (on === false) {
            return null;
        }
        return on.apply(void 0, __spreadArray([], __read(args))).pipe(take$3(1))
            .subscribe(function () { return reset(); });
    }

    function shareReplay(configOrBufferSize, windowTime, scheduler) {
        var _a, _b;
        var bufferSize;
        var refCount = false;
        if (configOrBufferSize && typeof configOrBufferSize === 'object') {
            bufferSize = (_a = configOrBufferSize.bufferSize) !== null && _a !== void 0 ? _a : Infinity;
            windowTime = (_b = configOrBufferSize.windowTime) !== null && _b !== void 0 ? _b : Infinity;
            refCount = !!configOrBufferSize.refCount;
            scheduler = configOrBufferSize.scheduler;
        }
        else {
            bufferSize = configOrBufferSize !== null && configOrBufferSize !== void 0 ? configOrBufferSize : Infinity;
        }
        return share$2({
            connector: function () { return new ReplaySubject(bufferSize, windowTime, scheduler); },
            resetOnError: true,
            resetOnComplete: false,
            resetOnRefCountZero: refCount
        });
    }

    function single(predicate) {
        return operate(function (source, subscriber) {
            var hasValue = false;
            var singleValue;
            var seenValue = false;
            var index = 0;
            source.subscribe(new OperatorSubscriber(subscriber, function (value) {
                seenValue = true;
                if (!predicate || predicate(value, index++, source)) {
                    hasValue && subscriber.error(new SequenceError('Too many matching values'));
                    hasValue = true;
                    singleValue = value;
                }
            }, function () {
                if (hasValue) {
                    subscriber.next(singleValue);
                    subscriber.complete();
                }
                else {
                    subscriber.error(seenValue ? new NotFoundError('No matching values') : new EmptyError());
                }
            }));
        });
    }

    function skip(count) {
        return filter$5(function (_, index) { return count <= index; });
    }

    function skipLast(skipCount) {
        return skipCount <= 0
            ?
                identity$2
            : operate(function (source, subscriber) {
                var ring = new Array(skipCount);
                var seen = 0;
                source.subscribe(new OperatorSubscriber(subscriber, function (value) {
                    var valueIndex = seen++;
                    if (valueIndex < skipCount) {
                        ring[valueIndex] = value;
                    }
                    else {
                        var index = valueIndex % skipCount;
                        var oldValue = ring[index];
                        ring[index] = value;
                        subscriber.next(oldValue);
                    }
                }));
                return function () {
                    ring = null;
                };
            });
    }

    function skipUntil(notifier) {
        return operate(function (source, subscriber) {
            var taking = false;
            var skipSubscriber = new OperatorSubscriber(subscriber, function () {
                skipSubscriber === null || skipSubscriber === void 0 ? void 0 : skipSubscriber.unsubscribe();
                taking = true;
            }, noop$2);
            innerFrom(notifier).subscribe(skipSubscriber);
            source.subscribe(new OperatorSubscriber(subscriber, function (value) { return taking && subscriber.next(value); }));
        });
    }

    function skipWhile(predicate) {
        return operate(function (source, subscriber) {
            var taking = false;
            var index = 0;
            source.subscribe(new OperatorSubscriber(subscriber, function (value) { return (taking || (taking = !predicate(value, index++))) && subscriber.next(value); }));
        });
    }

    function startWith() {
        var values = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            values[_i] = arguments[_i];
        }
        var scheduler = popScheduler(values);
        return operate(function (source, subscriber) {
            (scheduler ? concat$1(values, source, scheduler) : concat$1(values, source)).subscribe(subscriber);
        });
    }

    function switchMap(project, resultSelector) {
        return operate(function (source, subscriber) {
            var innerSubscriber = null;
            var index = 0;
            var isComplete = false;
            var checkComplete = function () { return isComplete && !innerSubscriber && subscriber.complete(); };
            source.subscribe(new OperatorSubscriber(subscriber, function (value) {
                innerSubscriber === null || innerSubscriber === void 0 ? void 0 : innerSubscriber.unsubscribe();
                var innerIndex = 0;
                var outerIndex = index++;
                innerFrom(project(value, outerIndex)).subscribe((innerSubscriber = new OperatorSubscriber(subscriber, function (innerValue) { return subscriber.next(resultSelector ? resultSelector(value, innerValue, outerIndex, innerIndex++) : innerValue); }, function () {
                    innerSubscriber = null;
                    checkComplete();
                })));
            }, function () {
                isComplete = true;
                checkComplete();
            }));
        });
    }

    function switchAll() {
        return switchMap(identity$2);
    }

    function switchMapTo(innerObservable, resultSelector) {
        return isFunction(resultSelector) ? switchMap(function () { return innerObservable; }, resultSelector) : switchMap(function () { return innerObservable; });
    }

    function switchScan(accumulator, seed) {
        return operate(function (source, subscriber) {
            var state = seed;
            switchMap(function (value, index) { return accumulator(state, value, index); }, function (_, innerValue) { return ((state = innerValue), innerValue); })(source).subscribe(subscriber);
            return function () {
                state = null;
            };
        });
    }

    function takeUntil$9(notifier) {
        return operate(function (source, subscriber) {
            innerFrom(notifier).subscribe(new OperatorSubscriber(subscriber, function () { return subscriber.complete(); }, noop$2));
            !subscriber.closed && source.subscribe(subscriber);
        });
    }

    function takeWhile(predicate, inclusive) {
        if (inclusive === void 0) { inclusive = false; }
        return operate(function (source, subscriber) {
            var index = 0;
            source.subscribe(new OperatorSubscriber(subscriber, function (value) {
                var result = predicate(value, index++);
                (result || inclusive) && subscriber.next(value);
                !result && subscriber.complete();
            }));
        });
    }

    function tap(observerOrNext, error, complete) {
        var tapObserver = isFunction(observerOrNext) || error || complete
            ?
                { next: observerOrNext, error: error, complete: complete }
            : observerOrNext;
        return tapObserver
            ? operate(function (source, subscriber) {
                var _a;
                (_a = tapObserver.subscribe) === null || _a === void 0 ? void 0 : _a.call(tapObserver);
                var isUnsub = true;
                source.subscribe(new OperatorSubscriber(subscriber, function (value) {
                    var _a;
                    (_a = tapObserver.next) === null || _a === void 0 ? void 0 : _a.call(tapObserver, value);
                    subscriber.next(value);
                }, function () {
                    var _a;
                    isUnsub = false;
                    (_a = tapObserver.complete) === null || _a === void 0 ? void 0 : _a.call(tapObserver);
                    subscriber.complete();
                }, function (err) {
                    var _a;
                    isUnsub = false;
                    (_a = tapObserver.error) === null || _a === void 0 ? void 0 : _a.call(tapObserver, err);
                    subscriber.error(err);
                }, function () {
                    var _a, _b;
                    if (isUnsub) {
                        (_a = tapObserver.unsubscribe) === null || _a === void 0 ? void 0 : _a.call(tapObserver);
                    }
                    (_b = tapObserver.finalize) === null || _b === void 0 ? void 0 : _b.call(tapObserver);
                }));
            })
            :
                identity$2;
    }

    var defaultThrottleConfig = {
        leading: true,
        trailing: false,
    };
    function throttle(durationSelector, _a) {
        var _b = _a === void 0 ? defaultThrottleConfig : _a, leading = _b.leading, trailing = _b.trailing;
        return operate(function (source, subscriber) {
            var hasValue = false;
            var sendValue = null;
            var throttled = null;
            var isComplete = false;
            var endThrottling = function () {
                throttled === null || throttled === void 0 ? void 0 : throttled.unsubscribe();
                throttled = null;
                if (trailing) {
                    send();
                    isComplete && subscriber.complete();
                }
            };
            var cleanupThrottling = function () {
                throttled = null;
                isComplete && subscriber.complete();
            };
            var startThrottle = function (value) {
                return (throttled = innerFrom(durationSelector(value)).subscribe(new OperatorSubscriber(subscriber, endThrottling, cleanupThrottling)));
            };
            var send = function () {
                if (hasValue) {
                    hasValue = false;
                    var value = sendValue;
                    sendValue = null;
                    subscriber.next(value);
                    !isComplete && startThrottle(value);
                }
            };
            source.subscribe(new OperatorSubscriber(subscriber, function (value) {
                hasValue = true;
                sendValue = value;
                !(throttled && !throttled.closed) && (leading ? send() : startThrottle(value));
            }, function () {
                isComplete = true;
                !(trailing && hasValue && throttled && !throttled.closed) && subscriber.complete();
            }));
        });
    }

    function throttleTime(duration, scheduler, config) {
        if (scheduler === void 0) { scheduler = asyncScheduler; }
        if (config === void 0) { config = defaultThrottleConfig; }
        var duration$ = timer(duration, scheduler);
        return throttle(function () { return duration$; }, config);
    }

    function timeInterval(scheduler) {
        if (scheduler === void 0) { scheduler = async; }
        return function (source) {
            return defer$1(function () {
                return source.pipe(scan(function (_a, value) {
                    var current = _a.current;
                    return ({ value: value, current: scheduler.now(), last: current });
                }, {
                    current: scheduler.now(),
                    value: undefined,
                    last: undefined,
                }), map$8(function (_a) {
                    var current = _a.current, last = _a.last, value = _a.value;
                    return new TimeInterval(value, current - last);
                }));
            });
        };
    }
    var TimeInterval = (function () {
        function TimeInterval(value, interval) {
            this.value = value;
            this.interval = interval;
        }
        return TimeInterval;
    }());

    function timeoutWith(due, withObservable, scheduler) {
        var first;
        var each;
        var _with;
        scheduler = scheduler !== null && scheduler !== void 0 ? scheduler : async;
        if (isValidDate(due)) {
            first = due;
        }
        else if (typeof due === 'number') {
            each = due;
        }
        if (withObservable) {
            _with = function () { return withObservable; };
        }
        else {
            throw new TypeError('No observable provided to switch to');
        }
        if (first == null && each == null) {
            throw new TypeError('No timeout provided.');
        }
        return timeout({
            first: first,
            each: each,
            scheduler: scheduler,
            with: _with,
        });
    }

    function timestamp(timestampProvider) {
        if (timestampProvider === void 0) { timestampProvider = dateTimestampProvider; }
        return map$8(function (value) { return ({ value: value, timestamp: timestampProvider.now() }); });
    }

    function window$1(windowBoundaries) {
        return operate(function (source, subscriber) {
            var windowSubject = new Subject$1();
            subscriber.next(windowSubject.asObservable());
            var errorHandler = function (err) {
                windowSubject.error(err);
                subscriber.error(err);
            };
            source.subscribe(new OperatorSubscriber(subscriber, function (value) { return windowSubject === null || windowSubject === void 0 ? void 0 : windowSubject.next(value); }, function () {
                windowSubject.complete();
                subscriber.complete();
            }, errorHandler));
            windowBoundaries.subscribe(new OperatorSubscriber(subscriber, function () {
                windowSubject.complete();
                subscriber.next((windowSubject = new Subject$1()));
            }, noop$2, errorHandler));
            return function () {
                windowSubject === null || windowSubject === void 0 ? void 0 : windowSubject.unsubscribe();
                windowSubject = null;
            };
        });
    }

    function windowCount(windowSize, startWindowEvery) {
        if (startWindowEvery === void 0) { startWindowEvery = 0; }
        var startEvery = startWindowEvery > 0 ? startWindowEvery : windowSize;
        return operate(function (source, subscriber) {
            var windows = [new Subject$1()];
            var starts = [];
            var count = 0;
            subscriber.next(windows[0].asObservable());
            source.subscribe(new OperatorSubscriber(subscriber, function (value) {
                var e_1, _a;
                try {
                    for (var windows_1 = __values(windows), windows_1_1 = windows_1.next(); !windows_1_1.done; windows_1_1 = windows_1.next()) {
                        var window_1 = windows_1_1.value;
                        window_1.next(value);
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (windows_1_1 && !windows_1_1.done && (_a = windows_1.return)) _a.call(windows_1);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
                var c = count - windowSize + 1;
                if (c >= 0 && c % startEvery === 0) {
                    windows.shift().complete();
                }
                if (++count % startEvery === 0) {
                    var window_2 = new Subject$1();
                    windows.push(window_2);
                    subscriber.next(window_2.asObservable());
                }
            }, function () {
                while (windows.length > 0) {
                    windows.shift().complete();
                }
                subscriber.complete();
            }, function (err) {
                while (windows.length > 0) {
                    windows.shift().error(err);
                }
                subscriber.error(err);
            }, function () {
                starts = null;
                windows = null;
            }));
        });
    }

    function windowTime(windowTimeSpan) {
        var _a, _b;
        var otherArgs = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            otherArgs[_i - 1] = arguments[_i];
        }
        var scheduler = (_a = popScheduler(otherArgs)) !== null && _a !== void 0 ? _a : asyncScheduler;
        var windowCreationInterval = (_b = otherArgs[0]) !== null && _b !== void 0 ? _b : null;
        var maxWindowSize = otherArgs[1] || Infinity;
        return operate(function (source, subscriber) {
            var windowRecords = [];
            var restartOnClose = false;
            var closeWindow = function (record) {
                var window = record.window, subs = record.subs;
                window.complete();
                subs.unsubscribe();
                arrRemove(windowRecords, record);
                restartOnClose && startWindow();
            };
            var startWindow = function () {
                if (windowRecords) {
                    var subs = new Subscription();
                    subscriber.add(subs);
                    var window_1 = new Subject$1();
                    var record_1 = {
                        window: window_1,
                        subs: subs,
                        seen: 0,
                    };
                    windowRecords.push(record_1);
                    subscriber.next(window_1.asObservable());
                    executeSchedule(subs, scheduler, function () { return closeWindow(record_1); }, windowTimeSpan);
                }
            };
            if (windowCreationInterval !== null && windowCreationInterval >= 0) {
                executeSchedule(subscriber, scheduler, startWindow, windowCreationInterval, true);
            }
            else {
                restartOnClose = true;
            }
            startWindow();
            var loop = function (cb) { return windowRecords.slice().forEach(cb); };
            var terminate = function (cb) {
                loop(function (_a) {
                    var window = _a.window;
                    return cb(window);
                });
                cb(subscriber);
                subscriber.unsubscribe();
            };
            source.subscribe(new OperatorSubscriber(subscriber, function (value) {
                loop(function (record) {
                    record.window.next(value);
                    maxWindowSize <= ++record.seen && closeWindow(record);
                });
            }, function () { return terminate(function (consumer) { return consumer.complete(); }); }, function (err) { return terminate(function (consumer) { return consumer.error(err); }); }));
            return function () {
                windowRecords = null;
            };
        });
    }

    function windowToggle(openings, closingSelector) {
        return operate(function (source, subscriber) {
            var windows = [];
            var handleError = function (err) {
                while (0 < windows.length) {
                    windows.shift().error(err);
                }
                subscriber.error(err);
            };
            innerFrom(openings).subscribe(new OperatorSubscriber(subscriber, function (openValue) {
                var window = new Subject$1();
                windows.push(window);
                var closingSubscription = new Subscription();
                var closeWindow = function () {
                    arrRemove(windows, window);
                    window.complete();
                    closingSubscription.unsubscribe();
                };
                var closingNotifier;
                try {
                    closingNotifier = innerFrom(closingSelector(openValue));
                }
                catch (err) {
                    handleError(err);
                    return;
                }
                subscriber.next(window.asObservable());
                closingSubscription.add(closingNotifier.subscribe(new OperatorSubscriber(subscriber, closeWindow, noop$2, handleError)));
            }, noop$2));
            source.subscribe(new OperatorSubscriber(subscriber, function (value) {
                var e_1, _a;
                var windowsCopy = windows.slice();
                try {
                    for (var windowsCopy_1 = __values(windowsCopy), windowsCopy_1_1 = windowsCopy_1.next(); !windowsCopy_1_1.done; windowsCopy_1_1 = windowsCopy_1.next()) {
                        var window_1 = windowsCopy_1_1.value;
                        window_1.next(value);
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (windowsCopy_1_1 && !windowsCopy_1_1.done && (_a = windowsCopy_1.return)) _a.call(windowsCopy_1);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
            }, function () {
                while (0 < windows.length) {
                    windows.shift().complete();
                }
                subscriber.complete();
            }, handleError, function () {
                while (0 < windows.length) {
                    windows.shift().unsubscribe();
                }
            }));
        });
    }

    function windowWhen(closingSelector) {
        return operate(function (source, subscriber) {
            var window;
            var closingSubscriber;
            var handleError = function (err) {
                window.error(err);
                subscriber.error(err);
            };
            var openWindow = function () {
                closingSubscriber === null || closingSubscriber === void 0 ? void 0 : closingSubscriber.unsubscribe();
                window === null || window === void 0 ? void 0 : window.complete();
                window = new Subject$1();
                subscriber.next(window.asObservable());
                var closingNotifier;
                try {
                    closingNotifier = innerFrom(closingSelector());
                }
                catch (err) {
                    handleError(err);
                    return;
                }
                closingNotifier.subscribe((closingSubscriber = new OperatorSubscriber(subscriber, openWindow, openWindow, handleError)));
            };
            openWindow();
            source.subscribe(new OperatorSubscriber(subscriber, function (value) { return window.next(value); }, function () {
                window.complete();
                subscriber.complete();
            }, handleError, function () {
                closingSubscriber === null || closingSubscriber === void 0 ? void 0 : closingSubscriber.unsubscribe();
                window = null;
            }));
        });
    }

    function withLatestFrom() {
        var inputs = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            inputs[_i] = arguments[_i];
        }
        var project = popResultSelector(inputs);
        return operate(function (source, subscriber) {
            var len = inputs.length;
            var otherValues = new Array(len);
            var hasValue = inputs.map(function () { return false; });
            var ready = false;
            var _loop_1 = function (i) {
                innerFrom(inputs[i]).subscribe(new OperatorSubscriber(subscriber, function (value) {
                    otherValues[i] = value;
                    if (!ready && !hasValue[i]) {
                        hasValue[i] = true;
                        (ready = hasValue.every(identity$2)) && (hasValue = null);
                    }
                }, noop$2));
            };
            for (var i = 0; i < len; i++) {
                _loop_1(i);
            }
            source.subscribe(new OperatorSubscriber(subscriber, function (value) {
                if (ready) {
                    var values = __spreadArray([value], __read(otherValues));
                    subscriber.next(project ? project.apply(void 0, __spreadArray([], __read(values))) : values);
                }
            }));
        });
    }

    function zipAll(project) {
        return joinAllInternals(zip$1, project);
    }

    function zip() {
        var sources = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            sources[_i] = arguments[_i];
        }
        return operate(function (source, subscriber) {
            zip$1.apply(void 0, __spreadArray([source], __read(sources))).subscribe(subscriber);
        });
    }

    function zipWith() {
        var otherInputs = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            otherInputs[_i] = arguments[_i];
        }
        return zip.apply(void 0, __spreadArray([], __read(otherInputs)));
    }

    var esm5 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        Observable: Observable,
        ConnectableObservable: ConnectableObservable,
        observable: observable,
        animationFrames: animationFrames,
        Subject: Subject$1,
        BehaviorSubject: BehaviorSubject,
        ReplaySubject: ReplaySubject,
        AsyncSubject: AsyncSubject,
        asap: asap,
        asapScheduler: asapScheduler,
        async: async,
        asyncScheduler: asyncScheduler,
        queue: queue,
        queueScheduler: queueScheduler,
        animationFrame: animationFrame,
        animationFrameScheduler: animationFrameScheduler,
        VirtualTimeScheduler: VirtualTimeScheduler,
        VirtualAction: VirtualAction,
        Scheduler: Scheduler,
        Subscription: Subscription,
        Subscriber: Subscriber,
        Notification: Notification,
        get NotificationKind () { return NotificationKind; },
        pipe: pipe$1,
        noop: noop$2,
        identity: identity$2,
        isObservable: isObservable,
        lastValueFrom: lastValueFrom,
        firstValueFrom: firstValueFrom,
        ArgumentOutOfRangeError: ArgumentOutOfRangeError,
        EmptyError: EmptyError,
        NotFoundError: NotFoundError,
        ObjectUnsubscribedError: ObjectUnsubscribedError,
        SequenceError: SequenceError,
        TimeoutError: TimeoutError,
        UnsubscriptionError: UnsubscriptionError,
        bindCallback: bindCallback,
        bindNodeCallback: bindNodeCallback,
        combineLatest: combineLatest$1,
        concat: concat$1,
        connectable: connectable,
        defer: defer$1,
        empty: empty$1,
        forkJoin: forkJoin,
        from: from$2,
        fromEvent: fromEvent$1,
        fromEventPattern: fromEventPattern,
        generate: generate,
        iif: iif,
        interval: interval,
        merge: merge$1,
        never: never,
        of: of$2,
        onErrorResumeNext: onErrorResumeNext,
        pairs: pairs,
        partition: partition$1,
        race: race$1,
        range: range$1,
        throwError: throwError,
        timer: timer,
        using: using,
        zip: zip$1,
        scheduled: scheduled,
        EMPTY: EMPTY,
        NEVER: NEVER,
        config: config,
        audit: audit,
        auditTime: auditTime,
        buffer: buffer$1,
        bufferCount: bufferCount,
        bufferTime: bufferTime,
        bufferToggle: bufferToggle,
        bufferWhen: bufferWhen,
        catchError: catchError,
        combineAll: combineAll,
        combineLatestAll: combineLatestAll,
        combineLatestWith: combineLatestWith,
        concatAll: concatAll,
        concatMap: concatMap$3,
        concatMapTo: concatMapTo,
        concatWith: concatWith,
        connect: connect,
        count: count,
        debounce: debounce,
        debounceTime: debounceTime,
        defaultIfEmpty: defaultIfEmpty,
        delay: delay,
        delayWhen: delayWhen,
        dematerialize: dematerialize,
        distinct: distinct,
        distinctUntilChanged: distinctUntilChanged,
        distinctUntilKeyChanged: distinctUntilKeyChanged,
        elementAt: elementAt,
        endWith: endWith,
        every: every,
        exhaust: exhaust,
        exhaustAll: exhaustAll,
        exhaustMap: exhaustMap,
        expand: expand$3,
        filter: filter$5,
        finalize: finalize,
        find: find$1,
        findIndex: findIndex$2,
        first: first,
        groupBy: groupBy,
        ignoreElements: ignoreElements,
        isEmpty: isEmpty,
        last: last,
        map: map$8,
        mapTo: mapTo,
        materialize: materialize,
        max: max,
        mergeAll: mergeAll,
        flatMap: flatMap$2,
        mergeMap: mergeMap,
        mergeMapTo: mergeMapTo,
        mergeScan: mergeScan,
        mergeWith: mergeWith,
        min: min,
        multicast: multicast,
        observeOn: observeOn,
        pairwise: pairwise,
        pluck: pluck,
        publish: publish$1,
        publishBehavior: publishBehavior,
        publishLast: publishLast,
        publishReplay: publishReplay,
        raceWith: raceWith,
        reduce: reduce$1,
        repeat: repeat,
        repeatWhen: repeatWhen,
        retry: retry,
        retryWhen: retryWhen,
        refCount: refCount,
        sample: sample$1,
        sampleTime: sampleTime,
        scan: scan,
        sequenceEqual: sequenceEqual,
        share: share$2,
        shareReplay: shareReplay,
        single: single,
        skip: skip,
        skipLast: skipLast,
        skipUntil: skipUntil,
        skipWhile: skipWhile,
        startWith: startWith,
        subscribeOn: subscribeOn,
        switchAll: switchAll,
        switchMap: switchMap,
        switchMapTo: switchMapTo,
        switchScan: switchScan,
        take: take$3,
        takeLast: takeLast,
        takeUntil: takeUntil$9,
        takeWhile: takeWhile,
        tap: tap,
        throttle: throttle,
        throttleTime: throttleTime,
        throwIfEmpty: throwIfEmpty,
        timeInterval: timeInterval,
        timeout: timeout,
        timeoutWith: timeoutWith,
        timestamp: timestamp,
        toArray: toArray,
        window: window$1,
        windowCount: windowCount,
        windowTime: windowTime,
        windowToggle: windowToggle,
        windowWhen: windowWhen,
        withLatestFrom: withLatestFrom,
        zipAll: zipAll,
        zipWith: zipWith
    });

    var require$$4$1 = /*@__PURE__*/getAugmentedNamespace(esm5);

    function partition(predicate, thisArg) {
        return function (source) {
            return [filter$5(predicate, thisArg)(source), filter$5(not(predicate, thisArg))(source)];
        };
    }

    function race() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        return raceWith.apply(void 0, __spreadArray([], __read(argsOrArgArray(args))));
    }

    var operators = /*#__PURE__*/Object.freeze({
        __proto__: null,
        audit: audit,
        auditTime: auditTime,
        buffer: buffer$1,
        bufferCount: bufferCount,
        bufferTime: bufferTime,
        bufferToggle: bufferToggle,
        bufferWhen: bufferWhen,
        catchError: catchError,
        combineAll: combineAll,
        combineLatestAll: combineLatestAll,
        combineLatest: combineLatest,
        combineLatestWith: combineLatestWith,
        concat: concat,
        concatAll: concatAll,
        concatMap: concatMap$3,
        concatMapTo: concatMapTo,
        concatWith: concatWith,
        connect: connect,
        count: count,
        debounce: debounce,
        debounceTime: debounceTime,
        defaultIfEmpty: defaultIfEmpty,
        delay: delay,
        delayWhen: delayWhen,
        dematerialize: dematerialize,
        distinct: distinct,
        distinctUntilChanged: distinctUntilChanged,
        distinctUntilKeyChanged: distinctUntilKeyChanged,
        elementAt: elementAt,
        endWith: endWith,
        every: every,
        exhaust: exhaust,
        exhaustAll: exhaustAll,
        exhaustMap: exhaustMap,
        expand: expand$3,
        filter: filter$5,
        finalize: finalize,
        find: find$1,
        findIndex: findIndex$2,
        first: first,
        groupBy: groupBy,
        ignoreElements: ignoreElements,
        isEmpty: isEmpty,
        last: last,
        map: map$8,
        mapTo: mapTo,
        materialize: materialize,
        max: max,
        merge: merge,
        mergeAll: mergeAll,
        flatMap: flatMap$2,
        mergeMap: mergeMap,
        mergeMapTo: mergeMapTo,
        mergeScan: mergeScan,
        mergeWith: mergeWith,
        min: min,
        multicast: multicast,
        observeOn: observeOn,
        onErrorResumeNext: onErrorResumeNext$1,
        pairwise: pairwise,
        partition: partition,
        pluck: pluck,
        publish: publish$1,
        publishBehavior: publishBehavior,
        publishLast: publishLast,
        publishReplay: publishReplay,
        race: race,
        raceWith: raceWith,
        reduce: reduce$1,
        repeat: repeat,
        repeatWhen: repeatWhen,
        retry: retry,
        retryWhen: retryWhen,
        refCount: refCount,
        sample: sample$1,
        sampleTime: sampleTime,
        scan: scan,
        sequenceEqual: sequenceEqual,
        share: share$2,
        shareReplay: shareReplay,
        single: single,
        skip: skip,
        skipLast: skipLast,
        skipUntil: skipUntil,
        skipWhile: skipWhile,
        startWith: startWith,
        subscribeOn: subscribeOn,
        switchAll: switchAll,
        switchMap: switchMap,
        switchMapTo: switchMapTo,
        switchScan: switchScan,
        take: take$3,
        takeLast: takeLast,
        takeUntil: takeUntil$9,
        takeWhile: takeWhile,
        tap: tap,
        throttle: throttle,
        throttleTime: throttleTime,
        throwIfEmpty: throwIfEmpty,
        timeInterval: timeInterval,
        timeout: timeout,
        timeoutWith: timeoutWith,
        timestamp: timestamp,
        toArray: toArray,
        window: window$1,
        windowCount: windowCount,
        windowTime: windowTime,
        windowToggle: windowToggle,
        windowWhen: windowWhen,
        withLatestFrom: withLatestFrom,
        zip: zip,
        zipAll: zipAll,
        zipWith: zipWith
    });

    var require$$1$1 = /*@__PURE__*/getAugmentedNamespace(operators);

    var runAsync$5 = {exports: {}};

    function isPromise(obj) {
      return !!obj && (typeof obj === 'object' || typeof obj === 'function') && typeof obj.then === 'function';
    }

    /**
     * Return a function that will run a function asynchronously or synchronously
     *
     * example:
     * runAsync(wrappedFunction, callback)(...args);
     *
     * @param   {Function} func  Function to run
     * @param   {Function} cb    Callback function passed the `func` returned value
     * @return  {Function(arguments)} Arguments to pass to `func`. This function will in turn
     *                                return a Promise (Node >= 0.12) or call the callbacks.
     */

    var runAsync$4 = runAsync$5.exports = function (func, cb) {
      cb = cb || function () {};

      return function () {

        var args = arguments;

        var promise = new Promise(function (resolve, reject) {
          var resolved = false;
          const wrappedResolve = function (value) {
            if (resolved) {
              console.warn('Run-async promise already resolved.');
            }
            resolved = true;
            resolve(value);
          };

          var rejected = false;
          const wrappedReject = function (value) {
            if (rejected) {
              console.warn('Run-async promise already rejected.');
            }
            rejected = true;
            reject(value);
          };

          var usingCallback = false;
          var callbackConflict = false;
          var contextEnded = false;

          var answer = func.apply({
            async: function () {
              if (contextEnded) {
                console.warn('Run-async async() called outside a valid run-async context, callback will be ignored.');
                return function() {};
              }
              if (callbackConflict) {
                console.warn('Run-async wrapped function (async) returned a promise.\nCalls to async() callback can have unexpected results.');
              }
              usingCallback = true;
              return function (err, value) {
                if (err) {
                  wrappedReject(err);
                } else {
                  wrappedResolve(value);
                }
              };
            }
          }, Array.prototype.slice.call(args));

          if (usingCallback) {
            if (isPromise(answer)) {
              console.warn('Run-async wrapped function (sync) returned a promise but async() callback must be executed to resolve.');
            }
          } else {
            if (isPromise(answer)) {
              callbackConflict = true;
              answer.then(wrappedResolve, wrappedReject);
            } else {
              wrappedResolve(answer);
            }
          }
          contextEnded = true;
        });

        promise.then(cb.bind(null, null), cb);

        return promise;
      }
    };

    runAsync$4.cb = function (func, cb) {
      return runAsync$4(function () {
        var args = Array.prototype.slice.call(arguments);
        if (args.length === func.length - 1) {
          args.push(this.async());
        }
        return func.apply(this, args);
      }, cb);
    };

    var utils$2 = {};

    const _$b = {
      isFunction: isFunction_1,
    };
    const { from: from$1, of: of$1 } = require$$4$1;
    const runAsync$3 = runAsync$5.exports;

    /**
     * Resolve a question property value if it is passed as a function.
     * This method will overwrite the property on the question object with the received value.
     * @param  {Object} question - Question object
     * @param  {String} prop     - Property to fetch name
     * @param  {Object} answers  - Answers object
     * @return {Rx.Observable}   - Observable emitting once value is known
     */

    utils$2.fetchAsyncQuestionProperty = function (question, prop, answers) {
      if (!_$b.isFunction(question[prop])) {
        return of$1(question);
      }

      return from$1(
        runAsync$3(question[prop])(answers).then((value) => {
          question[prop] = value;
          return question;
        })
      );
    };

    const _$a = {
      isPlainObject: isPlainObject_1,
      clone: clone_1,
      isArray: isArray_1,
      get: get_1,
      set: set_1,
      isFunction: isFunction_1,
    };
    const { defer, empty, from, of } = require$$4$1;
    const { concatMap: concatMap$2, filter: filter$4, publish, reduce } = require$$1$1;
    const runAsync$2 = runAsync$5.exports;
    const utils$1 = utils$2;
    const Base$8 = baseUI;

    /**
     * Base interface class other can inherits from
     */

    class PromptUI extends Base$8 {
      constructor(prompts, opt) {
        super(opt);
        this.prompts = prompts;
      }

      run(questions, answers) {
        // Keep global reference to the answers
        if (_$a.isPlainObject(answers)) {
          this.answers = _$a.clone(answers);
        } else {
          this.answers = {};
        }

        // Make sure questions is an array.
        if (_$a.isPlainObject(questions)) {
          // It's either an object of questions or a single question
          questions = Object.values(questions).every(
            (v) => _$a.isPlainObject(v) && v.name === undefined
          )
            ? Object.entries(questions).map(([name, question]) => ({ name, ...question }))
            : [questions];
        }

        // Create an observable, unless we received one as parameter.
        // Note: As this is a public interface, we cannot do an instanceof check as we won't
        // be using the exact same object in memory.
        const obs = _$a.isArray(questions) ? from(questions) : questions;

        this.process = obs.pipe(
          concatMap$2(this.processQuestion.bind(this)),
          publish() // Creates a hot Observable. It prevents duplicating prompts.
        );

        this.process.connect();

        return this.process
          .pipe(
            reduce((answers, answer) => {
              _$a.set(answers, answer.name, answer.answer);
              return answers;
            }, this.answers)
          )
          .toPromise(Promise)
          .then(this.onCompletion.bind(this), this.onError.bind(this));
      }

      /**
       * Once all prompt are over
       */

      onCompletion() {
        this.close();

        return this.answers;
      }

      onError(error) {
        this.close();
        return Promise.reject(error);
      }

      processQuestion(question) {
        question = _$a.clone(question);
        return defer(() => {
          const obs = of(question);

          return obs.pipe(
            concatMap$2(this.setDefaultType.bind(this)),
            concatMap$2(this.filterIfRunnable.bind(this)),
            concatMap$2(() =>
              utils$1.fetchAsyncQuestionProperty(question, 'message', this.answers)
            ),
            concatMap$2(() =>
              utils$1.fetchAsyncQuestionProperty(question, 'default', this.answers)
            ),
            concatMap$2(() =>
              utils$1.fetchAsyncQuestionProperty(question, 'choices', this.answers)
            ),
            concatMap$2(this.fetchAnswer.bind(this))
          );
        });
      }

      fetchAnswer(question) {
        const Prompt = this.prompts[question.type];
        this.activePrompt = new Prompt(question, this.rl, this.answers);
        return defer(() =>
          from(this.activePrompt.run().then((answer) => ({ name: question.name, answer })))
        );
      }

      setDefaultType(question) {
        // Default type to input
        if (!this.prompts[question.type]) {
          question.type = 'input';
        }

        return defer(() => of(question));
      }

      filterIfRunnable(question) {
        if (
          question.askAnswered !== true &&
          _$a.get(this.answers, question.name) !== undefined
        ) {
          return empty();
        }

        if (question.when === false) {
          return empty();
        }

        if (!_$a.isFunction(question.when)) {
          return of(question);
        }

        const { answers } = this;
        return defer(() =>
          from(
            runAsync$2(question.when)(answers).then((shouldRun) => {
              if (shouldRun) {
                return question;
              }
            })
          ).pipe(filter$4((val) => val != null))
        );
      }
    }

    var prompt = PromptUI;

    var baseGetTag$2 = _baseGetTag,
        isObjectLike$3 = isObjectLike_1;

    /** `Object#toString` result references. */
    var numberTag$1 = '[object Number]';

    /**
     * Checks if `value` is classified as a `Number` primitive or object.
     *
     * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are
     * classified as numbers, use the `_.isFinite` method.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a number, else `false`.
     * @example
     *
     * _.isNumber(3);
     * // => true
     *
     * _.isNumber(Number.MIN_VALUE);
     * // => true
     *
     * _.isNumber(Infinity);
     * // => true
     *
     * _.isNumber('3');
     * // => false
     */
    function isNumber(value) {
      return typeof value == 'number' ||
        (isObjectLike$3(value) && baseGetTag$2(value) == numberTag$1);
    }

    var isNumber_1 = isNumber;

    /**
     * The base implementation of `_.findIndex` and `_.findLastIndex` without
     * support for iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {Function} predicate The function invoked per iteration.
     * @param {number} fromIndex The index to search from.
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {number} Returns the index of the matched value, else `-1`.
     */

    function baseFindIndex$2(array, predicate, fromIndex, fromRight) {
      var length = array.length,
          index = fromIndex + (fromRight ? 1 : -1);

      while ((fromRight ? index-- : ++index < length)) {
        if (predicate(array[index], index, array)) {
          return index;
        }
      }
      return -1;
    }

    var _baseFindIndex = baseFindIndex$2;

    /** Used to stand-in for `undefined` hash values. */

    var HASH_UNDEFINED = '__lodash_hash_undefined__';

    /**
     * Adds `value` to the array cache.
     *
     * @private
     * @name add
     * @memberOf SetCache
     * @alias push
     * @param {*} value The value to cache.
     * @returns {Object} Returns the cache instance.
     */
    function setCacheAdd$1(value) {
      this.__data__.set(value, HASH_UNDEFINED);
      return this;
    }

    var _setCacheAdd = setCacheAdd$1;

    /**
     * Checks if `value` is in the array cache.
     *
     * @private
     * @name has
     * @memberOf SetCache
     * @param {*} value The value to search for.
     * @returns {number} Returns `true` if `value` is found, else `false`.
     */

    function setCacheHas$1(value) {
      return this.__data__.has(value);
    }

    var _setCacheHas = setCacheHas$1;

    var MapCache = _MapCache,
        setCacheAdd = _setCacheAdd,
        setCacheHas = _setCacheHas;

    /**
     *
     * Creates an array cache object to store unique values.
     *
     * @private
     * @constructor
     * @param {Array} [values] The values to cache.
     */
    function SetCache$2(values) {
      var index = -1,
          length = values == null ? 0 : values.length;

      this.__data__ = new MapCache;
      while (++index < length) {
        this.add(values[index]);
      }
    }

    // Add methods to `SetCache`.
    SetCache$2.prototype.add = SetCache$2.prototype.push = setCacheAdd;
    SetCache$2.prototype.has = setCacheHas;

    var _SetCache = SetCache$2;

    /**
     * A specialized version of `_.some` for arrays without support for iteratee
     * shorthands.
     *
     * @private
     * @param {Array} [array] The array to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {boolean} Returns `true` if any element passes the predicate check,
     *  else `false`.
     */

    function arraySome$1(array, predicate) {
      var index = -1,
          length = array == null ? 0 : array.length;

      while (++index < length) {
        if (predicate(array[index], index, array)) {
          return true;
        }
      }
      return false;
    }

    var _arraySome = arraySome$1;

    /**
     * Checks if a `cache` value for `key` exists.
     *
     * @private
     * @param {Object} cache The cache to query.
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */

    function cacheHas$2(cache, key) {
      return cache.has(key);
    }

    var _cacheHas = cacheHas$2;

    var SetCache$1 = _SetCache,
        arraySome = _arraySome,
        cacheHas$1 = _cacheHas;

    /** Used to compose bitmasks for value comparisons. */
    var COMPARE_PARTIAL_FLAG$5 = 1,
        COMPARE_UNORDERED_FLAG$3 = 2;

    /**
     * A specialized version of `baseIsEqualDeep` for arrays with support for
     * partial deep comparisons.
     *
     * @private
     * @param {Array} array The array to compare.
     * @param {Array} other The other array to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} stack Tracks traversed `array` and `other` objects.
     * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
     */
    function equalArrays$2(array, other, bitmask, customizer, equalFunc, stack) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG$5,
          arrLength = array.length,
          othLength = other.length;

      if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
        return false;
      }
      // Check that cyclic values are equal.
      var arrStacked = stack.get(array);
      var othStacked = stack.get(other);
      if (arrStacked && othStacked) {
        return arrStacked == other && othStacked == array;
      }
      var index = -1,
          result = true,
          seen = (bitmask & COMPARE_UNORDERED_FLAG$3) ? new SetCache$1 : undefined;

      stack.set(array, other);
      stack.set(other, array);

      // Ignore non-index properties.
      while (++index < arrLength) {
        var arrValue = array[index],
            othValue = other[index];

        if (customizer) {
          var compared = isPartial
            ? customizer(othValue, arrValue, index, other, array, stack)
            : customizer(arrValue, othValue, index, array, other, stack);
        }
        if (compared !== undefined) {
          if (compared) {
            continue;
          }
          result = false;
          break;
        }
        // Recursively compare arrays (susceptible to call stack limits).
        if (seen) {
          if (!arraySome(other, function(othValue, othIndex) {
                if (!cacheHas$1(seen, othIndex) &&
                    (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
                  return seen.push(othIndex);
                }
              })) {
            result = false;
            break;
          }
        } else if (!(
              arrValue === othValue ||
                equalFunc(arrValue, othValue, bitmask, customizer, stack)
            )) {
          result = false;
          break;
        }
      }
      stack['delete'](array);
      stack['delete'](other);
      return result;
    }

    var _equalArrays = equalArrays$2;

    /**
     * Converts `map` to its key-value pairs.
     *
     * @private
     * @param {Object} map The map to convert.
     * @returns {Array} Returns the key-value pairs.
     */

    function mapToArray$1(map) {
      var index = -1,
          result = Array(map.size);

      map.forEach(function(value, key) {
        result[++index] = [key, value];
      });
      return result;
    }

    var _mapToArray = mapToArray$1;

    /**
     * Converts `set` to an array of its values.
     *
     * @private
     * @param {Object} set The set to convert.
     * @returns {Array} Returns the values.
     */

    function setToArray$3(set) {
      var index = -1,
          result = Array(set.size);

      set.forEach(function(value) {
        result[++index] = value;
      });
      return result;
    }

    var _setToArray = setToArray$3;

    var Symbol$1 = _Symbol,
        Uint8Array$1 = _Uint8Array,
        eq$1 = eq_1,
        equalArrays$1 = _equalArrays,
        mapToArray = _mapToArray,
        setToArray$2 = _setToArray;

    /** Used to compose bitmasks for value comparisons. */
    var COMPARE_PARTIAL_FLAG$4 = 1,
        COMPARE_UNORDERED_FLAG$2 = 2;

    /** `Object#toString` result references. */
    var boolTag$1 = '[object Boolean]',
        dateTag = '[object Date]',
        errorTag = '[object Error]',
        mapTag = '[object Map]',
        numberTag = '[object Number]',
        regexpTag = '[object RegExp]',
        setTag = '[object Set]',
        stringTag$1 = '[object String]',
        symbolTag = '[object Symbol]';

    var arrayBufferTag = '[object ArrayBuffer]',
        dataViewTag = '[object DataView]';

    /** Used to convert symbols to primitives and strings. */
    var symbolProto = Symbol$1 ? Symbol$1.prototype : undefined,
        symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

    /**
     * A specialized version of `baseIsEqualDeep` for comparing objects of
     * the same `toStringTag`.
     *
     * **Note:** This function only supports comparing values with tags of
     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {string} tag The `toStringTag` of the objects to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} stack Tracks traversed `object` and `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */
    function equalByTag$1(object, other, tag, bitmask, customizer, equalFunc, stack) {
      switch (tag) {
        case dataViewTag:
          if ((object.byteLength != other.byteLength) ||
              (object.byteOffset != other.byteOffset)) {
            return false;
          }
          object = object.buffer;
          other = other.buffer;

        case arrayBufferTag:
          if ((object.byteLength != other.byteLength) ||
              !equalFunc(new Uint8Array$1(object), new Uint8Array$1(other))) {
            return false;
          }
          return true;

        case boolTag$1:
        case dateTag:
        case numberTag:
          // Coerce booleans to `1` or `0` and dates to milliseconds.
          // Invalid dates are coerced to `NaN`.
          return eq$1(+object, +other);

        case errorTag:
          return object.name == other.name && object.message == other.message;

        case regexpTag:
        case stringTag$1:
          // Coerce regexes to strings and treat strings, primitives and objects,
          // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
          // for more details.
          return object == (other + '');

        case mapTag:
          var convert = mapToArray;

        case setTag:
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG$4;
          convert || (convert = setToArray$2);

          if (object.size != other.size && !isPartial) {
            return false;
          }
          // Assume cyclic values are equal.
          var stacked = stack.get(object);
          if (stacked) {
            return stacked == other;
          }
          bitmask |= COMPARE_UNORDERED_FLAG$2;

          // Recursively compare objects (susceptible to call stack limits).
          stack.set(object, other);
          var result = equalArrays$1(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
          stack['delete'](object);
          return result;

        case symbolTag:
          if (symbolValueOf) {
            return symbolValueOf.call(object) == symbolValueOf.call(other);
          }
      }
      return false;
    }

    var _equalByTag = equalByTag$1;

    var getAllKeys = _getAllKeys;

    /** Used to compose bitmasks for value comparisons. */
    var COMPARE_PARTIAL_FLAG$3 = 1;

    /** Used for built-in method references. */
    var objectProto$3 = Object.prototype;

    /** Used to check objects for own properties. */
    var hasOwnProperty$3 = objectProto$3.hasOwnProperty;

    /**
     * A specialized version of `baseIsEqualDeep` for objects with support for
     * partial deep comparisons.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} stack Tracks traversed `object` and `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */
    function equalObjects$1(object, other, bitmask, customizer, equalFunc, stack) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG$3,
          objProps = getAllKeys(object),
          objLength = objProps.length,
          othProps = getAllKeys(other),
          othLength = othProps.length;

      if (objLength != othLength && !isPartial) {
        return false;
      }
      var index = objLength;
      while (index--) {
        var key = objProps[index];
        if (!(isPartial ? key in other : hasOwnProperty$3.call(other, key))) {
          return false;
        }
      }
      // Check that cyclic values are equal.
      var objStacked = stack.get(object);
      var othStacked = stack.get(other);
      if (objStacked && othStacked) {
        return objStacked == other && othStacked == object;
      }
      var result = true;
      stack.set(object, other);
      stack.set(other, object);

      var skipCtor = isPartial;
      while (++index < objLength) {
        key = objProps[index];
        var objValue = object[key],
            othValue = other[key];

        if (customizer) {
          var compared = isPartial
            ? customizer(othValue, objValue, key, other, object, stack)
            : customizer(objValue, othValue, key, object, other, stack);
        }
        // Recursively compare objects (susceptible to call stack limits).
        if (!(compared === undefined
              ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))
              : compared
            )) {
          result = false;
          break;
        }
        skipCtor || (skipCtor = key == 'constructor');
      }
      if (result && !skipCtor) {
        var objCtor = object.constructor,
            othCtor = other.constructor;

        // Non `Object` object instances with different constructors are not equal.
        if (objCtor != othCtor &&
            ('constructor' in object && 'constructor' in other) &&
            !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
              typeof othCtor == 'function' && othCtor instanceof othCtor)) {
          result = false;
        }
      }
      stack['delete'](object);
      stack['delete'](other);
      return result;
    }

    var _equalObjects = equalObjects$1;

    var Stack$1 = _Stack,
        equalArrays = _equalArrays,
        equalByTag = _equalByTag,
        equalObjects = _equalObjects,
        getTag = _getTag,
        isArray$6 = isArray_1,
        isBuffer = isBuffer$3.exports,
        isTypedArray = isTypedArray_1;

    /** Used to compose bitmasks for value comparisons. */
    var COMPARE_PARTIAL_FLAG$2 = 1;

    /** `Object#toString` result references. */
    var argsTag = '[object Arguments]',
        arrayTag = '[object Array]',
        objectTag = '[object Object]';

    /** Used for built-in method references. */
    var objectProto$2 = Object.prototype;

    /** Used to check objects for own properties. */
    var hasOwnProperty$2 = objectProto$2.hasOwnProperty;

    /**
     * A specialized version of `baseIsEqual` for arrays and objects which performs
     * deep comparisons and tracks traversed objects enabling objects with circular
     * references to be compared.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} [stack] Tracks traversed `object` and `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */
    function baseIsEqualDeep$1(object, other, bitmask, customizer, equalFunc, stack) {
      var objIsArr = isArray$6(object),
          othIsArr = isArray$6(other),
          objTag = objIsArr ? arrayTag : getTag(object),
          othTag = othIsArr ? arrayTag : getTag(other);

      objTag = objTag == argsTag ? objectTag : objTag;
      othTag = othTag == argsTag ? objectTag : othTag;

      var objIsObj = objTag == objectTag,
          othIsObj = othTag == objectTag,
          isSameTag = objTag == othTag;

      if (isSameTag && isBuffer(object)) {
        if (!isBuffer(other)) {
          return false;
        }
        objIsArr = true;
        objIsObj = false;
      }
      if (isSameTag && !objIsObj) {
        stack || (stack = new Stack$1);
        return (objIsArr || isTypedArray(object))
          ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)
          : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
      }
      if (!(bitmask & COMPARE_PARTIAL_FLAG$2)) {
        var objIsWrapped = objIsObj && hasOwnProperty$2.call(object, '__wrapped__'),
            othIsWrapped = othIsObj && hasOwnProperty$2.call(other, '__wrapped__');

        if (objIsWrapped || othIsWrapped) {
          var objUnwrapped = objIsWrapped ? object.value() : object,
              othUnwrapped = othIsWrapped ? other.value() : other;

          stack || (stack = new Stack$1);
          return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
        }
      }
      if (!isSameTag) {
        return false;
      }
      stack || (stack = new Stack$1);
      return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
    }

    var _baseIsEqualDeep = baseIsEqualDeep$1;

    var baseIsEqualDeep = _baseIsEqualDeep,
        isObjectLike$2 = isObjectLike_1;

    /**
     * The base implementation of `_.isEqual` which supports partial comparisons
     * and tracks traversed objects.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @param {boolean} bitmask The bitmask flags.
     *  1 - Unordered comparison
     *  2 - Partial comparison
     * @param {Function} [customizer] The function to customize comparisons.
     * @param {Object} [stack] Tracks traversed `value` and `other` objects.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     */
    function baseIsEqual$2(value, other, bitmask, customizer, stack) {
      if (value === other) {
        return true;
      }
      if (value == null || other == null || (!isObjectLike$2(value) && !isObjectLike$2(other))) {
        return value !== value && other !== other;
      }
      return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual$2, stack);
    }

    var _baseIsEqual = baseIsEqual$2;

    var Stack = _Stack,
        baseIsEqual$1 = _baseIsEqual;

    /** Used to compose bitmasks for value comparisons. */
    var COMPARE_PARTIAL_FLAG$1 = 1,
        COMPARE_UNORDERED_FLAG$1 = 2;

    /**
     * The base implementation of `_.isMatch` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property values to match.
     * @param {Array} matchData The property names, values, and compare flags to match.
     * @param {Function} [customizer] The function to customize comparisons.
     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
     */
    function baseIsMatch$1(object, source, matchData, customizer) {
      var index = matchData.length,
          length = index,
          noCustomizer = !customizer;

      if (object == null) {
        return !length;
      }
      object = Object(object);
      while (index--) {
        var data = matchData[index];
        if ((noCustomizer && data[2])
              ? data[1] !== object[data[0]]
              : !(data[0] in object)
            ) {
          return false;
        }
      }
      while (++index < length) {
        data = matchData[index];
        var key = data[0],
            objValue = object[key],
            srcValue = data[1];

        if (noCustomizer && data[2]) {
          if (objValue === undefined && !(key in object)) {
            return false;
          }
        } else {
          var stack = new Stack;
          if (customizer) {
            var result = customizer(objValue, srcValue, key, object, source, stack);
          }
          if (!(result === undefined
                ? baseIsEqual$1(srcValue, objValue, COMPARE_PARTIAL_FLAG$1 | COMPARE_UNORDERED_FLAG$1, customizer, stack)
                : result
              )) {
            return false;
          }
        }
      }
      return true;
    }

    var _baseIsMatch = baseIsMatch$1;

    var isObject$1 = isObject_1;

    /**
     * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` if suitable for strict
     *  equality comparisons, else `false`.
     */
    function isStrictComparable$2(value) {
      return value === value && !isObject$1(value);
    }

    var _isStrictComparable = isStrictComparable$2;

    var isStrictComparable$1 = _isStrictComparable,
        keys$3 = keys_1;

    /**
     * Gets the property names, values, and compare flags of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the match data of `object`.
     */
    function getMatchData$1(object) {
      var result = keys$3(object),
          length = result.length;

      while (length--) {
        var key = result[length],
            value = object[key];

        result[length] = [key, value, isStrictComparable$1(value)];
      }
      return result;
    }

    var _getMatchData = getMatchData$1;

    /**
     * A specialized version of `matchesProperty` for source values suitable
     * for strict equality comparisons, i.e. `===`.
     *
     * @private
     * @param {string} key The key of the property to get.
     * @param {*} srcValue The value to match.
     * @returns {Function} Returns the new spec function.
     */

    function matchesStrictComparable$2(key, srcValue) {
      return function(object) {
        if (object == null) {
          return false;
        }
        return object[key] === srcValue &&
          (srcValue !== undefined || (key in Object(object)));
      };
    }

    var _matchesStrictComparable = matchesStrictComparable$2;

    var baseIsMatch = _baseIsMatch,
        getMatchData = _getMatchData,
        matchesStrictComparable$1 = _matchesStrictComparable;

    /**
     * The base implementation of `_.matches` which doesn't clone `source`.
     *
     * @private
     * @param {Object} source The object of property values to match.
     * @returns {Function} Returns the new spec function.
     */
    function baseMatches$1(source) {
      var matchData = getMatchData(source);
      if (matchData.length == 1 && matchData[0][2]) {
        return matchesStrictComparable$1(matchData[0][0], matchData[0][1]);
      }
      return function(object) {
        return object === source || baseIsMatch(object, source, matchData);
      };
    }

    var _baseMatches = baseMatches$1;

    /**
     * The base implementation of `_.hasIn` without support for deep paths.
     *
     * @private
     * @param {Object} [object] The object to query.
     * @param {Array|string} key The key to check.
     * @returns {boolean} Returns `true` if `key` exists, else `false`.
     */

    function baseHasIn$1(object, key) {
      return object != null && key in Object(object);
    }

    var _baseHasIn = baseHasIn$1;

    var castPath = _castPath,
        isArguments = isArguments_1,
        isArray$5 = isArray_1,
        isIndex = _isIndex,
        isLength = isLength_1,
        toKey$2 = _toKey;

    /**
     * Checks if `path` exists on `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array|string} path The path to check.
     * @param {Function} hasFunc The function to check properties.
     * @returns {boolean} Returns `true` if `path` exists, else `false`.
     */
    function hasPath$1(object, path, hasFunc) {
      path = castPath(path, object);

      var index = -1,
          length = path.length,
          result = false;

      while (++index < length) {
        var key = toKey$2(path[index]);
        if (!(result = object != null && hasFunc(object, key))) {
          break;
        }
        object = object[key];
      }
      if (result || ++index != length) {
        return result;
      }
      length = object == null ? 0 : object.length;
      return !!length && isLength(length) && isIndex(key, length) &&
        (isArray$5(object) || isArguments(object));
    }

    var _hasPath = hasPath$1;

    var baseHasIn = _baseHasIn,
        hasPath = _hasPath;

    /**
     * Checks if `path` is a direct or inherited property of `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path to check.
     * @returns {boolean} Returns `true` if `path` exists, else `false`.
     * @example
     *
     * var object = _.create({ 'a': _.create({ 'b': 2 }) });
     *
     * _.hasIn(object, 'a');
     * // => true
     *
     * _.hasIn(object, 'a.b');
     * // => true
     *
     * _.hasIn(object, ['a', 'b']);
     * // => true
     *
     * _.hasIn(object, 'b');
     * // => false
     */
    function hasIn$1(object, path) {
      return object != null && hasPath(object, path, baseHasIn);
    }

    var hasIn_1 = hasIn$1;

    var baseIsEqual = _baseIsEqual,
        get = get_1,
        hasIn = hasIn_1,
        isKey$1 = _isKey,
        isStrictComparable = _isStrictComparable,
        matchesStrictComparable = _matchesStrictComparable,
        toKey$1 = _toKey;

    /** Used to compose bitmasks for value comparisons. */
    var COMPARE_PARTIAL_FLAG = 1,
        COMPARE_UNORDERED_FLAG = 2;

    /**
     * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
     *
     * @private
     * @param {string} path The path of the property to get.
     * @param {*} srcValue The value to match.
     * @returns {Function} Returns the new spec function.
     */
    function baseMatchesProperty$1(path, srcValue) {
      if (isKey$1(path) && isStrictComparable(srcValue)) {
        return matchesStrictComparable(toKey$1(path), srcValue);
      }
      return function(object) {
        var objValue = get(object, path);
        return (objValue === undefined && objValue === srcValue)
          ? hasIn(object, path)
          : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
      };
    }

    var _baseMatchesProperty = baseMatchesProperty$1;

    /**
     * The base implementation of `_.property` without support for deep paths.
     *
     * @private
     * @param {string} key The key of the property to get.
     * @returns {Function} Returns the new accessor function.
     */

    function baseProperty$1(key) {
      return function(object) {
        return object == null ? undefined : object[key];
      };
    }

    var _baseProperty = baseProperty$1;

    var baseGet = _baseGet;

    /**
     * A specialized version of `baseProperty` which supports deep paths.
     *
     * @private
     * @param {Array|string} path The path of the property to get.
     * @returns {Function} Returns the new accessor function.
     */
    function basePropertyDeep$1(path) {
      return function(object) {
        return baseGet(object, path);
      };
    }

    var _basePropertyDeep = basePropertyDeep$1;

    var baseProperty = _baseProperty,
        basePropertyDeep = _basePropertyDeep,
        isKey = _isKey,
        toKey = _toKey;

    /**
     * Creates a function that returns the value at `path` of a given object.
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Util
     * @param {Array|string} path The path of the property to get.
     * @returns {Function} Returns the new accessor function.
     * @example
     *
     * var objects = [
     *   { 'a': { 'b': 2 } },
     *   { 'a': { 'b': 1 } }
     * ];
     *
     * _.map(objects, _.property('a.b'));
     * // => [2, 1]
     *
     * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
     * // => [1, 2]
     */
    function property$1(path) {
      return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
    }

    var property_1 = property$1;

    var baseMatches = _baseMatches,
        baseMatchesProperty = _baseMatchesProperty,
        identity$1 = identity_1,
        isArray$4 = isArray_1,
        property = property_1;

    /**
     * The base implementation of `_.iteratee`.
     *
     * @private
     * @param {*} [value=_.identity] The value to convert to an iteratee.
     * @returns {Function} Returns the iteratee.
     */
    function baseIteratee$4(value) {
      // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
      // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
      if (typeof value == 'function') {
        return value;
      }
      if (value == null) {
        return identity$1;
      }
      if (typeof value == 'object') {
        return isArray$4(value)
          ? baseMatchesProperty(value[0], value[1])
          : baseMatches(value);
      }
      return property(value);
    }

    var _baseIteratee = baseIteratee$4;

    /** Used to match a single whitespace character. */

    var reWhitespace = /\s/;

    /**
     * Used by `_.trim` and `_.trimEnd` to get the index of the last non-whitespace
     * character of `string`.
     *
     * @private
     * @param {string} string The string to inspect.
     * @returns {number} Returns the index of the last non-whitespace character.
     */
    function trimmedEndIndex$1(string) {
      var index = string.length;

      while (index-- && reWhitespace.test(string.charAt(index))) {}
      return index;
    }

    var _trimmedEndIndex = trimmedEndIndex$1;

    var trimmedEndIndex = _trimmedEndIndex;

    /** Used to match leading whitespace. */
    var reTrimStart = /^\s+/;

    /**
     * The base implementation of `_.trim`.
     *
     * @private
     * @param {string} string The string to trim.
     * @returns {string} Returns the trimmed string.
     */
    function baseTrim$1(string) {
      return string
        ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, '')
        : string;
    }

    var _baseTrim = baseTrim$1;

    var baseTrim = _baseTrim,
        isObject = isObject_1,
        isSymbol = isSymbol_1;

    /** Used as references for various `Number` constants. */
    var NAN = 0 / 0;

    /** Used to detect bad signed hexadecimal string values. */
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

    /** Used to detect binary string values. */
    var reIsBinary = /^0b[01]+$/i;

    /** Used to detect octal string values. */
    var reIsOctal = /^0o[0-7]+$/i;

    /** Built-in method references without a dependency on `root`. */
    var freeParseInt = parseInt;

    /**
     * Converts `value` to a number.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to process.
     * @returns {number} Returns the number.
     * @example
     *
     * _.toNumber(3.2);
     * // => 3.2
     *
     * _.toNumber(Number.MIN_VALUE);
     * // => 5e-324
     *
     * _.toNumber(Infinity);
     * // => Infinity
     *
     * _.toNumber('3.2');
     * // => 3.2
     */
    function toNumber$1(value) {
      if (typeof value == 'number') {
        return value;
      }
      if (isSymbol(value)) {
        return NAN;
      }
      if (isObject(value)) {
        var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
        value = isObject(other) ? (other + '') : other;
      }
      if (typeof value != 'string') {
        return value === 0 ? value : +value;
      }
      value = baseTrim(value);
      var isBinary = reIsBinary.test(value);
      return (isBinary || reIsOctal.test(value))
        ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
        : (reIsBadHex.test(value) ? NAN : +value);
    }

    var toNumber_1 = toNumber$1;

    var toNumber = toNumber_1;

    /** Used as references for various `Number` constants. */
    var INFINITY$1 = 1 / 0,
        MAX_INTEGER = 1.7976931348623157e+308;

    /**
     * Converts `value` to a finite number.
     *
     * @static
     * @memberOf _
     * @since 4.12.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted number.
     * @example
     *
     * _.toFinite(3.2);
     * // => 3.2
     *
     * _.toFinite(Number.MIN_VALUE);
     * // => 5e-324
     *
     * _.toFinite(Infinity);
     * // => 1.7976931348623157e+308
     *
     * _.toFinite('3.2');
     * // => 3.2
     */
    function toFinite$1(value) {
      if (!value) {
        return value === 0 ? value : 0;
      }
      value = toNumber(value);
      if (value === INFINITY$1 || value === -INFINITY$1) {
        var sign = (value < 0 ? -1 : 1);
        return sign * MAX_INTEGER;
      }
      return value === value ? value : 0;
    }

    var toFinite_1 = toFinite$1;

    var toFinite = toFinite_1;

    /**
     * Converts `value` to an integer.
     *
     * **Note:** This method is loosely based on
     * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.toInteger(3.2);
     * // => 3
     *
     * _.toInteger(Number.MIN_VALUE);
     * // => 0
     *
     * _.toInteger(Infinity);
     * // => 1.7976931348623157e+308
     *
     * _.toInteger('3.2');
     * // => 3
     */
    function toInteger$1(value) {
      var result = toFinite(value),
          remainder = result % 1;

      return result === result ? (remainder ? result - remainder : result) : 0;
    }

    var toInteger_1 = toInteger$1;

    var baseFindIndex$1 = _baseFindIndex,
        baseIteratee$3 = _baseIteratee,
        toInteger = toInteger_1;

    /* Built-in method references for those with the same name as other `lodash` methods. */
    var nativeMax = Math.max;

    /**
     * This method is like `_.find` except that it returns the index of the first
     * element `predicate` returns truthy for instead of the element itself.
     *
     * @static
     * @memberOf _
     * @since 1.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param {number} [fromIndex=0] The index to search from.
     * @returns {number} Returns the index of the found element, else `-1`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': false },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': true }
     * ];
     *
     * _.findIndex(users, function(o) { return o.user == 'barney'; });
     * // => 0
     *
     * // The `_.matches` iteratee shorthand.
     * _.findIndex(users, { 'user': 'fred', 'active': false });
     * // => 1
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.findIndex(users, ['active', false]);
     * // => 0
     *
     * // The `_.property` iteratee shorthand.
     * _.findIndex(users, 'active');
     * // => 2
     */
    function findIndex$1(array, predicate, fromIndex) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return -1;
      }
      var index = fromIndex == null ? 0 : toInteger(fromIndex);
      if (index < 0) {
        index = nativeMax(length + index, 0);
      }
      return baseFindIndex$1(array, baseIteratee$3(predicate), index);
    }

    var findIndex_1 = findIndex$1;

    var baseGetTag$1 = _baseGetTag,
        isArray$3 = isArray_1,
        isObjectLike$1 = isObjectLike_1;

    /** `Object#toString` result references. */
    var stringTag = '[object String]';

    /**
     * Checks if `value` is classified as a `String` primitive or object.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a string, else `false`.
     * @example
     *
     * _.isString('abc');
     * // => true
     *
     * _.isString(1);
     * // => false
     */
    function isString(value) {
      return typeof value == 'string' ||
        (!isArray$3(value) && isObjectLike$1(value) && baseGetTag$1(value) == stringTag);
    }

    var isString_1 = isString;

    var cliCursor$3 = {};

    var onetime$2 = {exports: {}};

    var mimicFn$2 = {exports: {}};

    const mimicFn$1 = (to, from) => {
    	for (const prop of Reflect.ownKeys(from)) {
    		Object.defineProperty(to, prop, Object.getOwnPropertyDescriptor(from, prop));
    	}

    	return to;
    };

    mimicFn$2.exports = mimicFn$1;
    // TODO: Remove this for the next major release
    mimicFn$2.exports.default = mimicFn$1;

    const mimicFn = mimicFn$2.exports;

    const calledFunctions = new WeakMap();

    const onetime$1 = (function_, options = {}) => {
    	if (typeof function_ !== 'function') {
    		throw new TypeError('Expected a function');
    	}

    	let returnValue;
    	let callCount = 0;
    	const functionName = function_.displayName || function_.name || '<anonymous>';

    	const onetime = function (...arguments_) {
    		calledFunctions.set(onetime, ++callCount);

    		if (callCount === 1) {
    			returnValue = function_.apply(this, arguments_);
    			function_ = null;
    		} else if (options.throw === true) {
    			throw new Error(`Function \`${functionName}\` can only be called once`);
    		}

    		return returnValue;
    	};

    	mimicFn(onetime, function_);
    	calledFunctions.set(onetime, callCount);

    	return onetime;
    };

    onetime$2.exports = onetime$1;
    // TODO: Remove this for the next major release
    onetime$2.exports.default = onetime$1;

    onetime$2.exports.callCount = function_ => {
    	if (!calledFunctions.has(function_)) {
    		throw new Error(`The given function \`${function_.name}\` is not wrapped by the \`onetime\` package`);
    	}

    	return calledFunctions.get(function_);
    };

    const onetime = onetime$2.exports;
    const signalExit = signalExit$1.exports;

    var restoreCursor = onetime(() => {
    	signalExit(() => {
    		process.stderr.write('\u001B[?25h');
    	}, {alwaysLast: true});
    });

    (function (exports) {
    const restoreCursor$1 = restoreCursor;

    let isHidden = false;

    exports.show = (writableStream = process.stderr) => {
    	if (!writableStream.isTTY) {
    		return;
    	}

    	isHidden = false;
    	writableStream.write('\u001B[?25h');
    };

    exports.hide = (writableStream = process.stderr) => {
    	if (!writableStream.isTTY) {
    		return;
    	}

    	restoreCursor$1();
    	isHidden = true;
    	writableStream.write('\u001B[?25l');
    };

    exports.toggle = (force, writableStream) => {
    	if (force !== undefined) {
    		isHidden = force;
    	}

    	if (isHidden) {
    		exports.show(writableStream);
    	} else {
    		exports.hide(writableStream);
    	}
    };
    }(cliCursor$3));

    var assignValue = _assignValue,
        copyObject = _copyObject,
        createAssigner = _createAssigner,
        isArrayLike$3 = isArrayLike_1,
        isPrototype = _isPrototype,
        keys$2 = keys_1;

    /** Used for built-in method references. */
    var objectProto$1 = Object.prototype;

    /** Used to check objects for own properties. */
    var hasOwnProperty$1 = objectProto$1.hasOwnProperty;

    /**
     * Assigns own enumerable string keyed properties of source objects to the
     * destination object. Source objects are applied from left to right.
     * Subsequent sources overwrite property assignments of previous sources.
     *
     * **Note:** This method mutates `object` and is loosely based on
     * [`Object.assign`](https://mdn.io/Object/assign).
     *
     * @static
     * @memberOf _
     * @since 0.10.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @see _.assignIn
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     * }
     *
     * function Bar() {
     *   this.c = 3;
     * }
     *
     * Foo.prototype.b = 2;
     * Bar.prototype.d = 4;
     *
     * _.assign({ 'a': 0 }, new Foo, new Bar);
     * // => { 'a': 1, 'c': 3 }
     */
    var assign = createAssigner(function(object, source) {
      if (isPrototype(source) || isArrayLike$3(source)) {
        copyObject(source, keys$2(source), object);
        return;
      }
      for (var key in source) {
        if (hasOwnProperty$1.call(source, key)) {
          assignValue(object, key, source[key]);
        }
      }
    });

    var assign_1 = assign;

    var baseRest = _baseRest,
        eq = eq_1,
        isIterateeCall = _isIterateeCall,
        keysIn = keysIn_1;

    /** Used for built-in method references. */
    var objectProto = Object.prototype;

    /** Used to check objects for own properties. */
    var hasOwnProperty = objectProto.hasOwnProperty;

    /**
     * Assigns own and inherited enumerable string keyed properties of source
     * objects to the destination object for all destination properties that
     * resolve to `undefined`. Source objects are applied from left to right.
     * Once a property is set, additional values of the same property are ignored.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @see _.defaultsDeep
     * @example
     *
     * _.defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
     * // => { 'a': 1, 'b': 2 }
     */
    var defaults$2 = baseRest(function(object, sources) {
      object = Object(object);

      var index = -1;
      var length = sources.length;
      var guard = length > 2 ? sources[2] : undefined;

      if (guard && isIterateeCall(sources[0], sources[1], guard)) {
        length = 1;
      }

      while (++index < length) {
        var source = sources[index];
        var props = keysIn(source);
        var propsIndex = -1;
        var propsLength = props.length;

        while (++propsIndex < propsLength) {
          var key = props[propsIndex];
          var value = object[key];

          if (value === undefined ||
              (eq(value, objectProto[key]) && !hasOwnProperty.call(object, key))) {
            object[key] = source[key];
          }
        }
      }

      return object;
    });

    var defaults_1 = defaults$2;

    /**
     * Creates a base function for methods like `_.forIn` and `_.forOwn`.
     *
     * @private
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new base function.
     */

    function createBaseFor$1(fromRight) {
      return function(object, iteratee, keysFunc) {
        var index = -1,
            iterable = Object(object),
            props = keysFunc(object),
            length = props.length;

        while (length--) {
          var key = props[fromRight ? length : ++index];
          if (iteratee(iterable[key], key, iterable) === false) {
            break;
          }
        }
        return object;
      };
    }

    var _createBaseFor = createBaseFor$1;

    var createBaseFor = _createBaseFor;

    /**
     * The base implementation of `baseForOwn` which iterates over `object`
     * properties returned by `keysFunc` and invokes `iteratee` for each property.
     * Iteratee functions may exit iteration early by explicitly returning `false`.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {Function} keysFunc The function to get the keys of `object`.
     * @returns {Object} Returns `object`.
     */
    var baseFor$1 = createBaseFor();

    var _baseFor = baseFor$1;

    var baseFor = _baseFor,
        keys$1 = keys_1;

    /**
     * The base implementation of `_.forOwn` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Object} Returns `object`.
     */
    function baseForOwn$1(object, iteratee) {
      return object && baseFor(object, iteratee, keys$1);
    }

    var _baseForOwn = baseForOwn$1;

    var isArrayLike$2 = isArrayLike_1;

    /**
     * Creates a `baseEach` or `baseEachRight` function.
     *
     * @private
     * @param {Function} eachFunc The function to iterate over a collection.
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new base function.
     */
    function createBaseEach$1(eachFunc, fromRight) {
      return function(collection, iteratee) {
        if (collection == null) {
          return collection;
        }
        if (!isArrayLike$2(collection)) {
          return eachFunc(collection, iteratee);
        }
        var length = collection.length,
            index = fromRight ? length : -1,
            iterable = Object(collection);

        while ((fromRight ? index-- : ++index < length)) {
          if (iteratee(iterable[index], index, iterable) === false) {
            break;
          }
        }
        return collection;
      };
    }

    var _createBaseEach = createBaseEach$1;

    var baseForOwn = _baseForOwn,
        createBaseEach = _createBaseEach;

    /**
     * The base implementation of `_.forEach` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array|Object} Returns `collection`.
     */
    var baseEach$2 = createBaseEach(baseForOwn);

    var _baseEach = baseEach$2;

    var baseEach$1 = _baseEach;

    /**
     * The base implementation of `_.filter` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {Array} Returns the new filtered array.
     */
    function baseFilter$1(collection, predicate) {
      var result = [];
      baseEach$1(collection, function(value, index, collection) {
        if (predicate(value, index, collection)) {
          result.push(value);
        }
      });
      return result;
    }

    var _baseFilter = baseFilter$1;

    var arrayFilter = _arrayFilter,
        baseFilter = _baseFilter,
        baseIteratee$2 = _baseIteratee,
        isArray$2 = isArray_1;

    /**
     * Iterates over elements of `collection`, returning an array of all elements
     * `predicate` returns truthy for. The predicate is invoked with three
     * arguments: (value, index|key, collection).
     *
     * **Note:** Unlike `_.remove`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new filtered array.
     * @see _.reject
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': true },
     *   { 'user': 'fred',   'age': 40, 'active': false }
     * ];
     *
     * _.filter(users, function(o) { return !o.active; });
     * // => objects for ['fred']
     *
     * // The `_.matches` iteratee shorthand.
     * _.filter(users, { 'age': 36, 'active': true });
     * // => objects for ['barney']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.filter(users, ['active', false]);
     * // => objects for ['fred']
     *
     * // The `_.property` iteratee shorthand.
     * _.filter(users, 'active');
     * // => objects for ['barney']
     *
     * // Combining several predicates using `_.overEvery` or `_.overSome`.
     * _.filter(users, _.overSome([{ 'age': 36 }, ['age', 40]]));
     * // => objects for ['fred', 'barney']
     */
    function filter$3(collection, predicate) {
      var func = isArray$2(collection) ? arrayFilter : baseFilter;
      return func(collection, baseIteratee$2(predicate));
    }

    var filter_1 = filter$3;

    var baseEach = _baseEach,
        isArrayLike$1 = isArrayLike_1;

    /**
     * The base implementation of `_.map` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns the new mapped array.
     */
    function baseMap$1(collection, iteratee) {
      var index = -1,
          result = isArrayLike$1(collection) ? Array(collection.length) : [];

      baseEach(collection, function(value, key, collection) {
        result[++index] = iteratee(value, key, collection);
      });
      return result;
    }

    var _baseMap = baseMap$1;

    var arrayMap = _arrayMap,
        baseIteratee$1 = _baseIteratee,
        baseMap = _baseMap,
        isArray$1 = isArray_1;

    /**
     * Creates an array of values by running each element in `collection` thru
     * `iteratee`. The iteratee is invoked with three arguments:
     * (value, index|key, collection).
     *
     * Many lodash methods are guarded to work as iteratees for methods like
     * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.
     *
     * The guarded methods are:
     * `ary`, `chunk`, `curry`, `curryRight`, `drop`, `dropRight`, `every`,
     * `fill`, `invert`, `parseInt`, `random`, `range`, `rangeRight`, `repeat`,
     * `sampleSize`, `slice`, `some`, `sortBy`, `split`, `take`, `takeRight`,
     * `template`, `trim`, `trimEnd`, `trimStart`, and `words`
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new mapped array.
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * _.map([4, 8], square);
     * // => [16, 64]
     *
     * _.map({ 'a': 4, 'b': 8 }, square);
     * // => [16, 64] (iteration order is not guaranteed)
     *
     * var users = [
     *   { 'user': 'barney' },
     *   { 'user': 'fred' }
     * ];
     *
     * // The `_.property` iteratee shorthand.
     * _.map(users, 'user');
     * // => ['barney', 'fred']
     */
    function map$7(collection, iteratee) {
      var func = isArray$1(collection) ? arrayMap : baseMap;
      return func(collection, baseIteratee$1(iteratee));
    }

    var map_1 = map$7;

    var baseIteratee = _baseIteratee,
        isArrayLike = isArrayLike_1,
        keys = keys_1;

    /**
     * Creates a `_.find` or `_.findLast` function.
     *
     * @private
     * @param {Function} findIndexFunc The function to find the collection index.
     * @returns {Function} Returns the new find function.
     */
    function createFind$1(findIndexFunc) {
      return function(collection, predicate, fromIndex) {
        var iterable = Object(collection);
        if (!isArrayLike(collection)) {
          var iteratee = baseIteratee(predicate);
          collection = keys(collection);
          predicate = function(key) { return iteratee(iterable[key], key, iterable); };
        }
        var index = findIndexFunc(collection, predicate, fromIndex);
        return index > -1 ? iterable[iteratee ? collection[index] : index] : undefined;
      };
    }

    var _createFind = createFind$1;

    var createFind = _createFind,
        findIndex = findIndex_1;

    /**
     * Iterates over elements of `collection`, returning the first element
     * `predicate` returns truthy for. The predicate is invoked with three
     * arguments: (value, index|key, collection).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param {number} [fromIndex=0] The index to search from.
     * @returns {*} Returns the matched element, else `undefined`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'age': 36, 'active': true },
     *   { 'user': 'fred',    'age': 40, 'active': false },
     *   { 'user': 'pebbles', 'age': 1,  'active': true }
     * ];
     *
     * _.find(users, function(o) { return o.age < 40; });
     * // => object for 'barney'
     *
     * // The `_.matches` iteratee shorthand.
     * _.find(users, { 'age': 1, 'active': true });
     * // => object for 'pebbles'
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.find(users, ['active', false]);
     * // => object for 'fred'
     *
     * // The `_.property` iteratee shorthand.
     * _.find(users, 'active');
     * // => object for 'barney'
     */
    var find = createFind(findIndex);

    var find_1 = find;

    const _$9 = {
      isString: isString_1,
      isNumber: isNumber_1,
      extend: extend$1,
      isFunction: isFunction_1,
    };

    /**
     * Choice object
     * Normalize input as choice object
     * @constructor
     * @param {Number|String|Object} val  Choice value. If an object is passed, it should contains
     *                                    at least one of `value` or `name` property
     */

    var choice = class Choice {
      constructor(val, answers) {
        // Don't process Choice and Separator object
        if (val instanceof Choice || val.type === 'separator') {
          // eslint-disable-next-line no-constructor-return
          return val;
        }

        if (_$9.isString(val) || _$9.isNumber(val)) {
          this.name = String(val);
          this.value = val;
          this.short = String(val);
        } else {
          _$9.extend(this, val, {
            name: val.name || val.value,
            value: 'value' in val ? val.value : val.name,
            short: val.short || val.name || val.value,
          });
        }

        if (_$9.isFunction(val.disabled)) {
          this.disabled = val.disabled(answers);
        } else {
          this.disabled = val.disabled;
        }
      }
    };

    const assert$2 = require$$5__default["default"];
    const _$8 = {
      isNumber: isNumber_1,
      filter: filter_1,
      map: map_1,
      find: find_1,
    };
    const Separator$2 = separator;
    const Choice = choice;

    /**
     * Choices collection
     * Collection of multiple `choice` object
     * @constructor
     * @param {Array} choices  All `choice` to keep in the collection
     */

    var choices = class Choices {
      constructor(choices, answers) {
        this.choices = choices.map((val) => {
          if (val.type === 'separator') {
            if (!(val instanceof Separator$2)) {
              val = new Separator$2(val.line);
            }

            return val;
          }

          return new Choice(val, answers);
        });

        this.realChoices = this.choices
          .filter(Separator$2.exclude)
          .filter((item) => !item.disabled);

        Object.defineProperty(this, 'length', {
          get() {
            return this.choices.length;
          },
          set(val) {
            this.choices.length = val;
          },
        });

        Object.defineProperty(this, 'realLength', {
          get() {
            return this.realChoices.length;
          },
          set() {
            throw new Error('Cannot set `realLength` of a Choices collection');
          },
        });
      }

      /**
       * Get a valid choice from the collection
       * @param  {Number} selector  The selected choice index
       * @return {Choice|Undefined} Return the matched choice or undefined
       */

      getChoice(selector) {
        assert$2(_$8.isNumber(selector));
        return this.realChoices[selector];
      }

      /**
       * Get a raw element from the collection
       * @param  {Number} selector  The selected index value
       * @return {Choice|Undefined} Return the matched choice or undefined
       */

      get(selector) {
        assert$2(_$8.isNumber(selector));
        return this.choices[selector];
      }

      /**
       * Match the valid choices against a where clause
       * @param  {Object} whereClause Lodash `where` clause
       * @return {Array}              Matching choices or empty array
       */

      where(whereClause) {
        return _$8.filter(this.realChoices, whereClause);
      }

      /**
       * Pluck a particular key from the choices
       * @param  {String} propertyName Property name to select
       * @return {Array}               Selected properties
       */

      pluck(propertyName) {
        return _$8.map(this.realChoices, propertyName);
      }

      // Expose usual Array methods
      indexOf(...args) {
        return this.choices.indexOf(...args);
      }

      forEach(...args) {
        return this.choices.forEach(...args);
      }

      filter(...args) {
        return this.choices.filter(...args);
      }

      reduce(...args) {
        return this.choices.reduce(...args);
      }

      find(func) {
        return _$8.find(this.choices, func);
      }

      push(...args) {
        const objs = _$8.map(args, (val) => new Choice(val));
        this.choices.push(...objs);
        this.realChoices = this.choices
          .filter(Separator$2.exclude)
          .filter((item) => !item.disabled);
        return this.choices;
      }
    };

    var cliWidth$1 = {exports: {}};

    (function (module, exports) {

    module.exports = cliWidth;

    function normalizeOpts(options) {
      let defaultOpts = {
        defaultWidth: 0,
        output: process.stdout,
        tty: require$$1__default$2["default"],
      };

      if (!options) {
        return defaultOpts;
      }

      Object.keys(defaultOpts).forEach(function (key) {
        if (!options[key]) {
          options[key] = defaultOpts[key];
        }
      });

      return options;
    }

    function cliWidth(options) {
      let opts = normalizeOpts(options);

      if (opts.output.getWindowSize) {
        return opts.output.getWindowSize()[0] || opts.defaultWidth;
      }

      if (opts.tty.getWindowSize) {
        return opts.tty.getWindowSize()[1] || opts.defaultWidth;
      }

      if (opts.output.columns) {
        return opts.output.columns;
      }

      if (process.env.CLI_WIDTH) {
        let width = parseInt(process.env.CLI_WIDTH, 10);

        if (!isNaN(width) && width !== 0) {
          return width;
        }
      }

      return opts.defaultWidth;
    }
    }(cliWidth$1));

    var ansiRegex$1 = ({onlyFirst = false} = {}) => {
    	const pattern = [
    		'[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)',
    		'(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))'
    	].join('|');

    	return new RegExp(pattern, onlyFirst ? undefined : 'g');
    };

    const ansiRegex = ansiRegex$1;

    var stripAnsi$3 = string => typeof string === 'string' ? string.replace(ansiRegex(), '') : string;

    var stringWidth$2 = {exports: {}};

    var isFullwidthCodePoint$2 = {exports: {}};

    /* eslint-disable yoda */

    const isFullwidthCodePoint$1 = codePoint => {
    	if (Number.isNaN(codePoint)) {
    		return false;
    	}

    	// Code points are derived from:
    	// http://www.unix.org/Public/UNIDATA/EastAsianWidth.txt
    	if (
    		codePoint >= 0x1100 && (
    			codePoint <= 0x115F || // Hangul Jamo
    			codePoint === 0x2329 || // LEFT-POINTING ANGLE BRACKET
    			codePoint === 0x232A || // RIGHT-POINTING ANGLE BRACKET
    			// CJK Radicals Supplement .. Enclosed CJK Letters and Months
    			(0x2E80 <= codePoint && codePoint <= 0x3247 && codePoint !== 0x303F) ||
    			// Enclosed CJK Letters and Months .. CJK Unified Ideographs Extension A
    			(0x3250 <= codePoint && codePoint <= 0x4DBF) ||
    			// CJK Unified Ideographs .. Yi Radicals
    			(0x4E00 <= codePoint && codePoint <= 0xA4C6) ||
    			// Hangul Jamo Extended-A
    			(0xA960 <= codePoint && codePoint <= 0xA97C) ||
    			// Hangul Syllables
    			(0xAC00 <= codePoint && codePoint <= 0xD7A3) ||
    			// CJK Compatibility Ideographs
    			(0xF900 <= codePoint && codePoint <= 0xFAFF) ||
    			// Vertical Forms
    			(0xFE10 <= codePoint && codePoint <= 0xFE19) ||
    			// CJK Compatibility Forms .. Small Form Variants
    			(0xFE30 <= codePoint && codePoint <= 0xFE6B) ||
    			// Halfwidth and Fullwidth Forms
    			(0xFF01 <= codePoint && codePoint <= 0xFF60) ||
    			(0xFFE0 <= codePoint && codePoint <= 0xFFE6) ||
    			// Kana Supplement
    			(0x1B000 <= codePoint && codePoint <= 0x1B001) ||
    			// Enclosed Ideographic Supplement
    			(0x1F200 <= codePoint && codePoint <= 0x1F251) ||
    			// CJK Unified Ideographs Extension B .. Tertiary Ideographic Plane
    			(0x20000 <= codePoint && codePoint <= 0x3FFFD)
    		)
    	) {
    		return true;
    	}

    	return false;
    };

    isFullwidthCodePoint$2.exports = isFullwidthCodePoint$1;
    isFullwidthCodePoint$2.exports.default = isFullwidthCodePoint$1;

    var emojiRegex$1 = function () {
      // https://mths.be/emoji
      return /\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62(?:\uDB40\uDC65\uDB40\uDC6E\uDB40\uDC67|\uDB40\uDC73\uDB40\uDC63\uDB40\uDC74|\uDB40\uDC77\uDB40\uDC6C\uDB40\uDC73)\uDB40\uDC7F|\uD83D\uDC68(?:\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68\uD83C\uDFFB|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFE])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83D\uDC68|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D[\uDC66\uDC67])|[\u2695\u2696\u2708]\uFE0F|\uD83D[\uDC66\uDC67]|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|(?:\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708])\uFE0F|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C[\uDFFB-\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFB\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)\uD83C\uDFFB|\uD83E\uDDD1(?:\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])|\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1)|(?:\uD83E\uDDD1\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFE])|(?:\uD83E\uDDD1\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)(?:\uD83C[\uDFFB\uDFFC])|\uD83D\uDC69(?:\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFC-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|(?:\uD83E\uDDD1\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)(?:\uD83C[\uDFFB-\uDFFD])|\uD83D\uDC69\u200D\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8|\uD83D\uDC69(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|(?:(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)\uFE0F|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF])\u200D[\u2640\u2642]|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD6-\uDDDD])(?:(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|\u200D[\u2640\u2642])|\uD83C\uDFF4\u200D\u2620)\uFE0F|\uD83D\uDC69\u200D\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08|\uD83D\uDC15\u200D\uD83E\uDDBA|\uD83D\uDC69\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC67|\uD83C\uDDFD\uD83C\uDDF0|\uD83C\uDDF4\uD83C\uDDF2|\uD83C\uDDF6\uD83C\uDDE6|[#\*0-9]\uFE0F\u20E3|\uD83C\uDDE7(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF])|\uD83C\uDDF9(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF])|\uD83C\uDDEA(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA])|\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])|\uD83C\uDDF7(?:\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC])|\uD83D\uDC69(?:\uD83C[\uDFFB-\uDFFF])|\uD83C\uDDF2(?:\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF])|\uD83C\uDDE6(?:\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF])|\uD83C\uDDF0(?:\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF])|\uD83C\uDDED(?:\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA])|\uD83C\uDDE9(?:\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF])|\uD83C\uDDFE(?:\uD83C[\uDDEA\uDDF9])|\uD83C\uDDEC(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE])|\uD83C\uDDF8(?:\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF])|\uD83C\uDDEB(?:\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7])|\uD83C\uDDF5(?:\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE])|\uD83C\uDDFB(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA])|\uD83C\uDDF3(?:\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF])|\uD83C\uDDE8(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF])|\uD83C\uDDF1(?:\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE])|\uD83C\uDDFF(?:\uD83C[\uDDE6\uDDF2\uDDFC])|\uD83C\uDDFC(?:\uD83C[\uDDEB\uDDF8])|\uD83C\uDDFA(?:\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF])|\uD83C\uDDEE(?:\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9])|\uD83C\uDDEF(?:\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5])|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u270A-\u270D]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC70\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDCAA\uDD74\uDD7A\uDD90\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD36\uDDB5\uDDB6\uDDBB\uDDD2-\uDDD5])(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u270A\u270B\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF93\uDFA0-\uDFCA\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF4\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC3E\uDC40\uDC42-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDD7A\uDD95\uDD96\uDDA4\uDDFB-\uDE4F\uDE80-\uDEC5\uDECC\uDED0-\uDED2\uDED5\uDEEB\uDEEC\uDEF4-\uDEFA\uDFE0-\uDFEB]|\uD83E[\uDD0D-\uDD3A\uDD3C-\uDD45\uDD47-\uDD71\uDD73-\uDD76\uDD7A-\uDDA2\uDDA5-\uDDAA\uDDAE-\uDDCA\uDDCD-\uDDFF\uDE70-\uDE73\uDE78-\uDE7A\uDE80-\uDE82\uDE90-\uDE95])|(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDED5\uDEE0-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEFA\uDFE0-\uDFEB]|\uD83E[\uDD0D-\uDD3A\uDD3C-\uDD45\uDD47-\uDD71\uDD73-\uDD76\uDD7A-\uDDA2\uDDA5-\uDDAA\uDDAE-\uDDCA\uDDCD-\uDDFF\uDE70-\uDE73\uDE78-\uDE7A\uDE80-\uDE82\uDE90-\uDE95])\uFE0F|(?:[\u261D\u26F9\u270A-\u270D]|\uD83C[\uDF85\uDFC2-\uDFC4\uDFC7\uDFCA-\uDFCC]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66-\uDC78\uDC7C\uDC81-\uDC83\uDC85-\uDC87\uDC8F\uDC91\uDCAA\uDD74\uDD75\uDD7A\uDD90\uDD95\uDD96\uDE45-\uDE47\uDE4B-\uDE4F\uDEA3\uDEB4-\uDEB6\uDEC0\uDECC]|\uD83E[\uDD0F\uDD18-\uDD1F\uDD26\uDD30-\uDD39\uDD3C-\uDD3E\uDDB5\uDDB6\uDDB8\uDDB9\uDDBB\uDDCD-\uDDCF\uDDD1-\uDDDD])/g;
    };

    const stripAnsi$2 = stripAnsi$3;
    const isFullwidthCodePoint = isFullwidthCodePoint$2.exports;
    const emojiRegex = emojiRegex$1;

    const stringWidth$1 = string => {
    	if (typeof string !== 'string' || string.length === 0) {
    		return 0;
    	}

    	string = stripAnsi$2(string);

    	if (string.length === 0) {
    		return 0;
    	}

    	string = string.replace(emojiRegex(), '  ');

    	let width = 0;

    	for (let i = 0; i < string.length; i++) {
    		const code = string.codePointAt(i);

    		// Ignore control characters
    		if (code <= 0x1F || (code >= 0x7F && code <= 0x9F)) {
    			continue;
    		}

    		// Ignore combining characters
    		if (code >= 0x300 && code <= 0x36F) {
    			continue;
    		}

    		// Surrogates
    		if (code > 0xFFFF) {
    			i++;
    		}

    		width += isFullwidthCodePoint(code) ? 2 : 1;
    	}

    	return width;
    };

    stringWidth$2.exports = stringWidth$1;
    // TODO: remove this in the next major version
    stringWidth$2.exports.default = stringWidth$1;

    var ora$1 = {exports: {}};

    var dots = {
    	interval: 80,
    	frames: [
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		""
    	]
    };
    var dots2 = {
    	interval: 80,
    	frames: [
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		""
    	]
    };
    var dots3 = {
    	interval: 80,
    	frames: [
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		""
    	]
    };
    var dots4 = {
    	interval: 80,
    	frames: [
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		""
    	]
    };
    var dots5 = {
    	interval: 80,
    	frames: [
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		""
    	]
    };
    var dots6 = {
    	interval: 80,
    	frames: [
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		""
    	]
    };
    var dots7 = {
    	interval: 80,
    	frames: [
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		""
    	]
    };
    var dots8 = {
    	interval: 80,
    	frames: [
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		""
    	]
    };
    var dots9 = {
    	interval: 80,
    	frames: [
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		""
    	]
    };
    var dots10 = {
    	interval: 80,
    	frames: [
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		""
    	]
    };
    var dots11 = {
    	interval: 100,
    	frames: [
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		""
    	]
    };
    var dots12 = {
    	interval: 80,
    	frames: [
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		""
    	]
    };
    var dots8Bit = {
    	interval: 80,
    	frames: [
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		""
    	]
    };
    var line = {
    	interval: 130,
    	frames: [
    		"-",
    		"\\",
    		"|",
    		"/"
    	]
    };
    var line2 = {
    	interval: 100,
    	frames: [
    		"",
    		"-",
    		"",
    		"",
    		"",
    		"-"
    	]
    };
    var pipe = {
    	interval: 100,
    	frames: [
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		""
    	]
    };
    var simpleDots = {
    	interval: 400,
    	frames: [
    		".  ",
    		".. ",
    		"...",
    		"   "
    	]
    };
    var simpleDotsScrolling = {
    	interval: 200,
    	frames: [
    		".  ",
    		".. ",
    		"...",
    		" ..",
    		"  .",
    		"   "
    	]
    };
    var star$1 = {
    	interval: 70,
    	frames: [
    		"",
    		"",
    		"",
    		"",
    		"",
    		""
    	]
    };
    var star2 = {
    	interval: 80,
    	frames: [
    		"+",
    		"x",
    		"*"
    	]
    };
    var flip = {
    	interval: 70,
    	frames: [
    		"_",
    		"_",
    		"_",
    		"-",
    		"`",
    		"`",
    		"'",
    		"",
    		"-",
    		"_",
    		"_",
    		"_"
    	]
    };
    var hamburger = {
    	interval: 100,
    	frames: [
    		"",
    		"",
    		""
    	]
    };
    var growVertical = {
    	interval: 120,
    	frames: [
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		""
    	]
    };
    var growHorizontal = {
    	interval: 120,
    	frames: [
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		""
    	]
    };
    var balloon = {
    	interval: 140,
    	frames: [
    		" ",
    		".",
    		"o",
    		"O",
    		"@",
    		"*",
    		" "
    	]
    };
    var balloon2 = {
    	interval: 120,
    	frames: [
    		".",
    		"o",
    		"O",
    		"",
    		"O",
    		"o",
    		"."
    	]
    };
    var noise = {
    	interval: 100,
    	frames: [
    		"",
    		"",
    		""
    	]
    };
    var bounce = {
    	interval: 120,
    	frames: [
    		"",
    		"",
    		"",
    		""
    	]
    };
    var boxBounce = {
    	interval: 120,
    	frames: [
    		"",
    		"",
    		"",
    		""
    	]
    };
    var boxBounce2 = {
    	interval: 100,
    	frames: [
    		"",
    		"",
    		"",
    		""
    	]
    };
    var triangle = {
    	interval: 50,
    	frames: [
    		"",
    		"",
    		"",
    		""
    	]
    };
    var arc = {
    	interval: 100,
    	frames: [
    		"",
    		"",
    		"",
    		"",
    		"",
    		""
    	]
    };
    var circle = {
    	interval: 120,
    	frames: [
    		"",
    		"",
    		""
    	]
    };
    var squareCorners = {
    	interval: 180,
    	frames: [
    		"",
    		"",
    		"",
    		""
    	]
    };
    var circleQuarters = {
    	interval: 120,
    	frames: [
    		"",
    		"",
    		"",
    		""
    	]
    };
    var circleHalves = {
    	interval: 50,
    	frames: [
    		"",
    		"",
    		"",
    		""
    	]
    };
    var squish = {
    	interval: 100,
    	frames: [
    		"",
    		""
    	]
    };
    var toggle = {
    	interval: 250,
    	frames: [
    		"",
    		""
    	]
    };
    var toggle2 = {
    	interval: 80,
    	frames: [
    		"",
    		""
    	]
    };
    var toggle3 = {
    	interval: 120,
    	frames: [
    		"",
    		""
    	]
    };
    var toggle4 = {
    	interval: 100,
    	frames: [
    		"",
    		"",
    		"",
    		""
    	]
    };
    var toggle5 = {
    	interval: 100,
    	frames: [
    		"",
    		""
    	]
    };
    var toggle6 = {
    	interval: 300,
    	frames: [
    		"",
    		""
    	]
    };
    var toggle7 = {
    	interval: 80,
    	frames: [
    		"",
    		""
    	]
    };
    var toggle8 = {
    	interval: 100,
    	frames: [
    		"",
    		""
    	]
    };
    var toggle9 = {
    	interval: 100,
    	frames: [
    		"",
    		""
    	]
    };
    var toggle10 = {
    	interval: 100,
    	frames: [
    		"",
    		"",
    		""
    	]
    };
    var toggle11 = {
    	interval: 50,
    	frames: [
    		"",
    		""
    	]
    };
    var toggle12 = {
    	interval: 120,
    	frames: [
    		"",
    		""
    	]
    };
    var toggle13 = {
    	interval: 80,
    	frames: [
    		"=",
    		"*",
    		"-"
    	]
    };
    var arrow = {
    	interval: 100,
    	frames: [
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		""
    	]
    };
    var arrow2 = {
    	interval: 80,
    	frames: [
    		" ",
    		" ",
    		" ",
    		" ",
    		" ",
    		" ",
    		" ",
    		" "
    	]
    };
    var arrow3 = {
    	interval: 120,
    	frames: [
    		"",
    		"",
    		"",
    		"",
    		"",
    		""
    	]
    };
    var bouncingBar = {
    	interval: 80,
    	frames: [
    		"[    ]",
    		"[=   ]",
    		"[==  ]",
    		"[=== ]",
    		"[ ===]",
    		"[  ==]",
    		"[   =]",
    		"[    ]",
    		"[   =]",
    		"[  ==]",
    		"[ ===]",
    		"[====]",
    		"[=== ]",
    		"[==  ]",
    		"[=   ]"
    	]
    };
    var bouncingBall = {
    	interval: 80,
    	frames: [
    		"(     )",
    		"(     )",
    		"(     )",
    		"(     )",
    		"(     )",
    		"(     )",
    		"(     )",
    		"(     )",
    		"(     )",
    		"(     )"
    	]
    };
    var smiley = {
    	interval: 200,
    	frames: [
    		" ",
    		" "
    	]
    };
    var monkey = {
    	interval: 300,
    	frames: [
    		" ",
    		" ",
    		" ",
    		" "
    	]
    };
    var hearts = {
    	interval: 100,
    	frames: [
    		" ",
    		" ",
    		" ",
    		" ",
    		" "
    	]
    };
    var clock = {
    	interval: 100,
    	frames: [
    		" ",
    		" ",
    		" ",
    		" ",
    		" ",
    		" ",
    		" ",
    		" ",
    		" ",
    		" ",
    		" ",
    		" "
    	]
    };
    var earth = {
    	interval: 180,
    	frames: [
    		" ",
    		" ",
    		" "
    	]
    };
    var material = {
    	interval: 17,
    	frames: [
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		""
    	]
    };
    var moon = {
    	interval: 80,
    	frames: [
    		" ",
    		" ",
    		" ",
    		" ",
    		" ",
    		" ",
    		" ",
    		" "
    	]
    };
    var runner = {
    	interval: 140,
    	frames: [
    		" ",
    		" "
    	]
    };
    var pong = {
    	interval: 80,
    	frames: [
    		"       ",
    		"       ",
    		"       ",
    		"       ",
    		"       ",
    		"       ",
    		"       ",
    		"       ",
    		"       ",
    		"       ",
    		"       ",
    		"       ",
    		"       ",
    		"       ",
    		"       ",
    		"       ",
    		"       ",
    		"       ",
    		"       ",
    		"       ",
    		"       ",
    		"       ",
    		"       ",
    		"       ",
    		"       ",
    		"       ",
    		"       ",
    		"       ",
    		"       ",
    		"       "
    	]
    };
    var shark = {
    	interval: 120,
    	frames: [
    		"|\\____________",
    		"_|\\___________",
    		"__|\\__________",
    		"___|\\_________",
    		"____|\\________",
    		"_____|\\_______",
    		"______|\\______",
    		"_______|\\_____",
    		"________|\\____",
    		"_________|\\___",
    		"__________|\\__",
    		"___________|\\_",
    		"____________|\\",
    		"____________/|",
    		"___________/|_",
    		"__________/|__",
    		"_________/|___",
    		"________/|____",
    		"_______/|_____",
    		"______/|______",
    		"_____/|_______",
    		"____/|________",
    		"___/|_________",
    		"__/|__________",
    		"_/|___________",
    		"/|____________"
    	]
    };
    var dqpb = {
    	interval: 100,
    	frames: [
    		"d",
    		"q",
    		"p",
    		"b"
    	]
    };
    var weather = {
    	interval: 100,
    	frames: [
    		" ",
    		" ",
    		" ",
    		" ",
    		" ",
    		" ",
    		" ",
    		" ",
    		" ",
    		" ",
    		" ",
    		" ",
    		" ",
    		" ",
    		" ",
    		" ",
    		" ",
    		" ",
    		" ",
    		" ",
    		" ",
    		" ",
    		" "
    	]
    };
    var christmas = {
    	interval: 400,
    	frames: [
    		"",
    		""
    	]
    };
    var grenade = {
    	interval: 80,
    	frames: [
    		"  ",
    		"  ",
    		"  ",
    		"  ",
    		"  ",
    		"  ",
    		"  |",
    		"  ",
    		"  ",
    		"  ",
    		"  ",
    		"   ",
    		"   ",
    		"   "
    	]
    };
    var point = {
    	interval: 125,
    	frames: [
    		"",
    		"",
    		"",
    		"",
    		""
    	]
    };
    var layer = {
    	interval: 150,
    	frames: [
    		"-",
    		"=",
    		""
    	]
    };
    var betaWave = {
    	interval: 80,
    	frames: [
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		""
    	]
    };
    var fingerDance = {
    	interval: 160,
    	frames: [
    		" ",
    		" ",
    		" ",
    		" ",
    		" ",
    		" "
    	]
    };
    var fistBump = {
    	interval: 80,
    	frames: [
    		" ",
    		" ",
    		" ",
    		" ",
    		" ",
    		" ",
    		" "
    	]
    };
    var soccerHeader = {
    	interval: 80,
    	frames: [
    		"         ",
    		"         ",
    		"         ",
    		"         ",
    		"         ",
    		"         ",
    		"         ",
    		"         ",
    		"         ",
    		"         ",
    		"         ",
    		"         "
    	]
    };
    var mindblown = {
    	interval: 160,
    	frames: [
    		" ",
    		" ",
    		" ",
    		" ",
    		" ",
    		" ",
    		" ",
    		" ",
    		" ",
    		" ",
    		" ",
    		" ",
    		" ",
    		" "
    	]
    };
    var speaker = {
    	interval: 160,
    	frames: [
    		" ",
    		" ",
    		" ",
    		" "
    	]
    };
    var orangePulse = {
    	interval: 100,
    	frames: [
    		" ",
    		" ",
    		" ",
    		" ",
    		" "
    	]
    };
    var bluePulse = {
    	interval: 100,
    	frames: [
    		" ",
    		" ",
    		" ",
    		" ",
    		" "
    	]
    };
    var orangeBluePulse = {
    	interval: 100,
    	frames: [
    		" ",
    		" ",
    		" ",
    		" ",
    		" ",
    		" ",
    		" ",
    		" ",
    		" ",
    		" "
    	]
    };
    var timeTravel = {
    	interval: 100,
    	frames: [
    		" ",
    		" ",
    		" ",
    		" ",
    		" ",
    		" ",
    		" ",
    		" ",
    		" ",
    		" ",
    		" ",
    		" "
    	]
    };
    var aesthetic = {
    	interval: 80,
    	frames: [
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		"",
    		""
    	]
    };
    var require$$0$1 = {
    	dots: dots,
    	dots2: dots2,
    	dots3: dots3,
    	dots4: dots4,
    	dots5: dots5,
    	dots6: dots6,
    	dots7: dots7,
    	dots8: dots8,
    	dots9: dots9,
    	dots10: dots10,
    	dots11: dots11,
    	dots12: dots12,
    	dots8Bit: dots8Bit,
    	line: line,
    	line2: line2,
    	pipe: pipe,
    	simpleDots: simpleDots,
    	simpleDotsScrolling: simpleDotsScrolling,
    	star: star$1,
    	star2: star2,
    	flip: flip,
    	hamburger: hamburger,
    	growVertical: growVertical,
    	growHorizontal: growHorizontal,
    	balloon: balloon,
    	balloon2: balloon2,
    	noise: noise,
    	bounce: bounce,
    	boxBounce: boxBounce,
    	boxBounce2: boxBounce2,
    	triangle: triangle,
    	arc: arc,
    	circle: circle,
    	squareCorners: squareCorners,
    	circleQuarters: circleQuarters,
    	circleHalves: circleHalves,
    	squish: squish,
    	toggle: toggle,
    	toggle2: toggle2,
    	toggle3: toggle3,
    	toggle4: toggle4,
    	toggle5: toggle5,
    	toggle6: toggle6,
    	toggle7: toggle7,
    	toggle8: toggle8,
    	toggle9: toggle9,
    	toggle10: toggle10,
    	toggle11: toggle11,
    	toggle12: toggle12,
    	toggle13: toggle13,
    	arrow: arrow,
    	arrow2: arrow2,
    	arrow3: arrow3,
    	bouncingBar: bouncingBar,
    	bouncingBall: bouncingBall,
    	smiley: smiley,
    	monkey: monkey,
    	hearts: hearts,
    	clock: clock,
    	earth: earth,
    	material: material,
    	moon: moon,
    	runner: runner,
    	pong: pong,
    	shark: shark,
    	dqpb: dqpb,
    	weather: weather,
    	christmas: christmas,
    	grenade: grenade,
    	point: point,
    	layer: layer,
    	betaWave: betaWave,
    	fingerDance: fingerDance,
    	fistBump: fistBump,
    	soccerHeader: soccerHeader,
    	mindblown: mindblown,
    	speaker: speaker,
    	orangePulse: orangePulse,
    	bluePulse: bluePulse,
    	orangeBluePulse: orangeBluePulse,
    	timeTravel: timeTravel,
    	aesthetic: aesthetic
    };

    const spinners = Object.assign({}, require$$0$1); // eslint-disable-line import/extensions

    const spinnersList = Object.keys(spinners);

    Object.defineProperty(spinners, 'random', {
    	get() {
    		const randomIndex = Math.floor(Math.random() * spinnersList.length);
    		const spinnerName = spinnersList[randomIndex];
    		return spinners[spinnerName];
    	}
    });

    var cliSpinners$1 = spinners;

    var isUnicodeSupported$2 = () => {
    	if (process.platform !== 'win32') {
    		return true;
    	}

    	return Boolean(process.env.CI) ||
    		Boolean(process.env.WT_SESSION) || // Windows Terminal
    		process.env.TERM_PROGRAM === 'vscode' ||
    		process.env.TERM === 'xterm-256color' ||
    		process.env.TERM === 'alacritty';
    };

    const chalk$b = source;
    const isUnicodeSupported$1 = isUnicodeSupported$2;

    const main$2 = {
    	info: chalk$b.blue(''),
    	success: chalk$b.green(''),
    	warning: chalk$b.yellow(''),
    	error: chalk$b.red('')
    };

    const fallback = {
    	info: chalk$b.blue('i'),
    	success: chalk$b.green(''),
    	warning: chalk$b.yellow(''),
    	error: chalk$b.red('')
    };

    var logSymbols$1 = isUnicodeSupported$1() ? main$2 : fallback;

    var wcwidth$2 = {exports: {}};

    var clone$1 = {exports: {}};

    (function (module) {
    var clone = (function() {

    /**
     * Clones (copies) an Object using deep copying.
     *
     * This function supports circular references by default, but if you are certain
     * there are no circular references in your object, you can save some CPU time
     * by calling clone(obj, false).
     *
     * Caution: if `circular` is false and `parent` contains circular references,
     * your program may enter an infinite loop and crash.
     *
     * @param `parent` - the object to be cloned
     * @param `circular` - set to true if the object to be cloned may contain
     *    circular references. (optional - true by default)
     * @param `depth` - set to a number if the object is only to be cloned to
     *    a particular depth. (optional - defaults to Infinity)
     * @param `prototype` - sets the prototype to be used when cloning an object.
     *    (optional - defaults to parent prototype).
    */
    function clone(parent, circular, depth, prototype) {
      if (typeof circular === 'object') {
        depth = circular.depth;
        prototype = circular.prototype;
        circular = circular.circular;
      }
      // maintain two arrays for circular references, where corresponding parents
      // and children have the same index
      var allParents = [];
      var allChildren = [];

      var useBuffer = typeof Buffer != 'undefined';

      if (typeof circular == 'undefined')
        circular = true;

      if (typeof depth == 'undefined')
        depth = Infinity;

      // recurse this function so we don't reset allParents and allChildren
      function _clone(parent, depth) {
        // cloning null always returns null
        if (parent === null)
          return null;

        if (depth == 0)
          return parent;

        var child;
        var proto;
        if (typeof parent != 'object') {
          return parent;
        }

        if (clone.__isArray(parent)) {
          child = [];
        } else if (clone.__isRegExp(parent)) {
          child = new RegExp(parent.source, __getRegExpFlags(parent));
          if (parent.lastIndex) child.lastIndex = parent.lastIndex;
        } else if (clone.__isDate(parent)) {
          child = new Date(parent.getTime());
        } else if (useBuffer && Buffer.isBuffer(parent)) {
          if (Buffer.allocUnsafe) {
            // Node.js >= 4.5.0
            child = Buffer.allocUnsafe(parent.length);
          } else {
            // Older Node.js versions
            child = new Buffer(parent.length);
          }
          parent.copy(child);
          return child;
        } else {
          if (typeof prototype == 'undefined') {
            proto = Object.getPrototypeOf(parent);
            child = Object.create(proto);
          }
          else {
            child = Object.create(prototype);
            proto = prototype;
          }
        }

        if (circular) {
          var index = allParents.indexOf(parent);

          if (index != -1) {
            return allChildren[index];
          }
          allParents.push(parent);
          allChildren.push(child);
        }

        for (var i in parent) {
          var attrs;
          if (proto) {
            attrs = Object.getOwnPropertyDescriptor(proto, i);
          }

          if (attrs && attrs.set == null) {
            continue;
          }
          child[i] = _clone(parent[i], depth - 1);
        }

        return child;
      }

      return _clone(parent, depth);
    }

    /**
     * Simple flat clone using prototype, accepts only objects, usefull for property
     * override on FLAT configuration object (no nested props).
     *
     * USE WITH CAUTION! This may not behave as you wish if you do not know how this
     * works.
     */
    clone.clonePrototype = function clonePrototype(parent) {
      if (parent === null)
        return null;

      var c = function () {};
      c.prototype = parent;
      return new c();
    };

    // private utility functions

    function __objToStr(o) {
      return Object.prototype.toString.call(o);
    }clone.__objToStr = __objToStr;

    function __isDate(o) {
      return typeof o === 'object' && __objToStr(o) === '[object Date]';
    }clone.__isDate = __isDate;

    function __isArray(o) {
      return typeof o === 'object' && __objToStr(o) === '[object Array]';
    }clone.__isArray = __isArray;

    function __isRegExp(o) {
      return typeof o === 'object' && __objToStr(o) === '[object RegExp]';
    }clone.__isRegExp = __isRegExp;

    function __getRegExpFlags(re) {
      var flags = '';
      if (re.global) flags += 'g';
      if (re.ignoreCase) flags += 'i';
      if (re.multiline) flags += 'm';
      return flags;
    }clone.__getRegExpFlags = __getRegExpFlags;

    return clone;
    })();

    if (module.exports) {
      module.exports = clone;
    }
    }(clone$1));

    var clone = clone$1.exports;

    var defaults$1 = function(options, defaults) {
      options = options || {};

      Object.keys(defaults).forEach(function(key) {
        if (typeof options[key] === 'undefined') {
          options[key] = clone(defaults[key]);
        }
      });

      return options;
    };

    var combining$1 = [
        [ 0x0300, 0x036F ], [ 0x0483, 0x0486 ], [ 0x0488, 0x0489 ],
        [ 0x0591, 0x05BD ], [ 0x05BF, 0x05BF ], [ 0x05C1, 0x05C2 ],
        [ 0x05C4, 0x05C5 ], [ 0x05C7, 0x05C7 ], [ 0x0600, 0x0603 ],
        [ 0x0610, 0x0615 ], [ 0x064B, 0x065E ], [ 0x0670, 0x0670 ],
        [ 0x06D6, 0x06E4 ], [ 0x06E7, 0x06E8 ], [ 0x06EA, 0x06ED ],
        [ 0x070F, 0x070F ], [ 0x0711, 0x0711 ], [ 0x0730, 0x074A ],
        [ 0x07A6, 0x07B0 ], [ 0x07EB, 0x07F3 ], [ 0x0901, 0x0902 ],
        [ 0x093C, 0x093C ], [ 0x0941, 0x0948 ], [ 0x094D, 0x094D ],
        [ 0x0951, 0x0954 ], [ 0x0962, 0x0963 ], [ 0x0981, 0x0981 ],
        [ 0x09BC, 0x09BC ], [ 0x09C1, 0x09C4 ], [ 0x09CD, 0x09CD ],
        [ 0x09E2, 0x09E3 ], [ 0x0A01, 0x0A02 ], [ 0x0A3C, 0x0A3C ],
        [ 0x0A41, 0x0A42 ], [ 0x0A47, 0x0A48 ], [ 0x0A4B, 0x0A4D ],
        [ 0x0A70, 0x0A71 ], [ 0x0A81, 0x0A82 ], [ 0x0ABC, 0x0ABC ],
        [ 0x0AC1, 0x0AC5 ], [ 0x0AC7, 0x0AC8 ], [ 0x0ACD, 0x0ACD ],
        [ 0x0AE2, 0x0AE3 ], [ 0x0B01, 0x0B01 ], [ 0x0B3C, 0x0B3C ],
        [ 0x0B3F, 0x0B3F ], [ 0x0B41, 0x0B43 ], [ 0x0B4D, 0x0B4D ],
        [ 0x0B56, 0x0B56 ], [ 0x0B82, 0x0B82 ], [ 0x0BC0, 0x0BC0 ],
        [ 0x0BCD, 0x0BCD ], [ 0x0C3E, 0x0C40 ], [ 0x0C46, 0x0C48 ],
        [ 0x0C4A, 0x0C4D ], [ 0x0C55, 0x0C56 ], [ 0x0CBC, 0x0CBC ],
        [ 0x0CBF, 0x0CBF ], [ 0x0CC6, 0x0CC6 ], [ 0x0CCC, 0x0CCD ],
        [ 0x0CE2, 0x0CE3 ], [ 0x0D41, 0x0D43 ], [ 0x0D4D, 0x0D4D ],
        [ 0x0DCA, 0x0DCA ], [ 0x0DD2, 0x0DD4 ], [ 0x0DD6, 0x0DD6 ],
        [ 0x0E31, 0x0E31 ], [ 0x0E34, 0x0E3A ], [ 0x0E47, 0x0E4E ],
        [ 0x0EB1, 0x0EB1 ], [ 0x0EB4, 0x0EB9 ], [ 0x0EBB, 0x0EBC ],
        [ 0x0EC8, 0x0ECD ], [ 0x0F18, 0x0F19 ], [ 0x0F35, 0x0F35 ],
        [ 0x0F37, 0x0F37 ], [ 0x0F39, 0x0F39 ], [ 0x0F71, 0x0F7E ],
        [ 0x0F80, 0x0F84 ], [ 0x0F86, 0x0F87 ], [ 0x0F90, 0x0F97 ],
        [ 0x0F99, 0x0FBC ], [ 0x0FC6, 0x0FC6 ], [ 0x102D, 0x1030 ],
        [ 0x1032, 0x1032 ], [ 0x1036, 0x1037 ], [ 0x1039, 0x1039 ],
        [ 0x1058, 0x1059 ], [ 0x1160, 0x11FF ], [ 0x135F, 0x135F ],
        [ 0x1712, 0x1714 ], [ 0x1732, 0x1734 ], [ 0x1752, 0x1753 ],
        [ 0x1772, 0x1773 ], [ 0x17B4, 0x17B5 ], [ 0x17B7, 0x17BD ],
        [ 0x17C6, 0x17C6 ], [ 0x17C9, 0x17D3 ], [ 0x17DD, 0x17DD ],
        [ 0x180B, 0x180D ], [ 0x18A9, 0x18A9 ], [ 0x1920, 0x1922 ],
        [ 0x1927, 0x1928 ], [ 0x1932, 0x1932 ], [ 0x1939, 0x193B ],
        [ 0x1A17, 0x1A18 ], [ 0x1B00, 0x1B03 ], [ 0x1B34, 0x1B34 ],
        [ 0x1B36, 0x1B3A ], [ 0x1B3C, 0x1B3C ], [ 0x1B42, 0x1B42 ],
        [ 0x1B6B, 0x1B73 ], [ 0x1DC0, 0x1DCA ], [ 0x1DFE, 0x1DFF ],
        [ 0x200B, 0x200F ], [ 0x202A, 0x202E ], [ 0x2060, 0x2063 ],
        [ 0x206A, 0x206F ], [ 0x20D0, 0x20EF ], [ 0x302A, 0x302F ],
        [ 0x3099, 0x309A ], [ 0xA806, 0xA806 ], [ 0xA80B, 0xA80B ],
        [ 0xA825, 0xA826 ], [ 0xFB1E, 0xFB1E ], [ 0xFE00, 0xFE0F ],
        [ 0xFE20, 0xFE23 ], [ 0xFEFF, 0xFEFF ], [ 0xFFF9, 0xFFFB ],
        [ 0x10A01, 0x10A03 ], [ 0x10A05, 0x10A06 ], [ 0x10A0C, 0x10A0F ],
        [ 0x10A38, 0x10A3A ], [ 0x10A3F, 0x10A3F ], [ 0x1D167, 0x1D169 ],
        [ 0x1D173, 0x1D182 ], [ 0x1D185, 0x1D18B ], [ 0x1D1AA, 0x1D1AD ],
        [ 0x1D242, 0x1D244 ], [ 0xE0001, 0xE0001 ], [ 0xE0020, 0xE007F ],
        [ 0xE0100, 0xE01EF ]
    ];

    var defaults = defaults$1;
    var combining = combining$1;

    var DEFAULTS = {
      nul: 0,
      control: 0
    };

    wcwidth$2.exports = function wcwidth(str) {
      return wcswidth(str, DEFAULTS)
    };

    wcwidth$2.exports.config = function(opts) {
      opts = defaults(opts || {}, DEFAULTS);
      return function wcwidth(str) {
        return wcswidth(str, opts)
      }
    };

    /*
     *  The following functions define the column width of an ISO 10646
     *  character as follows:
     *  - The null character (U+0000) has a column width of 0.
     *  - Other C0/C1 control characters and DEL will lead to a return value
     *    of -1.
     *  - Non-spacing and enclosing combining characters (general category
     *    code Mn or Me in the
     *    Unicode database) have a column width of 0.
     *  - SOFT HYPHEN (U+00AD) has a column width of 1.
     *  - Other format characters (general category code Cf in the Unicode
     *    database) and ZERO WIDTH
     *    SPACE (U+200B) have a column width of 0.
     *  - Hangul Jamo medial vowels and final consonants (U+1160-U+11FF)
     *    have a column width of 0.
     *  - Spacing characters in the East Asian Wide (W) or East Asian
     *    Full-width (F) category as
     *    defined in Unicode Technical Report #11 have a column width of 2.
     *  - All remaining characters (including all printable ISO 8859-1 and
     *    WGL4 characters, Unicode control characters, etc.) have a column
     *    width of 1.
     *  This implementation assumes that characters are encoded in ISO 10646.
    */

    function wcswidth(str, opts) {
      if (typeof str !== 'string') return wcwidth$1(str, opts)

      var s = 0;
      for (var i = 0; i < str.length; i++) {
        var n = wcwidth$1(str.charCodeAt(i), opts);
        if (n < 0) return -1
        s += n;
      }

      return s
    }

    function wcwidth$1(ucs, opts) {
      // test for 8-bit control characters
      if (ucs === 0) return opts.nul
      if (ucs < 32 || (ucs >= 0x7f && ucs < 0xa0)) return opts.control

      // binary search in table of non-spacing characters
      if (bisearch(ucs)) return 0

      // if we arrive here, ucs is not a combining or C0/C1 control character
      return 1 +
          (ucs >= 0x1100 &&
           (ucs <= 0x115f ||                       // Hangul Jamo init. consonants
            ucs == 0x2329 || ucs == 0x232a ||
            (ucs >= 0x2e80 && ucs <= 0xa4cf &&
             ucs != 0x303f) ||                     // CJK ... Yi
            (ucs >= 0xac00 && ucs <= 0xd7a3) ||    // Hangul Syllables
            (ucs >= 0xf900 && ucs <= 0xfaff) ||    // CJK Compatibility Ideographs
            (ucs >= 0xfe10 && ucs <= 0xfe19) ||    // Vertical forms
            (ucs >= 0xfe30 && ucs <= 0xfe6f) ||    // CJK Compatibility Forms
            (ucs >= 0xff00 && ucs <= 0xff60) ||    // Fullwidth Forms
            (ucs >= 0xffe0 && ucs <= 0xffe6) ||
            (ucs >= 0x20000 && ucs <= 0x2fffd) ||
            (ucs >= 0x30000 && ucs <= 0x3fffd)));
    }

    function bisearch(ucs) {
      var min = 0;
      var max = combining.length - 1;
      var mid;

      if (ucs < combining[0][0] || ucs > combining[max][1]) return false

      while (max >= min) {
        mid = Math.floor((min + max) / 2);
        if (ucs > combining[mid][1]) min = mid + 1;
        else if (ucs < combining[mid][0]) max = mid - 1;
        else return true
      }

      return false
    }

    var isInteractive$1 = ({stream = process.stdout} = {}) => {
    	return Boolean(
    		stream && stream.isTTY &&
    		process.env.TERM !== 'dumb' &&
    		!('CI' in process.env)
    	);
    };

    var bl = {exports: {}};

    const { Buffer: Buffer$9 } = require$$0__default$3["default"];
    const symbol = Symbol.for('BufferList');

    function BufferList$1 (buf) {
      if (!(this instanceof BufferList$1)) {
        return new BufferList$1(buf)
      }

      BufferList$1._init.call(this, buf);
    }

    BufferList$1._init = function _init (buf) {
      Object.defineProperty(this, symbol, { value: true });

      this._bufs = [];
      this.length = 0;

      if (buf) {
        this.append(buf);
      }
    };

    BufferList$1.prototype._new = function _new (buf) {
      return new BufferList$1(buf)
    };

    BufferList$1.prototype._offset = function _offset (offset) {
      if (offset === 0) {
        return [0, 0]
      }

      let tot = 0;

      for (let i = 0; i < this._bufs.length; i++) {
        const _t = tot + this._bufs[i].length;
        if (offset < _t || i === this._bufs.length - 1) {
          return [i, offset - tot]
        }
        tot = _t;
      }
    };

    BufferList$1.prototype._reverseOffset = function (blOffset) {
      const bufferId = blOffset[0];
      let offset = blOffset[1];

      for (let i = 0; i < bufferId; i++) {
        offset += this._bufs[i].length;
      }

      return offset
    };

    BufferList$1.prototype.get = function get (index) {
      if (index > this.length || index < 0) {
        return undefined
      }

      const offset = this._offset(index);

      return this._bufs[offset[0]][offset[1]]
    };

    BufferList$1.prototype.slice = function slice (start, end) {
      if (typeof start === 'number' && start < 0) {
        start += this.length;
      }

      if (typeof end === 'number' && end < 0) {
        end += this.length;
      }

      return this.copy(null, 0, start, end)
    };

    BufferList$1.prototype.copy = function copy (dst, dstStart, srcStart, srcEnd) {
      if (typeof srcStart !== 'number' || srcStart < 0) {
        srcStart = 0;
      }

      if (typeof srcEnd !== 'number' || srcEnd > this.length) {
        srcEnd = this.length;
      }

      if (srcStart >= this.length) {
        return dst || Buffer$9.alloc(0)
      }

      if (srcEnd <= 0) {
        return dst || Buffer$9.alloc(0)
      }

      const copy = !!dst;
      const off = this._offset(srcStart);
      const len = srcEnd - srcStart;
      let bytes = len;
      let bufoff = (copy && dstStart) || 0;
      let start = off[1];

      // copy/slice everything
      if (srcStart === 0 && srcEnd === this.length) {
        if (!copy) {
          // slice, but full concat if multiple buffers
          return this._bufs.length === 1
            ? this._bufs[0]
            : Buffer$9.concat(this._bufs, this.length)
        }

        // copy, need to copy individual buffers
        for (let i = 0; i < this._bufs.length; i++) {
          this._bufs[i].copy(dst, bufoff);
          bufoff += this._bufs[i].length;
        }

        return dst
      }

      // easy, cheap case where it's a subset of one of the buffers
      if (bytes <= this._bufs[off[0]].length - start) {
        return copy
          ? this._bufs[off[0]].copy(dst, dstStart, start, start + bytes)
          : this._bufs[off[0]].slice(start, start + bytes)
      }

      if (!copy) {
        // a slice, we need something to copy in to
        dst = Buffer$9.allocUnsafe(len);
      }

      for (let i = off[0]; i < this._bufs.length; i++) {
        const l = this._bufs[i].length - start;

        if (bytes > l) {
          this._bufs[i].copy(dst, bufoff, start);
          bufoff += l;
        } else {
          this._bufs[i].copy(dst, bufoff, start, start + bytes);
          bufoff += l;
          break
        }

        bytes -= l;

        if (start) {
          start = 0;
        }
      }

      // safeguard so that we don't return uninitialized memory
      if (dst.length > bufoff) return dst.slice(0, bufoff)

      return dst
    };

    BufferList$1.prototype.shallowSlice = function shallowSlice (start, end) {
      start = start || 0;
      end = typeof end !== 'number' ? this.length : end;

      if (start < 0) {
        start += this.length;
      }

      if (end < 0) {
        end += this.length;
      }

      if (start === end) {
        return this._new()
      }

      const startOffset = this._offset(start);
      const endOffset = this._offset(end);
      const buffers = this._bufs.slice(startOffset[0], endOffset[0] + 1);

      if (endOffset[1] === 0) {
        buffers.pop();
      } else {
        buffers[buffers.length - 1] = buffers[buffers.length - 1].slice(0, endOffset[1]);
      }

      if (startOffset[1] !== 0) {
        buffers[0] = buffers[0].slice(startOffset[1]);
      }

      return this._new(buffers)
    };

    BufferList$1.prototype.toString = function toString (encoding, start, end) {
      return this.slice(start, end).toString(encoding)
    };

    BufferList$1.prototype.consume = function consume (bytes) {
      // first, normalize the argument, in accordance with how Buffer does it
      bytes = Math.trunc(bytes);
      // do nothing if not a positive number
      if (Number.isNaN(bytes) || bytes <= 0) return this

      while (this._bufs.length) {
        if (bytes >= this._bufs[0].length) {
          bytes -= this._bufs[0].length;
          this.length -= this._bufs[0].length;
          this._bufs.shift();
        } else {
          this._bufs[0] = this._bufs[0].slice(bytes);
          this.length -= bytes;
          break
        }
      }

      return this
    };

    BufferList$1.prototype.duplicate = function duplicate () {
      const copy = this._new();

      for (let i = 0; i < this._bufs.length; i++) {
        copy.append(this._bufs[i]);
      }

      return copy
    };

    BufferList$1.prototype.append = function append (buf) {
      if (buf == null) {
        return this
      }

      if (buf.buffer) {
        // append a view of the underlying ArrayBuffer
        this._appendBuffer(Buffer$9.from(buf.buffer, buf.byteOffset, buf.byteLength));
      } else if (Array.isArray(buf)) {
        for (let i = 0; i < buf.length; i++) {
          this.append(buf[i]);
        }
      } else if (this._isBufferList(buf)) {
        // unwrap argument into individual BufferLists
        for (let i = 0; i < buf._bufs.length; i++) {
          this.append(buf._bufs[i]);
        }
      } else {
        // coerce number arguments to strings, since Buffer(number) does
        // uninitialized memory allocation
        if (typeof buf === 'number') {
          buf = buf.toString();
        }

        this._appendBuffer(Buffer$9.from(buf));
      }

      return this
    };

    BufferList$1.prototype._appendBuffer = function appendBuffer (buf) {
      this._bufs.push(buf);
      this.length += buf.length;
    };

    BufferList$1.prototype.indexOf = function (search, offset, encoding) {
      if (encoding === undefined && typeof offset === 'string') {
        encoding = offset;
        offset = undefined;
      }

      if (typeof search === 'function' || Array.isArray(search)) {
        throw new TypeError('The "value" argument must be one of type string, Buffer, BufferList, or Uint8Array.')
      } else if (typeof search === 'number') {
        search = Buffer$9.from([search]);
      } else if (typeof search === 'string') {
        search = Buffer$9.from(search, encoding);
      } else if (this._isBufferList(search)) {
        search = search.slice();
      } else if (Array.isArray(search.buffer)) {
        search = Buffer$9.from(search.buffer, search.byteOffset, search.byteLength);
      } else if (!Buffer$9.isBuffer(search)) {
        search = Buffer$9.from(search);
      }

      offset = Number(offset || 0);

      if (isNaN(offset)) {
        offset = 0;
      }

      if (offset < 0) {
        offset = this.length + offset;
      }

      if (offset < 0) {
        offset = 0;
      }

      if (search.length === 0) {
        return offset > this.length ? this.length : offset
      }

      const blOffset = this._offset(offset);
      let blIndex = blOffset[0]; // index of which internal buffer we're working on
      let buffOffset = blOffset[1]; // offset of the internal buffer we're working on

      // scan over each buffer
      for (; blIndex < this._bufs.length; blIndex++) {
        const buff = this._bufs[blIndex];

        while (buffOffset < buff.length) {
          const availableWindow = buff.length - buffOffset;

          if (availableWindow >= search.length) {
            const nativeSearchResult = buff.indexOf(search, buffOffset);

            if (nativeSearchResult !== -1) {
              return this._reverseOffset([blIndex, nativeSearchResult])
            }

            buffOffset = buff.length - search.length + 1; // end of native search window
          } else {
            const revOffset = this._reverseOffset([blIndex, buffOffset]);

            if (this._match(revOffset, search)) {
              return revOffset
            }

            buffOffset++;
          }
        }

        buffOffset = 0;
      }

      return -1
    };

    BufferList$1.prototype._match = function (offset, search) {
      if (this.length - offset < search.length) {
        return false
      }

      for (let searchOffset = 0; searchOffset < search.length; searchOffset++) {
        if (this.get(offset + searchOffset) !== search[searchOffset]) {
          return false
        }
      }
      return true
    }

    ;(function () {
      const methods = {
        readDoubleBE: 8,
        readDoubleLE: 8,
        readFloatBE: 4,
        readFloatLE: 4,
        readInt32BE: 4,
        readInt32LE: 4,
        readUInt32BE: 4,
        readUInt32LE: 4,
        readInt16BE: 2,
        readInt16LE: 2,
        readUInt16BE: 2,
        readUInt16LE: 2,
        readInt8: 1,
        readUInt8: 1,
        readIntBE: null,
        readIntLE: null,
        readUIntBE: null,
        readUIntLE: null
      };

      for (const m in methods) {
        (function (m) {
          if (methods[m] === null) {
            BufferList$1.prototype[m] = function (offset, byteLength) {
              return this.slice(offset, offset + byteLength)[m](0, byteLength)
            };
          } else {
            BufferList$1.prototype[m] = function (offset = 0) {
              return this.slice(offset, offset + methods[m])[m](0)
            };
          }
        }(m));
      }
    }());

    // Used internally by the class and also as an indicator of this object being
    // a `BufferList`. It's not possible to use `instanceof BufferList` in a browser
    // environment because there could be multiple different copies of the
    // BufferList class and some `BufferList`s might be `BufferList`s.
    BufferList$1.prototype._isBufferList = function _isBufferList (b) {
      return b instanceof BufferList$1 || BufferList$1.isBufferList(b)
    };

    BufferList$1.isBufferList = function isBufferList (b) {
      return b != null && b[symbol]
    };

    var BufferList_1 = BufferList$1;

    const DuplexStream = readable.exports.Duplex;
    const inherits$1 = inherits$2.exports;
    const BufferList = BufferList_1;

    function BufferListStream$1 (callback) {
      if (!(this instanceof BufferListStream$1)) {
        return new BufferListStream$1(callback)
      }

      if (typeof callback === 'function') {
        this._callback = callback;

        const piper = function piper (err) {
          if (this._callback) {
            this._callback(err);
            this._callback = null;
          }
        }.bind(this);

        this.on('pipe', function onPipe (src) {
          src.on('error', piper);
        });
        this.on('unpipe', function onUnpipe (src) {
          src.removeListener('error', piper);
        });

        callback = null;
      }

      BufferList._init.call(this, callback);
      DuplexStream.call(this);
    }

    inherits$1(BufferListStream$1, DuplexStream);
    Object.assign(BufferListStream$1.prototype, BufferList.prototype);

    BufferListStream$1.prototype._new = function _new (callback) {
      return new BufferListStream$1(callback)
    };

    BufferListStream$1.prototype._write = function _write (buf, encoding, callback) {
      this._appendBuffer(buf);

      if (typeof callback === 'function') {
        callback();
      }
    };

    BufferListStream$1.prototype._read = function _read (size) {
      if (!this.length) {
        return this.push(null)
      }

      size = Math.min(size, this.length);
      this.push(this.slice(0, size));
      this.consume(size);
    };

    BufferListStream$1.prototype.end = function end (chunk) {
      DuplexStream.prototype.end.call(this, chunk);

      if (this._callback) {
        this._callback(null, this.slice());
        this._callback = null;
      }
    };

    BufferListStream$1.prototype._destroy = function _destroy (err, cb) {
      this._bufs.length = 0;
      this.length = 0;
      cb(err);
    };

    BufferListStream$1.prototype._isBufferList = function _isBufferList (b) {
      return b instanceof BufferListStream$1 || b instanceof BufferList || BufferListStream$1.isBufferList(b)
    };

    BufferListStream$1.isBufferList = BufferList.isBufferList;

    bl.exports = BufferListStream$1;
    bl.exports.BufferListStream = BufferListStream$1;
    bl.exports.BufferList = BufferList;

    const readline = require$$3__default["default"];
    const chalk$a = source;
    const cliCursor$2 = cliCursor$3;
    const cliSpinners = cliSpinners$1;
    const logSymbols = logSymbols$1;
    const stripAnsi$1 = stripAnsi$3;
    const wcwidth = wcwidth$2.exports;
    const isInteractive = isInteractive$1;
    const isUnicodeSupported = isUnicodeSupported$2;
    const {BufferListStream} = bl.exports;

    const TEXT = Symbol('text');
    const PREFIX_TEXT = Symbol('prefixText');
    const ASCII_ETX_CODE = 0x03; // Ctrl+C emits this code

    class StdinDiscarder {
    	constructor() {
    		this.requests = 0;

    		this.mutedStream = new BufferListStream();
    		this.mutedStream.pipe(process.stdout);

    		const self = this; // eslint-disable-line unicorn/no-this-assignment
    		this.ourEmit = function (event, data, ...args) {
    			const {stdin} = process;
    			if (self.requests > 0 || stdin.emit === self.ourEmit) {
    				if (event === 'keypress') { // Fixes readline behavior
    					return;
    				}

    				if (event === 'data' && data.includes(ASCII_ETX_CODE)) {
    					process.emit('SIGINT');
    				}

    				Reflect.apply(self.oldEmit, this, [event, data, ...args]);
    			} else {
    				Reflect.apply(process.stdin.emit, this, [event, data, ...args]);
    			}
    		};
    	}

    	start() {
    		this.requests++;

    		if (this.requests === 1) {
    			this.realStart();
    		}
    	}

    	stop() {
    		if (this.requests <= 0) {
    			throw new Error('`stop` called more times than `start`');
    		}

    		this.requests--;

    		if (this.requests === 0) {
    			this.realStop();
    		}
    	}

    	realStart() {
    		// No known way to make it work reliably on Windows
    		if (process.platform === 'win32') {
    			return;
    		}

    		this.rl = readline.createInterface({
    			input: process.stdin,
    			output: this.mutedStream
    		});

    		this.rl.on('SIGINT', () => {
    			if (process.listenerCount('SIGINT') === 0) {
    				process.emit('SIGINT');
    			} else {
    				this.rl.close();
    				process.kill(process.pid, 'SIGINT');
    			}
    		});
    	}

    	realStop() {
    		if (process.platform === 'win32') {
    			return;
    		}

    		this.rl.close();
    		this.rl = undefined;
    	}
    }

    let stdinDiscarder;

    class Ora {
    	constructor(options) {
    		if (!stdinDiscarder) {
    			stdinDiscarder = new StdinDiscarder();
    		}

    		if (typeof options === 'string') {
    			options = {
    				text: options
    			};
    		}

    		this.options = {
    			text: '',
    			color: 'cyan',
    			stream: process.stderr,
    			discardStdin: true,
    			...options
    		};

    		this.spinner = this.options.spinner;

    		this.color = this.options.color;
    		this.hideCursor = this.options.hideCursor !== false;
    		this.interval = this.options.interval || this.spinner.interval || 100;
    		this.stream = this.options.stream;
    		this.id = undefined;
    		this.isEnabled = typeof this.options.isEnabled === 'boolean' ? this.options.isEnabled : isInteractive({stream: this.stream});
    		this.isSilent = typeof this.options.isSilent === 'boolean' ? this.options.isSilent : false;

    		// Set *after* `this.stream`
    		this.text = this.options.text;
    		this.prefixText = this.options.prefixText;
    		this.linesToClear = 0;
    		this.indent = this.options.indent;
    		this.discardStdin = this.options.discardStdin;
    		this.isDiscardingStdin = false;
    	}

    	get indent() {
    		return this._indent;
    	}

    	set indent(indent = 0) {
    		if (!(indent >= 0 && Number.isInteger(indent))) {
    			throw new Error('The `indent` option must be an integer from 0 and up');
    		}

    		this._indent = indent;
    	}

    	_updateInterval(interval) {
    		if (interval !== undefined) {
    			this.interval = interval;
    		}
    	}

    	get spinner() {
    		return this._spinner;
    	}

    	set spinner(spinner) {
    		this.frameIndex = 0;

    		if (typeof spinner === 'object') {
    			if (spinner.frames === undefined) {
    				throw new Error('The given spinner must have a `frames` property');
    			}

    			this._spinner = spinner;
    		} else if (!isUnicodeSupported()) {
    			this._spinner = cliSpinners.line;
    		} else if (spinner === undefined) {
    			// Set default spinner
    			this._spinner = cliSpinners.dots;
    		} else if (spinner !== 'default' && cliSpinners[spinner]) {
    			this._spinner = cliSpinners[spinner];
    		} else {
    			throw new Error(`There is no built-in spinner named '${spinner}'. See https://github.com/sindresorhus/cli-spinners/blob/main/spinners.json for a full list.`);
    		}

    		this._updateInterval(this._spinner.interval);
    	}

    	get text() {
    		return this[TEXT];
    	}

    	set text(value) {
    		this[TEXT] = value;
    		this.updateLineCount();
    	}

    	get prefixText() {
    		return this[PREFIX_TEXT];
    	}

    	set prefixText(value) {
    		this[PREFIX_TEXT] = value;
    		this.updateLineCount();
    	}

    	get isSpinning() {
    		return this.id !== undefined;
    	}

    	getFullPrefixText(prefixText = this[PREFIX_TEXT], postfix = ' ') {
    		if (typeof prefixText === 'string') {
    			return prefixText + postfix;
    		}

    		if (typeof prefixText === 'function') {
    			return prefixText() + postfix;
    		}

    		return '';
    	}

    	updateLineCount() {
    		const columns = this.stream.columns || 80;
    		const fullPrefixText = this.getFullPrefixText(this.prefixText, '-');
    		this.lineCount = 0;
    		for (const line of stripAnsi$1(fullPrefixText + '--' + this[TEXT]).split('\n')) {
    			this.lineCount += Math.max(1, Math.ceil(wcwidth(line) / columns));
    		}
    	}

    	get isEnabled() {
    		return this._isEnabled && !this.isSilent;
    	}

    	set isEnabled(value) {
    		if (typeof value !== 'boolean') {
    			throw new TypeError('The `isEnabled` option must be a boolean');
    		}

    		this._isEnabled = value;
    	}

    	get isSilent() {
    		return this._isSilent;
    	}

    	set isSilent(value) {
    		if (typeof value !== 'boolean') {
    			throw new TypeError('The `isSilent` option must be a boolean');
    		}

    		this._isSilent = value;
    	}

    	frame() {
    		const {frames} = this.spinner;
    		let frame = frames[this.frameIndex];

    		if (this.color) {
    			frame = chalk$a[this.color](frame);
    		}

    		this.frameIndex = ++this.frameIndex % frames.length;
    		const fullPrefixText = (typeof this.prefixText === 'string' && this.prefixText !== '') ? this.prefixText + ' ' : '';
    		const fullText = typeof this.text === 'string' ? ' ' + this.text : '';

    		return fullPrefixText + frame + fullText;
    	}

    	clear() {
    		if (!this.isEnabled || !this.stream.isTTY) {
    			return this;
    		}

    		for (let i = 0; i < this.linesToClear; i++) {
    			if (i > 0) {
    				this.stream.moveCursor(0, -1);
    			}

    			this.stream.clearLine();
    			this.stream.cursorTo(this.indent);
    		}

    		this.linesToClear = 0;

    		return this;
    	}

    	render() {
    		if (this.isSilent) {
    			return this;
    		}

    		this.clear();
    		this.stream.write(this.frame());
    		this.linesToClear = this.lineCount;

    		return this;
    	}

    	start(text) {
    		if (text) {
    			this.text = text;
    		}

    		if (this.isSilent) {
    			return this;
    		}

    		if (!this.isEnabled) {
    			if (this.text) {
    				this.stream.write(`- ${this.text}\n`);
    			}

    			return this;
    		}

    		if (this.isSpinning) {
    			return this;
    		}

    		if (this.hideCursor) {
    			cliCursor$2.hide(this.stream);
    		}

    		if (this.discardStdin && process.stdin.isTTY) {
    			this.isDiscardingStdin = true;
    			stdinDiscarder.start();
    		}

    		this.render();
    		this.id = setInterval(this.render.bind(this), this.interval);

    		return this;
    	}

    	stop() {
    		if (!this.isEnabled) {
    			return this;
    		}

    		clearInterval(this.id);
    		this.id = undefined;
    		this.frameIndex = 0;
    		this.clear();
    		if (this.hideCursor) {
    			cliCursor$2.show(this.stream);
    		}

    		if (this.discardStdin && process.stdin.isTTY && this.isDiscardingStdin) {
    			stdinDiscarder.stop();
    			this.isDiscardingStdin = false;
    		}

    		return this;
    	}

    	succeed(text) {
    		return this.stopAndPersist({symbol: logSymbols.success, text});
    	}

    	fail(text) {
    		return this.stopAndPersist({symbol: logSymbols.error, text});
    	}

    	warn(text) {
    		return this.stopAndPersist({symbol: logSymbols.warning, text});
    	}

    	info(text) {
    		return this.stopAndPersist({symbol: logSymbols.info, text});
    	}

    	stopAndPersist(options = {}) {
    		if (this.isSilent) {
    			return this;
    		}

    		const prefixText = options.prefixText || this.prefixText;
    		const text = options.text || this.text;
    		const fullText = (typeof text === 'string') ? ' ' + text : '';

    		this.stop();
    		this.stream.write(`${this.getFullPrefixText(prefixText, ' ')}${options.symbol || ' '}${fullText}\n`);

    		return this;
    	}
    }

    const oraFactory = function (options) {
    	return new Ora(options);
    };

    ora$1.exports = oraFactory;

    ora$1.exports.promise = (action, options) => {
    	// eslint-disable-next-line promise/prefer-await-to-then
    	if (typeof action.then !== 'function') {
    		throw new TypeError('Parameter `action` must be a Promise');
    	}

    	const spinner = new Ora(options);
    	spinner.start();

    	(async () => {
    		try {
    			await action;
    			spinner.succeed();
    		} catch {
    			spinner.fail();
    		}
    	})();

    	return spinner;
    };

    const _$7 = {
      last: last_1,
      flatten: flatten_1,
    };
    const util = readline$1;
    const cliWidth = cliWidth$1.exports;
    const stripAnsi = stripAnsi$3;
    const stringWidth = stringWidth$2.exports;
    const ora = ora$1.exports;

    function height(content) {
      return content.split('\n').length;
    }

    function lastLine(content) {
      return _$7.last(content.split('\n'));
    }

    class ScreenManager$1 {
      constructor(rl) {
        // These variables are keeping information to allow correct prompt re-rendering
        this.height = 0;
        this.extraLinesUnderPrompt = 0;

        this.rl = rl;
      }

      renderWithSpinner(content, bottomContent) {
        if (this.spinnerId) {
          clearInterval(this.spinnerId);
        }

        let spinner;
        let contentFunc;
        let bottomContentFunc;

        if (bottomContent) {
          spinner = ora(bottomContent);
          contentFunc = () => content;
          bottomContentFunc = () => spinner.frame();
        } else {
          spinner = ora(content);
          contentFunc = () => spinner.frame();
          bottomContentFunc = () => '';
        }

        this.spinnerId = setInterval(
          () => this.render(contentFunc(), bottomContentFunc(), true),
          spinner.interval
        );
      }

      render(content, bottomContent, spinning = false) {
        if (this.spinnerId && !spinning) {
          clearInterval(this.spinnerId);
        }

        this.rl.output.unmute();
        this.clean(this.extraLinesUnderPrompt);

        /**
         * Write message to screen and setPrompt to control backspace
         */

        const promptLine = lastLine(content);
        const rawPromptLine = stripAnsi(promptLine);

        // Remove the rl.line from our prompt. We can't rely on the content of
        // rl.line (mainly because of the password prompt), so just rely on it's
        // length.
        let prompt = rawPromptLine;
        if (this.rl.line.length) {
          prompt = prompt.slice(0, -this.rl.line.length);
        }

        this.rl.setPrompt(prompt);

        // SetPrompt will change cursor position, now we can get correct value
        const cursorPos = this.rl._getCursorPos();
        const width = this.normalizedCliWidth();

        content = this.forceLineReturn(content, width);
        if (bottomContent) {
          bottomContent = this.forceLineReturn(bottomContent, width);
        }

        // Manually insert an extra line if we're at the end of the line.
        // This prevent the cursor from appearing at the beginning of the
        // current line.
        if (rawPromptLine.length % width === 0) {
          content += '\n';
        }

        const fullContent = content + (bottomContent ? '\n' + bottomContent : '');
        this.rl.output.write(fullContent);

        /**
         * Re-adjust the cursor at the correct position.
         */

        // We need to consider parts of the prompt under the cursor as part of the bottom
        // content in order to correctly cleanup and re-render.
        const promptLineUpDiff = Math.floor(rawPromptLine.length / width) - cursorPos.rows;
        const bottomContentHeight =
          promptLineUpDiff + (bottomContent ? height(bottomContent) : 0);
        if (bottomContentHeight > 0) {
          util.up(this.rl, bottomContentHeight);
        }

        // Reset cursor at the beginning of the line
        util.left(this.rl, stringWidth(lastLine(fullContent)));

        // Adjust cursor on the right
        if (cursorPos.cols > 0) {
          util.right(this.rl, cursorPos.cols);
        }

        /**
         * Set up state for next re-rendering
         */
        this.extraLinesUnderPrompt = bottomContentHeight;
        this.height = height(fullContent);

        this.rl.output.mute();
      }

      clean(extraLines) {
        if (extraLines > 0) {
          util.down(this.rl, extraLines);
        }

        util.clearLine(this.rl, this.height);
      }

      done() {
        this.rl.setPrompt('');
        this.rl.output.unmute();
        this.rl.output.write('\n');
      }

      releaseCursor() {
        if (this.extraLinesUnderPrompt > 0) {
          util.down(this.rl, this.extraLinesUnderPrompt);
        }
      }

      normalizedCliWidth() {
        const width = cliWidth({
          defaultWidth: 80,
          output: this.rl.output,
        });
        return width;
      }

      breakLines(lines, width) {
        // Break lines who're longer than the cli width so we can normalize the natural line
        // returns behavior across terminals.
        width = width || this.normalizedCliWidth();
        const regex = new RegExp('(?:(?:\\033[[0-9;]*m)*.?){1,' + width + '}', 'g');
        return lines.map((line) => {
          const chunk = line.match(regex);
          // Last match is always empty
          chunk.pop();
          return chunk || '';
        });
      }

      forceLineReturn(content, width) {
        width = width || this.normalizedCliWidth();
        return _$7.flatten(this.breakLines(content.split('\n'), width)).join('\n');
      }
    }

    var screenManager = ScreenManager$1;

    /**
     * Base prompt implementation
     * Should be extended by prompt types.
     */
    const _$6 = {
      assign: assign_1,
      defaults: defaults_1,
      clone: clone_1,
    };
    const chalk$9 = source;
    const runAsync$1 = runAsync$5.exports;
    const { filter: filter$2, flatMap: flatMap$1, share: share$1, take: take$2, takeUntil: takeUntil$8 } = require$$1$1;
    const Choices = choices;
    const ScreenManager = screenManager;

    class Prompt {
      constructor(question, rl, answers) {
        // Setup instance defaults property
        _$6.assign(this, {
          answers,
          status: 'pending',
        });

        // Set defaults prompt options
        this.opt = _$6.defaults(_$6.clone(question), {
          validate: () => true,
          validatingText: '',
          filter: (val) => val,
          filteringText: '',
          when: () => true,
          suffix: '',
          prefix: chalk$9.green('?'),
        });

        // Make sure name is present
        if (!this.opt.name) {
          this.throwParamError('name');
        }

        // Set default message if no message defined
        if (!this.opt.message) {
          this.opt.message = this.opt.name + ':';
        }

        // Normalize choices
        if (Array.isArray(this.opt.choices)) {
          this.opt.choices = new Choices(this.opt.choices, answers);
        }

        this.rl = rl;
        this.screen = new ScreenManager(this.rl);
      }

      /**
       * Start the Inquiry session and manage output value filtering
       * @return {Promise}
       */

      run() {
        return new Promise((resolve, reject) => {
          this._run(
            (value) => resolve(value),
            (error) => reject(error)
          );
        });
      }

      // Default noop (this one should be overwritten in prompts)
      _run(cb) {
        cb();
      }

      /**
       * Throw an error telling a required parameter is missing
       * @param  {String} name Name of the missing param
       * @return {Throw Error}
       */

      throwParamError(name) {
        throw new Error('You must provide a `' + name + '` parameter');
      }

      /**
       * Called when the UI closes. Override to do any specific cleanup necessary
       */
      close() {
        this.screen.releaseCursor();
      }

      /**
       * Run the provided validation method each time a submit event occur.
       * @param  {Rx.Observable} submit - submit event flow
       * @return {Object}        Object containing two observables: `success` and `error`
       */
      handleSubmitEvents(submit) {
        const self = this;
        const validate = runAsync$1(this.opt.validate);
        const asyncFilter = runAsync$1(this.opt.filter);
        const validation = submit.pipe(
          flatMap$1((value) => {
            this.startSpinner(value, this.opt.filteringText);
            return asyncFilter(value, self.answers).then(
              (filteredValue) => {
                this.startSpinner(filteredValue, this.opt.validatingText);
                return validate(filteredValue, self.answers).then(
                  (isValid) => ({ isValid, value: filteredValue }),
                  (err) => ({ isValid: err, value: filteredValue })
                );
              },
              (err) => ({ isValid: err })
            );
          }),
          share$1()
        );

        const success = validation.pipe(
          filter$2((state) => state.isValid === true),
          take$2(1)
        );
        const error = validation.pipe(
          filter$2((state) => state.isValid !== true),
          takeUntil$8(success)
        );

        return {
          success,
          error,
        };
      }

      startSpinner(value, bottomContent) {
        value = this.getSpinningValue(value);
        // If the question will spin, cut off the prefix (for layout purposes)
        const content = bottomContent
          ? this.getQuestion() + value
          : this.getQuestion().slice(this.opt.prefix.length + 1) + value;

        this.screen.renderWithSpinner(content, bottomContent);
      }

      /**
       * Allow override, e.g. for password prompts
       * See: https://github.com/SBoudrias/Inquirer.js/issues/1022
       *
       * @return {String} value to display while spinning
       */
      getSpinningValue(value) {
        return value;
      }

      /**
       * Generate the prompt question string
       * @return {String} prompt question string
       */
      getQuestion() {
        let message =
          (this.opt.prefix ? this.opt.prefix + ' ' : '') +
          chalk$9.bold(this.opt.message) +
          this.opt.suffix +
          chalk$9.reset(' ');

        // Append the default if available, and if question isn't touched/answered
        if (
          this.opt.default != null &&
          this.status !== 'touched' &&
          this.status !== 'answered'
        ) {
          // If default password is supplied, hide it
          if (this.opt.type === 'password') {
            message += chalk$9.italic.dim('[hidden] ');
          } else {
            message += chalk$9.dim('(' + this.opt.default + ') ');
          }
        }

        return message;
      }
    }

    var base = Prompt;

    const { fromEvent } = require$$4$1;
    const { filter: filter$1, map: map$6, share, takeUntil: takeUntil$7 } = require$$1$1;

    function normalizeKeypressEvents(value, key) {
      return { value, key: key || {} };
    }

    var events = function (rl) {
      const keypress = fromEvent(rl.input, 'keypress', normalizeKeypressEvents)
        .pipe(takeUntil$7(fromEvent(rl, 'close')))
        // Ignore `enter` key. On the readline, we only care about the `line` event.
        .pipe(filter$1(({ key }) => key.name !== 'enter' && key.name !== 'return'));

      return {
        line: fromEvent(rl, 'line'),
        keypress,

        normalizedUpKey: keypress.pipe(
          filter$1(
            ({ key }) =>
              key.name === 'up' || key.name === 'k' || (key.name === 'p' && key.ctrl)
          ),
          share()
        ),

        normalizedDownKey: keypress.pipe(
          filter$1(
            ({ key }) =>
              key.name === 'down' || key.name === 'j' || (key.name === 'n' && key.ctrl)
          ),
          share()
        ),

        numberKey: keypress.pipe(
          filter$1((e) => e.value && '123456789'.indexOf(e.value) >= 0),
          map$6((e) => Number(e.value)),
          share()
        ),

        spaceKey: keypress.pipe(
          filter$1(({ key }) => key && key.name === 'space'),
          share()
        ),
        aKey: keypress.pipe(
          filter$1(({ key }) => key && key.name === 'a'),
          share()
        ),
        iKey: keypress.pipe(
          filter$1(({ key }) => key && key.name === 'i'),
          share()
        ),
      };
    };

    /**
     * The base implementation of `_.sum` and `_.sumBy` without support for
     * iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {number} Returns the sum.
     */

    function baseSum$1(array, iteratee) {
      var result,
          index = -1,
          length = array.length;

      while (++index < length) {
        var current = iteratee(array[index]);
        if (current !== undefined) {
          result = result === undefined ? current : (result + current);
        }
      }
      return result;
    }

    var _baseSum = baseSum$1;

    var baseSum = _baseSum,
        identity = identity_1;

    /**
     * Computes the sum of the values in `array`.
     *
     * @static
     * @memberOf _
     * @since 3.4.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @returns {number} Returns the sum.
     * @example
     *
     * _.sum([4, 2, 8, 6]);
     * // => 20
     */
    function sum(array) {
      return (array && array.length)
        ? baseSum(array, identity)
        : 0;
    }

    var sum_1 = sum;

    const _$5 = {
      sum: sum_1,
      flatten: flatten_1,
    };
    const chalk$8 = source;

    /**
     * The paginator returns a subset of the choices if the list is too long.
     */

    class Paginator$4 {
      constructor(screen, options = {}) {
        const { isInfinite = true } = options;
        this.lastIndex = 0;
        this.screen = screen;
        this.isInfinite = isInfinite;
      }

      paginate(output, active, pageSize) {
        pageSize = pageSize || 7;
        let lines = output.split('\n');

        if (this.screen) {
          lines = this.screen.breakLines(lines);
          active = _$5.sum(lines.map((lineParts) => lineParts.length).splice(0, active));
          lines = _$5.flatten(lines);
        }

        // Make sure there's enough lines to paginate
        if (lines.length <= pageSize) {
          return output;
        }
        const visibleLines = this.isInfinite
          ? this.getInfiniteLines(lines, active, pageSize)
          : this.getFiniteLines(lines, active, pageSize);
        this.lastIndex = active;
        return (
          visibleLines.join('\n') +
          '\n' +
          chalk$8.dim('(Move up and down to reveal more choices)')
        );
      }

      getInfiniteLines(lines, active, pageSize) {
        if (this.pointer === undefined) {
          this.pointer = 0;
        }
        const middleOfList = Math.floor(pageSize / 2);
        // Move the pointer only when the user go down and limit it to the middle of the list
        if (
          this.pointer < middleOfList &&
          this.lastIndex < active &&
          active - this.lastIndex < pageSize
        ) {
          this.pointer = Math.min(middleOfList, this.pointer + active - this.lastIndex);
        }

        // Duplicate the lines so it give an infinite list look
        const infinite = _$5.flatten([lines, lines, lines]);
        const topIndex = Math.max(0, active + lines.length - this.pointer);

        return infinite.splice(topIndex, pageSize);
      }

      getFiniteLines(lines, active, pageSize) {
        let topIndex = active - pageSize / 2;
        if (topIndex < 0) {
          topIndex = 0;
        } else if (topIndex + pageSize > lines.length) {
          topIndex = lines.length - pageSize;
        }
        return lines.splice(topIndex, pageSize);
      }
    }

    var paginator = Paginator$4;

    function incrementListIndex$3(current, dir, opt) {
      const len = opt.choices.realLength;
      const shouldLoop = 'loop' in opt ? Boolean(opt.loop) : true;
      if (dir === 'up') {
        if (current > 0) {
          return current - 1;
        }
        return shouldLoop ? len - 1 : current;
      }
      if (dir === 'down') {
        if (current < len - 1) {
          return current + 1;
        }
        return shouldLoop ? 0 : current;
      }
      throw new Error('dir must be up or down');
    }

    var incrementListIndex_1 = incrementListIndex$3;

    /**
     * `list` type prompt
     */

    const _$4 = {
      isNumber: isNumber_1,
      findIndex: findIndex_1,
      isString: isString_1,
    };
    const chalk$7 = source;
    const figures$1 = figures$4.exports;
    const cliCursor$1 = cliCursor$3;
    const runAsync = runAsync$5.exports;
    const { flatMap, map: map$5, take: take$1, takeUntil: takeUntil$6 } = require$$1$1;
    const Base$7 = base;
    const observe$7 = events;
    const Paginator$3 = paginator;
    const incrementListIndex$2 = incrementListIndex_1;

    class ListPrompt extends Base$7 {
      constructor(questions, rl, answers) {
        super(questions, rl, answers);

        if (!this.opt.choices) {
          this.throwParamError('choices');
        }

        this.firstRender = true;
        this.selected = 0;

        const def = this.opt.default;

        // If def is a Number, then use as index. Otherwise, check for value.
        if (_$4.isNumber(def) && def >= 0 && def < this.opt.choices.realLength) {
          this.selected = def;
        } else if (!_$4.isNumber(def) && def != null) {
          const index = _$4.findIndex(
            this.opt.choices.realChoices,
            ({ value }) => value === def
          );
          this.selected = Math.max(index, 0);
        }

        // Make sure no default is set (so it won't be printed)
        this.opt.default = null;

        const shouldLoop = this.opt.loop === undefined ? true : this.opt.loop;
        this.paginator = new Paginator$3(this.screen, { isInfinite: shouldLoop });
      }

      /**
       * Start the Inquiry session
       * @param  {Function} cb      Callback when prompt is done
       * @return {this}
       */

      _run(cb) {
        this.done = cb;

        const self = this;

        const events = observe$7(this.rl);
        events.normalizedUpKey.pipe(takeUntil$6(events.line)).forEach(this.onUpKey.bind(this));
        events.normalizedDownKey
          .pipe(takeUntil$6(events.line))
          .forEach(this.onDownKey.bind(this));
        events.numberKey.pipe(takeUntil$6(events.line)).forEach(this.onNumberKey.bind(this));
        events.line
          .pipe(
            take$1(1),
            map$5(this.getCurrentValue.bind(this)),
            flatMap((value) =>
              runAsync(self.opt.filter)(value, self.answers).catch((err) => err)
            )
          )
          .forEach(this.onSubmit.bind(this));

        // Init the prompt
        cliCursor$1.hide();
        this.render();

        return this;
      }

      /**
       * Render the prompt to screen
       * @return {ListPrompt} self
       */

      render() {
        // Render question
        let message = this.getQuestion();

        if (this.firstRender) {
          message += chalk$7.dim('(Use arrow keys)');
        }

        // Render choices or answer depending on the state
        if (this.status === 'answered') {
          message += chalk$7.cyan(this.opt.choices.getChoice(this.selected).short);
        } else {
          const choicesStr = listRender(this.opt.choices, this.selected);
          const indexPosition = this.opt.choices.indexOf(
            this.opt.choices.getChoice(this.selected)
          );
          const realIndexPosition =
            this.opt.choices.reduce((acc, value, i) => {
              // Dont count lines past the choice we are looking at
              if (i > indexPosition) {
                return acc;
              }
              // Add line if it's a separator
              if (value.type === 'separator') {
                return acc + 1;
              }

              let l = value.name;
              // Non-strings take up one line
              if (typeof l !== 'string') {
                return acc + 1;
              }

              // Calculate lines taken up by string
              l = l.split('\n');
              return acc + l.length;
            }, 0) - 1;
          message +=
            '\n' + this.paginator.paginate(choicesStr, realIndexPosition, this.opt.pageSize);
        }

        this.firstRender = false;

        this.screen.render(message);
      }

      /**
       * When user press `enter` key
       */

      onSubmit(value) {
        this.status = 'answered';

        // Rerender prompt
        this.render();

        this.screen.done();
        cliCursor$1.show();
        this.done(value);
      }

      getCurrentValue() {
        return this.opt.choices.getChoice(this.selected).value;
      }

      /**
       * When user press a key
       */
      onUpKey() {
        this.selected = incrementListIndex$2(this.selected, 'up', this.opt);
        this.render();
      }

      onDownKey() {
        this.selected = incrementListIndex$2(this.selected, 'down', this.opt);
        this.render();
      }

      onNumberKey(input) {
        if (input <= this.opt.choices.realLength) {
          this.selected = input - 1;
        }

        this.render();
      }
    }

    /**
     * Function for rendering list choices
     * @param  {Number} pointer Position of the pointer
     * @return {String}         Rendered content
     */
    function listRender(choices, pointer) {
      let output = '';
      let separatorOffset = 0;

      choices.forEach((choice, i) => {
        if (choice.type === 'separator') {
          separatorOffset++;
          output += '  ' + choice + '\n';
          return;
        }

        if (choice.disabled) {
          separatorOffset++;
          output += '  - ' + choice.name;
          output += ' (' + (_$4.isString(choice.disabled) ? choice.disabled : 'Disabled') + ')';
          output += '\n';
          return;
        }

        const isSelected = i - separatorOffset === pointer;
        let line = (isSelected ? figures$1.pointer + ' ' : '  ') + choice.name;
        if (isSelected) {
          line = chalk$7.cyan(line);
        }

        output += line + ' \n';
      });

      return output.replace(/\n$/, '');
    }

    var list = ListPrompt;

    /**
     * `input` type prompt
     */

    const chalk$6 = source;
    const { map: map$4, takeUntil: takeUntil$5 } = require$$1$1;
    const Base$6 = base;
    const observe$6 = events;

    class InputPrompt extends Base$6 {
      /**
       * Start the Inquiry session
       * @param  {Function} cb      Callback when prompt is done
       * @return {this}
       */

      _run(cb) {
        this.done = cb;

        // Once user confirm (enter key)
        const events = observe$6(this.rl);
        const submit = events.line.pipe(map$4(this.filterInput.bind(this)));

        const validation = this.handleSubmitEvents(submit);
        validation.success.forEach(this.onEnd.bind(this));
        validation.error.forEach(this.onError.bind(this));

        events.keypress
          .pipe(takeUntil$5(validation.success))
          .forEach(this.onKeypress.bind(this));

        // Init
        this.render();

        return this;
      }

      /**
       * Render the prompt to screen
       * @return {InputPrompt} self
       */

      render(error) {
        let bottomContent = '';
        let appendContent = '';
        let message = this.getQuestion();
        const { transformer } = this.opt;
        const isFinal = this.status === 'answered';

        if (isFinal) {
          appendContent = this.answer;
        } else {
          appendContent = this.rl.line;
        }

        if (transformer) {
          message += transformer(appendContent, this.answers, { isFinal });
        } else {
          message += isFinal ? chalk$6.cyan(appendContent) : appendContent;
        }

        if (error) {
          bottomContent = chalk$6.red('>> ') + error;
        }

        this.screen.render(message, bottomContent);
      }

      /**
       * When user press `enter` key
       */

      filterInput(input) {
        if (!input) {
          return this.opt.default == null ? '' : this.opt.default;
        }

        return input;
      }

      onEnd(state) {
        this.answer = state.value;
        this.status = 'answered';

        // Re-render prompt
        this.render();

        this.screen.done();
        this.done(state.value);
      }

      onError({ value = '', isValid }) {
        this.rl.line += value;
        this.rl.cursor += value.length;
        this.render(isValid);
      }

      /**
       * When user press a key
       */

      onKeypress() {
        this.state = 'touched';

        this.render();
      }
    }

    var input = InputPrompt;

    /**
     * `input` type prompt
     */

    const Input = input;

    /**
     * Extention of the Input prompt specifically for use with number inputs.
     */

    class NumberPrompt extends Input {
      filterInput(input) {
        if (input && typeof input === 'string') {
          input = input.trim();
          // Match a number in the input
          const numberMatch = input.match(/(^-?\d+|^\d+\.\d*|^\d*\.\d+)(e\d+)?$/);
          // If a number is found, return that input.
          if (numberMatch) {
            return Number(numberMatch[0]);
          }
        }

        // If the input was invalid return the default value.
        return this.opt.default == null ? NaN : this.opt.default;
      }
    }

    var number = NumberPrompt;

    var baseGetTag = _baseGetTag,
        isObjectLike = isObjectLike_1;

    /** `Object#toString` result references. */
    var boolTag = '[object Boolean]';

    /**
     * Checks if `value` is classified as a boolean primitive or object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a boolean, else `false`.
     * @example
     *
     * _.isBoolean(false);
     * // => true
     *
     * _.isBoolean(null);
     * // => false
     */
    function isBoolean(value) {
      return value === true || value === false ||
        (isObjectLike(value) && baseGetTag(value) == boolTag);
    }

    var isBoolean_1 = isBoolean;

    /**
     * `confirm` type prompt
     */

    const _$3 = {
      extend: extend$1,
      isBoolean: isBoolean_1,
    };
    const chalk$5 = source;
    const { take, takeUntil: takeUntil$4 } = require$$1$1;
    const Base$5 = base;
    const observe$5 = events;

    class ConfirmPrompt extends Base$5 {
      constructor(questions, rl, answers) {
        super(questions, rl, answers);

        let rawDefault = true;

        _$3.extend(this.opt, {
          filter(input) {
            let value = rawDefault;
            if (input != null && input !== '') {
              value = /^y(es)?/i.test(input);
            }

            return value;
          },
        });

        if (_$3.isBoolean(this.opt.default)) {
          rawDefault = this.opt.default;
        }

        this.opt.default = rawDefault ? 'Y/n' : 'y/N';
      }

      /**
       * Start the Inquiry session
       * @param  {Function} cb   Callback when prompt is done
       * @return {this}
       */

      _run(cb) {
        this.done = cb;

        // Once user confirm (enter key)
        const events = observe$5(this.rl);
        events.keypress.pipe(takeUntil$4(events.line)).forEach(this.onKeypress.bind(this));

        events.line.pipe(take(1)).forEach(this.onEnd.bind(this));

        // Init
        this.render();

        return this;
      }

      /**
       * Render the prompt to screen
       * @return {ConfirmPrompt} self
       */

      render(answer) {
        let message = this.getQuestion();

        if (typeof answer === 'boolean') {
          message += chalk$5.cyan(answer ? 'Yes' : 'No');
        } else {
          message += this.rl.line;
        }

        this.screen.render(message);

        return this;
      }

      /**
       * When user press `enter` key
       */

      onEnd(input) {
        this.status = 'answered';

        const output = this.opt.filter(input);
        this.render(output);

        this.screen.done();
        this.done(output);
      }

      /**
       * When user press a key
       */

      onKeypress() {
        this.render();
      }
    }

    var confirm = ConfirmPrompt;

    /**
     * `rawlist` type prompt
     */

    const _$2 = {
      extend: extend$1,
      isNumber: isNumber_1,
      findIndex: findIndex_1,
    };
    const chalk$4 = source;
    const { map: map$3, takeUntil: takeUntil$3 } = require$$1$1;
    const Base$4 = base;
    const Separator$1 = separator;
    const observe$4 = events;
    const Paginator$2 = paginator;
    const incrementListIndex$1 = incrementListIndex_1;

    class RawListPrompt extends Base$4 {
      constructor(questions, rl, answers) {
        super(questions, rl, answers);

        if (!this.opt.choices) {
          this.throwParamError('choices');
        }

        this.opt.validChoices = this.opt.choices.filter(Separator$1.exclude);

        this.selected = 0;
        this.rawDefault = 0;

        _$2.extend(this.opt, {
          validate(val) {
            return val != null;
          },
        });

        const def = this.opt.default;
        if (_$2.isNumber(def) && def >= 0 && def < this.opt.choices.realLength) {
          this.selected = def;
          this.rawDefault = def;
        } else if (!_$2.isNumber(def) && def != null) {
          const index = _$2.findIndex(
            this.opt.choices.realChoices,
            ({ value }) => value === def
          );
          const safeIndex = Math.max(index, 0);
          this.selected = safeIndex;
          this.rawDefault = safeIndex;
        }

        // Make sure no default is set (so it won't be printed)
        this.opt.default = null;

        const shouldLoop = this.opt.loop === undefined ? true : this.opt.loop;
        this.paginator = new Paginator$2(undefined, { isInfinite: shouldLoop });
      }

      /**
       * Start the Inquiry session
       * @param  {Function} cb      Callback when prompt is done
       * @return {this}
       */

      _run(cb) {
        this.done = cb;

        // Once user confirm (enter key)
        const events = observe$4(this.rl);
        const submit = events.line.pipe(map$3(this.getCurrentValue.bind(this)));

        const validation = this.handleSubmitEvents(submit);
        validation.success.forEach(this.onEnd.bind(this));
        validation.error.forEach(this.onError.bind(this));

        events.normalizedUpKey
          .pipe(takeUntil$3(validation.success))
          .forEach(this.onUpKey.bind(this));
        events.normalizedDownKey
          .pipe(takeUntil$3(validation.success))
          .forEach(this.onDownKey.bind(this));
        events.keypress
          .pipe(takeUntil$3(validation.success))
          .forEach(this.onKeypress.bind(this));
        // Init the prompt
        this.render();

        return this;
      }

      /**
       * Render the prompt to screen
       * @return {RawListPrompt} self
       */

      render(error) {
        // Render question
        let message = this.getQuestion();
        let bottomContent = '';

        if (this.status === 'answered') {
          message += chalk$4.cyan(this.opt.choices.getChoice(this.selected).short);
        } else {
          const choicesStr = renderChoices$2(this.opt.choices, this.selected);
          message +=
            '\n' + this.paginator.paginate(choicesStr, this.selected, this.opt.pageSize);
          message += '\n  Answer: ';
        }
        message += this.rl.line;

        if (error) {
          bottomContent = '\n' + chalk$4.red('>> ') + error;
        }

        this.screen.render(message, bottomContent);
      }

      /**
       * When user press `enter` key
       */

      getCurrentValue(index) {
        if (index == null) {
          index = this.rawDefault;
        } else if (index === '') {
          this.selected = this.selected === undefined ? -1 : this.selected;
          index = this.selected;
        } else {
          index -= 1;
        }

        const choice = this.opt.choices.getChoice(index);
        return choice ? choice.value : null;
      }

      onEnd(state) {
        this.status = 'answered';
        this.answer = state.value;

        // Re-render prompt
        this.render();

        this.screen.done();
        this.done(state.value);
      }

      onError() {
        this.render('Please enter a valid index');
      }

      /**
       * When user press a key
       */

      onKeypress() {
        const index = this.rl.line.length ? Number(this.rl.line) - 1 : 0;

        if (this.opt.choices.getChoice(index)) {
          this.selected = index;
        } else {
          this.selected = undefined;
        }
        this.render();
      }

      /**
       * When user press up key
       */

      onUpKey() {
        this.onArrowKey('up');
      }

      /**
       * When user press down key
       */

      onDownKey() {
        this.onArrowKey('down');
      }

      /**
       * When user press up or down key
       * @param {String} type Arrow type: up or down
       */

      onArrowKey(type) {
        this.selected = incrementListIndex$1(this.selected, type, this.opt);
        this.rl.line = String(this.selected + 1);
      }
    }

    /**
     * Function for rendering list choices
     * @param  {Number} pointer Position of the pointer
     * @return {String}         Rendered content
     */

    function renderChoices$2(choices, pointer) {
      let output = '';
      let separatorOffset = 0;

      choices.forEach((choice, i) => {
        output += '\n  ';

        if (choice.type === 'separator') {
          separatorOffset++;
          output += ' ' + choice;
          return;
        }

        const index = i - separatorOffset;
        let display = index + 1 + ') ' + choice.name;
        if (index === pointer) {
          display = chalk$4.cyan(display);
        }

        output += display;
      });

      return output;
    }

    var rawlist = RawListPrompt;

    /**
     * The base implementation of `_.isNaN` without support for number objects.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
     */

    function baseIsNaN$1(value) {
      return value !== value;
    }

    var _baseIsNaN = baseIsNaN$1;

    /**
     * A specialized version of `_.indexOf` which performs strict equality
     * comparisons of values, i.e. `===`.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @param {number} fromIndex The index to search from.
     * @returns {number} Returns the index of the matched value, else `-1`.
     */

    function strictIndexOf$1(array, value, fromIndex) {
      var index = fromIndex - 1,
          length = array.length;

      while (++index < length) {
        if (array[index] === value) {
          return index;
        }
      }
      return -1;
    }

    var _strictIndexOf = strictIndexOf$1;

    var baseFindIndex = _baseFindIndex,
        baseIsNaN = _baseIsNaN,
        strictIndexOf = _strictIndexOf;

    /**
     * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @param {number} fromIndex The index to search from.
     * @returns {number} Returns the index of the matched value, else `-1`.
     */
    function baseIndexOf$1(array, value, fromIndex) {
      return value === value
        ? strictIndexOf(array, value, fromIndex)
        : baseFindIndex(array, baseIsNaN, fromIndex);
    }

    var _baseIndexOf = baseIndexOf$1;

    var baseIndexOf = _baseIndexOf;

    /**
     * A specialized version of `_.includes` for arrays without support for
     * specifying an index to search from.
     *
     * @private
     * @param {Array} [array] The array to inspect.
     * @param {*} target The value to search for.
     * @returns {boolean} Returns `true` if `target` is found, else `false`.
     */
    function arrayIncludes$1(array, value) {
      var length = array == null ? 0 : array.length;
      return !!length && baseIndexOf(array, value, 0) > -1;
    }

    var _arrayIncludes = arrayIncludes$1;

    /**
     * This function is like `arrayIncludes` except that it accepts a comparator.
     *
     * @private
     * @param {Array} [array] The array to inspect.
     * @param {*} target The value to search for.
     * @param {Function} comparator The comparator invoked per element.
     * @returns {boolean} Returns `true` if `target` is found, else `false`.
     */

    function arrayIncludesWith$1(array, value, comparator) {
      var index = -1,
          length = array == null ? 0 : array.length;

      while (++index < length) {
        if (comparator(value, array[index])) {
          return true;
        }
      }
      return false;
    }

    var _arrayIncludesWith = arrayIncludesWith$1;

    /**
     * This method returns `undefined`.
     *
     * @static
     * @memberOf _
     * @since 2.3.0
     * @category Util
     * @example
     *
     * _.times(2, _.noop);
     * // => [undefined, undefined]
     */

    function noop$1() {
      // No operation performed.
    }

    var noop_1 = noop$1;

    var Set$1 = _Set,
        noop = noop_1,
        setToArray$1 = _setToArray;

    /** Used as references for various `Number` constants. */
    var INFINITY = 1 / 0;

    /**
     * Creates a set object of `values`.
     *
     * @private
     * @param {Array} values The values to add to the set.
     * @returns {Object} Returns the new set.
     */
    var createSet$1 = !(Set$1 && (1 / setToArray$1(new Set$1([,-0]))[1]) == INFINITY) ? noop : function(values) {
      return new Set$1(values);
    };

    var _createSet = createSet$1;

    var SetCache = _SetCache,
        arrayIncludes = _arrayIncludes,
        arrayIncludesWith = _arrayIncludesWith,
        cacheHas = _cacheHas,
        createSet = _createSet,
        setToArray = _setToArray;

    /** Used as the size to enable large array optimizations. */
    var LARGE_ARRAY_SIZE = 200;

    /**
     * The base implementation of `_.uniqBy` without support for iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     */
    function baseUniq$1(array, iteratee, comparator) {
      var index = -1,
          includes = arrayIncludes,
          length = array.length,
          isCommon = true,
          result = [],
          seen = result;

      if (comparator) {
        isCommon = false;
        includes = arrayIncludesWith;
      }
      else if (length >= LARGE_ARRAY_SIZE) {
        var set = iteratee ? null : createSet(array);
        if (set) {
          return setToArray(set);
        }
        isCommon = false;
        includes = cacheHas;
        seen = new SetCache;
      }
      else {
        seen = iteratee ? [] : result;
      }
      outer:
      while (++index < length) {
        var value = array[index],
            computed = iteratee ? iteratee(value) : value;

        value = (comparator || value !== 0) ? value : 0;
        if (isCommon && computed === computed) {
          var seenIndex = seen.length;
          while (seenIndex--) {
            if (seen[seenIndex] === computed) {
              continue outer;
            }
          }
          if (iteratee) {
            seen.push(computed);
          }
          result.push(value);
        }
        else if (!includes(seen, computed, comparator)) {
          if (seen !== result) {
            seen.push(computed);
          }
          result.push(value);
        }
      }
      return result;
    }

    var _baseUniq = baseUniq$1;

    var baseUniq = _baseUniq;

    /**
     * Creates a duplicate-free version of an array, using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons, in which only the first occurrence of each element
     * is kept. The order of result values is determined by the order they occur
     * in the array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * _.uniq([2, 1, 2]);
     * // => [2, 1]
     */
    function uniq(array) {
      return (array && array.length) ? baseUniq(array) : [];
    }

    var uniq_1 = uniq;

    /**
     * `rawlist` type prompt
     */

    const _$1 = {
      uniq: uniq_1,
      isString: isString_1,
      isNumber: isNumber_1,
      findIndex: findIndex_1,
    };
    const chalk$3 = source;
    const { map: map$2, takeUntil: takeUntil$2 } = require$$1$1;
    const Base$3 = base;
    const Separator = separator;
    const observe$3 = events;
    const Paginator$1 = paginator;

    class ExpandPrompt extends Base$3 {
      constructor(questions, rl, answers) {
        super(questions, rl, answers);

        if (!this.opt.choices) {
          this.throwParamError('choices');
        }

        this.validateChoices(this.opt.choices);

        // Add the default `help` (/expand) option
        this.opt.choices.push({
          key: 'h',
          name: 'Help, list all options',
          value: 'help',
        });

        this.opt.validate = (choice) => {
          if (choice == null) {
            return 'Please enter a valid command';
          }

          return choice !== 'help';
        };

        // Setup the default string (capitalize the default key)
        this.opt.default = this.generateChoicesString(this.opt.choices, this.opt.default);

        this.paginator = new Paginator$1(this.screen);
      }

      /**
       * Start the Inquiry session
       * @param  {Function} cb      Callback when prompt is done
       * @return {this}
       */

      _run(cb) {
        this.done = cb;

        // Save user answer and update prompt to show selected option.
        const events = observe$3(this.rl);
        const validation = this.handleSubmitEvents(
          events.line.pipe(map$2(this.getCurrentValue.bind(this)))
        );
        validation.success.forEach(this.onSubmit.bind(this));
        validation.error.forEach(this.onError.bind(this));
        this.keypressObs = events.keypress
          .pipe(takeUntil$2(validation.success))
          .forEach(this.onKeypress.bind(this));

        // Init the prompt
        this.render();

        return this;
      }

      /**
       * Render the prompt to screen
       * @return {ExpandPrompt} self
       */

      render(error, hint) {
        let message = this.getQuestion();
        let bottomContent = '';

        if (this.status === 'answered') {
          message += chalk$3.cyan(this.answer);
        } else if (this.status === 'expanded') {
          const choicesStr = renderChoices$1(this.opt.choices, this.selectedKey);
          message += this.paginator.paginate(choicesStr, this.selectedKey, this.opt.pageSize);
          message += '\n  Answer: ';
        }

        message += this.rl.line;

        if (error) {
          bottomContent = chalk$3.red('>> ') + error;
        }

        if (hint) {
          bottomContent = chalk$3.cyan('>> ') + hint;
        }

        this.screen.render(message, bottomContent);
      }

      getCurrentValue(input) {
        if (!input) {
          input = this.rawDefault;
        }

        const selected = this.opt.choices.where({ key: input.toLowerCase().trim() })[0];
        if (!selected) {
          return null;
        }

        return selected.value;
      }

      /**
       * Generate the prompt choices string
       * @return {String}  Choices string
       */

      getChoices() {
        let output = '';

        this.opt.choices.forEach((choice) => {
          output += '\n  ';

          if (choice.type === 'separator') {
            output += ' ' + choice;
            return;
          }

          let choiceStr = choice.key + ') ' + choice.name;
          if (this.selectedKey === choice.key) {
            choiceStr = chalk$3.cyan(choiceStr);
          }

          output += choiceStr;
        });

        return output;
      }

      onError(state) {
        if (state.value === 'help') {
          this.selectedKey = '';
          this.status = 'expanded';
          this.render();
          return;
        }

        this.render(state.isValid);
      }

      /**
       * When user press `enter` key
       */

      onSubmit(state) {
        this.status = 'answered';
        const choice = this.opt.choices.where({ value: state.value })[0];
        this.answer = choice.short || choice.name;

        // Re-render prompt
        this.render();
        this.screen.done();
        this.done(state.value);
      }

      /**
       * When user press a key
       */

      onKeypress() {
        this.selectedKey = this.rl.line.toLowerCase();
        const selected = this.opt.choices.where({ key: this.selectedKey })[0];
        if (this.status === 'expanded') {
          this.render();
        } else {
          this.render(null, selected ? selected.name : null);
        }
      }

      /**
       * Validate the choices
       * @param {Array} choices
       */

      validateChoices(choices) {
        let formatError;
        const errors = [];
        const keymap = {};
        choices.filter(Separator.exclude).forEach((choice) => {
          if (!choice.key || choice.key.length !== 1) {
            formatError = true;
          }

          choice.key = String(choice.key).toLowerCase();

          if (keymap[choice.key]) {
            errors.push(choice.key);
          }

          keymap[choice.key] = true;
        });

        if (formatError) {
          throw new Error(
            'Format error: `key` param must be a single letter and is required.'
          );
        }

        if (keymap.h) {
          throw new Error(
            'Reserved key error: `key` param cannot be `h` - this value is reserved.'
          );
        }

        if (errors.length) {
          throw new Error(
            'Duplicate key error: `key` param must be unique. Duplicates: ' +
              _$1.uniq(errors).join(', ')
          );
        }
      }

      /**
       * Generate a string out of the choices keys
       * @param  {Array}  choices
       * @param  {Number|String} default - the choice index or name to capitalize
       * @return {String} The rendered choices key string
       */
      generateChoicesString(choices, defaultChoice) {
        let defIndex = choices.realLength - 1;
        if (_$1.isNumber(defaultChoice) && this.opt.choices.getChoice(defaultChoice)) {
          defIndex = defaultChoice;
        } else if (_$1.isString(defaultChoice)) {
          const index = _$1.findIndex(
            choices.realChoices,
            ({ value }) => value === defaultChoice
          );
          defIndex = index === -1 ? defIndex : index;
        }

        const defStr = this.opt.choices.pluck('key');
        this.rawDefault = defStr[defIndex];
        defStr[defIndex] = String(defStr[defIndex]).toUpperCase();
        return defStr.join('');
      }
    }

    /**
     * Function for rendering checkbox choices
     * @param  {String} pointer Selected key
     * @return {String}         Rendered content
     */

    function renderChoices$1(choices, pointer) {
      let output = '';

      choices.forEach((choice) => {
        output += '\n  ';

        if (choice.type === 'separator') {
          output += ' ' + choice;
          return;
        }

        let choiceStr = choice.key + ') ' + choice.name;
        if (pointer === choice.key) {
          choiceStr = chalk$3.cyan(choiceStr);
        }

        output += choiceStr;
      });

      return output;
    }

    var expand$2 = ExpandPrompt;

    /**
     * `list` type prompt
     */

    const _ = {
      isArray: isArray_1,
      map: map_1,
      isString: isString_1,
    };
    const chalk$2 = source;
    const cliCursor = cliCursor$3;
    const figures = figures$4.exports;
    const { map: map$1, takeUntil: takeUntil$1 } = require$$1$1;
    const Base$2 = base;
    const observe$2 = events;
    const Paginator = paginator;
    const incrementListIndex = incrementListIndex_1;

    class CheckboxPrompt extends Base$2 {
      constructor(questions, rl, answers) {
        super(questions, rl, answers);

        if (!this.opt.choices) {
          this.throwParamError('choices');
        }

        if (_.isArray(this.opt.default)) {
          this.opt.choices.forEach(function (choice) {
            if (this.opt.default.indexOf(choice.value) >= 0) {
              choice.checked = true;
            }
          }, this);
        }

        this.pointer = 0;

        // Make sure no default is set (so it won't be printed)
        this.opt.default = null;

        const shouldLoop = this.opt.loop === undefined ? true : this.opt.loop;
        this.paginator = new Paginator(this.screen, { isInfinite: shouldLoop });
      }

      /**
       * Start the Inquiry session
       * @param  {Function} cb      Callback when prompt is done
       * @return {this}
       */

      _run(cb) {
        this.done = cb;

        const events = observe$2(this.rl);

        const validation = this.handleSubmitEvents(
          events.line.pipe(map$1(this.getCurrentValue.bind(this)))
        );
        validation.success.forEach(this.onEnd.bind(this));
        validation.error.forEach(this.onError.bind(this));

        events.normalizedUpKey
          .pipe(takeUntil$1(validation.success))
          .forEach(this.onUpKey.bind(this));
        events.normalizedDownKey
          .pipe(takeUntil$1(validation.success))
          .forEach(this.onDownKey.bind(this));
        events.numberKey
          .pipe(takeUntil$1(validation.success))
          .forEach(this.onNumberKey.bind(this));
        events.spaceKey
          .pipe(takeUntil$1(validation.success))
          .forEach(this.onSpaceKey.bind(this));
        events.aKey.pipe(takeUntil$1(validation.success)).forEach(this.onAllKey.bind(this));
        events.iKey.pipe(takeUntil$1(validation.success)).forEach(this.onInverseKey.bind(this));

        // Init the prompt
        cliCursor.hide();
        this.render();
        this.firstRender = false;

        return this;
      }

      /**
       * Render the prompt to screen
       * @return {CheckboxPrompt} self
       */

      render(error) {
        // Render question
        let message = this.getQuestion();
        let bottomContent = '';

        if (!this.dontShowHints) {
          message +=
            '(Press ' +
            chalk$2.cyan.bold('<space>') +
            ' to select, ' +
            chalk$2.cyan.bold('<a>') +
            ' to toggle all, ' +
            chalk$2.cyan.bold('<i>') +
            ' to invert selection, and ' +
            chalk$2.cyan.bold('<enter>') +
            ' to proceed)';
        }

        // Render choices or answer depending on the state
        if (this.status === 'answered') {
          message += chalk$2.cyan(this.selection.join(', '));
        } else {
          const choicesStr = renderChoices(this.opt.choices, this.pointer);
          const indexPosition = this.opt.choices.indexOf(
            this.opt.choices.getChoice(this.pointer)
          );
          const realIndexPosition =
            this.opt.choices.reduce((acc, value, i) => {
              // Dont count lines past the choice we are looking at
              if (i > indexPosition) {
                return acc;
              }
              // Add line if it's a separator
              if (value.type === 'separator') {
                return acc + 1;
              }

              let l = value.name;
              // Non-strings take up one line
              if (typeof l !== 'string') {
                return acc + 1;
              }

              // Calculate lines taken up by string
              l = l.split('\n');
              return acc + l.length;
            }, 0) - 1;
          message +=
            '\n' + this.paginator.paginate(choicesStr, realIndexPosition, this.opt.pageSize);
        }

        if (error) {
          bottomContent = chalk$2.red('>> ') + error;
        }

        this.screen.render(message, bottomContent);
      }

      /**
       * When user press `enter` key
       */

      onEnd(state) {
        this.status = 'answered';
        this.dontShowHints = true;
        // Rerender prompt (and clean subline error)
        this.render();

        this.screen.done();
        cliCursor.show();
        this.done(state.value);
      }

      onError(state) {
        this.render(state.isValid);
      }

      getCurrentValue() {
        const choices = this.opt.choices.filter(
          (choice) => Boolean(choice.checked) && !choice.disabled
        );

        this.selection = _.map(choices, 'short');
        return _.map(choices, 'value');
      }

      onUpKey() {
        this.pointer = incrementListIndex(this.pointer, 'up', this.opt);
        this.render();
      }

      onDownKey() {
        this.pointer = incrementListIndex(this.pointer, 'down', this.opt);
        this.render();
      }

      onNumberKey(input) {
        if (input <= this.opt.choices.realLength) {
          this.pointer = input - 1;
          this.toggleChoice(this.pointer);
        }

        this.render();
      }

      onSpaceKey() {
        this.toggleChoice(this.pointer);
        this.render();
      }

      onAllKey() {
        const shouldBeChecked = Boolean(
          this.opt.choices.find((choice) => choice.type !== 'separator' && !choice.checked)
        );

        this.opt.choices.forEach((choice) => {
          if (choice.type !== 'separator') {
            choice.checked = shouldBeChecked;
          }
        });

        this.render();
      }

      onInverseKey() {
        this.opt.choices.forEach((choice) => {
          if (choice.type !== 'separator') {
            choice.checked = !choice.checked;
          }
        });

        this.render();
      }

      toggleChoice(index) {
        const item = this.opt.choices.getChoice(index);
        if (item !== undefined) {
          this.opt.choices.getChoice(index).checked = !item.checked;
        }
      }
    }

    /**
     * Function for rendering checkbox choices
     * @param  {Number} pointer Position of the pointer
     * @return {String}         Rendered content
     */

    function renderChoices(choices, pointer) {
      let output = '';
      let separatorOffset = 0;

      choices.forEach((choice, i) => {
        if (choice.type === 'separator') {
          separatorOffset++;
          output += ' ' + choice + '\n';
          return;
        }

        if (choice.disabled) {
          separatorOffset++;
          output += ' - ' + choice.name;
          output += ' (' + (_.isString(choice.disabled) ? choice.disabled : 'Disabled') + ')';
        } else {
          const line = getCheckbox(choice.checked) + ' ' + choice.name;
          if (i - separatorOffset === pointer) {
            output += chalk$2.cyan(figures.pointer + line);
          } else {
            output += ' ' + line;
          }
        }

        output += '\n';
      });

      return output.replace(/\n$/, '');
    }

    /**
     * Get the checkbox
     * @param  {Boolean} checked - add a X or not to the checkbox
     * @return {String} Composited checkbox string
     */

    function getCheckbox(checked) {
      return checked ? chalk$2.green(figures.radioOn) : figures.radioOff;
    }

    var checkbox = CheckboxPrompt;

    /**
     * `password` type prompt
     */

    const chalk$1 = source;
    const { map, takeUntil } = require$$1$1;
    const Base$1 = base;
    const observe$1 = events;

    function mask(input, maskChar) {
      input = String(input);
      maskChar = typeof maskChar === 'string' ? maskChar : '*';
      if (input.length === 0) {
        return '';
      }

      return new Array(input.length + 1).join(maskChar);
    }

    class PasswordPrompt extends Base$1 {
      /**
       * Start the Inquiry session
       * @param  {Function} cb      Callback when prompt is done
       * @return {this}
       */

      _run(cb) {
        this.done = cb;

        const events = observe$1(this.rl);

        // Once user confirm (enter key)
        const submit = events.line.pipe(map(this.filterInput.bind(this)));

        const validation = this.handleSubmitEvents(submit);
        validation.success.forEach(this.onEnd.bind(this));
        validation.error.forEach(this.onError.bind(this));

        events.keypress
          .pipe(takeUntil(validation.success))
          .forEach(this.onKeypress.bind(this));

        // Init
        this.render();

        return this;
      }

      /**
       * Render the prompt to screen
       * @return {PasswordPrompt} self
       */

      render(error) {
        let message = this.getQuestion();
        let bottomContent = '';

        if (this.status === 'answered') {
          message += this.getMaskedValue(this.answer);
        } else {
          message += this.getMaskedValue(this.rl.line || '');
        }

        if (error) {
          bottomContent = '\n' + chalk$1.red('>> ') + error;
        }

        this.screen.render(message, bottomContent);
      }

      getMaskedValue(value) {
        if (this.status === 'answered') {
          return this.opt.mask
            ? chalk$1.cyan(mask(value, this.opt.mask))
            : chalk$1.italic.dim('[hidden]');
        }
        return this.opt.mask
          ? mask(value, this.opt.mask)
          : chalk$1.italic.dim('[input is hidden] ');
      }

      /**
       * Mask value during async filter/validation.
       */
      getSpinningValue(value) {
        return this.getMaskedValue(value);
      }

      /**
       * When user press `enter` key
       */

      filterInput(input) {
        if (!input) {
          return this.opt.default == null ? '' : this.opt.default;
        }

        return input;
      }

      onEnd(state) {
        this.status = 'answered';
        this.answer = state.value;

        // Re-render prompt
        this.render();

        this.screen.done();
        this.done(state.value);
      }

      onError(state) {
        this.render(state.isValid);
      }

      onKeypress() {
        // If user press a key, just clear the default value
        if (this.opt.default) {
          this.opt.default = undefined;
        }

        this.render();
      }
    }

    var password = PasswordPrompt;

    var main$1 = {};

    var chardet = {};

    var match$1 = function(det, rec, confidence, name, lang) {
      this.confidence = confidence;
      this.name = name || rec.name(det);
      this.lang = lang;
    };

    var Match = match$1;

    /**
     * Charset recognizer for UTF-8
     */
    var utf8$1 = function() {
      this.name = function() {
        return 'UTF-8';
      };
      this.match = function(det) {

        var hasBOM = false,
          numValid = 0,
          numInvalid = 0,
          input = det.fRawInput,
          trailBytes = 0,
          confidence;

        if (det.fRawLength >= 3 &&
          (input[0] & 0xff) == 0xef && (input[1] & 0xff) == 0xbb && (input[2] & 0xff) == 0xbf) {
          hasBOM = true;
        }

        // Scan for multi-byte sequences
        for (var i = 0; i < det.fRawLength; i++) {
          var b = input[i];
          if ((b & 0x80) == 0)
            continue; // ASCII

          // Hi bit on char found.  Figure out how long the sequence should be
          if ((b & 0x0e0) == 0x0c0) {
            trailBytes = 1;
          } else if ((b & 0x0f0) == 0x0e0) {
            trailBytes = 2;
          } else if ((b & 0x0f8) == 0xf0) {
            trailBytes = 3;
          } else {
            numInvalid++;
            if (numInvalid > 5)
              break;
            trailBytes = 0;
          }

          // Verify that we've got the right number of trail bytes in the sequence
          for (;;) {
            i++;
            if (i >= det.fRawLength)
              break;

            if ((input[i] & 0xc0) != 0x080) {
              numInvalid++;
              break;
            }
            if (--trailBytes == 0) {
              numValid++;
              break;
            }
          }
        }

        // Cook up some sort of confidence score, based on presense of a BOM
        //    and the existence of valid and/or invalid multi-byte sequences.
        confidence = 0;
        if (hasBOM && numInvalid == 0)
          confidence = 100;
        else if (hasBOM && numValid > numInvalid * 10)
          confidence = 80;
        else if (numValid > 3 && numInvalid == 0)
          confidence = 100;
        else if (numValid > 0 && numInvalid == 0)
          confidence = 80;
        else if (numValid == 0 && numInvalid == 0)
          // Plain ASCII.
          confidence = 10;
        else if (numValid > numInvalid * 10)
          // Probably corruput utf-8 data.  Valid sequences aren't likely by chance.
          confidence = 25;
        else
          return null

        return new Match(det, this, confidence);
      };
    };

    var unicode$1 = {exports: {}};

    (function (module) {
    var util = require$$0__default$1["default"],
      Match = match$1;

    /**
     * This class matches UTF-16 and UTF-32, both big- and little-endian. The
     * BOM will be used if it is present.
     */
    module.exports.UTF_16BE = function() {
      this.name = function() {
        return 'UTF-16BE';
      };
      this.match = function(det) {
        var input = det.fRawInput;

        if (input.length >= 2 && ((input[0] & 0xff) == 0xfe && (input[1] & 0xff) == 0xff)) {
          return new Match(det, this, 100); // confidence = 100
        }

        // TODO: Do some statistics to check for unsigned UTF-16BE
        return null;
      };
    };

    module.exports.UTF_16LE = function() {
      this.name = function() {
        return 'UTF-16LE';
      };
      this.match = function(det) {
        var input = det.fRawInput;

        if (input.length >= 2 && ((input[0] & 0xff) == 0xff && (input[1] & 0xff) == 0xfe)) {
          // LE BOM is present.
          if (input.length >= 4 && input[2] == 0x00 && input[3] == 0x00) {
            // It is probably UTF-32 LE, not UTF-16
            return null;
          }
          return new Match(det, this, 100); // confidence = 100
        }

        // TODO: Do some statistics to check for unsigned UTF-16LE
        return null;
      };
    };

    function UTF_32() {}UTF_32.prototype.match = function(det) {
      var input      = det.fRawInput,
        limit      = (det.fRawLength / 4) * 4,
        numValid   = 0,
        numInvalid = 0,
        hasBOM     = false,
        confidence = 0;

      if (limit == 0) {
        return null;
      }

      if (this.getChar(input, 0) == 0x0000FEFF) {
        hasBOM = true;
      }

      for (var i = 0; i < limit; i += 4) {
        var ch = this.getChar(input, i);

        if (ch < 0 || ch >= 0x10FFFF || (ch >= 0xD800 && ch <= 0xDFFF)) {
          numInvalid += 1;
        } else {
          numValid += 1;
        }
      }

      // Cook up some sort of confidence score, based on presence of a BOM
      //    and the existence of valid and/or invalid multi-byte sequences.
      if (hasBOM && numInvalid == 0) {
        confidence = 100;
      } else if (hasBOM && numValid > numInvalid * 10) {
        confidence = 80;
      } else if (numValid > 3 && numInvalid == 0) {
        confidence = 100;
      } else if (numValid > 0 && numInvalid == 0) {
        confidence = 80;
      } else if (numValid > numInvalid * 10) {
        // Probably corrupt UTF-32BE data.  Valid sequences aren't likely by chance.
        confidence = 25;
      }

      // return confidence == 0 ? null : new CharsetMatch(det, this, confidence);
      return confidence == 0 ? null : new Match(det, this, confidence);
    };

    module.exports.UTF_32BE = function() {
      this.name = function() {
        return 'UTF-32BE';
      };
      this.getChar = function(input, index) {
        return (input[index + 0] & 0xff) << 24 | (input[index + 1] & 0xff) << 16 |
             (input[index + 2] & 0xff) <<  8 | (input[index + 3] & 0xff);
      };
    };
    util.inherits(module.exports.UTF_32BE, UTF_32);

    module.exports.UTF_32LE = function() {
      this.name = function() {
        return 'UTF-32LE';
      };
      this.getChar = function(input, index) {
        return (input[index + 3] & 0xff) << 24 | (input[index + 2] & 0xff) << 16 |
             (input[index + 1] & 0xff) <<  8 | (input[index + 0] & 0xff);
      };
    };
    util.inherits(module.exports.UTF_32LE, UTF_32);
    }(unicode$1));

    var mbcs$1 = {exports: {}};

    (function (module) {
    var util = require$$0__default$1["default"],
      Match = match$1;

    /**
     * Binary search implementation (recursive)
     */
    function binarySearch(arr, searchValue) {
      function find(arr, searchValue, left, right) {
        if (right < left)
          return -1;

        /*
        int mid = mid = (left + right) / 2;
        There is a bug in the above line;
        Joshua Bloch suggests the following replacement:
        */
        var mid = Math.floor((left + right) >>> 1);
        if (searchValue > arr[mid])
          return find(arr, searchValue, mid + 1, right);

        if (searchValue < arr[mid])
          return find(arr, searchValue, left, mid - 1);

        return mid;
      }
      return find(arr, searchValue, 0, arr.length - 1);
    }
    // 'Character'  iterated character class.
    //    Recognizers for specific mbcs encodings make their 'characters' available
    //    by providing a nextChar() function that fills in an instance of iteratedChar
    //    with the next char from the input.
    //    The returned characters are not converted to Unicode, but remain as the raw
    //    bytes (concatenated into an int) from the codepage data.
    //
    //  For Asian charsets, use the raw input rather than the input that has been
    //   stripped of markup.  Detection only considers multi-byte chars, effectively
    //   stripping markup anyway, and double byte chars do occur in markup too.
    //
    function IteratedChar() {

      this.charValue = 0; // 1-4 bytes from the raw input data
      this.index     = 0;
      this.nextIndex = 0;
      this.error     = false;
      this.done      = false;

      this.reset = function() {
        this.charValue = 0;
        this.index     = -1;
        this.nextIndex = 0;
        this.error     = false;
        this.done      = false;
      };

      this.nextByte = function(det) {
        if (this.nextIndex >= det.fRawLength) {
          this.done = true;
          return -1;
        }
        var byteValue = det.fRawInput[this.nextIndex++] & 0x00ff;
        return byteValue;
      };
    }


    /**
     * Asian double or multi-byte - charsets.
     * Match is determined mostly by the input data adhering to the
     * encoding scheme for the charset, and, optionally,
     * frequency-of-occurence of characters.
     */

    function mbcs() {}
    /**
     * Test the match of this charset with the input text data
     *      which is obtained via the CharsetDetector object.
     *
     * @param det  The CharsetDetector, which contains the input text
     *             to be checked for being in this charset.
     * @return     Two values packed into one int  (Damn java, anyhow)
     *             bits 0-7:  the match confidence, ranging from 0-100
     *             bits 8-15: The match reason, an enum-like value.
     */
    mbcs.prototype.match = function(det) {

      var doubleByteCharCount = 0,
        commonCharCount     = 0,
        badCharCount        = 0,
        totalCharCount      = 0,
        confidence          = 0;

      var iter = new IteratedChar();

      detectBlock: {
        for (iter.reset(); this.nextChar(iter, det);) {
          totalCharCount++;
          if (iter.error) {
            badCharCount++;
          } else {
            var cv = iter.charValue & 0xFFFFFFFF;

            if (cv <= 0xff) ; else {
              doubleByteCharCount++;
              if (this.commonChars != null) {
                // NOTE: This assumes that there are no 4-byte common chars.
                if (binarySearch(this.commonChars, cv) >= 0) {
                  commonCharCount++;
                }
              }
            }
          }
          if (badCharCount >= 2 && badCharCount * 5 >= doubleByteCharCount) {
            // console.log('its here!')
            // Bail out early if the byte data is not matching the encoding scheme.
            break detectBlock;
          }
        }

        if (doubleByteCharCount <= 10 && badCharCount== 0) {
          // Not many multi-byte chars.
          if (doubleByteCharCount == 0 && totalCharCount < 10) {
            // There weren't any multibyte sequences, and there was a low density of non-ASCII single bytes.
            // We don't have enough data to have any confidence.
            // Statistical analysis of single byte non-ASCII charcters would probably help here.
            confidence = 0;
          }
          else {
            //   ASCII or ISO file?  It's probably not our encoding,
            //   but is not incompatible with our encoding, so don't give it a zero.
            confidence = 10;
          }
          break detectBlock;
        }

        //
        //  No match if there are too many characters that don't fit the encoding scheme.
        //    (should we have zero tolerance for these?)
        //
        if (doubleByteCharCount < 20 * badCharCount) {
          confidence = 0;
          break detectBlock;
        }

        if (this.commonChars == null) {
          // We have no statistics on frequently occuring characters.
          //  Assess confidence purely on having a reasonable number of
          //  multi-byte characters (the more the better
          confidence = 30 + doubleByteCharCount - 20 * badCharCount;
          if (confidence > 100) {
            confidence = 100;
          }
        } else {
          //
          // Frequency of occurence statistics exist.
          //
          var maxVal = Math.log(parseFloat(doubleByteCharCount) / 4);
          var scaleFactor = 90.0 / maxVal;
          confidence = Math.floor(Math.log(commonCharCount + 1) * scaleFactor + 10);
          confidence = Math.min(confidence, 100);
        }
      }   // end of detectBlock:

      return confidence == 0 ? null : new Match(det, this, confidence);
    };

    /**
     * Get the next character (however many bytes it is) from the input data
     *    Subclasses for specific charset encodings must implement this function
     *    to get characters according to the rules of their encoding scheme.
     *
     *  This function is not a method of class iteratedChar only because
     *   that would require a lot of extra derived classes, which is awkward.
     * @param it  The iteratedChar 'struct' into which the returned char is placed.
     * @param det The charset detector, which is needed to get at the input byte data
     *            being iterated over.
     * @return    True if a character was returned, false at end of input.
     */

    mbcs.prototype.nextChar = function(iter, det) {};



    /**
     * Shift-JIS charset recognizer.
     */
    module.exports.sjis = function() {
      this.name = function() {
        return 'Shift-JIS';
      };
      this.language = function() {
        return 'ja';
      };

      // TODO:  This set of data comes from the character frequency-
      //        of-occurence analysis tool.  The data needs to be moved
      //        into a resource and loaded from there.
      this.commonChars = [
        0x8140, 0x8141, 0x8142, 0x8145, 0x815b, 0x8169, 0x816a, 0x8175, 0x8176, 0x82a0,
        0x82a2, 0x82a4, 0x82a9, 0x82aa, 0x82ab, 0x82ad, 0x82af, 0x82b1, 0x82b3, 0x82b5,
        0x82b7, 0x82bd, 0x82be, 0x82c1, 0x82c4, 0x82c5, 0x82c6, 0x82c8, 0x82c9, 0x82cc,
        0x82cd, 0x82dc, 0x82e0, 0x82e7, 0x82e8, 0x82e9, 0x82ea, 0x82f0, 0x82f1, 0x8341,
        0x8343, 0x834e, 0x834f, 0x8358, 0x835e, 0x8362, 0x8367, 0x8375, 0x8376, 0x8389,
        0x838a, 0x838b, 0x838d, 0x8393, 0x8e96, 0x93fa, 0x95aa
      ];

      this.nextChar = function(iter, det) {
        iter.index = iter.nextIndex;
        iter.error = false;

        var firstByte;
        firstByte = iter.charValue = iter.nextByte(det);
        if (firstByte < 0)
          return false;

        if (firstByte <= 0x7f || (firstByte > 0xa0 && firstByte <= 0xdf))
          return true;

        var secondByte = iter.nextByte(det);
        if (secondByte < 0)
          return false;

        iter.charValue = (firstByte << 8) | secondByte;
        if (! ((secondByte >= 0x40 && secondByte <= 0x7f) || (secondByte >= 0x80 && secondByte <= 0xff))) {
          // Illegal second byte value.
          iter.error = true;
        }
        return true;
      };
    };
    util.inherits(module.exports.sjis, mbcs);



    /**
     *   Big5 charset recognizer.
     */
    module.exports.big5 = function() {
      this.name = function() {
        return 'Big5';
      };
      this.language = function() {
        return 'zh';
      };
      // TODO:  This set of data comes from the character frequency-
      //        of-occurence analysis tool.  The data needs to be moved
      //        into a resource and loaded from there.
      this.commonChars = [
        0xa140, 0xa141, 0xa142, 0xa143, 0xa147, 0xa149, 0xa175, 0xa176, 0xa440, 0xa446,
        0xa447, 0xa448, 0xa451, 0xa454, 0xa457, 0xa464, 0xa46a, 0xa46c, 0xa477, 0xa4a3,
        0xa4a4, 0xa4a7, 0xa4c1, 0xa4ce, 0xa4d1, 0xa4df, 0xa4e8, 0xa4fd, 0xa540, 0xa548,
        0xa558, 0xa569, 0xa5cd, 0xa5e7, 0xa657, 0xa661, 0xa662, 0xa668, 0xa670, 0xa6a8,
        0xa6b3, 0xa6b9, 0xa6d3, 0xa6db, 0xa6e6, 0xa6f2, 0xa740, 0xa751, 0xa759, 0xa7da,
        0xa8a3, 0xa8a5, 0xa8ad, 0xa8d1, 0xa8d3, 0xa8e4, 0xa8fc, 0xa9c0, 0xa9d2, 0xa9f3,
        0xaa6b, 0xaaba, 0xaabe, 0xaacc, 0xaafc, 0xac47, 0xac4f, 0xacb0, 0xacd2, 0xad59,
        0xaec9, 0xafe0, 0xb0ea, 0xb16f, 0xb2b3, 0xb2c4, 0xb36f, 0xb44c, 0xb44e, 0xb54c,
        0xb5a5, 0xb5bd, 0xb5d0, 0xb5d8, 0xb671, 0xb7ed, 0xb867, 0xb944, 0xbad8, 0xbb44,
        0xbba1, 0xbdd1, 0xc2c4, 0xc3b9, 0xc440, 0xc45f
      ];
      this.nextChar = function(iter, det) {
        iter.index = iter.nextIndex;
        iter.error = false;

        var firstByte = iter.charValue = iter.nextByte(det);

        if (firstByte < 0)
          return false;

        // single byte character.
        if (firstByte <= 0x7f || firstByte == 0xff)
          return true;

        var secondByte = iter.nextByte(det);

        if (secondByte < 0)
          return false;

        iter.charValue = (iter.charValue << 8) | secondByte;

        if (secondByte < 0x40 || secondByte == 0x7f || secondByte == 0xff)
          iter.error = true;

        return true;
      };
    };
    util.inherits(module.exports.big5, mbcs);



    /**
     *  EUC charset recognizers.  One abstract class that provides the common function
     *  for getting the next character according to the EUC encoding scheme,
     *  and nested derived classes for EUC_KR, EUC_JP, EUC_CN.
     *
     *  Get the next character value for EUC based encodings.
     *  Character 'value' is simply the raw bytes that make up the character
     *     packed into an int.
     */
    function eucNextChar(iter, det) {
      iter.index = iter.nextIndex;
      iter.error = false;
      var firstByte  = 0;
      var secondByte = 0;
      var thirdByte  = 0;
      //int fourthByte = 0;
      buildChar: {
        firstByte = iter.charValue = iter.nextByte(det);
        if (firstByte < 0) {
          // Ran off the end of the input data
          iter.done = true;
          break buildChar;
        }
        if (firstByte <= 0x8d) {
          // single byte char
          break buildChar;
        }
        secondByte = iter.nextByte(det);
        iter.charValue = (iter.charValue << 8) | secondByte;
        if (firstByte >= 0xA1 && firstByte <= 0xfe) {
          // Two byte Char
          if (secondByte < 0xa1) {
            iter.error = true;
          }
          break buildChar;
        }
        if (firstByte == 0x8e) {
          // Code Set 2.
          //   In EUC-JP, total char size is 2 bytes, only one byte of actual char value.
          //   In EUC-TW, total char size is 4 bytes, three bytes contribute to char value.
          // We don't know which we've got.
          // Treat it like EUC-JP.  If the data really was EUC-TW, the following two
          //   bytes will look like a well formed 2 byte char.
          if (secondByte < 0xa1) {
            iter.error = true;
          }
          break buildChar;
        }
        if (firstByte == 0x8f) {
          // Code set 3.
          // Three byte total char size, two bytes of actual char value.
          thirdByte = iter.nextByte(det);
          iter.charValue = (iter.charValue << 8) | thirdByte;
          if (thirdByte < 0xa1) {
            iter.error = true;
          }
        }
      }
      return iter.done == false;
    }


    /**
     * The charset recognize for EUC-JP.  A singleton instance of this class
     *    is created and kept by the public CharsetDetector class
     */
    module.exports.euc_jp = function() {
      this.name = function() {
        return 'EUC-JP';
      };
      this.language = function() {
        return 'ja';
      };

      // TODO:  This set of data comes from the character frequency-
      //        of-occurence analysis tool.  The data needs to be moved
      //        into a resource and loaded from there.
      this.commonChars = [
        0xa1a1, 0xa1a2, 0xa1a3, 0xa1a6, 0xa1bc, 0xa1ca, 0xa1cb, 0xa1d6, 0xa1d7, 0xa4a2,
        0xa4a4, 0xa4a6, 0xa4a8, 0xa4aa, 0xa4ab, 0xa4ac, 0xa4ad, 0xa4af, 0xa4b1, 0xa4b3,
        0xa4b5, 0xa4b7, 0xa4b9, 0xa4bb, 0xa4bd, 0xa4bf, 0xa4c0, 0xa4c1, 0xa4c3, 0xa4c4,
        0xa4c6, 0xa4c7, 0xa4c8, 0xa4c9, 0xa4ca, 0xa4cb, 0xa4ce, 0xa4cf, 0xa4d0, 0xa4de,
        0xa4df, 0xa4e1, 0xa4e2, 0xa4e4, 0xa4e8, 0xa4e9, 0xa4ea, 0xa4eb, 0xa4ec, 0xa4ef,
        0xa4f2, 0xa4f3, 0xa5a2, 0xa5a3, 0xa5a4, 0xa5a6, 0xa5a7, 0xa5aa, 0xa5ad, 0xa5af,
        0xa5b0, 0xa5b3, 0xa5b5, 0xa5b7, 0xa5b8, 0xa5b9, 0xa5bf, 0xa5c3, 0xa5c6, 0xa5c7,
        0xa5c8, 0xa5c9, 0xa5cb, 0xa5d0, 0xa5d5, 0xa5d6, 0xa5d7, 0xa5de, 0xa5e0, 0xa5e1,
        0xa5e5, 0xa5e9, 0xa5ea, 0xa5eb, 0xa5ec, 0xa5ed, 0xa5f3, 0xb8a9, 0xb9d4, 0xbaee,
        0xbbc8, 0xbef0, 0xbfb7, 0xc4ea, 0xc6fc, 0xc7bd, 0xcab8, 0xcaf3, 0xcbdc, 0xcdd1
      ];

      this.nextChar = eucNextChar;
    };
    util.inherits(module.exports.euc_jp, mbcs);



    /**
     * The charset recognize for EUC-KR.  A singleton instance of this class
     *    is created and kept by the public CharsetDetector class
     */
    module.exports.euc_kr = function() {
      this.name = function() {
        return 'EUC-KR';
      };
      this.language = function() {
        return 'ko';
      };

      // TODO:  This set of data comes from the character frequency-
      //        of-occurence analysis tool.  The data needs to be moved
      //        into a resource and loaded from there.
      this.commonChars = [
        0xb0a1, 0xb0b3, 0xb0c5, 0xb0cd, 0xb0d4, 0xb0e6, 0xb0ed, 0xb0f8, 0xb0fa, 0xb0fc,
        0xb1b8, 0xb1b9, 0xb1c7, 0xb1d7, 0xb1e2, 0xb3aa, 0xb3bb, 0xb4c2, 0xb4cf, 0xb4d9,
        0xb4eb, 0xb5a5, 0xb5b5, 0xb5bf, 0xb5c7, 0xb5e9, 0xb6f3, 0xb7af, 0xb7c2, 0xb7ce,
        0xb8a6, 0xb8ae, 0xb8b6, 0xb8b8, 0xb8bb, 0xb8e9, 0xb9ab, 0xb9ae, 0xb9cc, 0xb9ce,
        0xb9fd, 0xbab8, 0xbace, 0xbad0, 0xbaf1, 0xbbe7, 0xbbf3, 0xbbfd, 0xbcad, 0xbcba,
        0xbcd2, 0xbcf6, 0xbdba, 0xbdc0, 0xbdc3, 0xbdc5, 0xbec6, 0xbec8, 0xbedf, 0xbeee,
        0xbef8, 0xbefa, 0xbfa1, 0xbfa9, 0xbfc0, 0xbfe4, 0xbfeb, 0xbfec, 0xbff8, 0xc0a7,
        0xc0af, 0xc0b8, 0xc0ba, 0xc0bb, 0xc0bd, 0xc0c7, 0xc0cc, 0xc0ce, 0xc0cf, 0xc0d6,
        0xc0da, 0xc0e5, 0xc0fb, 0xc0fc, 0xc1a4, 0xc1a6, 0xc1b6, 0xc1d6, 0xc1df, 0xc1f6,
        0xc1f8, 0xc4a1, 0xc5cd, 0xc6ae, 0xc7cf, 0xc7d1, 0xc7d2, 0xc7d8, 0xc7e5, 0xc8ad
      ];

      this.nextChar = eucNextChar;
    };
    util.inherits(module.exports.euc_kr, mbcs);



    /**
     *   GB-18030 recognizer. Uses simplified Chinese statistics.
     */
    module.exports.gb_18030 = function() {
      this.name = function() {
        return 'GB18030';
      };
      this.language = function() {
        return 'zh';
      };

      /*
       *  Get the next character value for EUC based encodings.
       *  Character 'value' is simply the raw bytes that make up the character
       *     packed into an int.
       */
      this.nextChar = function(iter, det) {
        iter.index = iter.nextIndex;
        iter.error = false;
        var firstByte  = 0;
        var secondByte = 0;
        var thirdByte  = 0;
        var fourthByte = 0;
        buildChar: {
          firstByte = iter.charValue = iter.nextByte(det);
          if (firstByte < 0) {
            // Ran off the end of the input data
            iter.done = true;
            break buildChar;
          }
          if (firstByte <= 0x80) {
            // single byte char
            break buildChar;
          }
          secondByte = iter.nextByte(det);
          iter.charValue = (iter.charValue << 8) | secondByte;
          if (firstByte >= 0x81 && firstByte <= 0xFE) {
            // Two byte Char
            if ((secondByte >= 0x40 && secondByte <= 0x7E) || (secondByte >=80 && secondByte <= 0xFE)) {
              break buildChar;
            }
            // Four byte char
            if (secondByte >= 0x30 && secondByte <= 0x39) {
              thirdByte = iter.nextByte(det);
              if (thirdByte >= 0x81 && thirdByte <= 0xFE) {
                fourthByte = iter.nextByte(det);
                if (fourthByte >= 0x30 && fourthByte <= 0x39) {
                  iter.charValue = (iter.charValue << 16) | (thirdByte << 8) | fourthByte;
                  break buildChar;
                }
              }
            }
            iter.error = true;
            break buildChar;
          }
        }
        return iter.done == false;
      };

      // TODO:  This set of data comes from the character frequency-
      //        of-occurence analysis tool.  The data needs to be moved
      //        into a resource and loaded from there.
      this.commonChars = [
        0xa1a1, 0xa1a2, 0xa1a3, 0xa1a4, 0xa1b0, 0xa1b1, 0xa1f1, 0xa1f3, 0xa3a1, 0xa3ac,
        0xa3ba, 0xb1a8, 0xb1b8, 0xb1be, 0xb2bb, 0xb3c9, 0xb3f6, 0xb4f3, 0xb5bd, 0xb5c4,
        0xb5e3, 0xb6af, 0xb6d4, 0xb6e0, 0xb7a2, 0xb7a8, 0xb7bd, 0xb7d6, 0xb7dd, 0xb8b4,
        0xb8df, 0xb8f6, 0xb9ab, 0xb9c9, 0xb9d8, 0xb9fa, 0xb9fd, 0xbacd, 0xbba7, 0xbbd6,
        0xbbe1, 0xbbfa, 0xbcbc, 0xbcdb, 0xbcfe, 0xbdcc, 0xbecd, 0xbedd, 0xbfb4, 0xbfc6,
        0xbfc9, 0xc0b4, 0xc0ed, 0xc1cb, 0xc2db, 0xc3c7, 0xc4dc, 0xc4ea, 0xc5cc, 0xc6f7,
        0xc7f8, 0xc8ab, 0xc8cb, 0xc8d5, 0xc8e7, 0xc9cf, 0xc9fa, 0xcab1, 0xcab5, 0xcac7,
        0xcad0, 0xcad6, 0xcaf5, 0xcafd, 0xccec, 0xcdf8, 0xceaa, 0xcec4, 0xced2, 0xcee5,
        0xcfb5, 0xcfc2, 0xcfd6, 0xd0c2, 0xd0c5, 0xd0d0, 0xd0d4, 0xd1a7, 0xd2aa, 0xd2b2,
        0xd2b5, 0xd2bb, 0xd2d4, 0xd3c3, 0xd3d0, 0xd3fd, 0xd4c2, 0xd4da, 0xd5e2, 0xd6d0
      ];
    };
    util.inherits(module.exports.gb_18030, mbcs);
    }(mbcs$1));

    var sbcs$1 = {exports: {}};

    (function (module) {
    var util = require$$0__default$1["default"],
      Match = match$1;

    /**
     * This class recognizes single-byte encodings. Because the encoding scheme is so
     * simple, language statistics are used to do the matching.
     */

    function NGramParser(theNgramList, theByteMap) {
      var N_GRAM_MASK = 0xFFFFFF;

      this.byteIndex = 0;
      this.ngram = 0;

      this.ngramList = theNgramList;
      this.byteMap = theByteMap;

      this.ngramCount = 0;
      this.hitCount = 0;

      this.spaceChar;

      /*
       * Binary search for value in table, which must have exactly 64 entries.
       */
      this.search = function(table, value) {
        var index = 0;

        if (table[index + 32] <= value) index += 32;
        if (table[index + 16] <= value) index += 16;
        if (table[index + 8]  <= value) index += 8;
        if (table[index + 4]  <= value) index += 4;
        if (table[index + 2]  <= value) index += 2;
        if (table[index + 1]  <= value) index += 1;
        if (table[index]      > value)  index -= 1;

        if (index < 0 || table[index] != value)
          return -1;

        return index;
      };

      this.lookup = function(thisNgram) {
        this.ngramCount += 1;
        if (this.search(this.ngramList, thisNgram) >= 0) {
          this.hitCount += 1;
        }
      };

      this.addByte = function(b) {
        this.ngram = ((this.ngram << 8) + (b & 0xFF)) & N_GRAM_MASK;
        this.lookup(this.ngram);
      };

      this.nextByte = function(det) {
        if (this.byteIndex >= det.fInputLen)
          return -1;

        return det.fInputBytes[this.byteIndex++] & 0xFF;
      };

      this.parse = function(det, spaceCh) {
        var b, ignoreSpace = false;
        this.spaceChar = spaceCh;

        while ((b = this.nextByte(det)) >= 0) {
          var mb = this.byteMap[b];

          // TODO: 0x20 might not be a space in all character sets...
          if (mb != 0) {
            if (!(mb == this.spaceChar && ignoreSpace)) {
              this.addByte(mb);
            }

            ignoreSpace = (mb == this.spaceChar);
          }
        }

        // TODO: Is this OK? The buffer could have ended in the middle of a word...
        this.addByte(this.spaceChar);

        var rawPercent = this.hitCount / this.ngramCount;

        // TODO - This is a bit of a hack to take care of a case
        // were we were getting a confidence of 135...
        if (rawPercent > 0.33)
          return 98;

        return Math.floor(rawPercent * 300.0);
      };
    }
    function NGramsPlusLang(la, ng) {
      this.fLang = la;
      this.fNGrams = ng;
    }
    function sbcs() {}sbcs.prototype.spaceChar = 0x20;
    sbcs.prototype.ngrams = function() {};
    sbcs.prototype.byteMap = function() {};
    sbcs.prototype.match = function(det) {

      var ngrams = this.ngrams();
      var multiple = (Array.isArray(ngrams) && ngrams[0] instanceof NGramsPlusLang);

      if (!multiple) {
        var parser = new NGramParser(ngrams, this.byteMap());
        var confidence = parser.parse(det, this.spaceChar);
        return confidence <= 0 ? null : new Match(det, this, confidence);
      }

      var bestConfidenceSoFar = -1;
      var lang = null;

      for (var i = ngrams.length - 1; i >= 0; i--) {
        var ngl = ngrams[i];

        var parser = new NGramParser(ngl.fNGrams, this.byteMap());
        var confidence = parser.parse(det, this.spaceChar);
        if (confidence > bestConfidenceSoFar) {
          bestConfidenceSoFar = confidence;
          lang = ngl.fLang;
        }
      }

      var name = this.name(det);
      return bestConfidenceSoFar <= 0 ? null : new Match(det, this, bestConfidenceSoFar, name, lang);
    };


    module.exports.ISO_8859_1 = function() {
      this.byteMap = function() {
        return [
          0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
          0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
          0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
          0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
          0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x00,
          0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
          0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
          0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
          0x20, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,
          0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F,
          0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,
          0x78, 0x79, 0x7A, 0x20, 0x20, 0x20, 0x20, 0x20,
          0x20, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,
          0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F,
          0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,
          0x78, 0x79, 0x7A, 0x20, 0x20, 0x20, 0x20, 0x20,
          0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
          0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
          0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
          0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
          0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
          0x20, 0x20, 0xAA, 0x20, 0x20, 0x20, 0x20, 0x20,
          0x20, 0x20, 0x20, 0x20, 0x20, 0xB5, 0x20, 0x20,
          0x20, 0x20, 0xBA, 0x20, 0x20, 0x20, 0x20, 0x20,
          0xE0, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7,
          0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF,
          0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0x20,
          0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE, 0xDF,
          0xE0, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7,
          0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF,
          0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0x20,
          0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE, 0xFF
        ];
      };

      this.ngrams = function() {
        return [
          new NGramsPlusLang('da', [
            0x206166, 0x206174, 0x206465, 0x20656E, 0x206572, 0x20666F, 0x206861, 0x206920,
            0x206D65, 0x206F67, 0x2070E5, 0x207369, 0x207374, 0x207469, 0x207669, 0x616620,
            0x616E20, 0x616E64, 0x617220, 0x617420, 0x646520, 0x64656E, 0x646572, 0x646574,
            0x652073, 0x656420, 0x656465, 0x656E20, 0x656E64, 0x657220, 0x657265, 0x657320,
            0x657420, 0x666F72, 0x676520, 0x67656E, 0x676572, 0x696765, 0x696C20, 0x696E67,
            0x6B6520, 0x6B6B65, 0x6C6572, 0x6C6967, 0x6C6C65, 0x6D6564, 0x6E6465, 0x6E6520,
            0x6E6720, 0x6E6765, 0x6F6720, 0x6F6D20, 0x6F7220, 0x70E520, 0x722064, 0x722065,
            0x722073, 0x726520, 0x737465, 0x742073, 0x746520, 0x746572, 0x74696C, 0x766572
          ]),
          new NGramsPlusLang('de', [
            0x20616E, 0x206175, 0x206265, 0x206461, 0x206465, 0x206469, 0x206569, 0x206765,
            0x206861, 0x20696E, 0x206D69, 0x207363, 0x207365, 0x20756E, 0x207665, 0x20766F,
            0x207765, 0x207A75, 0x626572, 0x636820, 0x636865, 0x636874, 0x646173, 0x64656E,
            0x646572, 0x646965, 0x652064, 0x652073, 0x65696E, 0x656974, 0x656E20, 0x657220,
            0x657320, 0x67656E, 0x68656E, 0x687420, 0x696368, 0x696520, 0x696E20, 0x696E65,
            0x697420, 0x6C6963, 0x6C6C65, 0x6E2061, 0x6E2064, 0x6E2073, 0x6E6420, 0x6E6465,
            0x6E6520, 0x6E6720, 0x6E6765, 0x6E7465, 0x722064, 0x726465, 0x726569, 0x736368,
            0x737465, 0x742064, 0x746520, 0x74656E, 0x746572, 0x756E64, 0x756E67, 0x766572
          ]),
          new NGramsPlusLang('en', [
            0x206120, 0x20616E, 0x206265, 0x20636F, 0x20666F, 0x206861, 0x206865, 0x20696E,
            0x206D61, 0x206F66, 0x207072, 0x207265, 0x207361, 0x207374, 0x207468, 0x20746F,
            0x207768, 0x616964, 0x616C20, 0x616E20, 0x616E64, 0x617320, 0x617420, 0x617465,
            0x617469, 0x642061, 0x642074, 0x652061, 0x652073, 0x652074, 0x656420, 0x656E74,
            0x657220, 0x657320, 0x666F72, 0x686174, 0x686520, 0x686572, 0x696420, 0x696E20,
            0x696E67, 0x696F6E, 0x697320, 0x6E2061, 0x6E2074, 0x6E6420, 0x6E6720, 0x6E7420,
            0x6F6620, 0x6F6E20, 0x6F7220, 0x726520, 0x727320, 0x732061, 0x732074, 0x736169,
            0x737420, 0x742074, 0x746572, 0x746861, 0x746865, 0x74696F, 0x746F20, 0x747320
          ]),
          new NGramsPlusLang('es', [
            0x206120, 0x206361, 0x20636F, 0x206465, 0x20656C, 0x20656E, 0x206573, 0x20696E,
            0x206C61, 0x206C6F, 0x207061, 0x20706F, 0x207072, 0x207175, 0x207265, 0x207365,
            0x20756E, 0x207920, 0x612063, 0x612064, 0x612065, 0x61206C, 0x612070, 0x616369,
            0x61646F, 0x616C20, 0x617220, 0x617320, 0x6369F3, 0x636F6E, 0x646520, 0x64656C,
            0x646F20, 0x652064, 0x652065, 0x65206C, 0x656C20, 0x656E20, 0x656E74, 0x657320,
            0x657374, 0x69656E, 0x69F36E, 0x6C6120, 0x6C6F73, 0x6E2065, 0x6E7465, 0x6F2064,
            0x6F2065, 0x6F6E20, 0x6F7220, 0x6F7320, 0x706172, 0x717565, 0x726120, 0x726573,
            0x732064, 0x732065, 0x732070, 0x736520, 0x746520, 0x746F20, 0x756520, 0xF36E20
          ]),
          new NGramsPlusLang('fr', [
            0x206175, 0x20636F, 0x206461, 0x206465, 0x206475, 0x20656E, 0x206574, 0x206C61,
            0x206C65, 0x207061, 0x20706F, 0x207072, 0x207175, 0x207365, 0x20736F, 0x20756E,
            0x20E020, 0x616E74, 0x617469, 0x636520, 0x636F6E, 0x646520, 0x646573, 0x647520,
            0x652061, 0x652063, 0x652064, 0x652065, 0x65206C, 0x652070, 0x652073, 0x656E20,
            0x656E74, 0x657220, 0x657320, 0x657420, 0x657572, 0x696F6E, 0x697320, 0x697420,
            0x6C6120, 0x6C6520, 0x6C6573, 0x6D656E, 0x6E2064, 0x6E6520, 0x6E7320, 0x6E7420,
            0x6F6E20, 0x6F6E74, 0x6F7572, 0x717565, 0x72206C, 0x726520, 0x732061, 0x732064,
            0x732065, 0x73206C, 0x732070, 0x742064, 0x746520, 0x74696F, 0x756520, 0x757220
          ]),
          new NGramsPlusLang('it', [
            0x20616C, 0x206368, 0x20636F, 0x206465, 0x206469, 0x206520, 0x20696C, 0x20696E,
            0x206C61, 0x207065, 0x207072, 0x20756E, 0x612063, 0x612064, 0x612070, 0x612073,
            0x61746F, 0x636865, 0x636F6E, 0x64656C, 0x646920, 0x652061, 0x652063, 0x652064,
            0x652069, 0x65206C, 0x652070, 0x652073, 0x656C20, 0x656C6C, 0x656E74, 0x657220,
            0x686520, 0x692061, 0x692063, 0x692064, 0x692073, 0x696120, 0x696C20, 0x696E20,
            0x696F6E, 0x6C6120, 0x6C6520, 0x6C6920, 0x6C6C61, 0x6E6520, 0x6E6920, 0x6E6F20,
            0x6E7465, 0x6F2061, 0x6F2064, 0x6F2069, 0x6F2073, 0x6F6E20, 0x6F6E65, 0x706572,
            0x726120, 0x726520, 0x736920, 0x746120, 0x746520, 0x746920, 0x746F20, 0x7A696F
          ]),
          new NGramsPlusLang('nl', [
            0x20616C, 0x206265, 0x206461, 0x206465, 0x206469, 0x206565, 0x20656E, 0x206765,
            0x206865, 0x20696E, 0x206D61, 0x206D65, 0x206F70, 0x207465, 0x207661, 0x207665,
            0x20766F, 0x207765, 0x207A69, 0x61616E, 0x616172, 0x616E20, 0x616E64, 0x617220,
            0x617420, 0x636874, 0x646520, 0x64656E, 0x646572, 0x652062, 0x652076, 0x65656E,
            0x656572, 0x656E20, 0x657220, 0x657273, 0x657420, 0x67656E, 0x686574, 0x696520,
            0x696E20, 0x696E67, 0x697320, 0x6E2062, 0x6E2064, 0x6E2065, 0x6E2068, 0x6E206F,
            0x6E2076, 0x6E6465, 0x6E6720, 0x6F6E64, 0x6F6F72, 0x6F7020, 0x6F7220, 0x736368,
            0x737465, 0x742064, 0x746520, 0x74656E, 0x746572, 0x76616E, 0x766572, 0x766F6F
          ]),
          new NGramsPlusLang('no', [
            0x206174, 0x206176, 0x206465, 0x20656E, 0x206572, 0x20666F, 0x206861, 0x206920,
            0x206D65, 0x206F67, 0x2070E5, 0x207365, 0x20736B, 0x20736F, 0x207374, 0x207469,
            0x207669, 0x20E520, 0x616E64, 0x617220, 0x617420, 0x646520, 0x64656E, 0x646574,
            0x652073, 0x656420, 0x656E20, 0x656E65, 0x657220, 0x657265, 0x657420, 0x657474,
            0x666F72, 0x67656E, 0x696B6B, 0x696C20, 0x696E67, 0x6B6520, 0x6B6B65, 0x6C6520,
            0x6C6C65, 0x6D6564, 0x6D656E, 0x6E2073, 0x6E6520, 0x6E6720, 0x6E6765, 0x6E6E65,
            0x6F6720, 0x6F6D20, 0x6F7220, 0x70E520, 0x722073, 0x726520, 0x736F6D, 0x737465,
            0x742073, 0x746520, 0x74656E, 0x746572, 0x74696C, 0x747420, 0x747465, 0x766572
          ]),
          new NGramsPlusLang('pt', [
            0x206120, 0x20636F, 0x206461, 0x206465, 0x20646F, 0x206520, 0x206573, 0x206D61,
            0x206E6F, 0x206F20, 0x207061, 0x20706F, 0x207072, 0x207175, 0x207265, 0x207365,
            0x20756D, 0x612061, 0x612063, 0x612064, 0x612070, 0x616465, 0x61646F, 0x616C20,
            0x617220, 0x617261, 0x617320, 0x636F6D, 0x636F6E, 0x646120, 0x646520, 0x646F20,
            0x646F73, 0x652061, 0x652064, 0x656D20, 0x656E74, 0x657320, 0x657374, 0x696120,
            0x696361, 0x6D656E, 0x6E7465, 0x6E746F, 0x6F2061, 0x6F2063, 0x6F2064, 0x6F2065,
            0x6F2070, 0x6F7320, 0x706172, 0x717565, 0x726120, 0x726573, 0x732061, 0x732064,
            0x732065, 0x732070, 0x737461, 0x746520, 0x746F20, 0x756520, 0xE36F20, 0xE7E36F
          ]),
          new NGramsPlusLang('sv', [
            0x206174, 0x206176, 0x206465, 0x20656E, 0x2066F6, 0x206861, 0x206920, 0x20696E,
            0x206B6F, 0x206D65, 0x206F63, 0x2070E5, 0x20736B, 0x20736F, 0x207374, 0x207469,
            0x207661, 0x207669, 0x20E472, 0x616465, 0x616E20, 0x616E64, 0x617220, 0x617474,
            0x636820, 0x646520, 0x64656E, 0x646572, 0x646574, 0x656420, 0x656E20, 0x657220,
            0x657420, 0x66F672, 0x67656E, 0x696C6C, 0x696E67, 0x6B6120, 0x6C6C20, 0x6D6564,
            0x6E2073, 0x6E6120, 0x6E6465, 0x6E6720, 0x6E6765, 0x6E696E, 0x6F6368, 0x6F6D20,
            0x6F6E20, 0x70E520, 0x722061, 0x722073, 0x726120, 0x736B61, 0x736F6D, 0x742073,
            0x746120, 0x746520, 0x746572, 0x74696C, 0x747420, 0x766172, 0xE47220, 0xF67220,
          ])
        ];
      };

      this.name = function(det) {
        return (det && det.fC1Bytes) ? 'windows-1252' : 'ISO-8859-1';
      };
    };
    util.inherits(module.exports.ISO_8859_1, sbcs);


    module.exports.ISO_8859_2 = function() {
      this.byteMap = function() {
        return [
          0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
          0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
          0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
          0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
          0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x00,
          0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
          0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
          0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
          0x20, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,
          0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F,
          0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,
          0x78, 0x79, 0x7A, 0x20, 0x20, 0x20, 0x20, 0x20,
          0x20, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,
          0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F,
          0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,
          0x78, 0x79, 0x7A, 0x20, 0x20, 0x20, 0x20, 0x20,
          0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
          0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
          0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
          0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
          0x20, 0xB1, 0x20, 0xB3, 0x20, 0xB5, 0xB6, 0x20,
          0x20, 0xB9, 0xBA, 0xBB, 0xBC, 0x20, 0xBE, 0xBF,
          0x20, 0xB1, 0x20, 0xB3, 0x20, 0xB5, 0xB6, 0xB7,
          0x20, 0xB9, 0xBA, 0xBB, 0xBC, 0x20, 0xBE, 0xBF,
          0xE0, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7,
          0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF,
          0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0x20,
          0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE, 0xDF,
          0xE0, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7,
          0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF,
          0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0x20,
          0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE, 0x20
        ];
      };

      this.ngrams = function() {
        return [
          new NGramsPlusLang('cs', [
            0x206120, 0x206279, 0x20646F, 0x206A65, 0x206E61, 0x206E65, 0x206F20, 0x206F64,
            0x20706F, 0x207072, 0x2070F8, 0x20726F, 0x207365, 0x20736F, 0x207374, 0x20746F,
            0x207620, 0x207679, 0x207A61, 0x612070, 0x636520, 0x636820, 0x652070, 0x652073,
            0x652076, 0x656D20, 0x656EED, 0x686F20, 0x686F64, 0x697374, 0x6A6520, 0x6B7465,
            0x6C6520, 0x6C6920, 0x6E6120, 0x6EE920, 0x6EEC20, 0x6EED20, 0x6F2070, 0x6F646E,
            0x6F6A69, 0x6F7374, 0x6F7520, 0x6F7661, 0x706F64, 0x706F6A, 0x70726F, 0x70F865,
            0x736520, 0x736F75, 0x737461, 0x737469, 0x73746E, 0x746572, 0x746EED, 0x746F20,
            0x752070, 0xBE6520, 0xE16EED, 0xE9686F, 0xED2070, 0xED2073, 0xED6D20, 0xF86564,
          ]),
          new NGramsPlusLang('hu', [
            0x206120, 0x20617A, 0x206265, 0x206567, 0x20656C, 0x206665, 0x206861, 0x20686F,
            0x206973, 0x206B65, 0x206B69, 0x206BF6, 0x206C65, 0x206D61, 0x206D65, 0x206D69,
            0x206E65, 0x20737A, 0x207465, 0x20E973, 0x612061, 0x61206B, 0x61206D, 0x612073,
            0x616B20, 0x616E20, 0x617A20, 0x62616E, 0x62656E, 0x656779, 0x656B20, 0x656C20,
            0x656C65, 0x656D20, 0x656E20, 0x657265, 0x657420, 0x657465, 0x657474, 0x677920,
            0x686F67, 0x696E74, 0x697320, 0x6B2061, 0x6BF67A, 0x6D6567, 0x6D696E, 0x6E2061,
            0x6E616B, 0x6E656B, 0x6E656D, 0x6E7420, 0x6F6779, 0x732061, 0x737A65, 0x737A74,
            0x737AE1, 0x73E967, 0x742061, 0x747420, 0x74E173, 0x7A6572, 0xE16E20, 0xE97320,
          ]),
          new NGramsPlusLang('pl', [
            0x20637A, 0x20646F, 0x206920, 0x206A65, 0x206B6F, 0x206D61, 0x206D69, 0x206E61,
            0x206E69, 0x206F64, 0x20706F, 0x207072, 0x207369, 0x207720, 0x207769, 0x207779,
            0x207A20, 0x207A61, 0x612070, 0x612077, 0x616E69, 0x636820, 0x637A65, 0x637A79,
            0x646F20, 0x647A69, 0x652070, 0x652073, 0x652077, 0x65207A, 0x65676F, 0x656A20,
            0x656D20, 0x656E69, 0x676F20, 0x696120, 0x696520, 0x69656A, 0x6B6120, 0x6B6920,
            0x6B6965, 0x6D6965, 0x6E6120, 0x6E6961, 0x6E6965, 0x6F2070, 0x6F7761, 0x6F7769,
            0x706F6C, 0x707261, 0x70726F, 0x70727A, 0x727A65, 0x727A79, 0x7369EA, 0x736B69,
            0x737461, 0x776965, 0x796368, 0x796D20, 0x7A6520, 0x7A6965, 0x7A7920, 0xF37720,
          ]),
          new NGramsPlusLang('ro', [
            0x206120, 0x206163, 0x206361, 0x206365, 0x20636F, 0x206375, 0x206465, 0x206469,
            0x206C61, 0x206D61, 0x207065, 0x207072, 0x207365, 0x2073E3, 0x20756E, 0x20BA69,
            0x20EE6E, 0x612063, 0x612064, 0x617265, 0x617420, 0x617465, 0x617520, 0x636172,
            0x636F6E, 0x637520, 0x63E320, 0x646520, 0x652061, 0x652063, 0x652064, 0x652070,
            0x652073, 0x656120, 0x656920, 0x656C65, 0x656E74, 0x657374, 0x692061, 0x692063,
            0x692064, 0x692070, 0x696520, 0x696920, 0x696E20, 0x6C6120, 0x6C6520, 0x6C6F72,
            0x6C7569, 0x6E6520, 0x6E7472, 0x6F7220, 0x70656E, 0x726520, 0x726561, 0x727520,
            0x73E320, 0x746520, 0x747275, 0x74E320, 0x756920, 0x756C20, 0xBA6920, 0xEE6E20,
          ])
        ];
      };

      this.name = function(det) {
        return (det && det.fC1Bytes) ? 'windows-1250' : 'ISO-8859-2';
      };
    };
    util.inherits(module.exports.ISO_8859_2, sbcs);


    module.exports.ISO_8859_5 = function() {
      this.byteMap = function() {
        return [
          0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
          0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
          0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
          0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
          0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x00,
          0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
          0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
          0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
          0x20, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,
          0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F,
          0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,
          0x78, 0x79, 0x7A, 0x20, 0x20, 0x20, 0x20, 0x20,
          0x20, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,
          0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F,
          0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,
          0x78, 0x79, 0x7A, 0x20, 0x20, 0x20, 0x20, 0x20,
          0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
          0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
          0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
          0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
          0x20, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7,
          0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0x20, 0xFE, 0xFF,
          0xD0, 0xD1, 0xD2, 0xD3, 0xD4, 0xD5, 0xD6, 0xD7,
          0xD8, 0xD9, 0xDA, 0xDB, 0xDC, 0xDD, 0xDE, 0xDF,
          0xE0, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7,
          0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF,
          0xD0, 0xD1, 0xD2, 0xD3, 0xD4, 0xD5, 0xD6, 0xD7,
          0xD8, 0xD9, 0xDA, 0xDB, 0xDC, 0xDD, 0xDE, 0xDF,
          0xE0, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7,
          0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF,
          0x20, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7,
          0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0x20, 0xFE, 0xFF
        ];
      };

      this.ngrams = function() {
        return [
          0x20D220, 0x20D2DE, 0x20D4DE, 0x20D7D0, 0x20D820, 0x20DAD0, 0x20DADE, 0x20DDD0,
          0x20DDD5, 0x20DED1, 0x20DFDE, 0x20DFE0, 0x20E0D0, 0x20E1DE, 0x20E1E2, 0x20E2DE,
          0x20E7E2, 0x20EDE2, 0xD0DDD8, 0xD0E2EC, 0xD3DE20, 0xD5DBEC, 0xD5DDD8, 0xD5E1E2,
          0xD5E220, 0xD820DF, 0xD8D520, 0xD8D820, 0xD8EF20, 0xDBD5DD, 0xDBD820, 0xDBECDD,
          0xDDD020, 0xDDD520, 0xDDD8D5, 0xDDD8EF, 0xDDDE20, 0xDDDED2, 0xDE20D2, 0xDE20DF,
          0xDE20E1, 0xDED220, 0xDED2D0, 0xDED3DE, 0xDED920, 0xDEDBEC, 0xDEDC20, 0xDEE1E2,
          0xDFDEDB, 0xDFE0D5, 0xDFE0D8, 0xDFE0DE, 0xE0D0D2, 0xE0D5D4, 0xE1E2D0, 0xE1E2D2,
          0xE1E2D8, 0xE1EF20, 0xE2D5DB, 0xE2DE20, 0xE2DEE0, 0xE2EC20, 0xE7E2DE, 0xEBE520
        ];
      };

      this.name = function(det) {
        return 'ISO-8859-5';
      };

      this.language = function() {
        return 'ru';
      };
    };
    util.inherits(module.exports.ISO_8859_5, sbcs);


    module.exports.ISO_8859_6 = function() {
      this.byteMap = function() {
        return [
          0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
          0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
          0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
          0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
          0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x00,
          0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
          0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
          0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
          0x20, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,
          0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F,
          0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,
          0x78, 0x79, 0x7A, 0x20, 0x20, 0x20, 0x20, 0x20,
          0x20, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,
          0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F,
          0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,
          0x78, 0x79, 0x7A, 0x20, 0x20, 0x20, 0x20, 0x20,
          0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
          0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
          0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
          0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
          0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
          0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
          0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
          0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
          0x20, 0xC1, 0xC2, 0xC3, 0xC4, 0xC5, 0xC6, 0xC7,
          0xC8, 0xC9, 0xCA, 0xCB, 0xCC, 0xCD, 0xCE, 0xCF,
          0xD0, 0xD1, 0xD2, 0xD3, 0xD4, 0xD5, 0xD6, 0xD7,
          0xD8, 0xD9, 0xDA, 0x20, 0x20, 0x20, 0x20, 0x20,
          0xE0, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7,
          0xE8, 0xE9, 0xEA, 0x20, 0x20, 0x20, 0x20, 0x20,
          0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
          0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20
        ];
      };

      this.ngrams = function() {
        return [
          0x20C7E4, 0x20C7E6, 0x20C8C7, 0x20D9E4, 0x20E1EA, 0x20E4E4, 0x20E5E6, 0x20E8C7,
          0xC720C7, 0xC7C120, 0xC7CA20, 0xC7D120, 0xC7E420, 0xC7E4C3, 0xC7E4C7, 0xC7E4C8,
          0xC7E4CA, 0xC7E4CC, 0xC7E4CD, 0xC7E4CF, 0xC7E4D3, 0xC7E4D9, 0xC7E4E2, 0xC7E4E5,
          0xC7E4E8, 0xC7E4EA, 0xC7E520, 0xC7E620, 0xC7E6CA, 0xC820C7, 0xC920C7, 0xC920E1,
          0xC920E4, 0xC920E5, 0xC920E8, 0xCA20C7, 0xCF20C7, 0xCFC920, 0xD120C7, 0xD1C920,
          0xD320C7, 0xD920C7, 0xD9E4E9, 0xE1EA20, 0xE420C7, 0xE4C920, 0xE4E920, 0xE4EA20,
          0xE520C7, 0xE5C720, 0xE5C920, 0xE5E620, 0xE620C7, 0xE720C7, 0xE7C720, 0xE8C7E4,
          0xE8E620, 0xE920C7, 0xEA20C7, 0xEA20E5, 0xEA20E8, 0xEAC920, 0xEAD120, 0xEAE620
        ];
      };

      this.name = function(det) {
        return 'ISO-8859-6';
      };

      this.language = function() {
        return 'ar';
      };
    };
    util.inherits(module.exports.ISO_8859_6, sbcs);


    module.exports.ISO_8859_7 = function() {
      this.byteMap = function() {
        return [
          0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
          0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
          0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
          0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
          0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x00,
          0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
          0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
          0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
          0x20, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,
          0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F,
          0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,
          0x78, 0x79, 0x7A, 0x20, 0x20, 0x20, 0x20, 0x20,
          0x20, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,
          0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F,
          0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,
          0x78, 0x79, 0x7A, 0x20, 0x20, 0x20, 0x20, 0x20,
          0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
          0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
          0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
          0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
          0x20, 0xA1, 0xA2, 0x20, 0x20, 0x20, 0x20, 0x20,
          0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
          0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0xDC, 0x20,
          0xDD, 0xDE, 0xDF, 0x20, 0xFC, 0x20, 0xFD, 0xFE,
          0xC0, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7,
          0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF,
          0xF0, 0xF1, 0x20, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7,
          0xF8, 0xF9, 0xFA, 0xFB, 0xDC, 0xDD, 0xDE, 0xDF,
          0xE0, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7,
          0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF,
          0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7,
          0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE, 0x20
        ];
      };

      this.ngrams = function() {
        return [
          0x20E1ED, 0x20E1F0, 0x20E3E9, 0x20E4E9, 0x20E5F0, 0x20E720, 0x20EAE1, 0x20ECE5,
          0x20EDE1, 0x20EF20, 0x20F0E1, 0x20F0EF, 0x20F0F1, 0x20F3F4, 0x20F3F5, 0x20F4E7,
          0x20F4EF, 0xDFE120, 0xE120E1, 0xE120F4, 0xE1E920, 0xE1ED20, 0xE1F0FC, 0xE1F220,
          0xE3E9E1, 0xE5E920, 0xE5F220, 0xE720F4, 0xE7ED20, 0xE7F220, 0xE920F4, 0xE9E120,
          0xE9EADE, 0xE9F220, 0xEAE1E9, 0xEAE1F4, 0xECE520, 0xED20E1, 0xED20E5, 0xED20F0,
          0xEDE120, 0xEFF220, 0xEFF520, 0xF0EFF5, 0xF0F1EF, 0xF0FC20, 0xF220E1, 0xF220E5,
          0xF220EA, 0xF220F0, 0xF220F4, 0xF3E520, 0xF3E720, 0xF3F4EF, 0xF4E120, 0xF4E1E9,
          0xF4E7ED, 0xF4E7F2, 0xF4E9EA, 0xF4EF20, 0xF4EFF5, 0xF4F9ED, 0xF9ED20, 0xFEED20
        ];
      };

      this.name = function(det) {
        return (det && det.fC1Bytes) ? 'windows-1253' : 'ISO-8859-7';
      };

      this.language = function() {
        return 'el';
      };
    };
    util.inherits(module.exports.ISO_8859_7, sbcs);

    module.exports.ISO_8859_8 = function() {

      this.byteMap = function() {
        return [
          0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
          0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
          0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
          0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
          0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x00,
          0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
          0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
          0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
          0x20, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,
          0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F,
          0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,
          0x78, 0x79, 0x7A, 0x20, 0x20, 0x20, 0x20, 0x20,
          0x20, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,
          0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F,
          0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,
          0x78, 0x79, 0x7A, 0x20, 0x20, 0x20, 0x20, 0x20,
          0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
          0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
          0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
          0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
          0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
          0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
          0x20, 0x20, 0x20, 0x20, 0x20, 0xB5, 0x20, 0x20,
          0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
          0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
          0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
          0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
          0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
          0xE0, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7,
          0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF,
          0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7,
          0xF8, 0xF9, 0xFA, 0x20, 0x20, 0x20, 0x20, 0x20
        ];
      };

      this.ngrams = function() {
        return [
          new NGramsPlusLang('he', [
            0x20E0E5, 0x20E0E7, 0x20E0E9, 0x20E0FA, 0x20E1E9, 0x20E1EE, 0x20E4E0, 0x20E4E5,
            0x20E4E9, 0x20E4EE, 0x20E4F2, 0x20E4F9, 0x20E4FA, 0x20ECE0, 0x20ECE4, 0x20EEE0,
            0x20F2EC, 0x20F9EC, 0xE0FA20, 0xE420E0, 0xE420E1, 0xE420E4, 0xE420EC, 0xE420EE,
            0xE420F9, 0xE4E5E0, 0xE5E020, 0xE5ED20, 0xE5EF20, 0xE5F820, 0xE5FA20, 0xE920E4,
            0xE9E420, 0xE9E5FA, 0xE9E9ED, 0xE9ED20, 0xE9EF20, 0xE9F820, 0xE9FA20, 0xEC20E0,
            0xEC20E4, 0xECE020, 0xECE420, 0xED20E0, 0xED20E1, 0xED20E4, 0xED20EC, 0xED20EE,
            0xED20F9, 0xEEE420, 0xEF20E4, 0xF0E420, 0xF0E920, 0xF0E9ED, 0xF2EC20, 0xF820E4,
            0xF8E9ED, 0xF9EC20, 0xFA20E0, 0xFA20E1, 0xFA20E4, 0xFA20EC, 0xFA20EE, 0xFA20F9,
          ]),
          new NGramsPlusLang('he', [
            0x20E0E5, 0x20E0EC, 0x20E4E9, 0x20E4EC, 0x20E4EE, 0x20E4F0, 0x20E9F0, 0x20ECF2,
            0x20ECF9, 0x20EDE5, 0x20EDE9, 0x20EFE5, 0x20EFE9, 0x20F8E5, 0x20F8E9, 0x20FAE0,
            0x20FAE5, 0x20FAE9, 0xE020E4, 0xE020EC, 0xE020ED, 0xE020FA, 0xE0E420, 0xE0E5E4,
            0xE0EC20, 0xE0EE20, 0xE120E4, 0xE120ED, 0xE120FA, 0xE420E4, 0xE420E9, 0xE420EC,
            0xE420ED, 0xE420EF, 0xE420F8, 0xE420FA, 0xE4EC20, 0xE5E020, 0xE5E420, 0xE7E020,
            0xE9E020, 0xE9E120, 0xE9E420, 0xEC20E4, 0xEC20ED, 0xEC20FA, 0xECF220, 0xECF920,
            0xEDE9E9, 0xEDE9F0, 0xEDE9F8, 0xEE20E4, 0xEE20ED, 0xEE20FA, 0xEEE120, 0xEEE420,
            0xF2E420, 0xF920E4, 0xF920ED, 0xF920FA, 0xF9E420, 0xFAE020, 0xFAE420, 0xFAE5E9,
          ])
        ];
      };

      this.name = function(det) {
        return (det && det.fC1Bytes) ? 'windows-1255' : 'ISO-8859-8';
      };

      this.language = function() {
        return 'he';
      };

    };
    util.inherits(module.exports.ISO_8859_8, sbcs);


    module.exports.ISO_8859_9 = function() {
      this.byteMap = function() {
        return [
          0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
          0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
          0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
          0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
          0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x00,
          0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
          0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
          0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
          0x20, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,
          0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F,
          0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,
          0x78, 0x79, 0x7A, 0x20, 0x20, 0x20, 0x20, 0x20,
          0x20, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,
          0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F,
          0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,
          0x78, 0x79, 0x7A, 0x20, 0x20, 0x20, 0x20, 0x20,
          0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
          0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
          0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
          0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
          0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
          0x20, 0x20, 0xAA, 0x20, 0x20, 0x20, 0x20, 0x20,
          0x20, 0x20, 0x20, 0x20, 0x20, 0xB5, 0x20, 0x20,
          0x20, 0x20, 0xBA, 0x20, 0x20, 0x20, 0x20, 0x20,
          0xE0, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7,
          0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF,
          0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0x20,
          0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0x69, 0xFE, 0xDF,
          0xE0, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7,
          0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF,
          0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0x20,
          0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE, 0xFF
        ];
      };

      this.ngrams = function() {
        return [
          0x206261, 0x206269, 0x206275, 0x206461, 0x206465, 0x206765, 0x206861, 0x20696C,
          0x206B61, 0x206B6F, 0x206D61, 0x206F6C, 0x207361, 0x207461, 0x207665, 0x207961,
          0x612062, 0x616B20, 0x616C61, 0x616D61, 0x616E20, 0x616EFD, 0x617220, 0x617261,
          0x6172FD, 0x6173FD, 0x617961, 0x626972, 0x646120, 0x646520, 0x646920, 0x652062,
          0x65206B, 0x656469, 0x656E20, 0x657220, 0x657269, 0x657369, 0x696C65, 0x696E20,
          0x696E69, 0x697220, 0x6C616E, 0x6C6172, 0x6C6520, 0x6C6572, 0x6E2061, 0x6E2062,
          0x6E206B, 0x6E6461, 0x6E6465, 0x6E6520, 0x6E6920, 0x6E696E, 0x6EFD20, 0x72696E,
          0x72FD6E, 0x766520, 0x796120, 0x796F72, 0xFD6E20, 0xFD6E64, 0xFD6EFD, 0xFDF0FD
        ];
      };

      this.name = function(det) {
        return (det && det.fC1Bytes) ? 'windows-1254' : 'ISO-8859-9';
      };

      this.language = function() {
        return 'tr';
      };
    };
    util.inherits(module.exports.ISO_8859_9, sbcs);


    module.exports.windows_1251 = function() {
      this.byteMap = function() {
        return [
          0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
          0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
          0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
          0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
          0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x00,
          0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
          0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
          0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
          0x20, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,
          0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F,
          0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,
          0x78, 0x79, 0x7A, 0x20, 0x20, 0x20, 0x20, 0x20,
          0x20, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,
          0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F,
          0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,
          0x78, 0x79, 0x7A, 0x20, 0x20, 0x20, 0x20, 0x20,
          0x90, 0x83, 0x20, 0x83, 0x20, 0x20, 0x20, 0x20,
          0x20, 0x20, 0x9A, 0x20, 0x9C, 0x9D, 0x9E, 0x9F,
          0x90, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
          0x20, 0x20, 0x9A, 0x20, 0x9C, 0x9D, 0x9E, 0x9F,
          0x20, 0xA2, 0xA2, 0xBC, 0x20, 0xB4, 0x20, 0x20,
          0xB8, 0x20, 0xBA, 0x20, 0x20, 0x20, 0x20, 0xBF,
          0x20, 0x20, 0xB3, 0xB3, 0xB4, 0xB5, 0x20, 0x20,
          0xB8, 0x20, 0xBA, 0x20, 0xBC, 0xBE, 0xBE, 0xBF,
          0xE0, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7,
          0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF,
          0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7,
          0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE, 0xFF,
          0xE0, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7,
          0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF,
          0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7,
          0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE, 0xFF
        ];
      };

      this.ngrams = function() {
        return [
          0x20E220, 0x20E2EE, 0x20E4EE, 0x20E7E0, 0x20E820, 0x20EAE0, 0x20EAEE, 0x20EDE0,
          0x20EDE5, 0x20EEE1, 0x20EFEE, 0x20EFF0, 0x20F0E0, 0x20F1EE, 0x20F1F2, 0x20F2EE,
          0x20F7F2, 0x20FDF2, 0xE0EDE8, 0xE0F2FC, 0xE3EE20, 0xE5EBFC, 0xE5EDE8, 0xE5F1F2,
          0xE5F220, 0xE820EF, 0xE8E520, 0xE8E820, 0xE8FF20, 0xEBE5ED, 0xEBE820, 0xEBFCED,
          0xEDE020, 0xEDE520, 0xEDE8E5, 0xEDE8FF, 0xEDEE20, 0xEDEEE2, 0xEE20E2, 0xEE20EF,
          0xEE20F1, 0xEEE220, 0xEEE2E0, 0xEEE3EE, 0xEEE920, 0xEEEBFC, 0xEEEC20, 0xEEF1F2,
          0xEFEEEB, 0xEFF0E5, 0xEFF0E8, 0xEFF0EE, 0xF0E0E2, 0xF0E5E4, 0xF1F2E0, 0xF1F2E2,
          0xF1F2E8, 0xF1FF20, 0xF2E5EB, 0xF2EE20, 0xF2EEF0, 0xF2FC20, 0xF7F2EE, 0xFBF520
        ];
      };

      this.name = function(det) {
        return 'windows-1251';
      };

      this.language = function() {
        return 'ru';
      };
    };
    util.inherits(module.exports.windows_1251, sbcs);


    module.exports.windows_1256 = function() {
      this.byteMap = function() {
        return [
          0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
          0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
          0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
          0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
          0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x00,
          0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
          0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
          0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
          0x20, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,
          0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F,
          0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,
          0x78, 0x79, 0x7A, 0x20, 0x20, 0x20, 0x20, 0x20,
          0x20, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,
          0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F,
          0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,
          0x78, 0x79, 0x7A, 0x20, 0x20, 0x20, 0x20, 0x20,
          0x20, 0x81, 0x20, 0x83, 0x20, 0x20, 0x20, 0x20,
          0x88, 0x20, 0x8A, 0x20, 0x9C, 0x8D, 0x8E, 0x8F,
          0x90, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
          0x98, 0x20, 0x9A, 0x20, 0x9C, 0x20, 0x20, 0x9F,
          0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
          0x20, 0x20, 0xAA, 0x20, 0x20, 0x20, 0x20, 0x20,
          0x20, 0x20, 0x20, 0x20, 0x20, 0xB5, 0x20, 0x20,
          0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
          0xC0, 0xC1, 0xC2, 0xC3, 0xC4, 0xC5, 0xC6, 0xC7,
          0xC8, 0xC9, 0xCA, 0xCB, 0xCC, 0xCD, 0xCE, 0xCF,
          0xD0, 0xD1, 0xD2, 0xD3, 0xD4, 0xD5, 0xD6, 0x20,
          0xD8, 0xD9, 0xDA, 0xDB, 0xDC, 0xDD, 0xDE, 0xDF,
          0xE0, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7,
          0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF,
          0x20, 0x20, 0x20, 0x20, 0xF4, 0x20, 0x20, 0x20,
          0x20, 0xF9, 0x20, 0xFB, 0xFC, 0x20, 0x20, 0xFF
        ];
      };

      this.ngrams = function() {
        return [
          0x20C7E1, 0x20C7E4, 0x20C8C7, 0x20DAE1, 0x20DDED, 0x20E1E1, 0x20E3E4, 0x20E6C7,
          0xC720C7, 0xC7C120, 0xC7CA20, 0xC7D120, 0xC7E120, 0xC7E1C3, 0xC7E1C7, 0xC7E1C8,
          0xC7E1CA, 0xC7E1CC, 0xC7E1CD, 0xC7E1CF, 0xC7E1D3, 0xC7E1DA, 0xC7E1DE, 0xC7E1E3,
          0xC7E1E6, 0xC7E1ED, 0xC7E320, 0xC7E420, 0xC7E4CA, 0xC820C7, 0xC920C7, 0xC920DD,
          0xC920E1, 0xC920E3, 0xC920E6, 0xCA20C7, 0xCF20C7, 0xCFC920, 0xD120C7, 0xD1C920,
          0xD320C7, 0xDA20C7, 0xDAE1EC, 0xDDED20, 0xE120C7, 0xE1C920, 0xE1EC20, 0xE1ED20,
          0xE320C7, 0xE3C720, 0xE3C920, 0xE3E420, 0xE420C7, 0xE520C7, 0xE5C720, 0xE6C7E1,
          0xE6E420, 0xEC20C7, 0xED20C7, 0xED20E3, 0xED20E6, 0xEDC920, 0xEDD120, 0xEDE420
        ];
      };

      this.name = function(det) {
        return 'windows-1256';
      };

      this.language = function() {
        return 'ar';
      };
    };
    util.inherits(module.exports.windows_1256, sbcs);


    module.exports.KOI8_R = function() {
      this.byteMap = function() {
        return [
          0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
          0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
          0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
          0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
          0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x00,
          0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
          0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
          0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
          0x20, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,
          0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F,
          0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,
          0x78, 0x79, 0x7A, 0x20, 0x20, 0x20, 0x20, 0x20,
          0x20, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,
          0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F,
          0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,
          0x78, 0x79, 0x7A, 0x20, 0x20, 0x20, 0x20, 0x20,
          0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
          0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
          0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
          0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
          0x20, 0x20, 0x20, 0xA3, 0x20, 0x20, 0x20, 0x20,
          0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
          0x20, 0x20, 0x20, 0xA3, 0x20, 0x20, 0x20, 0x20,
          0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
          0xC0, 0xC1, 0xC2, 0xC3, 0xC4, 0xC5, 0xC6, 0xC7,
          0xC8, 0xC9, 0xCA, 0xCB, 0xCC, 0xCD, 0xCE, 0xCF,
          0xD0, 0xD1, 0xD2, 0xD3, 0xD4, 0xD5, 0xD6, 0xD7,
          0xD8, 0xD9, 0xDA, 0xDB, 0xDC, 0xDD, 0xDE, 0xDF,
          0xC0, 0xC1, 0xC2, 0xC3, 0xC4, 0xC5, 0xC6, 0xC7,
          0xC8, 0xC9, 0xCA, 0xCB, 0xCC, 0xCD, 0xCE, 0xCF,
          0xD0, 0xD1, 0xD2, 0xD3, 0xD4, 0xD5, 0xD6, 0xD7,
          0xD8, 0xD9, 0xDA, 0xDB, 0xDC, 0xDD, 0xDE, 0xDF
        ];
      };

      this.ngrams = function() {
        return [
          0x20C4CF, 0x20C920, 0x20CBC1, 0x20CBCF, 0x20CEC1, 0x20CEC5, 0x20CFC2, 0x20D0CF,
          0x20D0D2, 0x20D2C1, 0x20D3CF, 0x20D3D4, 0x20D4CF, 0x20D720, 0x20D7CF, 0x20DAC1,
          0x20DCD4, 0x20DED4, 0xC1CEC9, 0xC1D4D8, 0xC5CCD8, 0xC5CEC9, 0xC5D3D4, 0xC5D420,
          0xC7CF20, 0xC920D0, 0xC9C520, 0xC9C920, 0xC9D120, 0xCCC5CE, 0xCCC920, 0xCCD8CE,
          0xCEC120, 0xCEC520, 0xCEC9C5, 0xCEC9D1, 0xCECF20, 0xCECFD7, 0xCF20D0, 0xCF20D3,
          0xCF20D7, 0xCFC7CF, 0xCFCA20, 0xCFCCD8, 0xCFCD20, 0xCFD3D4, 0xCFD720, 0xCFD7C1,
          0xD0CFCC, 0xD0D2C5, 0xD0D2C9, 0xD0D2CF, 0xD2C1D7, 0xD2C5C4, 0xD3D120, 0xD3D4C1,
          0xD3D4C9, 0xD3D4D7, 0xD4C5CC, 0xD4CF20, 0xD4CFD2, 0xD4D820, 0xD9C820, 0xDED4CF
        ];
      };

      this.name = function(det) {
        return 'KOI8-R';
      };

      this.language = function() {
        return 'ru';
      };
    };
    util.inherits(module.exports.KOI8_R, sbcs);


    /*
    module.exports.ISO_8859_7 = function() {
      this.byteMap = function() {
        return [

        ];
      };

      this.ngrams = function() {
        return [

        ];
      };

      this.name = function(det) {
        if (typeof det == 'undefined')
          return 'ISO-8859-7';
        return det.fC1Bytes ? 'windows-1253' : 'ISO-8859-7';
      };

      this.language = function() {
        return 'el';
      };
    };
    util.inherits(module.exports.ISO_8859_7, sbcs);
    */
    }(sbcs$1));

    var iso2022$1 = {exports: {}};

    (function (module) {
    var util = require$$0__default$1["default"],
      Match = match$1;


    /**
     * This is a superclass for the individual detectors for
     * each of the detectable members of the ISO 2022 family
     * of encodings.
     */

    function ISO_2022() {}

    ISO_2022.prototype.match = function(det) {

      /**
       * Matching function shared among the 2022 detectors JP, CN and KR
       * Counts up the number of legal an unrecognized escape sequences in
       * the sample of text, and computes a score based on the total number &
       * the proportion that fit the encoding.
       *
       *
       * @param text the byte buffer containing text to analyse
       * @param textLen  the size of the text in the byte.
       * @param escapeSequences the byte escape sequences to test for.
       * @return match quality, in the range of 0-100.
       */

      var i, j;
      var escN;
      var hits   = 0;
      var misses = 0;
      var shifts = 0;
      var quality;

      // TODO: refactor me
      var text = det.fInputBytes;
      var textLen = det.fInputLen;

      scanInput:
        for (i = 0; i < textLen; i++) {
          if (text[i] == 0x1b) {
            checkEscapes:
              for (escN = 0; escN < this.escapeSequences.length; escN++) {
                var seq = this.escapeSequences[escN];

                if ((textLen - i) < seq.length)
                  continue checkEscapes;

                for (j = 1; j < seq.length; j++)
                  if (seq[j] != text[i + j])
                    continue checkEscapes;


                hits++;
                i += seq.length - 1;
                continue scanInput;
              }

              misses++;
          }

          // Shift in/out
          if (text[i] == 0x0e || text[i] == 0x0f)
            shifts++;

        }

      if (hits == 0)
        return null;

      //
      // Initial quality is based on relative proportion of recongized vs.
      //   unrecognized escape sequences.
      //   All good:  quality = 100;
      //   half or less good: quality = 0;
      //   linear inbetween.
      quality = (100 * hits - 100 * misses) / (hits + misses);

      // Back off quality if there were too few escape sequences seen.
      //   Include shifts in this computation, so that KR does not get penalized
      //   for having only a single Escape sequence, but many shifts.
      if (hits + shifts < 5)
        quality -= (5 - (hits + shifts)) * 10;

      return quality <= 0 ? null : new Match(det, this, quality);
    };

    module.exports.ISO_2022_JP = function() {
      this.name = function() {
        return 'ISO-2022-JP';
      };
      this.escapeSequences = [
        [ 0x1b, 0x24, 0x28, 0x43 ],   // KS X 1001:1992
        [ 0x1b, 0x24, 0x28, 0x44 ],   // JIS X 212-1990
        [ 0x1b, 0x24, 0x40 ],         // JIS C 6226-1978
        [ 0x1b, 0x24, 0x41 ],         // GB 2312-80
        [ 0x1b, 0x24, 0x42 ],         // JIS X 208-1983
        [ 0x1b, 0x26, 0x40 ],         // JIS X 208 1990, 1997
        [ 0x1b, 0x28, 0x42 ],         // ASCII
        [ 0x1b, 0x28, 0x48 ],         // JIS-Roman
        [ 0x1b, 0x28, 0x49 ],         // Half-width katakana
        [ 0x1b, 0x28, 0x4a ],         // JIS-Roman
        [ 0x1b, 0x2e, 0x41 ],         // ISO 8859-1
        [ 0x1b, 0x2e, 0x46 ]          // ISO 8859-7
      ];
    };
    util.inherits(module.exports.ISO_2022_JP, ISO_2022);



    module.exports.ISO_2022_KR = function() {
      this.name = function() {
        return 'ISO-2022-KR';
      };
      this.escapeSequences = [
        [ 0x1b, 0x24, 0x29, 0x43 ]
      ];
    };
    util.inherits(module.exports.ISO_2022_KR, ISO_2022);



    module.exports.ISO_2022_CN = function() {
      this.name = function() {
        return 'ISO-2022-CN';
      };
      this.escapeSequences = [
        [ 0x1b, 0x24, 0x29, 0x41 ],   // GB 2312-80
        [ 0x1b, 0x24, 0x29, 0x47 ],   // CNS 11643-1992 Plane 1
        [ 0x1b, 0x24, 0x2A, 0x48 ],   // CNS 11643-1992 Plane 2
        [ 0x1b, 0x24, 0x29, 0x45 ],   // ISO-IR-165
        [ 0x1b, 0x24, 0x2B, 0x49 ],   // CNS 11643-1992 Plane 3
        [ 0x1b, 0x24, 0x2B, 0x4A ],   // CNS 11643-1992 Plane 4
        [ 0x1b, 0x24, 0x2B, 0x4B ],   // CNS 11643-1992 Plane 5
        [ 0x1b, 0x24, 0x2B, 0x4C ],   // CNS 11643-1992 Plane 6
        [ 0x1b, 0x24, 0x2B, 0x4D ],   // CNS 11643-1992 Plane 7
        [ 0x1b, 0x4e ],               // SS2
        [ 0x1b, 0x4f ]                // SS3
      ];
    };
    util.inherits(module.exports.ISO_2022_CN, ISO_2022);
    }(iso2022$1));

    var fs$4 = require$$0__default$6["default"];

    var utf8  = utf8$1,
      unicode = unicode$1.exports,
      mbcs    = mbcs$1.exports,
      sbcs    = sbcs$1.exports,
      iso2022 = iso2022$1.exports;

    var self$1 = commonjsGlobal;

    var recognisers = [
      new utf8,
      new unicode.UTF_16BE,
      new unicode.UTF_16LE,
      new unicode.UTF_32BE,
      new unicode.UTF_32LE,
      new mbcs.sjis,
      new mbcs.big5,
      new mbcs.euc_jp,
      new mbcs.euc_kr,
      new mbcs.gb_18030,
      new iso2022.ISO_2022_JP,
      new iso2022.ISO_2022_KR,
      new iso2022.ISO_2022_CN,
      new sbcs.ISO_8859_1,
      new sbcs.ISO_8859_2,
      new sbcs.ISO_8859_5,
      new sbcs.ISO_8859_6,
      new sbcs.ISO_8859_7,
      new sbcs.ISO_8859_8,
      new sbcs.ISO_8859_9,
      new sbcs.windows_1251,
      new sbcs.windows_1256,
      new sbcs.KOI8_R
    ];

    chardet.detect = function(buffer, opts) {

      // Tally up the byte occurence statistics.
      var fByteStats = [];
      for (var i = 0; i < 256; i++)
        fByteStats[i] = 0;

      for (var i = buffer.length - 1; i >= 0; i--)
        fByteStats[buffer[i] & 0x00ff]++;

      var fC1Bytes = false;
      for (var i = 0x80; i <= 0x9F; i += 1) {
        if (fByteStats[i] != 0) {
          fC1Bytes = true;
          break;
        }
      }

      var context = {
        fByteStats:  fByteStats,
        fC1Bytes:    fC1Bytes,
        fRawInput:   buffer,
        fRawLength:  buffer.length,
        fInputBytes: buffer,
        fInputLen:   buffer.length
      };

      var matches = recognisers.map(function(rec) {
        return rec.match(context);
      }).filter(function(match) {
        return !!match;
      }).sort(function(a, b) {
        return b.confidence - a.confidence;
      });

      if (opts && opts.returnAllMatches === true) {
        return matches;
      }
      else {
        return matches.length > 0 ? matches[0].name : null;
      }
    };

    chardet.detectFile = function(filepath, opts, cb) {
      if (typeof opts === 'function') {
        cb = opts;
        opts = undefined;
      }

      var fd;

      var handler = function(err, buffer) {
        if (fd) {
          fs$4.closeSync(fd);
        }

        if (err) return cb(err, null);
        cb(null, self$1.detect(buffer, opts));
      };

      if (opts && opts.sampleSize) {
        fd = fs$4.openSync(filepath, 'r'),
          sample = Buffer.allocUnsafe(opts.sampleSize);

        fs$4.read(fd, sample, 0, opts.sampleSize, null, function(err) {
          handler(err, sample);
        });
        return;
      }

      fs$4.readFile(filepath, handler);
    };

    chardet.detectFileSync = function(filepath, opts) {
      if (opts && opts.sampleSize) {
        var fd = fs$4.openSync(filepath, 'r'),
          sample = Buffer.allocUnsafe(opts.sampleSize);

        fs$4.readSync(fd, sample, 0, opts.sampleSize);
        fs$4.closeSync(fd);
        return self$1.detect(sample, opts);
      }

      return self$1.detect(fs$4.readFileSync(filepath), opts);
    };

    // Wrappers for the previous functions to return all encodings
    chardet.detectAll = function(buffer, opts) {
      if (typeof opts !== 'object') {
        opts = {};
      }
      opts.returnAllMatches = true;
      return self$1.detect(buffer, opts);
    };

    chardet.detectFileAll = function(filepath, opts, cb) {
      if (typeof opts === 'function') {
        cb = opts;
        opts = undefined;
      }
      if (typeof opts !== 'object') {
        opts = {};
      }
      opts.returnAllMatches = true;
      self$1.detectFile(filepath, opts, cb);
    };

    chardet.detectFileAllSync = function(filepath, opts) {
      if (typeof opts !== 'object') {
        opts = {};
      }
      opts.returnAllMatches = true;
      return self$1.detectFileSync(filepath, opts);
    };

    var lib = {exports: {}};

    /* eslint-disable node/no-deprecated-api */

    var buffer = require$$0__default$3["default"];
    var Buffer$8 = buffer.Buffer;

    var safer = {};

    var key;

    for (key in buffer) {
      if (!buffer.hasOwnProperty(key)) continue
      if (key === 'SlowBuffer' || key === 'Buffer') continue
      safer[key] = buffer[key];
    }

    var Safer = safer.Buffer = {};
    for (key in Buffer$8) {
      if (!Buffer$8.hasOwnProperty(key)) continue
      if (key === 'allocUnsafe' || key === 'allocUnsafeSlow') continue
      Safer[key] = Buffer$8[key];
    }

    safer.Buffer.prototype = Buffer$8.prototype;

    if (!Safer.from || Safer.from === Uint8Array.from) {
      Safer.from = function (value, encodingOrOffset, length) {
        if (typeof value === 'number') {
          throw new TypeError('The "value" argument must not be of type number. Received type ' + typeof value)
        }
        if (value && typeof value.length === 'undefined') {
          throw new TypeError('The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type ' + typeof value)
        }
        return Buffer$8(value, encodingOrOffset, length)
      };
    }

    if (!Safer.alloc) {
      Safer.alloc = function (size, fill, encoding) {
        if (typeof size !== 'number') {
          throw new TypeError('The "size" argument must be of type number. Received type ' + typeof size)
        }
        if (size < 0 || size >= 2 * (1 << 30)) {
          throw new RangeError('The value "' + size + '" is invalid for option "size"')
        }
        var buf = Buffer$8(size);
        if (!fill || fill.length === 0) {
          buf.fill(0);
        } else if (typeof encoding === 'string') {
          buf.fill(fill, encoding);
        } else {
          buf.fill(fill);
        }
        return buf
      };
    }

    if (!safer.kStringMaxLength) {
      try {
        safer.kStringMaxLength = process.binding('buffer').kStringMaxLength;
      } catch (e) {
        // we can't determine kStringMaxLength in environments where process.binding
        // is unsupported, so let's not set it
      }
    }

    if (!safer.constants) {
      safer.constants = {
        MAX_LENGTH: safer.kMaxLength
      };
      if (safer.kStringMaxLength) {
        safer.constants.MAX_STRING_LENGTH = safer.kStringMaxLength;
      }
    }

    var safer_1 = safer;

    var bomHandling = {};

    var BOMChar = '\uFEFF';

    bomHandling.PrependBOM = PrependBOMWrapper;
    function PrependBOMWrapper(encoder, options) {
        this.encoder = encoder;
        this.addBOM = true;
    }

    PrependBOMWrapper.prototype.write = function(str) {
        if (this.addBOM) {
            str = BOMChar + str;
            this.addBOM = false;
        }

        return this.encoder.write(str);
    };

    PrependBOMWrapper.prototype.end = function() {
        return this.encoder.end();
    };


    //------------------------------------------------------------------------------

    bomHandling.StripBOM = StripBOMWrapper;
    function StripBOMWrapper(decoder, options) {
        this.decoder = decoder;
        this.pass = false;
        this.options = options || {};
    }

    StripBOMWrapper.prototype.write = function(buf) {
        var res = this.decoder.write(buf);
        if (this.pass || !res)
            return res;

        if (res[0] === BOMChar) {
            res = res.slice(1);
            if (typeof this.options.stripBOM === 'function')
                this.options.stripBOM();
        }

        this.pass = true;
        return res;
    };

    StripBOMWrapper.prototype.end = function() {
        return this.decoder.end();
    };

    var encodings = {};

    var Buffer$7 = safer_1.Buffer;

    // Export Node.js internal encodings.

    var internal = {
        // Encodings
        utf8:   { type: "_internal", bomAware: true},
        cesu8:  { type: "_internal", bomAware: true},
        unicode11utf8: "utf8",

        ucs2:   { type: "_internal", bomAware: true},
        utf16le: "ucs2",

        binary: { type: "_internal" },
        base64: { type: "_internal" },
        hex:    { type: "_internal" },

        // Codec.
        _internal: InternalCodec,
    };

    //------------------------------------------------------------------------------

    function InternalCodec(codecOptions, iconv) {
        this.enc = codecOptions.encodingName;
        this.bomAware = codecOptions.bomAware;

        if (this.enc === "base64")
            this.encoder = InternalEncoderBase64;
        else if (this.enc === "cesu8") {
            this.enc = "utf8"; // Use utf8 for decoding.
            this.encoder = InternalEncoderCesu8;

            // Add decoder for versions of Node not supporting CESU-8
            if (Buffer$7.from('eda0bdedb2a9', 'hex').toString() !== '') {
                this.decoder = InternalDecoderCesu8;
                this.defaultCharUnicode = iconv.defaultCharUnicode;
            }
        }
    }

    InternalCodec.prototype.encoder = InternalEncoder;
    InternalCodec.prototype.decoder = InternalDecoder;

    //------------------------------------------------------------------------------

    // We use node.js internal decoder. Its signature is the same as ours.
    var StringDecoder = require$$1__default$3["default"].StringDecoder;

    if (!StringDecoder.prototype.end) // Node v0.8 doesn't have this method.
        StringDecoder.prototype.end = function() {};


    function InternalDecoder(options, codec) {
        StringDecoder.call(this, codec.enc);
    }

    InternalDecoder.prototype = StringDecoder.prototype;


    //------------------------------------------------------------------------------
    // Encoder is mostly trivial

    function InternalEncoder(options, codec) {
        this.enc = codec.enc;
    }

    InternalEncoder.prototype.write = function(str) {
        return Buffer$7.from(str, this.enc);
    };

    InternalEncoder.prototype.end = function() {
    };


    //------------------------------------------------------------------------------
    // Except base64 encoder, which must keep its state.

    function InternalEncoderBase64(options, codec) {
        this.prevStr = '';
    }

    InternalEncoderBase64.prototype.write = function(str) {
        str = this.prevStr + str;
        var completeQuads = str.length - (str.length % 4);
        this.prevStr = str.slice(completeQuads);
        str = str.slice(0, completeQuads);

        return Buffer$7.from(str, "base64");
    };

    InternalEncoderBase64.prototype.end = function() {
        return Buffer$7.from(this.prevStr, "base64");
    };


    //------------------------------------------------------------------------------
    // CESU-8 encoder is also special.

    function InternalEncoderCesu8(options, codec) {
    }

    InternalEncoderCesu8.prototype.write = function(str) {
        var buf = Buffer$7.alloc(str.length * 3), bufIdx = 0;
        for (var i = 0; i < str.length; i++) {
            var charCode = str.charCodeAt(i);
            // Naive implementation, but it works because CESU-8 is especially easy
            // to convert from UTF-16 (which all JS strings are encoded in).
            if (charCode < 0x80)
                buf[bufIdx++] = charCode;
            else if (charCode < 0x800) {
                buf[bufIdx++] = 0xC0 + (charCode >>> 6);
                buf[bufIdx++] = 0x80 + (charCode & 0x3f);
            }
            else { // charCode will always be < 0x10000 in javascript.
                buf[bufIdx++] = 0xE0 + (charCode >>> 12);
                buf[bufIdx++] = 0x80 + ((charCode >>> 6) & 0x3f);
                buf[bufIdx++] = 0x80 + (charCode & 0x3f);
            }
        }
        return buf.slice(0, bufIdx);
    };

    InternalEncoderCesu8.prototype.end = function() {
    };

    //------------------------------------------------------------------------------
    // CESU-8 decoder is not implemented in Node v4.0+

    function InternalDecoderCesu8(options, codec) {
        this.acc = 0;
        this.contBytes = 0;
        this.accBytes = 0;
        this.defaultCharUnicode = codec.defaultCharUnicode;
    }

    InternalDecoderCesu8.prototype.write = function(buf) {
        var acc = this.acc, contBytes = this.contBytes, accBytes = this.accBytes, 
            res = '';
        for (var i = 0; i < buf.length; i++) {
            var curByte = buf[i];
            if ((curByte & 0xC0) !== 0x80) { // Leading byte
                if (contBytes > 0) { // Previous code is invalid
                    res += this.defaultCharUnicode;
                    contBytes = 0;
                }

                if (curByte < 0x80) { // Single-byte code
                    res += String.fromCharCode(curByte);
                } else if (curByte < 0xE0) { // Two-byte code
                    acc = curByte & 0x1F;
                    contBytes = 1; accBytes = 1;
                } else if (curByte < 0xF0) { // Three-byte code
                    acc = curByte & 0x0F;
                    contBytes = 2; accBytes = 1;
                } else { // Four or more are not supported for CESU-8.
                    res += this.defaultCharUnicode;
                }
            } else { // Continuation byte
                if (contBytes > 0) { // We're waiting for it.
                    acc = (acc << 6) | (curByte & 0x3f);
                    contBytes--; accBytes++;
                    if (contBytes === 0) {
                        // Check for overlong encoding, but support Modified UTF-8 (encoding NULL as C0 80)
                        if (accBytes === 2 && acc < 0x80 && acc > 0)
                            res += this.defaultCharUnicode;
                        else if (accBytes === 3 && acc < 0x800)
                            res += this.defaultCharUnicode;
                        else
                            // Actually add character.
                            res += String.fromCharCode(acc);
                    }
                } else { // Unexpected continuation byte
                    res += this.defaultCharUnicode;
                }
            }
        }
        this.acc = acc; this.contBytes = contBytes; this.accBytes = accBytes;
        return res;
    };

    InternalDecoderCesu8.prototype.end = function() {
        var res = 0;
        if (this.contBytes > 0)
            res += this.defaultCharUnicode;
        return res;
    };

    var utf16 = {};

    var Buffer$6 = safer_1.Buffer;

    // Note: UTF16-LE (or UCS2) codec is Node.js native. See encodings/internal.js

    // == UTF16-BE codec. ==========================================================

    utf16.utf16be = Utf16BECodec;
    function Utf16BECodec() {
    }

    Utf16BECodec.prototype.encoder = Utf16BEEncoder;
    Utf16BECodec.prototype.decoder = Utf16BEDecoder;
    Utf16BECodec.prototype.bomAware = true;


    // -- Encoding

    function Utf16BEEncoder() {
    }

    Utf16BEEncoder.prototype.write = function(str) {
        var buf = Buffer$6.from(str, 'ucs2');
        for (var i = 0; i < buf.length; i += 2) {
            var tmp = buf[i]; buf[i] = buf[i+1]; buf[i+1] = tmp;
        }
        return buf;
    };

    Utf16BEEncoder.prototype.end = function() {
    };


    // -- Decoding

    function Utf16BEDecoder() {
        this.overflowByte = -1;
    }

    Utf16BEDecoder.prototype.write = function(buf) {
        if (buf.length == 0)
            return '';

        var buf2 = Buffer$6.alloc(buf.length + 1),
            i = 0, j = 0;

        if (this.overflowByte !== -1) {
            buf2[0] = buf[0];
            buf2[1] = this.overflowByte;
            i = 1; j = 2;
        }

        for (; i < buf.length-1; i += 2, j+= 2) {
            buf2[j] = buf[i+1];
            buf2[j+1] = buf[i];
        }

        this.overflowByte = (i == buf.length-1) ? buf[buf.length-1] : -1;

        return buf2.slice(0, j).toString('ucs2');
    };

    Utf16BEDecoder.prototype.end = function() {
    };


    // == UTF-16 codec =============================================================
    // Decoder chooses automatically from UTF-16LE and UTF-16BE using BOM and space-based heuristic.
    // Defaults to UTF-16LE, as it's prevalent and default in Node.
    // http://en.wikipedia.org/wiki/UTF-16 and http://encoding.spec.whatwg.org/#utf-16le
    // Decoder default can be changed: iconv.decode(buf, 'utf16', {defaultEncoding: 'utf-16be'});

    // Encoder uses UTF-16LE and prepends BOM (which can be overridden with addBOM: false).

    utf16.utf16 = Utf16Codec;
    function Utf16Codec(codecOptions, iconv) {
        this.iconv = iconv;
    }

    Utf16Codec.prototype.encoder = Utf16Encoder;
    Utf16Codec.prototype.decoder = Utf16Decoder;


    // -- Encoding (pass-through)

    function Utf16Encoder(options, codec) {
        options = options || {};
        if (options.addBOM === undefined)
            options.addBOM = true;
        this.encoder = codec.iconv.getEncoder('utf-16le', options);
    }

    Utf16Encoder.prototype.write = function(str) {
        return this.encoder.write(str);
    };

    Utf16Encoder.prototype.end = function() {
        return this.encoder.end();
    };


    // -- Decoding

    function Utf16Decoder(options, codec) {
        this.decoder = null;
        this.initialBytes = [];
        this.initialBytesLen = 0;

        this.options = options || {};
        this.iconv = codec.iconv;
    }

    Utf16Decoder.prototype.write = function(buf) {
        if (!this.decoder) {
            // Codec is not chosen yet. Accumulate initial bytes.
            this.initialBytes.push(buf);
            this.initialBytesLen += buf.length;
            
            if (this.initialBytesLen < 16) // We need more bytes to use space heuristic (see below)
                return '';

            // We have enough bytes -> detect endianness.
            var buf = Buffer$6.concat(this.initialBytes),
                encoding = detectEncoding(buf, this.options.defaultEncoding);
            this.decoder = this.iconv.getDecoder(encoding, this.options);
            this.initialBytes.length = this.initialBytesLen = 0;
        }

        return this.decoder.write(buf);
    };

    Utf16Decoder.prototype.end = function() {
        if (!this.decoder) {
            var buf = Buffer$6.concat(this.initialBytes),
                encoding = detectEncoding(buf, this.options.defaultEncoding);
            this.decoder = this.iconv.getDecoder(encoding, this.options);

            var res = this.decoder.write(buf),
                trail = this.decoder.end();

            return trail ? (res + trail) : res;
        }
        return this.decoder.end();
    };

    function detectEncoding(buf, defaultEncoding) {
        var enc = defaultEncoding || 'utf-16le';

        if (buf.length >= 2) {
            // Check BOM.
            if (buf[0] == 0xFE && buf[1] == 0xFF) // UTF-16BE BOM
                enc = 'utf-16be';
            else if (buf[0] == 0xFF && buf[1] == 0xFE) // UTF-16LE BOM
                enc = 'utf-16le';
            else {
                // No BOM found. Try to deduce encoding from initial content.
                // Most of the time, the content has ASCII chars (U+00**), but the opposite (U+**00) is uncommon.
                // So, we count ASCII as if it was LE or BE, and decide from that.
                var asciiCharsLE = 0, asciiCharsBE = 0, // Counts of chars in both positions
                    _len = Math.min(buf.length - (buf.length % 2), 64); // Len is always even.

                for (var i = 0; i < _len; i += 2) {
                    if (buf[i] === 0 && buf[i+1] !== 0) asciiCharsBE++;
                    if (buf[i] !== 0 && buf[i+1] === 0) asciiCharsLE++;
                }

                if (asciiCharsBE > asciiCharsLE)
                    enc = 'utf-16be';
                else if (asciiCharsBE < asciiCharsLE)
                    enc = 'utf-16le';
            }
        }

        return enc;
    }

    var utf7 = {};

    var Buffer$5 = safer_1.Buffer;

    // UTF-7 codec, according to https://tools.ietf.org/html/rfc2152
    // See also below a UTF-7-IMAP codec, according to http://tools.ietf.org/html/rfc3501#section-5.1.3

    utf7.utf7 = Utf7Codec;
    utf7.unicode11utf7 = 'utf7'; // Alias UNICODE-1-1-UTF-7
    function Utf7Codec(codecOptions, iconv) {
        this.iconv = iconv;
    }
    Utf7Codec.prototype.encoder = Utf7Encoder;
    Utf7Codec.prototype.decoder = Utf7Decoder;
    Utf7Codec.prototype.bomAware = true;


    // -- Encoding

    var nonDirectChars = /[^A-Za-z0-9'\(\),-\.\/:\? \n\r\t]+/g;

    function Utf7Encoder(options, codec) {
        this.iconv = codec.iconv;
    }

    Utf7Encoder.prototype.write = function(str) {
        // Naive implementation.
        // Non-direct chars are encoded as "+<base64>-"; single "+" char is encoded as "+-".
        return Buffer$5.from(str.replace(nonDirectChars, function(chunk) {
            return "+" + (chunk === '+' ? '' : 
                this.iconv.encode(chunk, 'utf16-be').toString('base64').replace(/=+$/, '')) 
                + "-";
        }.bind(this)));
    };

    Utf7Encoder.prototype.end = function() {
    };


    // -- Decoding

    function Utf7Decoder(options, codec) {
        this.iconv = codec.iconv;
        this.inBase64 = false;
        this.base64Accum = '';
    }

    var base64Regex = /[A-Za-z0-9\/+]/;
    var base64Chars = [];
    for (var i$1 = 0; i$1 < 256; i$1++)
        base64Chars[i$1] = base64Regex.test(String.fromCharCode(i$1));

    var plusChar = '+'.charCodeAt(0), 
        minusChar = '-'.charCodeAt(0),
        andChar = '&'.charCodeAt(0);

    Utf7Decoder.prototype.write = function(buf) {
        var res = "", lastI = 0,
            inBase64 = this.inBase64,
            base64Accum = this.base64Accum;

        // The decoder is more involved as we must handle chunks in stream.

        for (var i = 0; i < buf.length; i++) {
            if (!inBase64) { // We're in direct mode.
                // Write direct chars until '+'
                if (buf[i] == plusChar) {
                    res += this.iconv.decode(buf.slice(lastI, i), "ascii"); // Write direct chars.
                    lastI = i+1;
                    inBase64 = true;
                }
            } else { // We decode base64.
                if (!base64Chars[buf[i]]) { // Base64 ended.
                    if (i == lastI && buf[i] == minusChar) {// "+-" -> "+"
                        res += "+";
                    } else {
                        var b64str = base64Accum + buf.slice(lastI, i).toString();
                        res += this.iconv.decode(Buffer$5.from(b64str, 'base64'), "utf16-be");
                    }

                    if (buf[i] != minusChar) // Minus is absorbed after base64.
                        i--;

                    lastI = i+1;
                    inBase64 = false;
                    base64Accum = '';
                }
            }
        }

        if (!inBase64) {
            res += this.iconv.decode(buf.slice(lastI), "ascii"); // Write direct chars.
        } else {
            var b64str = base64Accum + buf.slice(lastI).toString();

            var canBeDecoded = b64str.length - (b64str.length % 8); // Minimal chunk: 2 quads -> 2x3 bytes -> 3 chars.
            base64Accum = b64str.slice(canBeDecoded); // The rest will be decoded in future.
            b64str = b64str.slice(0, canBeDecoded);

            res += this.iconv.decode(Buffer$5.from(b64str, 'base64'), "utf16-be");
        }

        this.inBase64 = inBase64;
        this.base64Accum = base64Accum;

        return res;
    };

    Utf7Decoder.prototype.end = function() {
        var res = "";
        if (this.inBase64 && this.base64Accum.length > 0)
            res = this.iconv.decode(Buffer$5.from(this.base64Accum, 'base64'), "utf16-be");

        this.inBase64 = false;
        this.base64Accum = '';
        return res;
    };


    // UTF-7-IMAP codec.
    // RFC3501 Sec. 5.1.3 Modified UTF-7 (http://tools.ietf.org/html/rfc3501#section-5.1.3)
    // Differences:
    //  * Base64 part is started by "&" instead of "+"
    //  * Direct characters are 0x20-0x7E, except "&" (0x26)
    //  * In Base64, "," is used instead of "/"
    //  * Base64 must not be used to represent direct characters.
    //  * No implicit shift back from Base64 (should always end with '-')
    //  * String must end in non-shifted position.
    //  * "-&" while in base64 is not allowed.


    utf7.utf7imap = Utf7IMAPCodec;
    function Utf7IMAPCodec(codecOptions, iconv) {
        this.iconv = iconv;
    }
    Utf7IMAPCodec.prototype.encoder = Utf7IMAPEncoder;
    Utf7IMAPCodec.prototype.decoder = Utf7IMAPDecoder;
    Utf7IMAPCodec.prototype.bomAware = true;


    // -- Encoding

    function Utf7IMAPEncoder(options, codec) {
        this.iconv = codec.iconv;
        this.inBase64 = false;
        this.base64Accum = Buffer$5.alloc(6);
        this.base64AccumIdx = 0;
    }

    Utf7IMAPEncoder.prototype.write = function(str) {
        var inBase64 = this.inBase64,
            base64Accum = this.base64Accum,
            base64AccumIdx = this.base64AccumIdx,
            buf = Buffer$5.alloc(str.length*5 + 10), bufIdx = 0;

        for (var i = 0; i < str.length; i++) {
            var uChar = str.charCodeAt(i);
            if (0x20 <= uChar && uChar <= 0x7E) { // Direct character or '&'.
                if (inBase64) {
                    if (base64AccumIdx > 0) {
                        bufIdx += buf.write(base64Accum.slice(0, base64AccumIdx).toString('base64').replace(/\//g, ',').replace(/=+$/, ''), bufIdx);
                        base64AccumIdx = 0;
                    }

                    buf[bufIdx++] = minusChar; // Write '-', then go to direct mode.
                    inBase64 = false;
                }

                if (!inBase64) {
                    buf[bufIdx++] = uChar; // Write direct character

                    if (uChar === andChar)  // Ampersand -> '&-'
                        buf[bufIdx++] = minusChar;
                }

            } else { // Non-direct character
                if (!inBase64) {
                    buf[bufIdx++] = andChar; // Write '&', then go to base64 mode.
                    inBase64 = true;
                }
                if (inBase64) {
                    base64Accum[base64AccumIdx++] = uChar >> 8;
                    base64Accum[base64AccumIdx++] = uChar & 0xFF;

                    if (base64AccumIdx == base64Accum.length) {
                        bufIdx += buf.write(base64Accum.toString('base64').replace(/\//g, ','), bufIdx);
                        base64AccumIdx = 0;
                    }
                }
            }
        }

        this.inBase64 = inBase64;
        this.base64AccumIdx = base64AccumIdx;

        return buf.slice(0, bufIdx);
    };

    Utf7IMAPEncoder.prototype.end = function() {
        var buf = Buffer$5.alloc(10), bufIdx = 0;
        if (this.inBase64) {
            if (this.base64AccumIdx > 0) {
                bufIdx += buf.write(this.base64Accum.slice(0, this.base64AccumIdx).toString('base64').replace(/\//g, ',').replace(/=+$/, ''), bufIdx);
                this.base64AccumIdx = 0;
            }

            buf[bufIdx++] = minusChar; // Write '-', then go to direct mode.
            this.inBase64 = false;
        }

        return buf.slice(0, bufIdx);
    };


    // -- Decoding

    function Utf7IMAPDecoder(options, codec) {
        this.iconv = codec.iconv;
        this.inBase64 = false;
        this.base64Accum = '';
    }

    var base64IMAPChars = base64Chars.slice();
    base64IMAPChars[','.charCodeAt(0)] = true;

    Utf7IMAPDecoder.prototype.write = function(buf) {
        var res = "", lastI = 0,
            inBase64 = this.inBase64,
            base64Accum = this.base64Accum;

        // The decoder is more involved as we must handle chunks in stream.
        // It is forgiving, closer to standard UTF-7 (for example, '-' is optional at the end).

        for (var i = 0; i < buf.length; i++) {
            if (!inBase64) { // We're in direct mode.
                // Write direct chars until '&'
                if (buf[i] == andChar) {
                    res += this.iconv.decode(buf.slice(lastI, i), "ascii"); // Write direct chars.
                    lastI = i+1;
                    inBase64 = true;
                }
            } else { // We decode base64.
                if (!base64IMAPChars[buf[i]]) { // Base64 ended.
                    if (i == lastI && buf[i] == minusChar) { // "&-" -> "&"
                        res += "&";
                    } else {
                        var b64str = base64Accum + buf.slice(lastI, i).toString().replace(/,/g, '/');
                        res += this.iconv.decode(Buffer$5.from(b64str, 'base64'), "utf16-be");
                    }

                    if (buf[i] != minusChar) // Minus may be absorbed after base64.
                        i--;

                    lastI = i+1;
                    inBase64 = false;
                    base64Accum = '';
                }
            }
        }

        if (!inBase64) {
            res += this.iconv.decode(buf.slice(lastI), "ascii"); // Write direct chars.
        } else {
            var b64str = base64Accum + buf.slice(lastI).toString().replace(/,/g, '/');

            var canBeDecoded = b64str.length - (b64str.length % 8); // Minimal chunk: 2 quads -> 2x3 bytes -> 3 chars.
            base64Accum = b64str.slice(canBeDecoded); // The rest will be decoded in future.
            b64str = b64str.slice(0, canBeDecoded);

            res += this.iconv.decode(Buffer$5.from(b64str, 'base64'), "utf16-be");
        }

        this.inBase64 = inBase64;
        this.base64Accum = base64Accum;

        return res;
    };

    Utf7IMAPDecoder.prototype.end = function() {
        var res = "";
        if (this.inBase64 && this.base64Accum.length > 0)
            res = this.iconv.decode(Buffer$5.from(this.base64Accum, 'base64'), "utf16-be");

        this.inBase64 = false;
        this.base64Accum = '';
        return res;
    };

    var sbcsCodec = {};

    var Buffer$4 = safer_1.Buffer;

    // Single-byte codec. Needs a 'chars' string parameter that contains 256 or 128 chars that
    // correspond to encoded bytes (if 128 - then lower half is ASCII). 

    sbcsCodec._sbcs = SBCSCodec;
    function SBCSCodec(codecOptions, iconv) {
        if (!codecOptions)
            throw new Error("SBCS codec is called without the data.")
        
        // Prepare char buffer for decoding.
        if (!codecOptions.chars || (codecOptions.chars.length !== 128 && codecOptions.chars.length !== 256))
            throw new Error("Encoding '"+codecOptions.type+"' has incorrect 'chars' (must be of len 128 or 256)");
        
        if (codecOptions.chars.length === 128) {
            var asciiString = "";
            for (var i = 0; i < 128; i++)
                asciiString += String.fromCharCode(i);
            codecOptions.chars = asciiString + codecOptions.chars;
        }

        this.decodeBuf = Buffer$4.from(codecOptions.chars, 'ucs2');
        
        // Encoding buffer.
        var encodeBuf = Buffer$4.alloc(65536, iconv.defaultCharSingleByte.charCodeAt(0));

        for (var i = 0; i < codecOptions.chars.length; i++)
            encodeBuf[codecOptions.chars.charCodeAt(i)] = i;

        this.encodeBuf = encodeBuf;
    }

    SBCSCodec.prototype.encoder = SBCSEncoder;
    SBCSCodec.prototype.decoder = SBCSDecoder;


    function SBCSEncoder(options, codec) {
        this.encodeBuf = codec.encodeBuf;
    }

    SBCSEncoder.prototype.write = function(str) {
        var buf = Buffer$4.alloc(str.length);
        for (var i = 0; i < str.length; i++)
            buf[i] = this.encodeBuf[str.charCodeAt(i)];
        
        return buf;
    };

    SBCSEncoder.prototype.end = function() {
    };


    function SBCSDecoder(options, codec) {
        this.decodeBuf = codec.decodeBuf;
    }

    SBCSDecoder.prototype.write = function(buf) {
        // Strings are immutable in JS -> we use ucs2 buffer to speed up computations.
        var decodeBuf = this.decodeBuf;
        var newBuf = Buffer$4.alloc(buf.length*2);
        var idx1 = 0, idx2 = 0;
        for (var i = 0; i < buf.length; i++) {
            idx1 = buf[i]*2; idx2 = i*2;
            newBuf[idx2] = decodeBuf[idx1];
            newBuf[idx2+1] = decodeBuf[idx1+1];
        }
        return newBuf.toString('ucs2');
    };

    SBCSDecoder.prototype.end = function() {
    };

    // Manually added data to be used by sbcs codec in addition to generated one.

    var sbcsData = {
        // Not supported by iconv, not sure why.
        "10029": "maccenteuro",
        "maccenteuro": {
            "type": "_sbcs",
            "chars": ""
        },

        "808": "cp808",
        "ibm808": "cp808",
        "cp808": {
            "type": "_sbcs",
            "chars": ""
        },

        "mik": {
            "type": "_sbcs",
            "chars": ""
        },

        // Aliases of generated encodings.
        "ascii8bit": "ascii",
        "usascii": "ascii",
        "ansix34": "ascii",
        "ansix341968": "ascii",
        "ansix341986": "ascii",
        "csascii": "ascii",
        "cp367": "ascii",
        "ibm367": "ascii",
        "isoir6": "ascii",
        "iso646us": "ascii",
        "iso646irv": "ascii",
        "us": "ascii",

        "latin1": "iso88591",
        "latin2": "iso88592",
        "latin3": "iso88593",
        "latin4": "iso88594",
        "latin5": "iso88599",
        "latin6": "iso885910",
        "latin7": "iso885913",
        "latin8": "iso885914",
        "latin9": "iso885915",
        "latin10": "iso885916",

        "csisolatin1": "iso88591",
        "csisolatin2": "iso88592",
        "csisolatin3": "iso88593",
        "csisolatin4": "iso88594",
        "csisolatincyrillic": "iso88595",
        "csisolatinarabic": "iso88596",
        "csisolatingreek" : "iso88597",
        "csisolatinhebrew": "iso88598",
        "csisolatin5": "iso88599",
        "csisolatin6": "iso885910",

        "l1": "iso88591",
        "l2": "iso88592",
        "l3": "iso88593",
        "l4": "iso88594",
        "l5": "iso88599",
        "l6": "iso885910",
        "l7": "iso885913",
        "l8": "iso885914",
        "l9": "iso885915",
        "l10": "iso885916",

        "isoir14": "iso646jp",
        "isoir57": "iso646cn",
        "isoir100": "iso88591",
        "isoir101": "iso88592",
        "isoir109": "iso88593",
        "isoir110": "iso88594",
        "isoir144": "iso88595",
        "isoir127": "iso88596",
        "isoir126": "iso88597",
        "isoir138": "iso88598",
        "isoir148": "iso88599",
        "isoir157": "iso885910",
        "isoir166": "tis620",
        "isoir179": "iso885913",
        "isoir199": "iso885914",
        "isoir203": "iso885915",
        "isoir226": "iso885916",

        "cp819": "iso88591",
        "ibm819": "iso88591",

        "cyrillic": "iso88595",

        "arabic": "iso88596",
        "arabic8": "iso88596",
        "ecma114": "iso88596",
        "asmo708": "iso88596",

        "greek" : "iso88597",
        "greek8" : "iso88597",
        "ecma118" : "iso88597",
        "elot928" : "iso88597",

        "hebrew": "iso88598",
        "hebrew8": "iso88598",

        "turkish": "iso88599",
        "turkish8": "iso88599",

        "thai": "iso885911",
        "thai8": "iso885911",

        "celtic": "iso885914",
        "celtic8": "iso885914",
        "isoceltic": "iso885914",

        "tis6200": "tis620",
        "tis62025291": "tis620",
        "tis62025330": "tis620",

        "10000": "macroman",
        "10006": "macgreek",
        "10007": "maccyrillic",
        "10079": "maciceland",
        "10081": "macturkish",

        "cspc8codepage437": "cp437",
        "cspc775baltic": "cp775",
        "cspc850multilingual": "cp850",
        "cspcp852": "cp852",
        "cspc862latinhebrew": "cp862",
        "cpgr": "cp869",

        "msee": "cp1250",
        "mscyrl": "cp1251",
        "msansi": "cp1252",
        "msgreek": "cp1253",
        "msturk": "cp1254",
        "mshebr": "cp1255",
        "msarab": "cp1256",
        "winbaltrim": "cp1257",

        "cp20866": "koi8r",
        "20866": "koi8r",
        "ibm878": "koi8r",
        "cskoi8r": "koi8r",

        "cp21866": "koi8u",
        "21866": "koi8u",
        "ibm1168": "koi8u",

        "strk10482002": "rk1048",

        "tcvn5712": "tcvn",
        "tcvn57121": "tcvn",

        "gb198880": "iso646cn",
        "cn": "iso646cn",

        "csiso14jisc6220ro": "iso646jp",
        "jisc62201969ro": "iso646jp",
        "jp": "iso646jp",

        "cshproman8": "hproman8",
        "r8": "hproman8",
        "roman8": "hproman8",
        "xroman8": "hproman8",
        "ibm1051": "hproman8",

        "mac": "macintosh",
        "csmacintosh": "macintosh",
    };

    // Generated data for sbcs codec. Don't edit manually. Regenerate using generation/gen-sbcs.js script.
    var sbcsDataGenerated = {
      "437": "cp437",
      "737": "cp737",
      "775": "cp775",
      "850": "cp850",
      "852": "cp852",
      "855": "cp855",
      "856": "cp856",
      "857": "cp857",
      "858": "cp858",
      "860": "cp860",
      "861": "cp861",
      "862": "cp862",
      "863": "cp863",
      "864": "cp864",
      "865": "cp865",
      "866": "cp866",
      "869": "cp869",
      "874": "windows874",
      "922": "cp922",
      "1046": "cp1046",
      "1124": "cp1124",
      "1125": "cp1125",
      "1129": "cp1129",
      "1133": "cp1133",
      "1161": "cp1161",
      "1162": "cp1162",
      "1163": "cp1163",
      "1250": "windows1250",
      "1251": "windows1251",
      "1252": "windows1252",
      "1253": "windows1253",
      "1254": "windows1254",
      "1255": "windows1255",
      "1256": "windows1256",
      "1257": "windows1257",
      "1258": "windows1258",
      "28591": "iso88591",
      "28592": "iso88592",
      "28593": "iso88593",
      "28594": "iso88594",
      "28595": "iso88595",
      "28596": "iso88596",
      "28597": "iso88597",
      "28598": "iso88598",
      "28599": "iso88599",
      "28600": "iso885910",
      "28601": "iso885911",
      "28603": "iso885913",
      "28604": "iso885914",
      "28605": "iso885915",
      "28606": "iso885916",
      "windows874": {
        "type": "_sbcs",
        "chars": ""
      },
      "win874": "windows874",
      "cp874": "windows874",
      "windows1250": {
        "type": "_sbcs",
        "chars": ""
      },
      "win1250": "windows1250",
      "cp1250": "windows1250",
      "windows1251": {
        "type": "_sbcs",
        "chars": ""
      },
      "win1251": "windows1251",
      "cp1251": "windows1251",
      "windows1252": {
        "type": "_sbcs",
        "chars": ""
      },
      "win1252": "windows1252",
      "cp1252": "windows1252",
      "windows1253": {
        "type": "_sbcs",
        "chars": ""
      },
      "win1253": "windows1253",
      "cp1253": "windows1253",
      "windows1254": {
        "type": "_sbcs",
        "chars": ""
      },
      "win1254": "windows1254",
      "cp1254": "windows1254",
      "windows1255": {
        "type": "_sbcs",
        "chars": ""
      },
      "win1255": "windows1255",
      "cp1255": "windows1255",
      "windows1256": {
        "type": "_sbcs",
        "chars": ""
      },
      "win1256": "windows1256",
      "cp1256": "windows1256",
      "windows1257": {
        "type": "_sbcs",
        "chars": ""
      },
      "win1257": "windows1257",
      "cp1257": "windows1257",
      "windows1258": {
        "type": "_sbcs",
        "chars": ""
      },
      "win1258": "windows1258",
      "cp1258": "windows1258",
      "iso88591": {
        "type": "_sbcs",
        "chars": ""
      },
      "cp28591": "iso88591",
      "iso88592": {
        "type": "_sbcs",
        "chars": ""
      },
      "cp28592": "iso88592",
      "iso88593": {
        "type": "_sbcs",
        "chars": ""
      },
      "cp28593": "iso88593",
      "iso88594": {
        "type": "_sbcs",
        "chars": ""
      },
      "cp28594": "iso88594",
      "iso88595": {
        "type": "_sbcs",
        "chars": ""
      },
      "cp28595": "iso88595",
      "iso88596": {
        "type": "_sbcs",
        "chars": ""
      },
      "cp28596": "iso88596",
      "iso88597": {
        "type": "_sbcs",
        "chars": ""
      },
      "cp28597": "iso88597",
      "iso88598": {
        "type": "_sbcs",
        "chars": ""
      },
      "cp28598": "iso88598",
      "iso88599": {
        "type": "_sbcs",
        "chars": ""
      },
      "cp28599": "iso88599",
      "iso885910": {
        "type": "_sbcs",
        "chars": ""
      },
      "cp28600": "iso885910",
      "iso885911": {
        "type": "_sbcs",
        "chars": ""
      },
      "cp28601": "iso885911",
      "iso885913": {
        "type": "_sbcs",
        "chars": ""
      },
      "cp28603": "iso885913",
      "iso885914": {
        "type": "_sbcs",
        "chars": ""
      },
      "cp28604": "iso885914",
      "iso885915": {
        "type": "_sbcs",
        "chars": ""
      },
      "cp28605": "iso885915",
      "iso885916": {
        "type": "_sbcs",
        "chars": ""
      },
      "cp28606": "iso885916",
      "cp437": {
        "type": "_sbcs",
        "chars": ""
      },
      "ibm437": "cp437",
      "csibm437": "cp437",
      "cp737": {
        "type": "_sbcs",
        "chars": ""
      },
      "ibm737": "cp737",
      "csibm737": "cp737",
      "cp775": {
        "type": "_sbcs",
        "chars": ""
      },
      "ibm775": "cp775",
      "csibm775": "cp775",
      "cp850": {
        "type": "_sbcs",
        "chars": ""
      },
      "ibm850": "cp850",
      "csibm850": "cp850",
      "cp852": {
        "type": "_sbcs",
        "chars": ""
      },
      "ibm852": "cp852",
      "csibm852": "cp852",
      "cp855": {
        "type": "_sbcs",
        "chars": ""
      },
      "ibm855": "cp855",
      "csibm855": "cp855",
      "cp856": {
        "type": "_sbcs",
        "chars": ""
      },
      "ibm856": "cp856",
      "csibm856": "cp856",
      "cp857": {
        "type": "_sbcs",
        "chars": ""
      },
      "ibm857": "cp857",
      "csibm857": "cp857",
      "cp858": {
        "type": "_sbcs",
        "chars": ""
      },
      "ibm858": "cp858",
      "csibm858": "cp858",
      "cp860": {
        "type": "_sbcs",
        "chars": ""
      },
      "ibm860": "cp860",
      "csibm860": "cp860",
      "cp861": {
        "type": "_sbcs",
        "chars": ""
      },
      "ibm861": "cp861",
      "csibm861": "cp861",
      "cp862": {
        "type": "_sbcs",
        "chars": ""
      },
      "ibm862": "cp862",
      "csibm862": "cp862",
      "cp863": {
        "type": "_sbcs",
        "chars": ""
      },
      "ibm863": "cp863",
      "csibm863": "cp863",
      "cp864": {
        "type": "_sbcs",
        "chars": "\u0000\u0001\u0002\u0003\u0004\u0005\u0006\u0007\b\t\n\u000b\f\r\u000e\u000f\u0010\u0011\u0012\u0013\u0014\u0015\u0016\u0017\u0018\u0019\u001a\u001b\u001c\u001d\u001e\u001f !\"#$&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~"
      },
      "ibm864": "cp864",
      "csibm864": "cp864",
      "cp865": {
        "type": "_sbcs",
        "chars": ""
      },
      "ibm865": "cp865",
      "csibm865": "cp865",
      "cp866": {
        "type": "_sbcs",
        "chars": ""
      },
      "ibm866": "cp866",
      "csibm866": "cp866",
      "cp869": {
        "type": "_sbcs",
        "chars": ""
      },
      "ibm869": "cp869",
      "csibm869": "cp869",
      "cp922": {
        "type": "_sbcs",
        "chars": ""
      },
      "ibm922": "cp922",
      "csibm922": "cp922",
      "cp1046": {
        "type": "_sbcs",
        "chars": ""
      },
      "ibm1046": "cp1046",
      "csibm1046": "cp1046",
      "cp1124": {
        "type": "_sbcs",
        "chars": ""
      },
      "ibm1124": "cp1124",
      "csibm1124": "cp1124",
      "cp1125": {
        "type": "_sbcs",
        "chars": ""
      },
      "ibm1125": "cp1125",
      "csibm1125": "cp1125",
      "cp1129": {
        "type": "_sbcs",
        "chars": ""
      },
      "ibm1129": "cp1129",
      "csibm1129": "cp1129",
      "cp1133": {
        "type": "_sbcs",
        "chars": ""
      },
      "ibm1133": "cp1133",
      "csibm1133": "cp1133",
      "cp1161": {
        "type": "_sbcs",
        "chars": ""
      },
      "ibm1161": "cp1161",
      "csibm1161": "cp1161",
      "cp1162": {
        "type": "_sbcs",
        "chars": ""
      },
      "ibm1162": "cp1162",
      "csibm1162": "cp1162",
      "cp1163": {
        "type": "_sbcs",
        "chars": ""
      },
      "ibm1163": "cp1163",
      "csibm1163": "cp1163",
      "maccroatian": {
        "type": "_sbcs",
        "chars": ""
      },
      "maccyrillic": {
        "type": "_sbcs",
        "chars": ""
      },
      "macgreek": {
        "type": "_sbcs",
        "chars": ""
      },
      "maciceland": {
        "type": "_sbcs",
        "chars": ""
      },
      "macroman": {
        "type": "_sbcs",
        "chars": ""
      },
      "macromania": {
        "type": "_sbcs",
        "chars": ""
      },
      "macthai": {
        "type": "_sbcs",
        "chars": ""
      },
      "macturkish": {
        "type": "_sbcs",
        "chars": ""
      },
      "macukraine": {
        "type": "_sbcs",
        "chars": ""
      },
      "koi8r": {
        "type": "_sbcs",
        "chars": ""
      },
      "koi8u": {
        "type": "_sbcs",
        "chars": ""
      },
      "koi8ru": {
        "type": "_sbcs",
        "chars": ""
      },
      "koi8t": {
        "type": "_sbcs",
        "chars": ""
      },
      "armscii8": {
        "type": "_sbcs",
        "chars": ")(.,-"
      },
      "rk1048": {
        "type": "_sbcs",
        "chars": ""
      },
      "tcvn": {
        "type": "_sbcs",
        "chars": "\u0000\u0003\u0007\b\t\n\u000b\f\r\u000e\u000f\u0010\u0018\u0019\u001a\u001b\u001c\u001d\u001e\u001f !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~"
      },
      "georgianacademy": {
        "type": "_sbcs",
        "chars": ""
      },
      "georgianps": {
        "type": "_sbcs",
        "chars": ""
      },
      "pt154": {
        "type": "_sbcs",
        "chars": ""
      },
      "viscii": {
        "type": "_sbcs",
        "chars": "\u0000\u0001\u0003\u0004\u0007\b\t\n\u000b\f\r\u000e\u000f\u0010\u0011\u0012\u0013\u0015\u0016\u0017\u0018\u001a\u001b\u001c\u001d\u001f !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~"
      },
      "iso646cn": {
        "type": "_sbcs",
        "chars": "\u0000\u0001\u0002\u0003\u0004\u0005\u0006\u0007\b\t\n\u000b\f\r\u000e\u000f\u0010\u0011\u0012\u0013\u0014\u0015\u0016\u0017\u0018\u0019\u001a\u001b\u001c\u001d\u001e\u001f !\"#%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}"
      },
      "iso646jp": {
        "type": "_sbcs",
        "chars": "\u0000\u0001\u0002\u0003\u0004\u0005\u0006\u0007\b\t\n\u000b\f\r\u000e\u000f\u0010\u0011\u0012\u0013\u0014\u0015\u0016\u0017\u0018\u0019\u001a\u001b\u001c\u001d\u001e\u001f !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[]^_`abcdefghijklmnopqrstuvwxyz{|}"
      },
      "hproman8": {
        "type": "_sbcs",
        "chars": ""
      },
      "macintosh": {
        "type": "_sbcs",
        "chars": ""
      },
      "ascii": {
        "type": "_sbcs",
        "chars": ""
      },
      "tis620": {
        "type": "_sbcs",
        "chars": ""
      }
    };

    var dbcsCodec = {};

    var Buffer$3 = safer_1.Buffer;

    // Multibyte codec. In this scheme, a character is represented by 1 or more bytes.
    // Our codec supports UTF-16 surrogates, extensions for GB18030 and unicode sequences.
    // To save memory and loading time, we read table files only when requested.

    dbcsCodec._dbcs = DBCSCodec;

    var UNASSIGNED = -1,
        GB18030_CODE = -2,
        SEQ_START  = -10,
        NODE_START = -1000,
        UNASSIGNED_NODE = new Array(0x100),
        DEF_CHAR = -1;

    for (var i = 0; i < 0x100; i++)
        UNASSIGNED_NODE[i] = UNASSIGNED;


    // Class DBCSCodec reads and initializes mapping tables.
    function DBCSCodec(codecOptions, iconv) {
        this.encodingName = codecOptions.encodingName;
        if (!codecOptions)
            throw new Error("DBCS codec is called without the data.")
        if (!codecOptions.table)
            throw new Error("Encoding '" + this.encodingName + "' has no data.");

        // Load tables.
        var mappingTable = codecOptions.table();


        // Decode tables: MBCS -> Unicode.

        // decodeTables is a trie, encoded as an array of arrays of integers. Internal arrays are trie nodes and all have len = 256.
        // Trie root is decodeTables[0].
        // Values: >=  0 -> unicode character code. can be > 0xFFFF
        //         == UNASSIGNED -> unknown/unassigned sequence.
        //         == GB18030_CODE -> this is the end of a GB18030 4-byte sequence.
        //         <= NODE_START -> index of the next node in our trie to process next byte.
        //         <= SEQ_START  -> index of the start of a character code sequence, in decodeTableSeq.
        this.decodeTables = [];
        this.decodeTables[0] = UNASSIGNED_NODE.slice(0); // Create root node.

        // Sometimes a MBCS char corresponds to a sequence of unicode chars. We store them as arrays of integers here. 
        this.decodeTableSeq = [];

        // Actual mapping tables consist of chunks. Use them to fill up decode tables.
        for (var i = 0; i < mappingTable.length; i++)
            this._addDecodeChunk(mappingTable[i]);

        this.defaultCharUnicode = iconv.defaultCharUnicode;

        
        // Encode tables: Unicode -> DBCS.

        // `encodeTable` is array mapping from unicode char to encoded char. All its values are integers for performance.
        // Because it can be sparse, it is represented as array of buckets by 256 chars each. Bucket can be null.
        // Values: >=  0 -> it is a normal char. Write the value (if <=256 then 1 byte, if <=65536 then 2 bytes, etc.).
        //         == UNASSIGNED -> no conversion found. Output a default char.
        //         <= SEQ_START  -> it's an index in encodeTableSeq, see below. The character starts a sequence.
        this.encodeTable = [];
        
        // `encodeTableSeq` is used when a sequence of unicode characters is encoded as a single code. We use a tree of
        // objects where keys correspond to characters in sequence and leafs are the encoded dbcs values. A special DEF_CHAR key
        // means end of sequence (needed when one sequence is a strict subsequence of another).
        // Objects are kept separately from encodeTable to increase performance.
        this.encodeTableSeq = [];

        // Some chars can be decoded, but need not be encoded.
        var skipEncodeChars = {};
        if (codecOptions.encodeSkipVals)
            for (var i = 0; i < codecOptions.encodeSkipVals.length; i++) {
                var val = codecOptions.encodeSkipVals[i];
                if (typeof val === 'number')
                    skipEncodeChars[val] = true;
                else
                    for (var j = val.from; j <= val.to; j++)
                        skipEncodeChars[j] = true;
            }
            
        // Use decode trie to recursively fill out encode tables.
        this._fillEncodeTable(0, 0, skipEncodeChars);

        // Add more encoding pairs when needed.
        if (codecOptions.encodeAdd) {
            for (var uChar in codecOptions.encodeAdd)
                if (Object.prototype.hasOwnProperty.call(codecOptions.encodeAdd, uChar))
                    this._setEncodeChar(uChar.charCodeAt(0), codecOptions.encodeAdd[uChar]);
        }

        this.defCharSB  = this.encodeTable[0][iconv.defaultCharSingleByte.charCodeAt(0)];
        if (this.defCharSB === UNASSIGNED) this.defCharSB = this.encodeTable[0]['?'];
        if (this.defCharSB === UNASSIGNED) this.defCharSB = "?".charCodeAt(0);


        // Load & create GB18030 tables when needed.
        if (typeof codecOptions.gb18030 === 'function') {
            this.gb18030 = codecOptions.gb18030(); // Load GB18030 ranges.

            // Add GB18030 decode tables.
            var thirdByteNodeIdx = this.decodeTables.length;
            var thirdByteNode = this.decodeTables[thirdByteNodeIdx] = UNASSIGNED_NODE.slice(0);

            var fourthByteNodeIdx = this.decodeTables.length;
            var fourthByteNode = this.decodeTables[fourthByteNodeIdx] = UNASSIGNED_NODE.slice(0);

            for (var i = 0x81; i <= 0xFE; i++) {
                var secondByteNodeIdx = NODE_START - this.decodeTables[0][i];
                var secondByteNode = this.decodeTables[secondByteNodeIdx];
                for (var j = 0x30; j <= 0x39; j++)
                    secondByteNode[j] = NODE_START - thirdByteNodeIdx;
            }
            for (var i = 0x81; i <= 0xFE; i++)
                thirdByteNode[i] = NODE_START - fourthByteNodeIdx;
            for (var i = 0x30; i <= 0x39; i++)
                fourthByteNode[i] = GB18030_CODE;
        }        
    }

    DBCSCodec.prototype.encoder = DBCSEncoder;
    DBCSCodec.prototype.decoder = DBCSDecoder;

    // Decoder helpers
    DBCSCodec.prototype._getDecodeTrieNode = function(addr) {
        var bytes = [];
        for (; addr > 0; addr >>= 8)
            bytes.push(addr & 0xFF);
        if (bytes.length == 0)
            bytes.push(0);

        var node = this.decodeTables[0];
        for (var i = bytes.length-1; i > 0; i--) { // Traverse nodes deeper into the trie.
            var val = node[bytes[i]];

            if (val == UNASSIGNED) { // Create new node.
                node[bytes[i]] = NODE_START - this.decodeTables.length;
                this.decodeTables.push(node = UNASSIGNED_NODE.slice(0));
            }
            else if (val <= NODE_START) { // Existing node.
                node = this.decodeTables[NODE_START - val];
            }
            else
                throw new Error("Overwrite byte in " + this.encodingName + ", addr: " + addr.toString(16));
        }
        return node;
    };


    DBCSCodec.prototype._addDecodeChunk = function(chunk) {
        // First element of chunk is the hex mbcs code where we start.
        var curAddr = parseInt(chunk[0], 16);

        // Choose the decoding node where we'll write our chars.
        var writeTable = this._getDecodeTrieNode(curAddr);
        curAddr = curAddr & 0xFF;

        // Write all other elements of the chunk to the table.
        for (var k = 1; k < chunk.length; k++) {
            var part = chunk[k];
            if (typeof part === "string") { // String, write as-is.
                for (var l = 0; l < part.length;) {
                    var code = part.charCodeAt(l++);
                    if (0xD800 <= code && code < 0xDC00) { // Decode surrogate
                        var codeTrail = part.charCodeAt(l++);
                        if (0xDC00 <= codeTrail && codeTrail < 0xE000)
                            writeTable[curAddr++] = 0x10000 + (code - 0xD800) * 0x400 + (codeTrail - 0xDC00);
                        else
                            throw new Error("Incorrect surrogate pair in "  + this.encodingName + " at chunk " + chunk[0]);
                    }
                    else if (0x0FF0 < code && code <= 0x0FFF) { // Character sequence (our own encoding used)
                        var len = 0xFFF - code + 2;
                        var seq = [];
                        for (var m = 0; m < len; m++)
                            seq.push(part.charCodeAt(l++)); // Simple variation: don't support surrogates or subsequences in seq.

                        writeTable[curAddr++] = SEQ_START - this.decodeTableSeq.length;
                        this.decodeTableSeq.push(seq);
                    }
                    else
                        writeTable[curAddr++] = code; // Basic char
                }
            } 
            else if (typeof part === "number") { // Integer, meaning increasing sequence starting with prev character.
                var charCode = writeTable[curAddr - 1] + 1;
                for (var l = 0; l < part; l++)
                    writeTable[curAddr++] = charCode++;
            }
            else
                throw new Error("Incorrect type '" + typeof part + "' given in "  + this.encodingName + " at chunk " + chunk[0]);
        }
        if (curAddr > 0xFF)
            throw new Error("Incorrect chunk in "  + this.encodingName + " at addr " + chunk[0] + ": too long" + curAddr);
    };

    // Encoder helpers
    DBCSCodec.prototype._getEncodeBucket = function(uCode) {
        var high = uCode >> 8; // This could be > 0xFF because of astral characters.
        if (this.encodeTable[high] === undefined)
            this.encodeTable[high] = UNASSIGNED_NODE.slice(0); // Create bucket on demand.
        return this.encodeTable[high];
    };

    DBCSCodec.prototype._setEncodeChar = function(uCode, dbcsCode) {
        var bucket = this._getEncodeBucket(uCode);
        var low = uCode & 0xFF;
        if (bucket[low] <= SEQ_START)
            this.encodeTableSeq[SEQ_START-bucket[low]][DEF_CHAR] = dbcsCode; // There's already a sequence, set a single-char subsequence of it.
        else if (bucket[low] == UNASSIGNED)
            bucket[low] = dbcsCode;
    };

    DBCSCodec.prototype._setEncodeSequence = function(seq, dbcsCode) {
        
        // Get the root of character tree according to first character of the sequence.
        var uCode = seq[0];
        var bucket = this._getEncodeBucket(uCode);
        var low = uCode & 0xFF;

        var node;
        if (bucket[low] <= SEQ_START) {
            // There's already a sequence with  - use it.
            node = this.encodeTableSeq[SEQ_START-bucket[low]];
        }
        else {
            // There was no sequence object - allocate a new one.
            node = {};
            if (bucket[low] !== UNASSIGNED) node[DEF_CHAR] = bucket[low]; // If a char was set before - make it a single-char subsequence.
            bucket[low] = SEQ_START - this.encodeTableSeq.length;
            this.encodeTableSeq.push(node);
        }

        // Traverse the character tree, allocating new nodes as needed.
        for (var j = 1; j < seq.length-1; j++) {
            var oldVal = node[uCode];
            if (typeof oldVal === 'object')
                node = oldVal;
            else {
                node = node[uCode] = {};
                if (oldVal !== undefined)
                    node[DEF_CHAR] = oldVal;
            }
        }

        // Set the leaf to given dbcsCode.
        uCode = seq[seq.length-1];
        node[uCode] = dbcsCode;
    };

    DBCSCodec.prototype._fillEncodeTable = function(nodeIdx, prefix, skipEncodeChars) {
        var node = this.decodeTables[nodeIdx];
        for (var i = 0; i < 0x100; i++) {
            var uCode = node[i];
            var mbCode = prefix + i;
            if (skipEncodeChars[mbCode])
                continue;

            if (uCode >= 0)
                this._setEncodeChar(uCode, mbCode);
            else if (uCode <= NODE_START)
                this._fillEncodeTable(NODE_START - uCode, mbCode << 8, skipEncodeChars);
            else if (uCode <= SEQ_START)
                this._setEncodeSequence(this.decodeTableSeq[SEQ_START - uCode], mbCode);
        }
    };



    // == Encoder ==================================================================

    function DBCSEncoder(options, codec) {
        // Encoder state
        this.leadSurrogate = -1;
        this.seqObj = undefined;
        
        // Static data
        this.encodeTable = codec.encodeTable;
        this.encodeTableSeq = codec.encodeTableSeq;
        this.defaultCharSingleByte = codec.defCharSB;
        this.gb18030 = codec.gb18030;
    }

    DBCSEncoder.prototype.write = function(str) {
        var newBuf = Buffer$3.alloc(str.length * (this.gb18030 ? 4 : 3)),
            leadSurrogate = this.leadSurrogate,
            seqObj = this.seqObj, nextChar = -1,
            i = 0, j = 0;

        while (true) {
            // 0. Get next character.
            if (nextChar === -1) {
                if (i == str.length) break;
                var uCode = str.charCodeAt(i++);
            }
            else {
                var uCode = nextChar;
                nextChar = -1;    
            }

            // 1. Handle surrogates.
            if (0xD800 <= uCode && uCode < 0xE000) { // Char is one of surrogates.
                if (uCode < 0xDC00) { // We've got lead surrogate.
                    if (leadSurrogate === -1) {
                        leadSurrogate = uCode;
                        continue;
                    } else {
                        leadSurrogate = uCode;
                        // Double lead surrogate found.
                        uCode = UNASSIGNED;
                    }
                } else { // We've got trail surrogate.
                    if (leadSurrogate !== -1) {
                        uCode = 0x10000 + (leadSurrogate - 0xD800) * 0x400 + (uCode - 0xDC00);
                        leadSurrogate = -1;
                    } else {
                        // Incomplete surrogate pair - only trail surrogate found.
                        uCode = UNASSIGNED;
                    }
                    
                }
            }
            else if (leadSurrogate !== -1) {
                // Incomplete surrogate pair - only lead surrogate found.
                nextChar = uCode; uCode = UNASSIGNED; // Write an error, then current char.
                leadSurrogate = -1;
            }

            // 2. Convert uCode character.
            var dbcsCode = UNASSIGNED;
            if (seqObj !== undefined && uCode != UNASSIGNED) { // We are in the middle of the sequence
                var resCode = seqObj[uCode];
                if (typeof resCode === 'object') { // Sequence continues.
                    seqObj = resCode;
                    continue;

                } else if (typeof resCode == 'number') { // Sequence finished. Write it.
                    dbcsCode = resCode;

                } else if (resCode == undefined) { // Current character is not part of the sequence.

                    // Try default character for this sequence
                    resCode = seqObj[DEF_CHAR];
                    if (resCode !== undefined) {
                        dbcsCode = resCode; // Found. Write it.
                        nextChar = uCode; // Current character will be written too in the next iteration.

                    }
                }
                seqObj = undefined;
            }
            else if (uCode >= 0) {  // Regular character
                var subtable = this.encodeTable[uCode >> 8];
                if (subtable !== undefined)
                    dbcsCode = subtable[uCode & 0xFF];
                
                if (dbcsCode <= SEQ_START) { // Sequence start
                    seqObj = this.encodeTableSeq[SEQ_START-dbcsCode];
                    continue;
                }

                if (dbcsCode == UNASSIGNED && this.gb18030) {
                    // Use GB18030 algorithm to find character(s) to write.
                    var idx = findIdx(this.gb18030.uChars, uCode);
                    if (idx != -1) {
                        var dbcsCode = this.gb18030.gbChars[idx] + (uCode - this.gb18030.uChars[idx]);
                        newBuf[j++] = 0x81 + Math.floor(dbcsCode / 12600); dbcsCode = dbcsCode % 12600;
                        newBuf[j++] = 0x30 + Math.floor(dbcsCode / 1260); dbcsCode = dbcsCode % 1260;
                        newBuf[j++] = 0x81 + Math.floor(dbcsCode / 10); dbcsCode = dbcsCode % 10;
                        newBuf[j++] = 0x30 + dbcsCode;
                        continue;
                    }
                }
            }

            // 3. Write dbcsCode character.
            if (dbcsCode === UNASSIGNED)
                dbcsCode = this.defaultCharSingleByte;
            
            if (dbcsCode < 0x100) {
                newBuf[j++] = dbcsCode;
            }
            else if (dbcsCode < 0x10000) {
                newBuf[j++] = dbcsCode >> 8;   // high byte
                newBuf[j++] = dbcsCode & 0xFF; // low byte
            }
            else {
                newBuf[j++] = dbcsCode >> 16;
                newBuf[j++] = (dbcsCode >> 8) & 0xFF;
                newBuf[j++] = dbcsCode & 0xFF;
            }
        }

        this.seqObj = seqObj;
        this.leadSurrogate = leadSurrogate;
        return newBuf.slice(0, j);
    };

    DBCSEncoder.prototype.end = function() {
        if (this.leadSurrogate === -1 && this.seqObj === undefined)
            return; // All clean. Most often case.

        var newBuf = Buffer$3.alloc(10), j = 0;

        if (this.seqObj) { // We're in the sequence.
            var dbcsCode = this.seqObj[DEF_CHAR];
            if (dbcsCode !== undefined) { // Write beginning of the sequence.
                if (dbcsCode < 0x100) {
                    newBuf[j++] = dbcsCode;
                }
                else {
                    newBuf[j++] = dbcsCode >> 8;   // high byte
                    newBuf[j++] = dbcsCode & 0xFF; // low byte
                }
            }
            this.seqObj = undefined;
        }

        if (this.leadSurrogate !== -1) {
            // Incomplete surrogate pair - only lead surrogate found.
            newBuf[j++] = this.defaultCharSingleByte;
            this.leadSurrogate = -1;
        }
        
        return newBuf.slice(0, j);
    };

    // Export for testing
    DBCSEncoder.prototype.findIdx = findIdx;


    // == Decoder ==================================================================

    function DBCSDecoder(options, codec) {
        // Decoder state
        this.nodeIdx = 0;
        this.prevBuf = Buffer$3.alloc(0);

        // Static data
        this.decodeTables = codec.decodeTables;
        this.decodeTableSeq = codec.decodeTableSeq;
        this.defaultCharUnicode = codec.defaultCharUnicode;
        this.gb18030 = codec.gb18030;
    }

    DBCSDecoder.prototype.write = function(buf) {
        var newBuf = Buffer$3.alloc(buf.length*2),
            nodeIdx = this.nodeIdx, 
            prevBuf = this.prevBuf, prevBufOffset = this.prevBuf.length,
            seqStart = -this.prevBuf.length, // idx of the start of current parsed sequence.
            uCode;

        if (prevBufOffset > 0) // Make prev buf overlap a little to make it easier to slice later.
            prevBuf = Buffer$3.concat([prevBuf, buf.slice(0, 10)]);
        
        for (var i = 0, j = 0; i < buf.length; i++) {
            var curByte = (i >= 0) ? buf[i] : prevBuf[i + prevBufOffset];

            // Lookup in current trie node.
            var uCode = this.decodeTables[nodeIdx][curByte];

            if (uCode >= 0) ;
            else if (uCode === UNASSIGNED) { // Unknown char.
                // TODO: Callback with seq.
                //var curSeq = (seqStart >= 0) ? buf.slice(seqStart, i+1) : prevBuf.slice(seqStart + prevBufOffset, i+1 + prevBufOffset);
                i = seqStart; // Try to parse again, after skipping first byte of the sequence ('i' will be incremented by 'for' cycle).
                uCode = this.defaultCharUnicode.charCodeAt(0);
            }
            else if (uCode === GB18030_CODE) {
                var curSeq = (seqStart >= 0) ? buf.slice(seqStart, i+1) : prevBuf.slice(seqStart + prevBufOffset, i+1 + prevBufOffset);
                var ptr = (curSeq[0]-0x81)*12600 + (curSeq[1]-0x30)*1260 + (curSeq[2]-0x81)*10 + (curSeq[3]-0x30);
                var idx = findIdx(this.gb18030.gbChars, ptr);
                uCode = this.gb18030.uChars[idx] + ptr - this.gb18030.gbChars[idx];
            }
            else if (uCode <= NODE_START) { // Go to next trie node.
                nodeIdx = NODE_START - uCode;
                continue;
            }
            else if (uCode <= SEQ_START) { // Output a sequence of chars.
                var seq = this.decodeTableSeq[SEQ_START - uCode];
                for (var k = 0; k < seq.length - 1; k++) {
                    uCode = seq[k];
                    newBuf[j++] = uCode & 0xFF;
                    newBuf[j++] = uCode >> 8;
                }
                uCode = seq[seq.length-1];
            }
            else
                throw new Error("iconv-lite internal error: invalid decoding table value " + uCode + " at " + nodeIdx + "/" + curByte);

            // Write the character to buffer, handling higher planes using surrogate pair.
            if (uCode > 0xFFFF) { 
                uCode -= 0x10000;
                var uCodeLead = 0xD800 + Math.floor(uCode / 0x400);
                newBuf[j++] = uCodeLead & 0xFF;
                newBuf[j++] = uCodeLead >> 8;

                uCode = 0xDC00 + uCode % 0x400;
            }
            newBuf[j++] = uCode & 0xFF;
            newBuf[j++] = uCode >> 8;

            // Reset trie node.
            nodeIdx = 0; seqStart = i+1;
        }

        this.nodeIdx = nodeIdx;
        this.prevBuf = (seqStart >= 0) ? buf.slice(seqStart) : prevBuf.slice(seqStart + prevBufOffset);
        return newBuf.slice(0, j).toString('ucs2');
    };

    DBCSDecoder.prototype.end = function() {
        var ret = '';

        // Try to parse all remaining chars.
        while (this.prevBuf.length > 0) {
            // Skip 1 character in the buffer.
            ret += this.defaultCharUnicode;
            var buf = this.prevBuf.slice(1);

            // Parse remaining as usual.
            this.prevBuf = Buffer$3.alloc(0);
            this.nodeIdx = 0;
            if (buf.length > 0)
                ret += this.write(buf);
        }

        this.nodeIdx = 0;
        return ret;
    };

    // Binary search for GB18030. Returns largest i such that table[i] <= val.
    function findIdx(table, val) {
        if (table[0] > val)
            return -1;

        var l = 0, r = table.length;
        while (l < r-1) { // always table[l] <= val < table[r]
            var mid = l + Math.floor((r-l+1)/2);
            if (table[mid] <= val)
                l = mid;
            else
                r = mid;
        }
        return l;
    }

    var require$$0 = [
    	[
    		"0",
    		"\u0000",
    		128
    	],
    	[
    		"a1",
    		"",
    		62
    	],
    	[
    		"8140",
    		"",
    		9,
    		""
    	],
    	[
    		"8180",
    		""
    	],
    	[
    		"81b8",
    		""
    	],
    	[
    		"81c8",
    		""
    	],
    	[
    		"81da",
    		""
    	],
    	[
    		"81f0",
    		""
    	],
    	[
    		"81fc",
    		""
    	],
    	[
    		"824f",
    		"",
    		9
    	],
    	[
    		"8260",
    		"",
    		25
    	],
    	[
    		"8281",
    		"",
    		25
    	],
    	[
    		"829f",
    		"",
    		82
    	],
    	[
    		"8340",
    		"",
    		62
    	],
    	[
    		"8380",
    		"",
    		22
    	],
    	[
    		"839f",
    		"",
    		16,
    		"",
    		6
    	],
    	[
    		"83bf",
    		"",
    		16,
    		"",
    		6
    	],
    	[
    		"8440",
    		"",
    		5,
    		"",
    		25
    	],
    	[
    		"8470",
    		"",
    		5,
    		"",
    		7
    	],
    	[
    		"8480",
    		"",
    		17
    	],
    	[
    		"849f",
    		""
    	],
    	[
    		"8740",
    		"",
    		19,
    		"",
    		9
    	],
    	[
    		"875f",
    		""
    	],
    	[
    		"877e",
    		""
    	],
    	[
    		"8780",
    		"",
    		4,
    		""
    	],
    	[
    		"889f",
    		""
    	],
    	[
    		"8940",
    		""
    	],
    	[
    		"8980",
    		""
    	],
    	[
    		"8a40",
    		""
    	],
    	[
    		"8a80",
    		""
    	],
    	[
    		"8b40",
    		""
    	],
    	[
    		"8b80",
    		""
    	],
    	[
    		"8c40",
    		""
    	],
    	[
    		"8c80",
    		""
    	],
    	[
    		"8d40",
    		""
    	],
    	[
    		"8d80",
    		""
    	],
    	[
    		"8e40",
    		""
    	],
    	[
    		"8e80",
    		""
    	],
    	[
    		"8f40",
    		""
    	],
    	[
    		"8f80",
    		""
    	],
    	[
    		"9040",
    		""
    	],
    	[
    		"9080",
    		""
    	],
    	[
    		"9140",
    		""
    	],
    	[
    		"9180",
    		""
    	],
    	[
    		"9240",
    		""
    	],
    	[
    		"9280",
    		""
    	],
    	[
    		"9340",
    		""
    	],
    	[
    		"9380",
    		""
    	],
    	[
    		"9440",
    		""
    	],
    	[
    		"9480",
    		""
    	],
    	[
    		"9540",
    		""
    	],
    	[
    		"9580",
    		""
    	],
    	[
    		"9640",
    		""
    	],
    	[
    		"9680",
    		""
    	],
    	[
    		"9740",
    		""
    	],
    	[
    		"9780",
    		""
    	],
    	[
    		"9840",
    		""
    	],
    	[
    		"989f",
    		""
    	],
    	[
    		"9940",
    		""
    	],
    	[
    		"9980",
    		""
    	],
    	[
    		"9a40",
    		""
    	],
    	[
    		"9a80",
    		""
    	],
    	[
    		"9b40",
    		""
    	],
    	[
    		"9b80",
    		""
    	],
    	[
    		"9c40",
    		""
    	],
    	[
    		"9c80",
    		""
    	],
    	[
    		"9d40",
    		""
    	],
    	[
    		"9d80",
    		""
    	],
    	[
    		"9e40",
    		""
    	],
    	[
    		"9e80",
    		""
    	],
    	[
    		"9f40",
    		""
    	],
    	[
    		"9f80",
    		""
    	],
    	[
    		"e040",
    		""
    	],
    	[
    		"e080",
    		""
    	],
    	[
    		"e140",
    		""
    	],
    	[
    		"e180",
    		""
    	],
    	[
    		"e240",
    		""
    	],
    	[
    		"e280",
    		""
    	],
    	[
    		"e340",
    		""
    	],
    	[
    		"e380",
    		""
    	],
    	[
    		"e440",
    		""
    	],
    	[
    		"e480",
    		""
    	],
    	[
    		"e540",
    		""
    	],
    	[
    		"e580",
    		""
    	],
    	[
    		"e640",
    		""
    	],
    	[
    		"e680",
    		""
    	],
    	[
    		"e740",
    		""
    	],
    	[
    		"e780",
    		""
    	],
    	[
    		"e840",
    		""
    	],
    	[
    		"e880",
    		""
    	],
    	[
    		"e940",
    		""
    	],
    	[
    		"e980",
    		""
    	],
    	[
    		"ea40",
    		""
    	],
    	[
    		"ea80",
    		""
    	],
    	[
    		"ed40",
    		""
    	],
    	[
    		"ed80",
    		""
    	],
    	[
    		"ee40",
    		""
    	],
    	[
    		"ee80",
    		""
    	],
    	[
    		"eeef",
    		"",
    		9,
    		""
    	],
    	[
    		"f040",
    		"",
    		62
    	],
    	[
    		"f080",
    		"",
    		124
    	],
    	[
    		"f140",
    		"",
    		62
    	],
    	[
    		"f180",
    		"",
    		124
    	],
    	[
    		"f240",
    		"",
    		62
    	],
    	[
    		"f280",
    		"",
    		124
    	],
    	[
    		"f340",
    		"",
    		62
    	],
    	[
    		"f380",
    		"",
    		124
    	],
    	[
    		"f440",
    		"",
    		62
    	],
    	[
    		"f480",
    		"",
    		124
    	],
    	[
    		"f540",
    		"",
    		62
    	],
    	[
    		"f580",
    		"",
    		124
    	],
    	[
    		"f640",
    		"",
    		62
    	],
    	[
    		"f680",
    		"",
    		124
    	],
    	[
    		"f740",
    		"",
    		62
    	],
    	[
    		"f780",
    		"",
    		124
    	],
    	[
    		"f840",
    		"",
    		62
    	],
    	[
    		"f880",
    		"",
    		124
    	],
    	[
    		"f940",
    		""
    	],
    	[
    		"fa40",
    		"",
    		9,
    		"",
    		9,
    		""
    	],
    	[
    		"fa80",
    		""
    	],
    	[
    		"fb40",
    		""
    	],
    	[
    		"fb80",
    		""
    	],
    	[
    		"fc40",
    		""
    	]
    ];

    var require$$1 = [
    	[
    		"0",
    		"\u0000",
    		127
    	],
    	[
    		"8ea1",
    		"",
    		62
    	],
    	[
    		"a1a1",
    		"",
    		9,
    		""
    	],
    	[
    		"a2a1",
    		""
    	],
    	[
    		"a2ba",
    		""
    	],
    	[
    		"a2ca",
    		""
    	],
    	[
    		"a2dc",
    		""
    	],
    	[
    		"a2f2",
    		""
    	],
    	[
    		"a2fe",
    		""
    	],
    	[
    		"a3b0",
    		"",
    		9
    	],
    	[
    		"a3c1",
    		"",
    		25
    	],
    	[
    		"a3e1",
    		"",
    		25
    	],
    	[
    		"a4a1",
    		"",
    		82
    	],
    	[
    		"a5a1",
    		"",
    		85
    	],
    	[
    		"a6a1",
    		"",
    		16,
    		"",
    		6
    	],
    	[
    		"a6c1",
    		"",
    		16,
    		"",
    		6
    	],
    	[
    		"a7a1",
    		"",
    		5,
    		"",
    		25
    	],
    	[
    		"a7d1",
    		"",
    		5,
    		"",
    		25
    	],
    	[
    		"a8a1",
    		""
    	],
    	[
    		"ada1",
    		"",
    		19,
    		"",
    		9
    	],
    	[
    		"adc0",
    		""
    	],
    	[
    		"addf",
    		"",
    		4,
    		""
    	],
    	[
    		"b0a1",
    		""
    	],
    	[
    		"b1a1",
    		""
    	],
    	[
    		"b2a1",
    		""
    	],
    	[
    		"b3a1",
    		""
    	],
    	[
    		"b4a1",
    		""
    	],
    	[
    		"b5a1",
    		""
    	],
    	[
    		"b6a1",
    		""
    	],
    	[
    		"b7a1",
    		""
    	],
    	[
    		"b8a1",
    		""
    	],
    	[
    		"b9a1",
    		""
    	],
    	[
    		"baa1",
    		""
    	],
    	[
    		"bba1",
    		""
    	],
    	[
    		"bca1",
    		""
    	],
    	[
    		"bda1",
    		""
    	],
    	[
    		"bea1",
    		""
    	],
    	[
    		"bfa1",
    		""
    	],
    	[
    		"c0a1",
    		""
    	],
    	[
    		"c1a1",
    		""
    	],
    	[
    		"c2a1",
    		""
    	],
    	[
    		"c3a1",
    		""
    	],
    	[
    		"c4a1",
    		""
    	],
    	[
    		"c5a1",
    		""
    	],
    	[
    		"c6a1",
    		""
    	],
    	[
    		"c7a1",
    		""
    	],
    	[
    		"c8a1",
    		""
    	],
    	[
    		"c9a1",
    		""
    	],
    	[
    		"caa1",
    		""
    	],
    	[
    		"cba1",
    		""
    	],
    	[
    		"cca1",
    		""
    	],
    	[
    		"cda1",
    		""
    	],
    	[
    		"cea1",
    		""
    	],
    	[
    		"cfa1",
    		""
    	],
    	[
    		"d0a1",
    		""
    	],
    	[
    		"d1a1",
    		""
    	],
    	[
    		"d2a1",
    		""
    	],
    	[
    		"d3a1",
    		""
    	],
    	[
    		"d4a1",
    		""
    	],
    	[
    		"d5a1",
    		""
    	],
    	[
    		"d6a1",
    		""
    	],
    	[
    		"d7a1",
    		""
    	],
    	[
    		"d8a1",
    		""
    	],
    	[
    		"d9a1",
    		""
    	],
    	[
    		"daa1",
    		""
    	],
    	[
    		"dba1",
    		""
    	],
    	[
    		"dca1",
    		""
    	],
    	[
    		"dda1",
    		""
    	],
    	[
    		"dea1",
    		""
    	],
    	[
    		"dfa1",
    		""
    	],
    	[
    		"e0a1",
    		""
    	],
    	[
    		"e1a1",
    		""
    	],
    	[
    		"e2a1",
    		""
    	],
    	[
    		"e3a1",
    		""
    	],
    	[
    		"e4a1",
    		""
    	],
    	[
    		"e5a1",
    		""
    	],
    	[
    		"e6a1",
    		""
    	],
    	[
    		"e7a1",
    		""
    	],
    	[
    		"e8a1",
    		""
    	],
    	[
    		"e9a1",
    		""
    	],
    	[
    		"eaa1",
    		""
    	],
    	[
    		"eba1",
    		""
    	],
    	[
    		"eca1",
    		""
    	],
    	[
    		"eda1",
    		""
    	],
    	[
    		"eea1",
    		""
    	],
    	[
    		"efa1",
    		""
    	],
    	[
    		"f0a1",
    		""
    	],
    	[
    		"f1a1",
    		""
    	],
    	[
    		"f2a1",
    		""
    	],
    	[
    		"f3a1",
    		""
    	],
    	[
    		"f4a1",
    		""
    	],
    	[
    		"f9a1",
    		""
    	],
    	[
    		"faa1",
    		""
    	],
    	[
    		"fba1",
    		""
    	],
    	[
    		"fca1",
    		""
    	],
    	[
    		"fcf1",
    		"",
    		9,
    		""
    	],
    	[
    		"8fa2af",
    		""
    	],
    	[
    		"8fa2c2",
    		""
    	],
    	[
    		"8fa2eb",
    		""
    	],
    	[
    		"8fa6e1",
    		""
    	],
    	[
    		"8fa6e7",
    		""
    	],
    	[
    		"8fa6e9",
    		""
    	],
    	[
    		"8fa6ec",
    		""
    	],
    	[
    		"8fa6f1",
    		""
    	],
    	[
    		"8fa7c2",
    		"",
    		10,
    		""
    	],
    	[
    		"8fa7f2",
    		"",
    		10,
    		""
    	],
    	[
    		"8fa9a1",
    		""
    	],
    	[
    		"8fa9a4",
    		""
    	],
    	[
    		"8fa9a6",
    		""
    	],
    	[
    		"8fa9a8",
    		""
    	],
    	[
    		"8fa9ab",
    		""
    	],
    	[
    		"8fa9af",
    		""
    	],
    	[
    		"8fa9c1",
    		""
    	],
    	[
    		"8faaa1",
    		""
    	],
    	[
    		"8faaba",
    		""
    	],
    	[
    		"8faba1",
    		""
    	],
    	[
    		"8fabbd",
    		""
    	],
    	[
    		"8fabc5",
    		""
    	],
    	[
    		"8fb0a1",
    		""
    	],
    	[
    		"8fb1a1",
    		""
    	],
    	[
    		"8fb2a1",
    		"",
    		4,
    		""
    	],
    	[
    		"8fb3a1",
    		""
    	],
    	[
    		"8fb4a1",
    		""
    	],
    	[
    		"8fb5a1",
    		""
    	],
    	[
    		"8fb6a1",
    		"",
    		5,
    		"",
    		4,
    		""
    	],
    	[
    		"8fb7a1",
    		"",
    		4,
    		""
    	],
    	[
    		"8fb8a1",
    		""
    	],
    	[
    		"8fb9a1",
    		""
    	],
    	[
    		"8fbaa1",
    		"",
    		4,
    		""
    	],
    	[
    		"8fbba1",
    		""
    	],
    	[
    		"8fbca1",
    		"",
    		4,
    		""
    	],
    	[
    		"8fbda1",
    		"",
    		4,
    		""
    	],
    	[
    		"8fbea1",
    		"",
    		4,
    		""
    	],
    	[
    		"8fbfa1",
    		""
    	],
    	[
    		"8fc0a1",
    		""
    	],
    	[
    		"8fc1a1",
    		""
    	],
    	[
    		"8fc2a1",
    		""
    	],
    	[
    		"8fc3a1",
    		"",
    		4,
    		""
    	],
    	[
    		"8fc4a1",
    		""
    	],
    	[
    		"8fc5a1",
    		""
    	],
    	[
    		"8fc6a1",
    		""
    	],
    	[
    		"8fc7a1",
    		""
    	],
    	[
    		"8fc8a1",
    		""
    	],
    	[
    		"8fc9a1",
    		"",
    		4,
    		"",
    		4,
    		""
    	],
    	[
    		"8fcaa1",
    		""
    	],
    	[
    		"8fcba1",
    		""
    	],
    	[
    		"8fcca1",
    		"",
    		9,
    		""
    	],
    	[
    		"8fcda1",
    		"",
    		5,
    		""
    	],
    	[
    		"8fcea1",
    		"",
    		6,
    		""
    	],
    	[
    		"8fcfa1",
    		""
    	],
    	[
    		"8fd0a1",
    		""
    	],
    	[
    		"8fd1a1",
    		""
    	],
    	[
    		"8fd2a1",
    		"",
    		5
    	],
    	[
    		"8fd3a1",
    		""
    	],
    	[
    		"8fd4a1",
    		"",
    		4,
    		""
    	],
    	[
    		"8fd5a1",
    		""
    	],
    	[
    		"8fd6a1",
    		""
    	],
    	[
    		"8fd7a1",
    		""
    	],
    	[
    		"8fd8a1",
    		""
    	],
    	[
    		"8fd9a1",
    		"",
    		4,
    		"",
    		6,
    		""
    	],
    	[
    		"8fdaa1",
    		"",
    		4,
    		""
    	],
    	[
    		"8fdba1",
    		"",
    		6,
    		""
    	],
    	[
    		"8fdca1",
    		"",
    		4,
    		""
    	],
    	[
    		"8fdda1",
    		"",
    		4,
    		""
    	],
    	[
    		"8fdea1",
    		"",
    		4,
    		""
    	],
    	[
    		"8fdfa1",
    		""
    	],
    	[
    		"8fe0a1",
    		""
    	],
    	[
    		"8fe1a1",
    		"",
    		4,
    		""
    	],
    	[
    		"8fe2a1",
    		""
    	],
    	[
    		"8fe3a1",
    		"",
    		5,
    		"",
    		4,
    		""
    	],
    	[
    		"8fe4a1",
    		"",
    		4,
    		""
    	],
    	[
    		"8fe5a1",
    		"",
    		4,
    		""
    	],
    	[
    		"8fe6a1",
    		""
    	],
    	[
    		"8fe7a1",
    		""
    	],
    	[
    		"8fe8a1",
    		"",
    		4,
    		""
    	],
    	[
    		"8fe9a1",
    		"",
    		4
    	],
    	[
    		"8feaa1",
    		"",
    		4,
    		""
    	],
    	[
    		"8feba1",
    		"",
    		4,
    		""
    	],
    	[
    		"8feca1",
    		""
    	],
    	[
    		"8feda1",
    		"",
    		4,
    		"",
    		4,
    		""
    	]
    ];

    var require$$2 = [
    	[
    		"0",
    		"\u0000",
    		127,
    		""
    	],
    	[
    		"8140",
    		"",
    		5,
    		"",
    		9,
    		"",
    		6,
    		""
    	],
    	[
    		"8180",
    		"",
    		6,
    		"",
    		4,
    		"",
    		4,
    		"",
    		5,
    		""
    	],
    	[
    		"8240",
    		"",
    		4,
    		"",
    		8,
    		"",
    		4,
    		"",
    		11
    	],
    	[
    		"8280",
    		"",
    		10,
    		"",
    		4,
    		"",
    		7,
    		"",
    		5,
    		"",
    		8,
    		"",
    		20,
    		"",
    		4,
    		"",
    		6,
    		""
    	],
    	[
    		"8340",
    		"",
    		17,
    		"",
    		5,
    		"",
    		10,
    		"",
    		4,
    		"",
    		9,
    		""
    	],
    	[
    		"8380",
    		"",
    		5,
    		"",
    		13,
    		"",
    		28,
    		"",
    		4,
    		"",
    		4,
    		"",
    		5
    	],
    	[
    		"8440",
    		"",
    		5,
    		"",
    		5,
    		""
    	],
    	[
    		"8480",
    		"",
    		9,
    		"",
    		4,
    		"",
    		6,
    		"",
    		6,
    		"",
    		9,
    		"",
    		5,
    		"",
    		10,
    		"",
    		7,
    		""
    	],
    	[
    		"8540",
    		"",
    		9,
    		""
    	],
    	[
    		"8580",
    		"",
    		4,
    		"",
    		6,
    		"",
    		4,
    		"",
    		4,
    		"",
    		7,
    		""
    	],
    	[
    		"8640",
    		"",
    		4,
    		"",
    		5,
    		"",
    		4,
    		"",
    		5,
    		""
    	],
    	[
    		"8680",
    		"",
    		4,
    		"",
    		4,
    		"",
    		5,
    		"",
    		6,
    		"",
    		8,
    		"",
    		4,
    		"",
    		4,
    		"",
    		4,
    		""
    	],
    	[
    		"8740",
    		"",
    		7,
    		"",
    		11,
    		"",
    		4,
    		"",
    		4
    	],
    	[
    		"8780",
    		"",
    		7,
    		"",
    		6,
    		"",
    		14,
    		"",
    		10,
    		"",
    		6,
    		"",
    		12,
    		"",
    		8,
    		"",
    		5,
    		"",
    		6
    	],
    	[
    		"8840",
    		"",
    		9,
    		"",
    		4,
    		"",
    		4,
    		""
    	],
    	[
    		"8880",
    		"",
    		4,
    		"",
    		6,
    		"",
    		8,
    		"",
    		6,
    		"",
    		7,
    		"",
    		4,
    		"",
    		4,
    		"",
    		7
    	],
    	[
    		"8940",
    		"",
    		5,
    		"",
    		6,
    		"",
    		4,
    		"",
    		5,
    		"",
    		4,
    		"",
    		16,
    		""
    	],
    	[
    		"8980",
    		"",
    		4,
    		"",
    		4,
    		"",
    		7,
    		"",
    		17,
    		"",
    		10,
    		"",
    		13,
    		"",
    		5,
    		"",
    		7,
    		"",
    		4,
    		""
    	],
    	[
    		"8a40",
    		"",
    		4,
    		"",
    		12,
    		""
    	],
    	[
    		"8a80",
    		"",
    		5,
    		"",
    		6,
    		"",
    		4,
    		"",
    		11,
    		"",
    		6,
    		"",
    		4,
    		"",
    		4,
    		"",
    		9,
    		"",
    		5
    	],
    	[
    		"8b40",
    		"",
    		8,
    		"",
    		17,
    		"",
    		6,
    		"",
    		13,
    		""
    	],
    	[
    		"8b80",
    		"",
    		4,
    		"",
    		4,
    		"",
    		5,
    		"",
    		4,
    		"",
    		4,
    		"",
    		22,
    		"",
    		11,
    		"",
    		25,
    		"",
    		7,
    		"",
    		6
    	],
    	[
    		"8c40",
    		"",
    		7,
    		""
    	],
    	[
    		"8c80",
    		"",
    		8,
    		"",
    		4,
    		"",
    		6,
    		"",
    		6,
    		"",
    		6,
    		"",
    		4,
    		"",
    		4,
    		"",
    		4
    	],
    	[
    		"8d40",
    		"",
    		5,
    		"",
    		5,
    		"",
    		5,
    		"",
    		6,
    		"",
    		9,
    		"",
    		4
    	],
    	[
    		"8d80",
    		"",
    		5,
    		"",
    		4,
    		"",
    		4,
    		"",
    		4,
    		"",
    		7,
    		"",
    		7,
    		"",
    		10,
    		"",
    		10,
    		"",
    		12,
    		"",
    		21,
    		""
    	],
    	[
    		"8e40",
    		"",
    		21,
    		"",
    		12,
    		"",
    		6,
    		"",
    		12,
    		""
    	],
    	[
    		"8e80",
    		"",
    		4,
    		"",
    		7,
    		"",
    		4,
    		"",
    		4,
    		"",
    		5,
    		"",
    		6,
    		"",
    		4,
    		"",
    		14,
    		"",
    		4,
    		"",
    		4,
    		"",
    		6
    	],
    	[
    		"8f40",
    		"",
    		5,
    		"",
    		11,
    		"",
    		8,
    		""
    	],
    	[
    		"8f80",
    		"",
    		6,
    		"",
    		14,
    		"",
    		5,
    		"",
    		5,
    		"",
    		4,
    		""
    	],
    	[
    		"9040",
    		"",
    		4,
    		"",
    		4,
    		"",
    		6,
    		""
    	],
    	[
    		"9080",
    		"",
    		7,
    		"",
    		4,
    		"",
    		4,
    		"",
    		4,
    		"",
    		4,
    		"",
    		18,
    		"",
    		6
    	],
    	[
    		"9140",
    		"",
    		6,
    		"",
    		6,
    		"",
    		18,
    		"",
    		4,
    		""
    	],
    	[
    		"9180",
    		"",
    		6,
    		"",
    		8,
    		"",
    		9,
    		"",
    		5,
    		"",
    		4,
    		"",
    		4,
    		"",
    		16,
    		"",
    		13,
    		"",
    		8,
    		"",
    		5,
    		"",
    		4,
    		""
    	],
    	[
    		"9240",
    		"",
    		6,
    		"",
    		5,
    		""
    	],
    	[
    		"9280",
    		"",
    		5,
    		"",
    		7,
    		"",
    		6,
    		""
    	],
    	[
    		"9340",
    		"",
    		6,
    		"",
    		4,
    		"",
    		4,
    		"",
    		5,
    		""
    	],
    	[
    		"9380",
    		"",
    		5,
    		"",
    		4,
    		"",
    		6,
    		"",
    		4,
    		"",
    		7,
    		"",
    		9,
    		"",
    		6,
    		"",
    		8,
    		"",
    		4,
    		"",
    		6,
    		""
    	],
    	[
    		"9440",
    		"",
    		24,
    		"",
    		7,
    		"",
    		7,
    		"",
    		4,
    		"",
    		8
    	],
    	[
    		"9480",
    		"",
    		4,
    		"",
    		4,
    		"",
    		14,
    		"",
    		7,
    		"",
    		7,
    		""
    	],
    	[
    		"9540",
    		"",
    		4,
    		"",
    		4,
    		"",
    		6,
    		""
    	],
    	[
    		"9580",
    		"",
    		4,
    		"",
    		4,
    		"",
    		8,
    		"",
    		4,
    		"",
    		4,
    		"",
    		25,
    		"",
    		7,
    		"",
    		5,
    		""
    	],
    	[
    		"9640",
    		"",
    		5,
    		"",
    		4,
    		""
    	],
    	[
    		"9680",
    		"",
    		7,
    		"",
    		9,
    		"",
    		7,
    		"",
    		4,
    		"",
    		6,
    		"",
    		6,
    		"",
    		5
    	],
    	[
    		"9740",
    		"",
    		7,
    		"",
    		8,
    		"",
    		7,
    		"",
    		9,
    		""
    	],
    	[
    		"9780",
    		"",
    		6,
    		"",
    		5,
    		"",
    		4,
    		"",
    		9,
    		"",
    		4,
    		"",
    		11,
    		"",
    		7,
    		"",
    		16,
    		""
    	],
    	[
    		"9840",
    		"",
    		4,
    		"",
    		5,
    		"",
    		9,
    		""
    	],
    	[
    		"9880",
    		"",
    		7,
    		"",
    		5,
    		"",
    		11,
    		"",
    		9,
    		"",
    		9,
    		"",
    		11,
    		"",
    		5,
    		"",
    		5,
    		"",
    		6,
    		"",
    		4,
    		"",
    		7,
    		"",
    		6,
    		""
    	],
    	[
    		"9940",
    		"",
    		4,
    		"",
    		10,
    		"",
    		6,
    		"",
    		8,
    		"",
    		4,
    		"",
    		7,
    		"",
    		5
    	],
    	[
    		"9980",
    		"",
    		114,
    		"",
    		6
    	],
    	[
    		"9a40",
    		"",
    		11,
    		"",
    		7,
    		"",
    		13,
    		""
    	],
    	[
    		"9a80",
    		"",
    		4,
    		"",
    		7,
    		"",
    		7,
    		"",
    		6,
    		"",
    		4,
    		"",
    		4,
    		"",
    		7,
    		"",
    		6,
    		"",
    		4,
    		"",
    		4,
    		""
    	],
    	[
    		"9b40",
    		"",
    		4,
    		""
    	],
    	[
    		"9b80",
    		"",
    		5,
    		"",
    		4,
    		"",
    		4,
    		"",
    		5,
    		""
    	],
    	[
    		"9c40",
    		"",
    		7,
    		""
    	],
    	[
    		"9c80",
    		"",
    		7,
    		"",
    		7,
    		"",
    		10,
    		"",
    		14,
    		"",
    		4,
    		"",
    		6,
    		"",
    		5
    	],
    	[
    		"9d40",
    		"",
    		7,
    		"",
    		4,
    		"",
    		9,
    		"",
    		6,
    		""
    	],
    	[
    		"9d80",
    		"",
    		9,
    		"",
    		5,
    		"",
    		6,
    		"",
    		12,
    		"",
    		4,
    		"",
    		10,
    		"",
    		5,
    		"",
    		5,
    		"",
    		6,
    		"",
    		10,
    		""
    	],
    	[
    		"9e40",
    		"",
    		7,
    		"",
    		32,
    		"",
    		7,
    		"",
    		6,
    		"",
    		6
    	],
    	[
    		"9e80",
    		"",
    		9,
    		"",
    		17,
    		"",
    		13,
    		"",
    		11,
    		"",
    		12,
    		"",
    		12,
    		""
    	],
    	[
    		"9f40",
    		"",
    		6,
    		"",
    		10,
    		"",
    		4,
    		"",
    		10,
    		"",
    		7,
    		""
    	],
    	[
    		"9f80",
    		"",
    		13,
    		"",
    		12,
    		"",
    		4,
    		"",
    		4,
    		"",
    		5,
    		"",
    		4,
    		"",
    		4,
    		"",
    		6,
    		"",
    		5,
    		"",
    		8,
    		"",
    		9,
    		"",
    		4
    	],
    	[
    		"a040",
    		"",
    		9,
    		"",
    		5,
    		"",
    		9,
    		"",
    		11,
    		"",
    		19
    	],
    	[
    		"a080",
    		"",
    		9,
    		"",
    		6,
    		"",
    		4,
    		"",
    		11,
    		"",
    		11,
    		"",
    		6,
    		""
    	],
    	[
    		"a1a1",
    		"",
    		7,
    		""
    	],
    	[
    		"a2a1",
    		"",
    		9
    	],
    	[
    		"a2b1",
    		"",
    		19,
    		"",
    		19,
    		"",
    		9
    	],
    	[
    		"a2e5",
    		"",
    		9
    	],
    	[
    		"a2f1",
    		"",
    		11
    	],
    	[
    		"a3a1",
    		"",
    		88,
    		""
    	],
    	[
    		"a4a1",
    		"",
    		82
    	],
    	[
    		"a5a1",
    		"",
    		85
    	],
    	[
    		"a6a1",
    		"",
    		16,
    		"",
    		6
    	],
    	[
    		"a6c1",
    		"",
    		16,
    		"",
    		6
    	],
    	[
    		"a6e0",
    		""
    	],
    	[
    		"a6ee",
    		""
    	],
    	[
    		"a6f4",
    		""
    	],
    	[
    		"a7a1",
    		"",
    		5,
    		"",
    		25
    	],
    	[
    		"a7d1",
    		"",
    		5,
    		"",
    		25
    	],
    	[
    		"a840",
    		"",
    		35,
    		"",
    		6
    	],
    	[
    		"a880",
    		"",
    		7,
    		""
    	],
    	[
    		"a8a1",
    		""
    	],
    	[
    		"a8bd",
    		""
    	],
    	[
    		"a8c0",
    		""
    	],
    	[
    		"a8c5",
    		"",
    		36
    	],
    	[
    		"a940",
    		"",
    		8,
    		""
    	],
    	[
    		"a959",
    		""
    	],
    	[
    		"a95c",
    		""
    	],
    	[
    		"a960",
    		"",
    		9,
    		"",
    		8
    	],
    	[
    		"a980",
    		"",
    		4,
    		""
    	],
    	[
    		"a996",
    		""
    	],
    	[
    		"a9a4",
    		"",
    		75
    	],
    	[
    		"aa40",
    		"",
    		5,
    		"",
    		5,
    		"",
    		8
    	],
    	[
    		"aa80",
    		"",
    		7,
    		"",
    		10,
    		""
    	],
    	[
    		"ab40",
    		"",
    		11,
    		"",
    		4,
    		"",
    		5,
    		"",
    		4
    	],
    	[
    		"ab80",
    		"",
    		6,
    		"",
    		4
    	],
    	[
    		"ac40",
    		"",
    		10,
    		"",
    		8,
    		"",
    		5,
    		"",
    		4,
    		"",
    		11
    	],
    	[
    		"ac80",
    		"",
    		6,
    		"",
    		12,
    		"",
    		4,
    		""
    	],
    	[
    		"ad40",
    		"",
    		10,
    		"",
    		7,
    		"",
    		15,
    		"",
    		12
    	],
    	[
    		"ad80",
    		"",
    		9,
    		"",
    		8,
    		"",
    		6,
    		""
    	],
    	[
    		"ae40",
    		"",
    		6,
    		"",
    		7,
    		"",
    		4,
    		""
    	],
    	[
    		"ae80",
    		"",
    		7,
    		"",
    		6,
    		"",
    		4,
    		""
    	],
    	[
    		"af40",
    		"",
    		4,
    		""
    	],
    	[
    		"af80",
    		""
    	],
    	[
    		"b040",
    		"",
    		6,
    		"",
    		5,
    		"",
    		4,
    		"",
    		6,
    		"",
    		7,
    		""
    	],
    	[
    		"b080",
    		"",
    		7,
    		"",
    		8,
    		"",
    		9,
    		""
    	],
    	[
    		"b140",
    		"",
    		4,
    		"",
    		7,
    		"",
    		10,
    		""
    	],
    	[
    		"b180",
    		"",
    		4,
    		"",
    		7,
    		"",
    		7,
    		""
    	],
    	[
    		"b240",
    		"",
    		11,
    		"",
    		5,
    		"",
    		11,
    		"",
    		4
    	],
    	[
    		"b280",
    		"",
    		12,
    		"",
    		8,
    		"",
    		4,
    		""
    	],
    	[
    		"b340",
    		"",
    		5,
    		""
    	],
    	[
    		"b380",
    		"",
    		11,
    		"",
    		7,
    		"",
    		6,
    		""
    	],
    	[
    		"b440",
    		"",
    		7,
    		"",
    		9
    	],
    	[
    		"b480",
    		"",
    		4,
    		"",
    		5,
    		"",
    		6,
    		""
    	],
    	[
    		"b540",
    		"",
    		5,
    		"",
    		9,
    		"",
    		4,
    		"",
    		14,
    		"",
    		4,
    		"",
    		8,
    		""
    	],
    	[
    		"b580",
    		"",
    		6,
    		"",
    		4,
    		""
    	],
    	[
    		"b640",
    		"",
    		6,
    		"",
    		11,
    		"",
    		10,
    		"",
    		4,
    		"",
    		5,
    		""
    	],
    	[
    		"b680",
    		"",
    		6,
    		"",
    		4,
    		""
    	],
    	[
    		"b740",
    		"",
    		14,
    		"",
    		5,
    		"",
    		9,
    		"",
    		4,
    		"",
    		16
    	],
    	[
    		"b780",
    		"",
    		6,
    		""
    	],
    	[
    		"b840",
    		"",
    		4,
    		"",
    		10,
    		"",
    		10,
    		"",
    		9,
    		"",
    		5,
    		""
    	],
    	[
    		"b880",
    		"",
    		4,
    		""
    	],
    	[
    		"b940",
    		"",
    		5,
    		"",
    		10,
    		"",
    		6,
    		""
    	],
    	[
    		"b980",
    		"",
    		7,
    		""
    	],
    	[
    		"ba40",
    		"",
    		4,
    		"",
    		4,
    		"",
    		7,
    		"",
    		5,
    		""
    	],
    	[
    		"ba80",
    		"",
    		4,
    		"",
    		5,
    		"",
    		12,
    		"",
    		5,
    		""
    	],
    	[
    		"bb40",
    		"",
    		9,
    		"",
    		36,
    		"",
    		5,
    		"",
    		9
    	],
    	[
    		"bb80",
    		"",
    		6,
    		"",
    		4,
    		""
    	],
    	[
    		"bc40",
    		"",
    		6,
    		"",
    		6,
    		"",
    		5,
    		"",
    		7,
    		"",
    		13,
    		"",
    		5
    	],
    	[
    		"bc80",
    		"",
    		14,
    		"",
    		6,
    		""
    	],
    	[
    		"bd40",
    		"",
    		54,
    		"",
    		7
    	],
    	[
    		"bd80",
    		"",
    		32,
    		""
    	],
    	[
    		"be40",
    		"",
    		12,
    		"",
    		6,
    		"",
    		42
    	],
    	[
    		"be80",
    		"",
    		32,
    		""
    	],
    	[
    		"bf40",
    		"",
    		62
    	],
    	[
    		"bf80",
    		"",
    		4,
    		"",
    		4,
    		"",
    		21,
    		""
    	],
    	[
    		"c040",
    		"",
    		35,
    		"",
    		23,
    		""
    	],
    	[
    		"c080",
    		"",
    		6,
    		"",
    		9,
    		""
    	],
    	[
    		"c140",
    		"",
    		4,
    		"",
    		7,
    		"",
    		4,
    		"",
    		4,
    		"",
    		6,
    		""
    	],
    	[
    		"c180",
    		"",
    		4,
    		"",
    		4,
    		"",
    		5,
    		""
    	],
    	[
    		"c240",
    		"",
    		6,
    		"",
    		5,
    		""
    	],
    	[
    		"c280",
    		"",
    		13,
    		"",
    		5,
    		"",
    		11,
    		""
    	],
    	[
    		"c340",
    		"",
    		5,
    		"",
    		4,
    		"",
    		6,
    		""
    	],
    	[
    		"c380",
    		"",
    		12,
    		"",
    		4,
    		""
    	],
    	[
    		"c440",
    		"",
    		5,
    		"",
    		4,
    		"",
    		4,
    		"",
    		5,
    		"",
    		4,
    		""
    	],
    	[
    		"c480",
    		"",
    		7,
    		"",
    		5,
    		"",
    		6,
    		""
    	],
    	[
    		"c540",
    		"",
    		14,
    		"",
    		4,
    		"",
    		5,
    		"",
    		4,
    		"",
    		5,
    		""
    	],
    	[
    		"c580",
    		"",
    		7,
    		"",
    		7,
    		""
    	],
    	[
    		"c640",
    		""
    	],
    	[
    		"c680",
    		"",
    		4,
    		"",
    		9,
    		""
    	],
    	[
    		"c740",
    		"",
    		4,
    		"",
    		4,
    		"",
    		6,
    		"",
    		6,
    		"",
    		6,
    		""
    	],
    	[
    		"c780",
    		""
    	],
    	[
    		"c840",
    		"",
    		4,
    		"",
    		5,
    		"",
    		5,
    		"",
    		7,
    		"",
    		5,
    		"",
    		7,
    		""
    	],
    	[
    		"c880",
    		"",
    		6,
    		"",
    		4,
    		"",
    		4,
    		""
    	],
    	[
    		"c940",
    		"",
    		4,
    		"",
    		7,
    		"",
    		12,
    		""
    	],
    	[
    		"c980",
    		"",
    		4,
    		"",
    		4,
    		"",
    		10,
    		""
    	],
    	[
    		"ca40",
    		"",
    		8,
    		"",
    		8,
    		"",
    		9,
    		"",
    		4,
    		"",
    		10
    	],
    	[
    		"ca80",
    		"",
    		4,
    		"",
    		8,
    		""
    	],
    	[
    		"cb40",
    		"",
    		6,
    		"",
    		10,
    		"",
    		6,
    		"",
    		5,
    		"",
    		6,
    		"",
    		6,
    		"",
    		4,
    		""
    	],
    	[
    		"cb80",
    		"",
    		5,
    		"",
    		6,
    		"",
    		14,
    		""
    	],
    	[
    		"cc40",
    		"",
    		4,
    		"",
    		10,
    		"",
    		15,
    		"",
    		13,
    		""
    	],
    	[
    		"cc80",
    		"",
    		11,
    		"",
    		4,
    		"",
    		7,
    		""
    	],
    	[
    		"cd40",
    		"",
    		6,
    		"",
    		6,
    		"",
    		4,
    		"",
    		5,
    		"",
    		4,
    		"",
    		4,
    		""
    	],
    	[
    		"cd80",
    		""
    	],
    	[
    		"ce40",
    		"",
    		6,
    		"",
    		5,
    		"",
    		7,
    		""
    	],
    	[
    		"ce80",
    		"",
    		4,
    		"",
    		6,
    		"",
    		4,
    		""
    	],
    	[
    		"cf40",
    		"",
    		4,
    		"",
    		4,
    		"",
    		6,
    		"",
    		9
    	],
    	[
    		"cf80",
    		"",
    		5,
    		"",
    		7,
    		"",
    		4,
    		""
    	],
    	[
    		"d040",
    		"",
    		13,
    		"",
    		5,
    		"",
    		5,
    		"",
    		5,
    		"",
    		6,
    		""
    	],
    	[
    		"d080",
    		"",
    		4,
    		"",
    		4,
    		"",
    		5,
    		""
    	],
    	[
    		"d140",
    		"",
    		4,
    		"",
    		4,
    		"",
    		6,
    		"",
    		5
    	],
    	[
    		"d180",
    		"",
    		4,
    		"",
    		4,
    		"",
    		4,
    		""
    	],
    	[
    		"d240",
    		"",
    		8,
    		"",
    		24,
    		"",
    		5,
    		"",
    		19,
    		""
    	],
    	[
    		"d280",
    		"",
    		26,
    		""
    	],
    	[
    		"d340",
    		"",
    		30,
    		"",
    		6
    	],
    	[
    		"d380",
    		"",
    		4,
    		"",
    		5,
    		"",
    		21,
    		""
    	],
    	[
    		"d440",
    		"",
    		31,
    		"",
    		8,
    		"",
    		21
    	],
    	[
    		"d480",
    		"",
    		25,
    		"",
    		6,
    		""
    	],
    	[
    		"d540",
    		"",
    		7,
    		"",
    		7,
    		"",
    		46
    	],
    	[
    		"d580",
    		"",
    		32,
    		""
    	],
    	[
    		"d640",
    		"",
    		34,
    		"",
    		27
    	],
    	[
    		"d680",
    		"",
    		30,
    		""
    	],
    	[
    		"d740",
    		"",
    		31,
    		"",
    		4,
    		"",
    		25
    	],
    	[
    		"d780",
    		"",
    		24,
    		""
    	],
    	[
    		"d840",
    		"",
    		8,
    		"",
    		7,
    		"",
    		5,
    		"",
    		6,
    		"",
    		6,
    		"",
    		6,
    		""
    	],
    	[
    		"d880",
    		"",
    		6,
    		"",
    		20,
    		""
    	],
    	[
    		"d940",
    		"",
    		62
    	],
    	[
    		"d980",
    		"",
    		32,
    		""
    	],
    	[
    		"da40",
    		"",
    		14,
    		"",
    		8,
    		"",
    		4,
    		"",
    		9,
    		""
    	],
    	[
    		"da80",
    		"",
    		12,
    		""
    	],
    	[
    		"db40",
    		"",
    		6,
    		"",
    		7,
    		"",
    		4,
    		""
    	],
    	[
    		"db80",
    		"",
    		4,
    		"",
    		5,
    		"",
    		11,
    		""
    	],
    	[
    		"dc40",
    		"",
    		4,
    		"",
    		6,
    		"",
    		6,
    		"",
    		11,
    		"",
    		6,
    		"",
    		7
    	],
    	[
    		"dc80",
    		"",
    		10,
    		"",
    		21,
    		""
    	],
    	[
    		"dd40",
    		"",
    		62
    	],
    	[
    		"dd80",
    		"",
    		32,
    		""
    	],
    	[
    		"de40",
    		"",
    		32,
    		""
    	],
    	[
    		"de80",
    		"",
    		4,
    		""
    	],
    	[
    		"df40",
    		"",
    		5,
    		"",
    		4,
    		"",
    		4,
    		"",
    		5,
    		"",
    		4,
    		"",
    		6,
    		""
    	],
    	[
    		"df80",
    		"",
    		4,
    		""
    	],
    	[
    		"e040",
    		"",
    		19,
    		""
    	],
    	[
    		"e080",
    		"",
    		10,
    		"",
    		6,
    		"",
    		8,
    		""
    	],
    	[
    		"e140",
    		"",
    		4,
    		"",
    		6,
    		"",
    		5,
    		"",
    		5,
    		""
    	],
    	[
    		"e180",
    		"",
    		10,
    		"",
    		9,
    		"",
    		8,
    		""
    	],
    	[
    		"e240",
    		"",
    		62
    	],
    	[
    		"e280",
    		"",
    		32,
    		"",
    		5,
    		""
    	],
    	[
    		"e340",
    		"",
    		45,
    		"",
    		16
    	],
    	[
    		"e380",
    		"",
    		7,
    		"",
    		24,
    		""
    	],
    	[
    		"e440",
    		"",
    		5,
    		"",
    		24,
    		"",
    		31
    	],
    	[
    		"e480",
    		"",
    		32,
    		""
    	],
    	[
    		"e540",
    		"",
    		51,
    		"",
    		10
    	],
    	[
    		"e580",
    		"",
    		31,
    		""
    	],
    	[
    		"e640",
    		"",
    		34,
    		"",
    		27
    	],
    	[
    		"e680",
    		"",
    		29,
    		""
    	],
    	[
    		"e740",
    		"",
    		7,
    		"",
    		54
    	],
    	[
    		"e780",
    		"",
    		32,
    		"",
    		6,
    		"",
    		4,
    		""
    	],
    	[
    		"e840",
    		"",
    		14,
    		"",
    		43,
    		""
    	],
    	[
    		"e880",
    		"",
    		20,
    		""
    	],
    	[
    		"e940",
    		"",
    		7,
    		"",
    		42
    	],
    	[
    		"e980",
    		"",
    		32,
    		""
    	],
    	[
    		"ea40",
    		"",
    		27,
    		"",
    		6,
    		""
    	],
    	[
    		"ea80",
    		"",
    		4,
    		"",
    		12,
    		""
    	],
    	[
    		"eb40",
    		"",
    		9,
    		"",
    		7,
    		"",
    		9,
    		"",
    		6,
    		""
    	],
    	[
    		"eb80",
    		"",
    		4,
    		""
    	],
    	[
    		"ec40",
    		"",
    		8,
    		"",
    		4,
    		"",
    		18,
    		"",
    		7
    	],
    	[
    		"ec80",
    		"",
    		4,
    		"",
    		7,
    		"",
    		4,
    		"",
    		4,
    		""
    	],
    	[
    		"ed40",
    		"",
    		6,
    		"",
    		46
    	],
    	[
    		"ed80",
    		"",
    		4,
    		"",
    		23,
    		""
    	],
    	[
    		"ee40",
    		"",
    		62
    	],
    	[
    		"ee80",
    		"",
    		32,
    		"",
    		4,
    		"",
    		6,
    		""
    	],
    	[
    		"ef40",
    		"",
    		5,
    		"",
    		37,
    		"",
    		4
    	],
    	[
    		"ef80",
    		"",
    		30,
    		"",
    		4,
    		"",
    		8,
    		""
    	],
    	[
    		"f040",
    		"",
    		4,
    		"",
    		28,
    		"",
    		26
    	],
    	[
    		"f080",
    		"",
    		9,
    		"",
    		12,
    		"",
    		4,
    		"",
    		6,
    		""
    	],
    	[
    		"f140",
    		"",
    		10,
    		"",
    		47
    	],
    	[
    		"f180",
    		"",
    		32,
    		""
    	],
    	[
    		"f240",
    		"",
    		62
    	],
    	[
    		"f280",
    		"",
    		32,
    		""
    	],
    	[
    		"f340",
    		"",
    		17,
    		"",
    		6,
    		"",
    		4,
    		""
    	],
    	[
    		"f380",
    		"",
    		8,
    		"",
    		6,
    		""
    	],
    	[
    		"f440",
    		"",
    		5,
    		"",
    		10,
    		"",
    		10,
    		"",
    		7,
    		"",
    		5
    	],
    	[
    		"f480",
    		"",
    		32,
    		""
    	],
    	[
    		"f540",
    		"",
    		62
    	],
    	[
    		"f580",
    		"",
    		32,
    		""
    	],
    	[
    		"f640",
    		"",
    		62
    	],
    	[
    		"f680",
    		"",
    		32,
    		"",
    		5,
    		"",
    		5,
    		"",
    		4,
    		"",
    		7,
    		""
    	],
    	[
    		"f740",
    		"",
    		62
    	],
    	[
    		"f780",
    		"",
    		4,
    		"",
    		4,
    		""
    	],
    	[
    		"f840",
    		"",
    		62
    	],
    	[
    		"f880",
    		"",
    		32
    	],
    	[
    		"f940",
    		"",
    		62
    	],
    	[
    		"f980",
    		"",
    		32
    	],
    	[
    		"fa40",
    		"",
    		62
    	],
    	[
    		"fa80",
    		"",
    		32
    	],
    	[
    		"fb40",
    		"",
    		27,
    		"",
    		9,
    		""
    	],
    	[
    		"fb80",
    		"",
    		5,
    		"",
    		8,
    		"",
    		5,
    		""
    	],
    	[
    		"fc40",
    		"",
    		8,
    		"",
    		4,
    		"",
    		8,
    		"",
    		6
    	],
    	[
    		"fc80",
    		"",
    		4,
    		"",
    		5,
    		"",
    		8,
    		""
    	],
    	[
    		"fd40",
    		"",
    		4,
    		"",
    		4,
    		"",
    		10,
    		"",
    		38
    	],
    	[
    		"fd80",
    		"",
    		5,
    		"",
    		11,
    		"",
    		4,
    		""
    	],
    	[
    		"fe40",
    		""
    	]
    ];

    var require$$3$1 = [
    	[
    		"a140",
    		"",
    		62
    	],
    	[
    		"a180",
    		"",
    		32
    	],
    	[
    		"a240",
    		"",
    		62
    	],
    	[
    		"a280",
    		"",
    		32
    	],
    	[
    		"a2ab",
    		"",
    		5
    	],
    	[
    		"a2e3",
    		""
    	],
    	[
    		"a2ef",
    		""
    	],
    	[
    		"a2fd",
    		""
    	],
    	[
    		"a340",
    		"",
    		62
    	],
    	[
    		"a380",
    		"",
    		31,
    		""
    	],
    	[
    		"a440",
    		"",
    		62
    	],
    	[
    		"a480",
    		"",
    		32
    	],
    	[
    		"a4f4",
    		"",
    		10
    	],
    	[
    		"a540",
    		"",
    		62
    	],
    	[
    		"a580",
    		"",
    		32
    	],
    	[
    		"a5f7",
    		"",
    		7
    	],
    	[
    		"a640",
    		"",
    		62
    	],
    	[
    		"a680",
    		"",
    		32
    	],
    	[
    		"a6b9",
    		"",
    		7
    	],
    	[
    		"a6d9",
    		"",
    		6
    	],
    	[
    		"a6ec",
    		""
    	],
    	[
    		"a6f3",
    		""
    	],
    	[
    		"a6f6",
    		"",
    		8
    	],
    	[
    		"a740",
    		"",
    		62
    	],
    	[
    		"a780",
    		"",
    		32
    	],
    	[
    		"a7c2",
    		"",
    		14
    	],
    	[
    		"a7f2",
    		"",
    		12
    	],
    	[
    		"a896",
    		"",
    		10
    	],
    	[
    		"a8bc",
    		""
    	],
    	[
    		"a8bf",
    		""
    	],
    	[
    		"a8c1",
    		""
    	],
    	[
    		"a8ea",
    		"",
    		20
    	],
    	[
    		"a958",
    		""
    	],
    	[
    		"a95b",
    		""
    	],
    	[
    		"a95d",
    		""
    	],
    	[
    		"a989",
    		"",
    		11
    	],
    	[
    		"a997",
    		"",
    		12
    	],
    	[
    		"a9f0",
    		"",
    		14
    	],
    	[
    		"aaa1",
    		"",
    		93
    	],
    	[
    		"aba1",
    		"",
    		93
    	],
    	[
    		"aca1",
    		"",
    		93
    	],
    	[
    		"ada1",
    		"",
    		93
    	],
    	[
    		"aea1",
    		"",
    		93
    	],
    	[
    		"afa1",
    		"",
    		93
    	],
    	[
    		"d7fa",
    		"",
    		4
    	],
    	[
    		"f8a1",
    		"",
    		93
    	],
    	[
    		"f9a1",
    		"",
    		93
    	],
    	[
    		"faa1",
    		"",
    		93
    	],
    	[
    		"fba1",
    		"",
    		93
    	],
    	[
    		"fca1",
    		"",
    		93
    	],
    	[
    		"fda1",
    		"",
    		93
    	],
    	[
    		"fe50",
    		""
    	],
    	[
    		"fe80",
    		"",
    		6,
    		"",
    		93
    	]
    ];

    var uChars = [
    	128,
    	165,
    	169,
    	178,
    	184,
    	216,
    	226,
    	235,
    	238,
    	244,
    	248,
    	251,
    	253,
    	258,
    	276,
    	284,
    	300,
    	325,
    	329,
    	334,
    	364,
    	463,
    	465,
    	467,
    	469,
    	471,
    	473,
    	475,
    	477,
    	506,
    	594,
    	610,
    	712,
    	716,
    	730,
    	930,
    	938,
    	962,
    	970,
    	1026,
    	1104,
    	1106,
    	8209,
    	8215,
    	8218,
    	8222,
    	8231,
    	8241,
    	8244,
    	8246,
    	8252,
    	8365,
    	8452,
    	8454,
    	8458,
    	8471,
    	8482,
    	8556,
    	8570,
    	8596,
    	8602,
    	8713,
    	8720,
    	8722,
    	8726,
    	8731,
    	8737,
    	8740,
    	8742,
    	8748,
    	8751,
    	8760,
    	8766,
    	8777,
    	8781,
    	8787,
    	8802,
    	8808,
    	8816,
    	8854,
    	8858,
    	8870,
    	8896,
    	8979,
    	9322,
    	9372,
    	9548,
    	9588,
    	9616,
    	9622,
    	9634,
    	9652,
    	9662,
    	9672,
    	9676,
    	9680,
    	9702,
    	9735,
    	9738,
    	9793,
    	9795,
    	11906,
    	11909,
    	11913,
    	11917,
    	11928,
    	11944,
    	11947,
    	11951,
    	11956,
    	11960,
    	11964,
    	11979,
    	12284,
    	12292,
    	12312,
    	12319,
    	12330,
    	12351,
    	12436,
    	12447,
    	12535,
    	12543,
    	12586,
    	12842,
    	12850,
    	12964,
    	13200,
    	13215,
    	13218,
    	13253,
    	13263,
    	13267,
    	13270,
    	13384,
    	13428,
    	13727,
    	13839,
    	13851,
    	14617,
    	14703,
    	14801,
    	14816,
    	14964,
    	15183,
    	15471,
    	15585,
    	16471,
    	16736,
    	17208,
    	17325,
    	17330,
    	17374,
    	17623,
    	17997,
    	18018,
    	18212,
    	18218,
    	18301,
    	18318,
    	18760,
    	18811,
    	18814,
    	18820,
    	18823,
    	18844,
    	18848,
    	18872,
    	19576,
    	19620,
    	19738,
    	19887,
    	40870,
    	59244,
    	59336,
    	59367,
    	59413,
    	59417,
    	59423,
    	59431,
    	59437,
    	59443,
    	59452,
    	59460,
    	59478,
    	59493,
    	63789,
    	63866,
    	63894,
    	63976,
    	63986,
    	64016,
    	64018,
    	64021,
    	64025,
    	64034,
    	64037,
    	64042,
    	65074,
    	65093,
    	65107,
    	65112,
    	65127,
    	65132,
    	65375,
    	65510,
    	65536
    ];
    var gbChars = [
    	0,
    	36,
    	38,
    	45,
    	50,
    	81,
    	89,
    	95,
    	96,
    	100,
    	103,
    	104,
    	105,
    	109,
    	126,
    	133,
    	148,
    	172,
    	175,
    	179,
    	208,
    	306,
    	307,
    	308,
    	309,
    	310,
    	311,
    	312,
    	313,
    	341,
    	428,
    	443,
    	544,
    	545,
    	558,
    	741,
    	742,
    	749,
    	750,
    	805,
    	819,
    	820,
    	7922,
    	7924,
    	7925,
    	7927,
    	7934,
    	7943,
    	7944,
    	7945,
    	7950,
    	8062,
    	8148,
    	8149,
    	8152,
    	8164,
    	8174,
    	8236,
    	8240,
    	8262,
    	8264,
    	8374,
    	8380,
    	8381,
    	8384,
    	8388,
    	8390,
    	8392,
    	8393,
    	8394,
    	8396,
    	8401,
    	8406,
    	8416,
    	8419,
    	8424,
    	8437,
    	8439,
    	8445,
    	8482,
    	8485,
    	8496,
    	8521,
    	8603,
    	8936,
    	8946,
    	9046,
    	9050,
    	9063,
    	9066,
    	9076,
    	9092,
    	9100,
    	9108,
    	9111,
    	9113,
    	9131,
    	9162,
    	9164,
    	9218,
    	9219,
    	11329,
    	11331,
    	11334,
    	11336,
    	11346,
    	11361,
    	11363,
    	11366,
    	11370,
    	11372,
    	11375,
    	11389,
    	11682,
    	11686,
    	11687,
    	11692,
    	11694,
    	11714,
    	11716,
    	11723,
    	11725,
    	11730,
    	11736,
    	11982,
    	11989,
    	12102,
    	12336,
    	12348,
    	12350,
    	12384,
    	12393,
    	12395,
    	12397,
    	12510,
    	12553,
    	12851,
    	12962,
    	12973,
    	13738,
    	13823,
    	13919,
    	13933,
    	14080,
    	14298,
    	14585,
    	14698,
    	15583,
    	15847,
    	16318,
    	16434,
    	16438,
    	16481,
    	16729,
    	17102,
    	17122,
    	17315,
    	17320,
    	17402,
    	17418,
    	17859,
    	17909,
    	17911,
    	17915,
    	17916,
    	17936,
    	17939,
    	17961,
    	18664,
    	18703,
    	18814,
    	18962,
    	19043,
    	33469,
    	33470,
    	33471,
    	33484,
    	33485,
    	33490,
    	33497,
    	33501,
    	33505,
    	33513,
    	33520,
    	33536,
    	33550,
    	37845,
    	37921,
    	37948,
    	38029,
    	38038,
    	38064,
    	38065,
    	38066,
    	38069,
    	38075,
    	38076,
    	38078,
    	39108,
    	39109,
    	39113,
    	39114,
    	39115,
    	39116,
    	39265,
    	39394,
    	189000
    ];
    var require$$4 = {
    	uChars: uChars,
    	gbChars: gbChars
    };

    var require$$5 = [
    	[
    		"0",
    		"\u0000",
    		127
    	],
    	[
    		"8141",
    		"",
    		4,
    		"",
    		6,
    		""
    	],
    	[
    		"8161",
    		"",
    		9,
    		"",
    		5,
    		""
    	],
    	[
    		"8181",
    		"",
    		18,
    		"",
    		4,
    		"",
    		6,
    		"",
    		5,
    		"",
    		6,
    		"",
    		7,
    		"",
    		7,
    		"",
    		4,
    		"",
    		4,
    		""
    	],
    	[
    		"8241",
    		"",
    		7,
    		"",
    		5
    	],
    	[
    		"8261",
    		"",
    		6,
    		"",
    		5,
    		""
    	],
    	[
    		"8281",
    		"",
    		7,
    		"",
    		7,
    		"",
    		4,
    		"",
    		10,
    		"",
    		5,
    		"",
    		17,
    		"",
    		7,
    		"",
    		6,
    		"",
    		7,
    		"",
    		18
    	],
    	[
    		"8341",
    		"",
    		5,
    		"",
    		5,
    		"",
    		7
    	],
    	[
    		"8361",
    		"",
    		18,
    		""
    	],
    	[
    		"8381",
    		"",
    		4,
    		"",
    		6,
    		"",
    		5,
    		"",
    		5,
    		"",
    		46,
    		"",
    		6,
    		"",
    		5,
    		"",
    		8
    	],
    	[
    		"8441",
    		"",
    		5,
    		"",
    		8
    	],
    	[
    		"8461",
    		"",
    		18
    	],
    	[
    		"8481",
    		"",
    		7,
    		"",
    		6,
    		"",
    		5,
    		"",
    		10,
    		"",
    		5,
    		"",
    		18,
    		"",
    		5,
    		"",
    		6,
    		"",
    		5,
    		"",
    		26,
    		""
    	],
    	[
    		"8541",
    		"",
    		5,
    		"",
    		4,
    		"",
    		6,
    		"",
    		4
    	],
    	[
    		"8561",
    		"",
    		5,
    		"",
    		5,
    		"",
    		6,
    		""
    	],
    	[
    		"8581",
    		"",
    		6,
    		"",
    		6,
    		"",
    		9,
    		"",
    		26,
    		"",
    		29,
    		"",
    		6,
    		"",
    		5,
    		""
    	],
    	[
    		"8641",
    		"",
    		6,
    		"",
    		5,
    		""
    	],
    	[
    		"8661",
    		"",
    		6,
    		"",
    		10
    	],
    	[
    		"8681",
    		"",
    		22,
    		"",
    		4,
    		"",
    		6,
    		"",
    		5,
    		"",
    		6,
    		"",
    		22,
    		"",
    		4,
    		""
    	],
    	[
    		"8741",
    		"",
    		9,
    		"",
    		15
    	],
    	[
    		"8761",
    		"",
    		18,
    		""
    	],
    	[
    		"8781",
    		"",
    		5,
    		"",
    		7,
    		"",
    		7,
    		"",
    		5,
    		"",
    		6,
    		"",
    		5,
    		"",
    		18,
    		"",
    		6,
    		"",
    		26,
    		"",
    		6,
    		"",
    		4
    	],
    	[
    		"8841",
    		"",
    		4,
    		"",
    		5,
    		"",
    		6,
    		"",
    		4
    	],
    	[
    		"8861",
    		"",
    		4,
    		""
    	],
    	[
    		"8881",
    		"",
    		15,
    		"",
    		4,
    		"",
    		6,
    		"",
    		5,
    		"",
    		54,
    		""
    	],
    	[
    		"8941",
    		"",
    		6,
    		"",
    		5,
    		""
    	],
    	[
    		"8961",
    		"",
    		10,
    		"",
    		5,
    		""
    	],
    	[
    		"8981",
    		"",
    		21,
    		"",
    		18,
    		"",
    		18,
    		"",
    		6,
    		"",
    		6,
    		"",
    		7,
    		"",
    		15
    	],
    	[
    		"8a41",
    		"",
    		10,
    		"",
    		6,
    		""
    	],
    	[
    		"8a61",
    		"",
    		4,
    		"",
    		18,
    		""
    	],
    	[
    		"8a81",
    		"",
    		4,
    		"",
    		19,
    		"",
    		5,
    		"",
    		7,
    		"",
    		5,
    		"",
    		6,
    		"",
    		5,
    		"",
    		4,
    		"",
    		5,
    		"",
    		26,
    		""
    	],
    	[
    		"8b41",
    		"",
    		5,
    		"",
    		4,
    		"",
    		6,
    		""
    	],
    	[
    		"8b61",
    		"",
    		6,
    		"",
    		8
    	],
    	[
    		"8b81",
    		"",
    		52,
    		"",
    		4,
    		"",
    		6,
    		"",
    		5,
    		"",
    		18,
    		"",
    		18
    	],
    	[
    		"8c41",
    		"",
    		15,
    		"",
    		4
    	],
    	[
    		"8c61",
    		"",
    		6,
    		"",
    		5,
    		"",
    		6,
    		"",
    		5
    	],
    	[
    		"8c81",
    		"",
    		12,
    		"",
    		26,
    		"",
    		50,
    		"",
    		5,
    		"",
    		16
    	],
    	[
    		"8d41",
    		"",
    		16,
    		"",
    		8
    	],
    	[
    		"8d61",
    		"",
    		17,
    		""
    	],
    	[
    		"8d81",
    		"",
    		4,
    		"",
    		33,
    		"",
    		6,
    		"",
    		7,
    		"",
    		6,
    		"",
    		9,
    		"",
    		6,
    		"",
    		5,
    		"",
    		6,
    		""
    	],
    	[
    		"8e41",
    		"",
    		6,
    		"",
    		5,
    		"",
    		8
    	],
    	[
    		"8e61",
    		"",
    		4,
    		"",
    		19
    	],
    	[
    		"8e81",
    		"",
    		13,
    		"",
    		6,
    		"",
    		4,
    		"",
    		6,
    		"",
    		5,
    		"",
    		6,
    		"",
    		5,
    		"",
    		11,
    		"",
    		7,
    		"",
    		6,
    		"",
    		5,
    		"",
    		7
    	],
    	[
    		"8f41",
    		"",
    		7,
    		"",
    		17
    	],
    	[
    		"8f61",
    		"",
    		7,
    		"",
    		6,
    		"",
    		4
    	],
    	[
    		"8f81",
    		"",
    		5,
    		"",
    		7,
    		"",
    		5,
    		"",
    		6,
    		"",
    		5,
    		"",
    		18,
    		"",
    		6,
    		"",
    		26,
    		"",
    		6,
    		"",
    		5
    	],
    	[
    		"9041",
    		"",
    		6,
    		"",
    		5,
    		""
    	],
    	[
    		"9061",
    		"",
    		5,
    		"",
    		15
    	],
    	[
    		"9081",
    		"",
    		12,
    		"",
    		6,
    		"",
    		5,
    		"",
    		4,
    		"",
    		6,
    		"",
    		4,
    		"",
    		5,
    		"",
    		11,
    		"",
    		33,
    		""
    	],
    	[
    		"9141",
    		"",
    		6,
    		"",
    		5
    	],
    	[
    		"9161",
    		"",
    		9,
    		"",
    		5
    	],
    	[
    		"9181",
    		"",
    		20,
    		"",
    		4,
    		"",
    		5,
    		"",
    		14,
    		"",
    		33,
    		"",
    		7,
    		"",
    		5,
    		"",
    		6
    	],
    	[
    		"9241",
    		"",
    		7,
    		"",
    		4,
    		""
    	],
    	[
    		"9261",
    		"",
    		7,
    		"",
    		7,
    		"",
    		4
    	],
    	[
    		"9281",
    		"",
    		21,
    		"",
    		18,
    		"",
    		6,
    		"",
    		7,
    		"",
    		6,
    		"",
    		35,
    		""
    	],
    	[
    		"9341",
    		"",
    		4,
    		""
    	],
    	[
    		"9361",
    		"",
    		6,
    		"",
    		8
    	],
    	[
    		"9381",
    		"",
    		37,
    		"",
    		4,
    		"",
    		4,
    		"",
    		6,
    		"",
    		5,
    		"",
    		7,
    		"",
    		22,
    		""
    	],
    	[
    		"9441",
    		"",
    		5,
    		"",
    		5,
    		"",
    		8
    	],
    	[
    		"9461",
    		"",
    		5,
    		"",
    		6,
    		"",
    		12
    	],
    	[
    		"9481",
    		"",
    		5,
    		"",
    		6,
    		"",
    		6,
    		"",
    		9,
    		"",
    		22,
    		"",
    		4,
    		"",
    		6,
    		"",
    		10,
    		"",
    		6,
    		"",
    		24
    	],
    	[
    		"9541",
    		"",
    		11,
    		"",
    		5,
    		""
    	],
    	[
    		"9561",
    		"",
    		6,
    		"",
    		5,
    		""
    	],
    	[
    		"9581",
    		"",
    		6,
    		"",
    		35,
    		"",
    		4,
    		"",
    		4,
    		"",
    		4,
    		"",
    		6,
    		"",
    		5,
    		"",
    		13,
    		"",
    		14
    	],
    	[
    		"9641",
    		"",
    		23,
    		""
    	],
    	[
    		"9661",
    		"",
    		6,
    		"",
    		5,
    		"",
    		8
    	],
    	[
    		"9681",
    		"",
    		10,
    		"",
    		5,
    		"",
    		13,
    		"",
    		33,
    		"",
    		6,
    		"",
    		44
    	],
    	[
    		"9741",
    		"",
    		16,
    		"",
    		8
    	],
    	[
    		"9761",
    		"",
    		17,
    		"",
    		7
    	],
    	[
    		"9781",
    		"",
    		11,
    		"",
    		5,
    		"",
    		6,
    		"",
    		89,
    		""
    	],
    	[
    		"9841",
    		"",
    		16,
    		"",
    		5,
    		""
    	],
    	[
    		"9861",
    		"",
    		6,
    		"",
    		15
    	],
    	[
    		"9881",
    		"",
    		21,
    		"",
    		6,
    		"",
    		5,
    		"",
    		4,
    		"",
    		6,
    		"",
    		5,
    		"",
    		6,
    		"",
    		5,
    		"",
    		6,
    		"",
    		5,
    		""
    	],
    	[
    		"9941",
    		"",
    		6,
    		"",
    		5,
    		""
    	],
    	[
    		"9961",
    		"",
    		6,
    		"",
    		5,
    		""
    	],
    	[
    		"9981",
    		"",
    		8,
    		"",
    		5,
    		"",
    		4,
    		"",
    		11,
    		"",
    		5,
    		"",
    		6,
    		"",
    		6,
    		"",
    		6,
    		"",
    		7,
    		"",
    		6,
    		"",
    		5,
    		""
    	],
    	[
    		"9a41",
    		"",
    		16
    	],
    	[
    		"9a61",
    		"",
    		6,
    		"",
    		6,
    		""
    	],
    	[
    		"9a81",
    		"",
    		4,
    		"",
    		6,
    		"",
    		5,
    		"",
    		5,
    		"",
    		6,
    		"",
    		5,
    		"",
    		5,
    		"",
    		33,
    		"",
    		5,
    		"",
    		6,
    		""
    	],
    	[
    		"9b41",
    		"",
    		6,
    		"",
    		8
    	],
    	[
    		"9b61",
    		"",
    		17,
    		"",
    		7
    	],
    	[
    		"9b81",
    		"",
    		25,
    		"",
    		4,
    		"",
    		5,
    		"",
    		50,
    		"",
    		22,
    		""
    	],
    	[
    		"9c41",
    		"",
    		4,
    		"",
    		5,
    		"",
    		5
    	],
    	[
    		"9c61",
    		"",
    		8,
    		"",
    		6,
    		"",
    		9
    	],
    	[
    		"9c81",
    		"",
    		8,
    		"",
    		6,
    		"",
    		6,
    		"",
    		9,
    		"",
    		26,
    		"",
    		6,
    		"",
    		5,
    		"",
    		18,
    		"",
    		6,
    		"",
    		12
    	],
    	[
    		"9d41",
    		"",
    		13,
    		"",
    		8
    	],
    	[
    		"9d61",
    		"",
    		25
    	],
    	[
    		"9d81",
    		"",
    		8,
    		"",
    		5,
    		"",
    		9,
    		"",
    		6,
    		"",
    		10,
    		"",
    		6,
    		"",
    		5,
    		"",
    		6,
    		"",
    		5,
    		""
    	],
    	[
    		"9e41",
    		"",
    		7,
    		"",
    		9,
    		""
    	],
    	[
    		"9e61",
    		"",
    		4,
    		"",
    		6,
    		""
    	],
    	[
    		"9e81",
    		"",
    		6,
    		"",
    		6,
    		"",
    		6,
    		"",
    		5,
    		"",
    		10,
    		"",
    		5,
    		"",
    		6,
    		"",
    		5,
    		"",
    		6,
    		""
    	],
    	[
    		"9f41",
    		"",
    		5,
    		"",
    		4,
    		"",
    		5,
    		""
    	],
    	[
    		"9f61",
    		"",
    		6,
    		"",
    		5,
    		""
    	],
    	[
    		"9f81",
    		"",
    		4,
    		"",
    		5,
    		"",
    		6,
    		"",
    		5,
    		"",
    		6,
    		"",
    		4,
    		"",
    		6,
    		"",
    		7,
    		"",
    		4,
    		"",
    		4,
    		""
    	],
    	[
    		"a041",
    		"",
    		5,
    		"",
    		6,
    		""
    	],
    	[
    		"a061",
    		"",
    		5,
    		"",
    		13
    	],
    	[
    		"a081",
    		"",
    		4,
    		"",
    		4,
    		"",
    		4,
    		"",
    		6,
    		"",
    		5,
    		"",
    		6,
    		"",
    		5,
    		"",
    		26,
    		"",
    		4,
    		"",
    		5,
    		"",
    		7,
    		""
    	],
    	[
    		"a141",
    		"",
    		18,
    		""
    	],
    	[
    		"a161",
    		"",
    		6,
    		"",
    		5,
    		""
    	],
    	[
    		"a181",
    		"",
    		14,
    		"",
    		5,
    		"",
    		4,
    		"",
    		9,
    		""
    	],
    	[
    		"a241",
    		"",
    		5,
    		"",
    		18
    	],
    	[
    		"a261",
    		"",
    		6,
    		"",
    		18
    	],
    	[
    		"a281",
    		"",
    		7,
    		"",
    		6,
    		"",
    		7,
    		""
    	],
    	[
    		"a341",
    		"",
    		6,
    		"",
    		10,
    		""
    	],
    	[
    		"a361",
    		"",
    		6,
    		"",
    		16
    	],
    	[
    		"a381",
    		"",
    		16,
    		"",
    		4,
    		"",
    		58,
    		"",
    		32,
    		""
    	],
    	[
    		"a441",
    		"",
    		5,
    		""
    	],
    	[
    		"a461",
    		"",
    		5,
    		"",
    		12
    	],
    	[
    		"a481",
    		"",
    		28,
    		"",
    		93
    	],
    	[
    		"a541",
    		"",
    		4,
    		"",
    		6,
    		"",
    		5,
    		""
    	],
    	[
    		"a561",
    		"",
    		17,
    		"",
    		5,
    		""
    	],
    	[
    		"a581",
    		"",
    		16,
    		"",
    		14,
    		"",
    		9
    	],
    	[
    		"a5b0",
    		"",
    		9
    	],
    	[
    		"a5c1",
    		"",
    		16,
    		"",
    		6
    	],
    	[
    		"a5e1",
    		"",
    		16,
    		"",
    		6
    	],
    	[
    		"a641",
    		"",
    		19,
    		""
    	],
    	[
    		"a661",
    		"",
    		5,
    		"",
    		5,
    		"",
    		6
    	],
    	[
    		"a681",
    		"",
    		6,
    		"",
    		18,
    		"",
    		7
    	],
    	[
    		"a741",
    		"",
    		4,
    		"",
    		6,
    		"",
    		7
    	],
    	[
    		"a761",
    		"",
    		22,
    		""
    	],
    	[
    		"a781",
    		"",
    		6,
    		"",
    		5,
    		"",
    		7,
    		"",
    		9,
    		"",
    		9,
    		"",
    		4,
    		"",
    		5,
    		"",
    		4,
    		""
    	],
    	[
    		"a841",
    		"",
    		10,
    		"",
    		14
    	],
    	[
    		"a861",
    		"",
    		18,
    		"",
    		6
    	],
    	[
    		"a881",
    		"",
    		19,
    		"",
    		11,
    		""
    	],
    	[
    		"a8a6",
    		""
    	],
    	[
    		"a8a8",
    		""
    	],
    	[
    		"a8b1",
    		"",
    		27,
    		"",
    		25,
    		"",
    		14,
    		""
    	],
    	[
    		"a941",
    		"",
    		14,
    		"",
    		10
    	],
    	[
    		"a961",
    		"",
    		18
    	],
    	[
    		"a981",
    		"",
    		14,
    		"",
    		6,
    		"",
    		27,
    		"",
    		25,
    		"",
    		14,
    		""
    	],
    	[
    		"aa41",
    		"",
    		6,
    		"",
    		4,
    		""
    	],
    	[
    		"aa61",
    		"",
    		4,
    		"",
    		5,
    		"",
    		6,
    		""
    	],
    	[
    		"aa81",
    		"",
    		29,
    		"",
    		82
    	],
    	[
    		"ab41",
    		"",
    		6,
    		"",
    		5,
    		""
    	],
    	[
    		"ab61",
    		"",
    		6,
    		"",
    		5,
    		"",
    		5
    	],
    	[
    		"ab81",
    		"",
    		8,
    		"",
    		6,
    		"",
    		12,
    		"",
    		85
    	],
    	[
    		"ac41",
    		"",
    		5,
    		"",
    		6,
    		""
    	],
    	[
    		"ac61",
    		"",
    		11,
    		"",
    		4
    	],
    	[
    		"ac81",
    		"",
    		28,
    		"",
    		5,
    		"",
    		25
    	],
    	[
    		"acd1",
    		"",
    		5,
    		"",
    		25
    	],
    	[
    		"ad41",
    		"",
    		6,
    		"",
    		5,
    		"",
    		7
    	],
    	[
    		"ad61",
    		"",
    		6,
    		"",
    		10,
    		""
    	],
    	[
    		"ad81",
    		"",
    		5,
    		"",
    		18,
    		""
    	],
    	[
    		"ae41",
    		"",
    		5,
    		"",
    		16
    	],
    	[
    		"ae61",
    		"",
    		5,
    		"",
    		6,
    		"",
    		4
    	],
    	[
    		"ae81",
    		"",
    		6,
    		"",
    		5,
    		""
    	],
    	[
    		"af41",
    		"",
    		19
    	],
    	[
    		"af61",
    		"",
    		13,
    		"",
    		5,
    		""
    	],
    	[
    		"af81",
    		"",
    		5,
    		"",
    		6,
    		"",
    		5,
    		""
    	],
    	[
    		"b041",
    		"",
    		5,
    		"",
    		5,
    		"",
    		12
    	],
    	[
    		"b061",
    		"",
    		5,
    		"",
    		19
    	],
    	[
    		"b081",
    		"",
    		13,
    		"",
    		6,
    		"",
    		5,
    		"",
    		7,
    		"",
    		4,
    		""
    	],
    	[
    		"b141",
    		"",
    		6,
    		"",
    		5,
    		""
    	],
    	[
    		"b161",
    		"",
    		6,
    		"",
    		5,
    		"",
    		11
    	],
    	[
    		"b181",
    		"",
    		14,
    		"",
    		6,
    		""
    	],
    	[
    		"b241",
    		"",
    		6,
    		"",
    		5,
    		""
    	],
    	[
    		"b261",
    		"",
    		18,
    		"",
    		5,
    		""
    	],
    	[
    		"b281",
    		"",
    		5,
    		"",
    		18,
    		"",
    		6,
    		""
    	],
    	[
    		"b341",
    		"",
    		19,
    		""
    	],
    	[
    		"b361",
    		"",
    		5,
    		"",
    		5,
    		"",
    		5
    	],
    	[
    		"b381",
    		"",
    		5,
    		"",
    		5,
    		"",
    		19,
    		"",
    		4,
    		""
    	],
    	[
    		"b441",
    		"",
    		5,
    		"",
    		6,
    		"",
    		5
    	],
    	[
    		"b461",
    		"",
    		6,
    		"",
    		10,
    		""
    	],
    	[
    		"b481",
    		"",
    		6,
    		"",
    		18,
    		"",
    		4,
    		"",
    		4,
    		""
    	],
    	[
    		"b541",
    		"",
    		14,
    		"",
    		5
    	],
    	[
    		"b561",
    		"",
    		5,
    		"",
    		5,
    		"",
    		4
    	],
    	[
    		"b581",
    		"",
    		6,
    		"",
    		5,
    		"",
    		11,
    		""
    	],
    	[
    		"b641",
    		"",
    		7,
    		"",
    		17
    	],
    	[
    		"b661",
    		"",
    		15,
    		""
    	],
    	[
    		"b681",
    		"",
    		5,
    		"",
    		6,
    		"",
    		5,
    		""
    	],
    	[
    		"b741",
    		"",
    		13,
    		"",
    		6,
    		""
    	],
    	[
    		"b761",
    		"",
    		20,
    		""
    	],
    	[
    		"b781",
    		"",
    		6,
    		"",
    		14,
    		""
    	],
    	[
    		"b841",
    		"",
    		7,
    		"",
    		17
    	],
    	[
    		"b861",
    		"",
    		8,
    		"",
    		13
    	],
    	[
    		"b881",
    		"",
    		5,
    		"",
    		24,
    		"",
    		4,
    		""
    	],
    	[
    		"b941",
    		"",
    		6,
    		"",
    		5,
    		""
    	],
    	[
    		"b961",
    		"",
    		14,
    		"",
    		6,
    		""
    	],
    	[
    		"b981",
    		"",
    		22,
    		"",
    		4,
    		"",
    		4,
    		""
    	],
    	[
    		"ba41",
    		"",
    		5,
    		"",
    		6,
    		""
    	],
    	[
    		"ba61",
    		"",
    		5,
    		"",
    		4,
    		"",
    		5
    	],
    	[
    		"ba81",
    		"",
    		6,
    		"",
    		9,
    		""
    	],
    	[
    		"bb41",
    		"",
    		4,
    		"",
    		5,
    		"",
    		4,
    		""
    	],
    	[
    		"bb61",
    		"",
    		6,
    		"",
    		5,
    		""
    	],
    	[
    		"bb81",
    		"",
    		31,
    		""
    	],
    	[
    		"bc41",
    		"",
    		17,
    		""
    	],
    	[
    		"bc61",
    		"",
    		5,
    		"",
    		6,
    		""
    	],
    	[
    		"bc81",
    		"",
    		4,
    		"",
    		6,
    		"",
    		5,
    		"",
    		5,
    		"",
    		4,
    		""
    	],
    	[
    		"bd41",
    		"",
    		7,
    		"",
    		7,
    		""
    	],
    	[
    		"bd61",
    		"",
    		5,
    		"",
    		13
    	],
    	[
    		"bd81",
    		"",
    		5,
    		"",
    		25,
    		""
    	],
    	[
    		"be41",
    		"",
    		7,
    		"",
    		14
    	],
    	[
    		"be61",
    		"",
    		7,
    		"",
    		7,
    		""
    	],
    	[
    		"be81",
    		"",
    		4,
    		"",
    		4,
    		"",
    		5,
    		"",
    		8,
    		"",
    		6,
    		""
    	],
    	[
    		"bf41",
    		"",
    		10,
    		"",
    		14
    	],
    	[
    		"bf61",
    		"",
    		18,
    		""
    	],
    	[
    		"bf81",
    		"",
    		5,
    		"",
    		7,
    		"",
    		6,
    		"",
    		5,
    		""
    	],
    	[
    		"c041",
    		"",
    		5,
    		"",
    		6,
    		"",
    		5
    	],
    	[
    		"c061",
    		"",
    		25
    	],
    	[
    		"c081",
    		"",
    		6,
    		"",
    		5,
    		"",
    		7,
    		""
    	],
    	[
    		"c141",
    		"",
    		5,
    		"",
    		6,
    		""
    	],
    	[
    		"c161",
    		"",
    		19,
    		""
    	],
    	[
    		"c181",
    		"",
    		31,
    		""
    	],
    	[
    		"c241",
    		"",
    		4,
    		"",
    		5,
    		""
    	],
    	[
    		"c261",
    		"",
    		4,
    		"",
    		5,
    		"",
    		6,
    		""
    	],
    	[
    		"c281",
    		"",
    		5,
    		"",
    		7,
    		"",
    		9,
    		""
    	],
    	[
    		"c341",
    		"",
    		4
    	],
    	[
    		"c361",
    		"",
    		4,
    		"",
    		5,
    		"",
    		11
    	],
    	[
    		"c381",
    		"",
    		5,
    		"",
    		7,
    		"",
    		5,
    		""
    	],
    	[
    		"c441",
    		"",
    		7,
    		"",
    		7,
    		""
    	],
    	[
    		"c461",
    		"",
    		5,
    		"",
    		4
    	],
    	[
    		"c481",
    		"",
    		5,
    		"",
    		11,
    		""
    	],
    	[
    		"c541",
    		"",
    		6,
    		"",
    		5,
    		""
    	],
    	[
    		"c561",
    		"",
    		6,
    		"",
    		5,
    		"",
    		4
    	],
    	[
    		"c581",
    		"",
    		6,
    		"",
    		5,
    		""
    	],
    	[
    		"c641",
    		"",
    		6,
    		"",
    		5
    	],
    	[
    		"c6a1",
    		""
    	],
    	[
    		"c7a1",
    		""
    	],
    	[
    		"c8a1",
    		""
    	],
    	[
    		"caa1",
    		""
    	],
    	[
    		"cba1",
    		""
    	],
    	[
    		"cca1",
    		""
    	],
    	[
    		"cda1",
    		""
    	],
    	[
    		"cea1",
    		""
    	],
    	[
    		"cfa1",
    		""
    	],
    	[
    		"d0a1",
    		""
    	],
    	[
    		"d1a1",
    		"",
    		5,
    		"",
    		4,
    		""
    	],
    	[
    		"d2a1",
    		"",
    		4,
    		"",
    		5,
    		"",
    		10,
    		"",
    		7,
    		"",
    		5,
    		""
    	],
    	[
    		"d3a1",
    		""
    	],
    	[
    		"d4a1",
    		""
    	],
    	[
    		"d5a1",
    		""
    	],
    	[
    		"d6a1",
    		""
    	],
    	[
    		"d7a1",
    		""
    	],
    	[
    		"d8a1",
    		""
    	],
    	[
    		"d9a1",
    		""
    	],
    	[
    		"daa1",
    		""
    	],
    	[
    		"dba1",
    		""
    	],
    	[
    		"dca1",
    		""
    	],
    	[
    		"dda1",
    		""
    	],
    	[
    		"dea1",
    		""
    	],
    	[
    		"dfa1",
    		""
    	],
    	[
    		"e0a1",
    		""
    	],
    	[
    		"e1a1",
    		""
    	],
    	[
    		"e2a1",
    		""
    	],
    	[
    		"e3a1",
    		""
    	],
    	[
    		"e4a1",
    		""
    	],
    	[
    		"e5a1",
    		""
    	],
    	[
    		"e6a1",
    		""
    	],
    	[
    		"e7a1",
    		""
    	],
    	[
    		"e8a1",
    		""
    	],
    	[
    		"e9a1",
    		""
    	],
    	[
    		"eaa1",
    		""
    	],
    	[
    		"eba1",
    		""
    	],
    	[
    		"eca1",
    		""
    	],
    	[
    		"eda1",
    		""
    	],
    	[
    		"eea1",
    		""
    	],
    	[
    		"efa1",
    		""
    	],
    	[
    		"f0a1",
    		""
    	],
    	[
    		"f1a1",
    		""
    	],
    	[
    		"f2a1",
    		""
    	],
    	[
    		"f3a1",
    		""
    	],
    	[
    		"f4a1",
    		""
    	],
    	[
    		"f5a1",
    		""
    	],
    	[
    		"f6a1",
    		""
    	],
    	[
    		"f7a1",
    		""
    	],
    	[
    		"f8a1",
    		""
    	],
    	[
    		"f9a1",
    		""
    	],
    	[
    		"faa1",
    		""
    	],
    	[
    		"fba1",
    		""
    	],
    	[
    		"fca1",
    		""
    	],
    	[
    		"fda1",
    		""
    	]
    ];

    var require$$6 = [
    	[
    		"0",
    		"\u0000",
    		127
    	],
    	[
    		"a140",
    		""
    	],
    	[
    		"a1a1",
    		"",
    		4,
    		""
    	],
    	[
    		"a240",
    		"",
    		7,
    		""
    	],
    	[
    		"a2a1",
    		"",
    		9,
    		"",
    		9,
    		"",
    		8,
    		"",
    		25,
    		"",
    		21
    	],
    	[
    		"a340",
    		"",
    		16,
    		"",
    		6,
    		"",
    		16,
    		"",
    		6,
    		"",
    		10
    	],
    	[
    		"a3a1",
    		"",
    		25,
    		""
    	],
    	[
    		"a3e1",
    		""
    	],
    	[
    		"a440",
    		""
    	],
    	[
    		"a4a1",
    		""
    	],
    	[
    		"a540",
    		""
    	],
    	[
    		"a5a1",
    		""
    	],
    	[
    		"a640",
    		""
    	],
    	[
    		"a6a1",
    		""
    	],
    	[
    		"a740",
    		""
    	],
    	[
    		"a7a1",
    		""
    	],
    	[
    		"a840",
    		""
    	],
    	[
    		"a8a1",
    		""
    	],
    	[
    		"a940",
    		""
    	],
    	[
    		"a9a1",
    		""
    	],
    	[
    		"aa40",
    		""
    	],
    	[
    		"aaa1",
    		""
    	],
    	[
    		"ab40",
    		""
    	],
    	[
    		"aba1",
    		""
    	],
    	[
    		"ac40",
    		""
    	],
    	[
    		"aca1",
    		""
    	],
    	[
    		"ad40",
    		""
    	],
    	[
    		"ada1",
    		""
    	],
    	[
    		"ae40",
    		""
    	],
    	[
    		"aea1",
    		""
    	],
    	[
    		"af40",
    		""
    	],
    	[
    		"afa1",
    		""
    	],
    	[
    		"b040",
    		""
    	],
    	[
    		"b0a1",
    		""
    	],
    	[
    		"b140",
    		""
    	],
    	[
    		"b1a1",
    		""
    	],
    	[
    		"b240",
    		""
    	],
    	[
    		"b2a1",
    		""
    	],
    	[
    		"b340",
    		""
    	],
    	[
    		"b3a1",
    		""
    	],
    	[
    		"b440",
    		""
    	],
    	[
    		"b4a1",
    		""
    	],
    	[
    		"b540",
    		""
    	],
    	[
    		"b5a1",
    		""
    	],
    	[
    		"b640",
    		""
    	],
    	[
    		"b6a1",
    		""
    	],
    	[
    		"b740",
    		""
    	],
    	[
    		"b7a1",
    		""
    	],
    	[
    		"b840",
    		""
    	],
    	[
    		"b8a1",
    		""
    	],
    	[
    		"b940",
    		""
    	],
    	[
    		"b9a1",
    		""
    	],
    	[
    		"ba40",
    		""
    	],
    	[
    		"baa1",
    		""
    	],
    	[
    		"bb40",
    		""
    	],
    	[
    		"bba1",
    		""
    	],
    	[
    		"bc40",
    		""
    	],
    	[
    		"bca1",
    		""
    	],
    	[
    		"bd40",
    		""
    	],
    	[
    		"bda1",
    		""
    	],
    	[
    		"be40",
    		""
    	],
    	[
    		"bea1",
    		""
    	],
    	[
    		"bf40",
    		""
    	],
    	[
    		"bfa1",
    		""
    	],
    	[
    		"c040",
    		""
    	],
    	[
    		"c0a1",
    		""
    	],
    	[
    		"c140",
    		""
    	],
    	[
    		"c1a1",
    		""
    	],
    	[
    		"c240",
    		""
    	],
    	[
    		"c2a1",
    		""
    	],
    	[
    		"c340",
    		""
    	],
    	[
    		"c3a1",
    		""
    	],
    	[
    		"c440",
    		""
    	],
    	[
    		"c4a1",
    		""
    	],
    	[
    		"c540",
    		""
    	],
    	[
    		"c5a1",
    		""
    	],
    	[
    		"c640",
    		""
    	],
    	[
    		"c940",
    		""
    	],
    	[
    		"c9a1",
    		""
    	],
    	[
    		"ca40",
    		""
    	],
    	[
    		"caa1",
    		""
    	],
    	[
    		"cb40",
    		""
    	],
    	[
    		"cba1",
    		""
    	],
    	[
    		"cc40",
    		""
    	],
    	[
    		"cca1",
    		""
    	],
    	[
    		"cd40",
    		""
    	],
    	[
    		"cda1",
    		""
    	],
    	[
    		"ce40",
    		""
    	],
    	[
    		"cea1",
    		""
    	],
    	[
    		"cf40",
    		""
    	],
    	[
    		"cfa1",
    		""
    	],
    	[
    		"d040",
    		""
    	],
    	[
    		"d0a1",
    		""
    	],
    	[
    		"d140",
    		""
    	],
    	[
    		"d1a1",
    		""
    	],
    	[
    		"d240",
    		""
    	],
    	[
    		"d2a1",
    		""
    	],
    	[
    		"d340",
    		""
    	],
    	[
    		"d3a1",
    		""
    	],
    	[
    		"d440",
    		""
    	],
    	[
    		"d4a1",
    		""
    	],
    	[
    		"d540",
    		""
    	],
    	[
    		"d5a1",
    		""
    	],
    	[
    		"d640",
    		""
    	],
    	[
    		"d6a1",
    		""
    	],
    	[
    		"d740",
    		""
    	],
    	[
    		"d7a1",
    		""
    	],
    	[
    		"d840",
    		""
    	],
    	[
    		"d8a1",
    		""
    	],
    	[
    		"d940",
    		""
    	],
    	[
    		"d9a1",
    		""
    	],
    	[
    		"da40",
    		""
    	],
    	[
    		"daa1",
    		""
    	],
    	[
    		"db40",
    		""
    	],
    	[
    		"dba1",
    		""
    	],
    	[
    		"dc40",
    		""
    	],
    	[
    		"dca1",
    		""
    	],
    	[
    		"dd40",
    		""
    	],
    	[
    		"dda1",
    		""
    	],
    	[
    		"de40",
    		""
    	],
    	[
    		"dea1",
    		""
    	],
    	[
    		"df40",
    		""
    	],
    	[
    		"dfa1",
    		""
    	],
    	[
    		"e040",
    		""
    	],
    	[
    		"e0a1",
    		""
    	],
    	[
    		"e140",
    		""
    	],
    	[
    		"e1a1",
    		""
    	],
    	[
    		"e240",
    		""
    	],
    	[
    		"e2a1",
    		""
    	],
    	[
    		"e340",
    		""
    	],
    	[
    		"e3a1",
    		""
    	],
    	[
    		"e440",
    		""
    	],
    	[
    		"e4a1",
    		""
    	],
    	[
    		"e540",
    		""
    	],
    	[
    		"e5a1",
    		""
    	],
    	[
    		"e640",
    		""
    	],
    	[
    		"e6a1",
    		""
    	],
    	[
    		"e740",
    		""
    	],
    	[
    		"e7a1",
    		""
    	],
    	[
    		"e840",
    		""
    	],
    	[
    		"e8a1",
    		""
    	],
    	[
    		"e940",
    		""
    	],
    	[
    		"e9a1",
    		""
    	],
    	[
    		"ea40",
    		""
    	],
    	[
    		"eaa1",
    		""
    	],
    	[
    		"eb40",
    		""
    	],
    	[
    		"eba1",
    		""
    	],
    	[
    		"ec40",
    		""
    	],
    	[
    		"eca1",
    		""
    	],
    	[
    		"ed40",
    		""
    	],
    	[
    		"eda1",
    		""
    	],
    	[
    		"ee40",
    		""
    	],
    	[
    		"eea1",
    		""
    	],
    	[
    		"ef40",
    		""
    	],
    	[
    		"efa1",
    		""
    	],
    	[
    		"f040",
    		""
    	],
    	[
    		"f0a1",
    		""
    	],
    	[
    		"f140",
    		""
    	],
    	[
    		"f1a1",
    		""
    	],
    	[
    		"f240",
    		""
    	],
    	[
    		"f2a1",
    		""
    	],
    	[
    		"f340",
    		""
    	],
    	[
    		"f3a1",
    		""
    	],
    	[
    		"f440",
    		""
    	],
    	[
    		"f4a1",
    		""
    	],
    	[
    		"f540",
    		""
    	],
    	[
    		"f5a1",
    		""
    	],
    	[
    		"f640",
    		""
    	],
    	[
    		"f6a1",
    		""
    	],
    	[
    		"f740",
    		""
    	],
    	[
    		"f7a1",
    		""
    	],
    	[
    		"f840",
    		""
    	],
    	[
    		"f8a1",
    		""
    	],
    	[
    		"f940",
    		""
    	],
    	[
    		"f9a1",
    		""
    	]
    ];

    var require$$7 = [
    	[
    		"8740",
    		""
    	],
    	[
    		"8767",
    		""
    	],
    	[
    		"87a1",
    		""
    	],
    	[
    		"8840",
    		"",
    		4,
    		""
    	],
    	[
    		"88a1",
    		""
    	],
    	[
    		"8940",
    		""
    	],
    	[
    		"8943",
    		""
    	],
    	[
    		"8946",
    		""
    	],
    	[
    		"894c",
    		""
    	],
    	[
    		"89a1",
    		""
    	],
    	[
    		"89ab",
    		""
    	],
    	[
    		"89b0",
    		""
    	],
    	[
    		"89b5",
    		""
    	],
    	[
    		"89c1",
    		""
    	],
    	[
    		"89c5",
    		""
    	],
    	[
    		"8a40",
    		""
    	],
    	[
    		"8a43",
    		""
    	],
    	[
    		"8a64",
    		""
    	],
    	[
    		"8a76",
    		""
    	],
    	[
    		"8aa1",
    		""
    	],
    	[
    		"8aac",
    		""
    	],
    	[
    		"8ab2",
    		""
    	],
    	[
    		"8abb",
    		""
    	],
    	[
    		"8ac9",
    		""
    	],
    	[
    		"8ace",
    		""
    	],
    	[
    		"8adf",
    		""
    	],
    	[
    		"8af6",
    		""
    	],
    	[
    		"8b40",
    		""
    	],
    	[
    		"8b55",
    		""
    	],
    	[
    		"8ba1",
    		""
    	],
    	[
    		"8bde",
    		""
    	],
    	[
    		"8c40",
    		""
    	],
    	[
    		"8ca1",
    		""
    	],
    	[
    		"8ca7",
    		""
    	],
    	[
    		"8cc9",
    		""
    	],
    	[
    		"8cce",
    		""
    	],
    	[
    		"8ce6",
    		""
    	],
    	[
    		"8d40",
    		""
    	],
    	[
    		"8d42",
    		""
    	],
    	[
    		"8da1",
    		""
    	],
    	[
    		"8e40",
    		""
    	],
    	[
    		"8ea1",
    		""
    	],
    	[
    		"8f40",
    		""
    	],
    	[
    		"8fa1",
    		""
    	],
    	[
    		"9040",
    		""
    	],
    	[
    		"90a1",
    		""
    	],
    	[
    		"9140",
    		""
    	],
    	[
    		"91a1",
    		""
    	],
    	[
    		"9240",
    		""
    	],
    	[
    		"92a1",
    		""
    	],
    	[
    		"9340",
    		""
    	],
    	[
    		"93a1",
    		""
    	],
    	[
    		"9440",
    		""
    	],
    	[
    		"94a1",
    		""
    	],
    	[
    		"9540",
    		""
    	],
    	[
    		"95a1",
    		""
    	],
    	[
    		"9640",
    		""
    	],
    	[
    		"96a1",
    		""
    	],
    	[
    		"9740",
    		""
    	],
    	[
    		"97a1",
    		""
    	],
    	[
    		"9840",
    		""
    	],
    	[
    		"98a1",
    		""
    	],
    	[
    		"9940",
    		""
    	],
    	[
    		"99a1",
    		""
    	],
    	[
    		"9a40",
    		""
    	],
    	[
    		"9aa1",
    		""
    	],
    	[
    		"9b40",
    		""
    	],
    	[
    		"9b62",
    		""
    	],
    	[
    		"9ba1",
    		""
    	],
    	[
    		"9c40",
    		""
    	],
    	[
    		"9ca1",
    		""
    	],
    	[
    		"9d40",
    		""
    	],
    	[
    		"9da1",
    		""
    	],
    	[
    		"9e40",
    		""
    	],
    	[
    		"9ea1",
    		""
    	],
    	[
    		"9ead",
    		""
    	],
    	[
    		"9ec5",
    		""
    	],
    	[
    		"9ef5",
    		""
    	],
    	[
    		"9f40",
    		""
    	],
    	[
    		"9f4f",
    		""
    	],
    	[
    		"9fa1",
    		""
    	],
    	[
    		"9fae",
    		""
    	],
    	[
    		"9fb2",
    		""
    	],
    	[
    		"9fc1",
    		""
    	],
    	[
    		"9fc9",
    		""
    	],
    	[
    		"9fdb",
    		""
    	],
    	[
    		"9fe7",
    		""
    	],
    	[
    		"9feb",
    		""
    	],
    	[
    		"9ff0",
    		""
    	],
    	[
    		"a040",
    		""
    	],
    	[
    		"a055",
    		""
    	],
    	[
    		"a058",
    		""
    	],
    	[
    		"a05b",
    		""
    	],
    	[
    		"a063",
    		""
    	],
    	[
    		"a073",
    		""
    	],
    	[
    		"a0a1",
    		""
    	],
    	[
    		"a0a6",
    		""
    	],
    	[
    		"a0ae",
    		""
    	],
    	[
    		"a0b0",
    		""
    	],
    	[
    		"a0d4",
    		""
    	],
    	[
    		"a0e2",
    		""
    	],
    	[
    		"a3c0",
    		"",
    		31,
    		""
    	],
    	[
    		"c6a1",
    		"",
    		9,
    		"",
    		9,
    		"",
    		9,
    		"",
    		23
    	],
    	[
    		"c740",
    		"",
    		58,
    		""
    	],
    	[
    		"c7a1",
    		"",
    		81,
    		"",
    		5,
    		"",
    		4
    	],
    	[
    		"c840",
    		"",
    		26,
    		"",
    		25,
    		""
    	],
    	[
    		"c8a1",
    		""
    	],
    	[
    		"c8cd",
    		""
    	],
    	[
    		"c8f5",
    		""
    	],
    	[
    		"f9fe",
    		""
    	],
    	[
    		"fa40",
    		""
    	],
    	[
    		"faa1",
    		""
    	],
    	[
    		"fb40",
    		""
    	],
    	[
    		"fba1",
    		""
    	],
    	[
    		"fc40",
    		""
    	],
    	[
    		"fca1",
    		""
    	],
    	[
    		"fd40",
    		""
    	],
    	[
    		"fda1",
    		""
    	],
    	[
    		"fe40",
    		""
    	],
    	[
    		"fea1",
    		""
    	]
    ];

    // Description of supported double byte encodings and aliases.
    // Tables are not require()-d until they are needed to speed up library load.
    // require()-s are direct to support Browserify.

    var dbcsData = {
        
        // == Japanese/ShiftJIS ====================================================
        // All japanese encodings are based on JIS X set of standards:
        // JIS X 0201 - Single-byte encoding of ASCII +  + Kana chars at 0xA1-0xDF.
        // JIS X 0208 - Main set of 6879 characters, placed in 94x94 plane, to be encoded by 2 bytes. 
        //              Has several variations in 1978, 1983, 1990 and 1997.
        // JIS X 0212 - Supplementary plane of 6067 chars in 94x94 plane. 1990. Effectively dead.
        // JIS X 0213 - Extension and modern replacement of 0208 and 0212. Total chars: 11233.
        //              2 planes, first is superset of 0208, second - revised 0212.
        //              Introduced in 2000, revised 2004. Some characters are in Unicode Plane 2 (0x2xxxx)

        // Byte encodings are:
        //  * Shift_JIS: Compatible with 0201, uses not defined chars in top half as lead bytes for double-byte
        //               encoding of 0208. Lead byte ranges: 0x81-0x9F, 0xE0-0xEF; Trail byte ranges: 0x40-0x7E, 0x80-0x9E, 0x9F-0xFC.
        //               Windows CP932 is a superset of Shift_JIS. Some companies added more chars, notably KDDI.
        //  * EUC-JP:    Up to 3 bytes per character. Used mostly on *nixes.
        //               0x00-0x7F       - lower part of 0201
        //               0x8E, 0xA1-0xDF - upper part of 0201
        //               (0xA1-0xFE)x2   - 0208 plane (94x94).
        //               0x8F, (0xA1-0xFE)x2 - 0212 plane (94x94).
        //  * JIS X 208: 7-bit, direct encoding of 0208. Byte ranges: 0x21-0x7E (94 values). Uncommon.
        //               Used as-is in ISO2022 family.
        //  * ISO2022-JP: Stateful encoding, with escape sequences to switch between ASCII, 
        //                0201-1976 Roman, 0208-1978, 0208-1983.
        //  * ISO2022-JP-1: Adds esc seq for 0212-1990.
        //  * ISO2022-JP-2: Adds esc seq for GB2313-1980, KSX1001-1992, ISO8859-1, ISO8859-7.
        //  * ISO2022-JP-3: Adds esc seq for 0201-1976 Kana set, 0213-2000 Planes 1, 2.
        //  * ISO2022-JP-2004: Adds 0213-2004 Plane 1.
        //
        // After JIS X 0213 appeared, Shift_JIS-2004, EUC-JISX0213 and ISO2022-JP-2004 followed, with just changing the planes.
        //
        // Overall, it seems that it's a mess :( http://www8.plala.or.jp/tkubota1/unicode-symbols-map2.html

        'shiftjis': {
            type: '_dbcs',
            table: function() { return require$$0 },
            encodeAdd: {'\u00a5': 0x5C, '\u203E': 0x7E},
            encodeSkipVals: [{from: 0xED40, to: 0xF940}],
        },
        'csshiftjis': 'shiftjis',
        'mskanji': 'shiftjis',
        'sjis': 'shiftjis',
        'windows31j': 'shiftjis',
        'ms31j': 'shiftjis',
        'xsjis': 'shiftjis',
        'windows932': 'shiftjis',
        'ms932': 'shiftjis',
        '932': 'shiftjis',
        'cp932': 'shiftjis',

        'eucjp': {
            type: '_dbcs',
            table: function() { return require$$1 },
            encodeAdd: {'\u00a5': 0x5C, '\u203E': 0x7E},
        },

        // TODO: KDDI extension to Shift_JIS
        // TODO: IBM CCSID 942 = CP932, but F0-F9 custom chars and other char changes.
        // TODO: IBM CCSID 943 = Shift_JIS = CP932 with original Shift_JIS lower 128 chars.


        // == Chinese/GBK ==========================================================
        // http://en.wikipedia.org/wiki/GBK
        // We mostly implement W3C recommendation: https://www.w3.org/TR/encoding/#gbk-encoder

        // Oldest GB2312 (1981, ~7600 chars) is a subset of CP936
        'gb2312': 'cp936',
        'gb231280': 'cp936',
        'gb23121980': 'cp936',
        'csgb2312': 'cp936',
        'csiso58gb231280': 'cp936',
        'euccn': 'cp936',

        // Microsoft's CP936 is a subset and approximation of GBK.
        'windows936': 'cp936',
        'ms936': 'cp936',
        '936': 'cp936',
        'cp936': {
            type: '_dbcs',
            table: function() { return require$$2 },
        },

        // GBK (~22000 chars) is an extension of CP936 that added user-mapped chars and some other.
        'gbk': {
            type: '_dbcs',
            table: function() { return require$$2.concat(require$$3$1) },
        },
        'xgbk': 'gbk',
        'isoir58': 'gbk',

        // GB18030 is an algorithmic extension of GBK.
        // Main source: https://www.w3.org/TR/encoding/#gbk-encoder
        // http://icu-project.org/docs/papers/gb18030.html
        // http://source.icu-project.org/repos/icu/data/trunk/charset/data/xml/gb-18030-2000.xml
        // http://www.khngai.com/chinese/charmap/tblgbk.php?page=0
        'gb18030': {
            type: '_dbcs',
            table: function() { return require$$2.concat(require$$3$1) },
            gb18030: function() { return require$$4 },
            encodeSkipVals: [0x80],
            encodeAdd: {'': 0xA2E3},
        },

        'chinese': 'gb18030',


        // == Korean ===============================================================
        // EUC-KR, KS_C_5601 and KS X 1001 are exactly the same.
        'windows949': 'cp949',
        'ms949': 'cp949',
        '949': 'cp949',
        'cp949': {
            type: '_dbcs',
            table: function() { return require$$5 },
        },

        'cseuckr': 'cp949',
        'csksc56011987': 'cp949',
        'euckr': 'cp949',
        'isoir149': 'cp949',
        'korean': 'cp949',
        'ksc56011987': 'cp949',
        'ksc56011989': 'cp949',
        'ksc5601': 'cp949',


        // == Big5/Taiwan/Hong Kong ================================================
        // There are lots of tables for Big5 and cp950. Please see the following links for history:
        // http://moztw.org/docs/big5/  http://www.haible.de/bruno/charsets/conversion-tables/Big5.html
        // Variations, in roughly number of defined chars:
        //  * Windows CP 950: Microsoft variant of Big5. Canonical: http://www.unicode.org/Public/MAPPINGS/VENDORS/MICSFT/WINDOWS/CP950.TXT
        //  * Windows CP 951: Microsoft variant of Big5-HKSCS-2001. Seems to be never public. http://me.abelcheung.org/articles/research/what-is-cp951/
        //  * Big5-2003 (Taiwan standard) almost superset of cp950.
        //  * Unicode-at-on (UAO) / Mozilla 1.8. Falling out of use on the Web. Not supported by other browsers.
        //  * Big5-HKSCS (-2001, -2004, -2008). Hong Kong standard. 
        //    many unicode code points moved from PUA to Supplementary plane (U+2XXXX) over the years.
        //    Plus, it has 4 combining sequences.
        //    Seems that Mozilla refused to support it for 10 yrs. https://bugzilla.mozilla.org/show_bug.cgi?id=162431 https://bugzilla.mozilla.org/show_bug.cgi?id=310299
        //    because big5-hkscs is the only encoding to include astral characters in non-algorithmic way.
        //    Implementations are not consistent within browsers; sometimes labeled as just big5.
        //    MS Internet Explorer switches from big5 to big5-hkscs when a patch applied.
        //    Great discussion & recap of what's going on https://bugzilla.mozilla.org/show_bug.cgi?id=912470#c31
        //    In the encoder, it might make sense to support encoding old PUA mappings to Big5 bytes seq-s.
        //    Official spec: http://www.ogcio.gov.hk/en/business/tech_promotion/ccli/terms/doc/2003cmp_2008.txt
        //                   http://www.ogcio.gov.hk/tc/business/tech_promotion/ccli/terms/doc/hkscs-2008-big5-iso.txt
        // 
        // Current understanding of how to deal with Big5(-HKSCS) is in the Encoding Standard, http://encoding.spec.whatwg.org/#big5-encoder
        // Unicode mapping (http://www.unicode.org/Public/MAPPINGS/OBSOLETE/EASTASIA/OTHER/BIG5.TXT) is said to be wrong.

        'windows950': 'cp950',
        'ms950': 'cp950',
        '950': 'cp950',
        'cp950': {
            type: '_dbcs',
            table: function() { return require$$6 },
        },

        // Big5 has many variations and is an extension of cp950. We use Encoding Standard's as a consensus.
        'big5': 'big5hkscs',
        'big5hkscs': {
            type: '_dbcs',
            table: function() { return require$$6.concat(require$$7) },
            encodeSkipVals: [0xa2cc],
        },

        'cnbig5': 'big5hkscs',
        'csbig5': 'big5hkscs',
        'xxbig5': 'big5hkscs',
    };

    (function (exports) {

    // Update this array if you add/rename/remove files in this directory.
    // We support Browserify by skipping automatic module discovery and requiring modules directly.
    var modules = [
        internal,
        utf16,
        utf7,
        sbcsCodec,
        sbcsData,
        sbcsDataGenerated,
        dbcsCodec,
        dbcsData,
    ];

    // Put all encoding/alias/codec definitions to single object and export it. 
    for (var i = 0; i < modules.length; i++) {
        var module = modules[i];
        for (var enc in module)
            if (Object.prototype.hasOwnProperty.call(module, enc))
                exports[enc] = module[enc];
    }
    }(encodings));

    var Buffer$2 = require$$0__default$3["default"].Buffer,
        Transform = require$$0__default$2["default"].Transform;


    // == Exports ==================================================================
    var streams = function(iconv) {
        
        // Additional Public API.
        iconv.encodeStream = function encodeStream(encoding, options) {
            return new IconvLiteEncoderStream(iconv.getEncoder(encoding, options), options);
        };

        iconv.decodeStream = function decodeStream(encoding, options) {
            return new IconvLiteDecoderStream(iconv.getDecoder(encoding, options), options);
        };

        iconv.supportsStreams = true;


        // Not published yet.
        iconv.IconvLiteEncoderStream = IconvLiteEncoderStream;
        iconv.IconvLiteDecoderStream = IconvLiteDecoderStream;
        iconv._collect = IconvLiteDecoderStream.prototype.collect;
    };


    // == Encoder stream =======================================================
    function IconvLiteEncoderStream(conv, options) {
        this.conv = conv;
        options = options || {};
        options.decodeStrings = false; // We accept only strings, so we don't need to decode them.
        Transform.call(this, options);
    }

    IconvLiteEncoderStream.prototype = Object.create(Transform.prototype, {
        constructor: { value: IconvLiteEncoderStream }
    });

    IconvLiteEncoderStream.prototype._transform = function(chunk, encoding, done) {
        if (typeof chunk != 'string')
            return done(new Error("Iconv encoding stream needs strings as its input."));
        try {
            var res = this.conv.write(chunk);
            if (res && res.length) this.push(res);
            done();
        }
        catch (e) {
            done(e);
        }
    };

    IconvLiteEncoderStream.prototype._flush = function(done) {
        try {
            var res = this.conv.end();
            if (res && res.length) this.push(res);
            done();
        }
        catch (e) {
            done(e);
        }
    };

    IconvLiteEncoderStream.prototype.collect = function(cb) {
        var chunks = [];
        this.on('error', cb);
        this.on('data', function(chunk) { chunks.push(chunk); });
        this.on('end', function() {
            cb(null, Buffer$2.concat(chunks));
        });
        return this;
    };


    // == Decoder stream =======================================================
    function IconvLiteDecoderStream(conv, options) {
        this.conv = conv;
        options = options || {};
        options.encoding = this.encoding = 'utf8'; // We output strings.
        Transform.call(this, options);
    }

    IconvLiteDecoderStream.prototype = Object.create(Transform.prototype, {
        constructor: { value: IconvLiteDecoderStream }
    });

    IconvLiteDecoderStream.prototype._transform = function(chunk, encoding, done) {
        if (!Buffer$2.isBuffer(chunk))
            return done(new Error("Iconv decoding stream needs buffers as its input."));
        try {
            var res = this.conv.write(chunk);
            if (res && res.length) this.push(res, this.encoding);
            done();
        }
        catch (e) {
            done(e);
        }
    };

    IconvLiteDecoderStream.prototype._flush = function(done) {
        try {
            var res = this.conv.end();
            if (res && res.length) this.push(res, this.encoding);                
            done();
        }
        catch (e) {
            done(e);
        }
    };

    IconvLiteDecoderStream.prototype.collect = function(cb) {
        var res = '';
        this.on('error', cb);
        this.on('data', function(chunk) { res += chunk; });
        this.on('end', function() {
            cb(null, res);
        });
        return this;
    };

    var Buffer$1 = require$$0__default$3["default"].Buffer;
    // Note: not polyfilled with safer-buffer on a purpose, as overrides Buffer

    // == Extend Node primitives to use iconv-lite =================================

    var extendNode = function (iconv) {
        var original = undefined; // Place to keep original methods.

        // Node authors rewrote Buffer internals to make it compatible with
        // Uint8Array and we cannot patch key functions since then.
        // Note: this does use older Buffer API on a purpose
        iconv.supportsNodeEncodingsExtension = !(Buffer$1.from || new Buffer$1(0) instanceof Uint8Array);

        iconv.extendNodeEncodings = function extendNodeEncodings() {
            if (original) return;
            original = {};

            if (!iconv.supportsNodeEncodingsExtension) {
                console.error("ACTION NEEDED: require('iconv-lite').extendNodeEncodings() is not supported in your version of Node");
                console.error("See more info at https://github.com/ashtuchkin/iconv-lite/wiki/Node-v4-compatibility");
                return;
            }

            var nodeNativeEncodings = {
                'hex': true, 'utf8': true, 'utf-8': true, 'ascii': true, 'binary': true, 
                'base64': true, 'ucs2': true, 'ucs-2': true, 'utf16le': true, 'utf-16le': true,
            };

            Buffer$1.isNativeEncoding = function(enc) {
                return enc && nodeNativeEncodings[enc.toLowerCase()];
            };

            // -- SlowBuffer -----------------------------------------------------------
            var SlowBuffer = require$$0__default$3["default"].SlowBuffer;

            original.SlowBufferToString = SlowBuffer.prototype.toString;
            SlowBuffer.prototype.toString = function(encoding, start, end) {
                encoding = String(encoding || 'utf8').toLowerCase();

                // Use native conversion when possible
                if (Buffer$1.isNativeEncoding(encoding))
                    return original.SlowBufferToString.call(this, encoding, start, end);

                // Otherwise, use our decoding method.
                if (typeof start == 'undefined') start = 0;
                if (typeof end == 'undefined') end = this.length;
                return iconv.decode(this.slice(start, end), encoding);
            };

            original.SlowBufferWrite = SlowBuffer.prototype.write;
            SlowBuffer.prototype.write = function(string, offset, length, encoding) {
                // Support both (string, offset, length, encoding)
                // and the legacy (string, encoding, offset, length)
                if (isFinite(offset)) {
                    if (!isFinite(length)) {
                        encoding = length;
                        length = undefined;
                    }
                } else {  // legacy
                    var swap = encoding;
                    encoding = offset;
                    offset = length;
                    length = swap;
                }

                offset = +offset || 0;
                var remaining = this.length - offset;
                if (!length) {
                    length = remaining;
                } else {
                    length = +length;
                    if (length > remaining) {
                        length = remaining;
                    }
                }
                encoding = String(encoding || 'utf8').toLowerCase();

                // Use native conversion when possible
                if (Buffer$1.isNativeEncoding(encoding))
                    return original.SlowBufferWrite.call(this, string, offset, length, encoding);

                if (string.length > 0 && (length < 0 || offset < 0))
                    throw new RangeError('attempt to write beyond buffer bounds');

                // Otherwise, use our encoding method.
                var buf = iconv.encode(string, encoding);
                if (buf.length < length) length = buf.length;
                buf.copy(this, offset, 0, length);
                return length;
            };

            // -- Buffer ---------------------------------------------------------------

            original.BufferIsEncoding = Buffer$1.isEncoding;
            Buffer$1.isEncoding = function(encoding) {
                return Buffer$1.isNativeEncoding(encoding) || iconv.encodingExists(encoding);
            };

            original.BufferByteLength = Buffer$1.byteLength;
            Buffer$1.byteLength = SlowBuffer.byteLength = function(str, encoding) {
                encoding = String(encoding || 'utf8').toLowerCase();

                // Use native conversion when possible
                if (Buffer$1.isNativeEncoding(encoding))
                    return original.BufferByteLength.call(this, str, encoding);

                // Slow, I know, but we don't have a better way yet.
                return iconv.encode(str, encoding).length;
            };

            original.BufferToString = Buffer$1.prototype.toString;
            Buffer$1.prototype.toString = function(encoding, start, end) {
                encoding = String(encoding || 'utf8').toLowerCase();

                // Use native conversion when possible
                if (Buffer$1.isNativeEncoding(encoding))
                    return original.BufferToString.call(this, encoding, start, end);

                // Otherwise, use our decoding method.
                if (typeof start == 'undefined') start = 0;
                if (typeof end == 'undefined') end = this.length;
                return iconv.decode(this.slice(start, end), encoding);
            };

            original.BufferWrite = Buffer$1.prototype.write;
            Buffer$1.prototype.write = function(string, offset, length, encoding) {
                var _offset = offset, _length = length, _encoding = encoding;
                // Support both (string, offset, length, encoding)
                // and the legacy (string, encoding, offset, length)
                if (isFinite(offset)) {
                    if (!isFinite(length)) {
                        encoding = length;
                        length = undefined;
                    }
                } else {  // legacy
                    var swap = encoding;
                    encoding = offset;
                    offset = length;
                    length = swap;
                }

                encoding = String(encoding || 'utf8').toLowerCase();

                // Use native conversion when possible
                if (Buffer$1.isNativeEncoding(encoding))
                    return original.BufferWrite.call(this, string, _offset, _length, _encoding);

                offset = +offset || 0;
                var remaining = this.length - offset;
                if (!length) {
                    length = remaining;
                } else {
                    length = +length;
                    if (length > remaining) {
                        length = remaining;
                    }
                }

                if (string.length > 0 && (length < 0 || offset < 0))
                    throw new RangeError('attempt to write beyond buffer bounds');

                // Otherwise, use our encoding method.
                var buf = iconv.encode(string, encoding);
                if (buf.length < length) length = buf.length;
                buf.copy(this, offset, 0, length);
                return length;

                // TODO: Set _charsWritten.
            };


            // -- Readable -------------------------------------------------------------
            if (iconv.supportsStreams) {
                var Readable = require$$0__default$2["default"].Readable;

                original.ReadableSetEncoding = Readable.prototype.setEncoding;
                Readable.prototype.setEncoding = function setEncoding(enc, options) {
                    // Use our own decoder, it has the same interface.
                    // We cannot use original function as it doesn't handle BOM-s.
                    this._readableState.decoder = iconv.getDecoder(enc, options);
                    this._readableState.encoding = enc;
                };

                Readable.prototype.collect = iconv._collect;
            }
        };

        // Remove iconv-lite Node primitive extensions.
        iconv.undoExtendNodeEncodings = function undoExtendNodeEncodings() {
            if (!iconv.supportsNodeEncodingsExtension)
                return;
            if (!original)
                throw new Error("require('iconv-lite').undoExtendNodeEncodings(): Nothing to undo; extendNodeEncodings() is not called.")

            delete Buffer$1.isNativeEncoding;

            var SlowBuffer = require$$0__default$3["default"].SlowBuffer;

            SlowBuffer.prototype.toString = original.SlowBufferToString;
            SlowBuffer.prototype.write = original.SlowBufferWrite;

            Buffer$1.isEncoding = original.BufferIsEncoding;
            Buffer$1.byteLength = original.BufferByteLength;
            Buffer$1.prototype.toString = original.BufferToString;
            Buffer$1.prototype.write = original.BufferWrite;

            if (iconv.supportsStreams) {
                var Readable = require$$0__default$2["default"].Readable;

                Readable.prototype.setEncoding = original.ReadableSetEncoding;
                delete Readable.prototype.collect;
            }

            original = undefined;
        };
    };

    (function (module) {

    // Some environments don't have global Buffer (e.g. React Native).
    // Solution would be installing npm modules "buffer" and "stream" explicitly.
    var Buffer = safer_1.Buffer;

    var bomHandling$1 = bomHandling,
        iconv = module.exports;

    // All codecs and aliases are kept here, keyed by encoding name/alias.
    // They are lazy loaded in `iconv.getCodec` from `encodings/index.js`.
    iconv.encodings = null;

    // Characters emitted in case of error.
    iconv.defaultCharUnicode = '';
    iconv.defaultCharSingleByte = '?';

    // Public API.
    iconv.encode = function encode(str, encoding, options) {
        str = "" + (str || ""); // Ensure string.

        var encoder = iconv.getEncoder(encoding, options);

        var res = encoder.write(str);
        var trail = encoder.end();
        
        return (trail && trail.length > 0) ? Buffer.concat([res, trail]) : res;
    };

    iconv.decode = function decode(buf, encoding, options) {
        if (typeof buf === 'string') {
            if (!iconv.skipDecodeWarning) {
                console.error('Iconv-lite warning: decode()-ing strings is deprecated. Refer to https://github.com/ashtuchkin/iconv-lite/wiki/Use-Buffers-when-decoding');
                iconv.skipDecodeWarning = true;
            }

            buf = Buffer.from("" + (buf || ""), "binary"); // Ensure buffer.
        }

        var decoder = iconv.getDecoder(encoding, options);

        var res = decoder.write(buf);
        var trail = decoder.end();

        return trail ? (res + trail) : res;
    };

    iconv.encodingExists = function encodingExists(enc) {
        try {
            iconv.getCodec(enc);
            return true;
        } catch (e) {
            return false;
        }
    };

    // Legacy aliases to convert functions
    iconv.toEncoding = iconv.encode;
    iconv.fromEncoding = iconv.decode;

    // Search for a codec in iconv.encodings. Cache codec data in iconv._codecDataCache.
    iconv._codecDataCache = {};
    iconv.getCodec = function getCodec(encoding) {
        if (!iconv.encodings)
            iconv.encodings = encodings; // Lazy load all encoding definitions.
        
        // Canonicalize encoding name: strip all non-alphanumeric chars and appended year.
        var enc = iconv._canonicalizeEncoding(encoding);

        // Traverse iconv.encodings to find actual codec.
        var codecOptions = {};
        while (true) {
            var codec = iconv._codecDataCache[enc];
            if (codec)
                return codec;

            var codecDef = iconv.encodings[enc];

            switch (typeof codecDef) {
                case "string": // Direct alias to other encoding.
                    enc = codecDef;
                    break;

                case "object": // Alias with options. Can be layered.
                    for (var key in codecDef)
                        codecOptions[key] = codecDef[key];

                    if (!codecOptions.encodingName)
                        codecOptions.encodingName = enc;
                    
                    enc = codecDef.type;
                    break;

                case "function": // Codec itself.
                    if (!codecOptions.encodingName)
                        codecOptions.encodingName = enc;

                    // The codec function must load all tables and return object with .encoder and .decoder methods.
                    // It'll be called only once (for each different options object).
                    codec = new codecDef(codecOptions, iconv);

                    iconv._codecDataCache[codecOptions.encodingName] = codec; // Save it to be reused later.
                    return codec;

                default:
                    throw new Error("Encoding not recognized: '" + encoding + "' (searched as: '"+enc+"')");
            }
        }
    };

    iconv._canonicalizeEncoding = function(encoding) {
        // Canonicalize encoding name: strip all non-alphanumeric chars and appended year.
        return (''+encoding).toLowerCase().replace(/:\d{4}$|[^0-9a-z]/g, "");
    };

    iconv.getEncoder = function getEncoder(encoding, options) {
        var codec = iconv.getCodec(encoding),
            encoder = new codec.encoder(options, codec);

        if (codec.bomAware && options && options.addBOM)
            encoder = new bomHandling$1.PrependBOM(encoder, options);

        return encoder;
    };

    iconv.getDecoder = function getDecoder(encoding, options) {
        var codec = iconv.getCodec(encoding),
            decoder = new codec.decoder(options, codec);

        if (codec.bomAware && !(options && options.stripBOM === false))
            decoder = new bomHandling$1.StripBOM(decoder, options);

        return decoder;
    };


    // Load extensions in Node. All of them are omitted in Browserify build via 'browser' field in package.json.
    var nodeVer = typeof process !== 'undefined' && process.versions && process.versions.node;
    if (nodeVer) {

        // Load streaming support in Node v0.10+
        var nodeVerArr = nodeVer.split(".").map(Number);
        if (nodeVerArr[0] > 0 || nodeVerArr[1] >= 10) {
            streams(iconv);
        }

        // Load Node primitive extensions.
        extendNode(iconv);
    }
    }(lib));

    var tmp = {};

    var isWindows$1 = process.platform === 'win32';
    var trailingSlashRe = isWindows$1 ? /[^:]\\$/ : /.\/$/;

    // https://github.com/nodejs/node/blob/3e7a14381497a3b73dda68d05b5130563cdab420/lib/os.js#L25-L43
    var osTmpdir = function () {
    	var path;

    	if (isWindows$1) {
    		path = process.env.TEMP ||
    			process.env.TMP ||
    			(process.env.SystemRoot || process.env.windir) + '\\temp';
    	} else {
    		path = process.env.TMPDIR ||
    			process.env.TMP ||
    			process.env.TEMP ||
    			'/tmp';
    	}

    	if (trailingSlashRe.test(path)) {
    		path = path.slice(0, -1);
    	}

    	return path;
    };

    /*!
     * Tmp
     *
     * Copyright (c) 2011-2017 KARASZI Istvan <github@spam.raszi.hu>
     *
     * MIT Licensed
     */

    /*
     * Module dependencies.
     */
    const fs$3 = require$$0__default$6["default"];
    const path$4 = require$$1__default$1["default"];
    const crypto = require$$2__default$1["default"];
    const osTmpDir = osTmpdir;
    const _c = process.binding('constants');

    /*
     * The working inner variables.
     */
    const
      /**
       * The temporary directory.
       * @type {string}
       */
      tmpDir = osTmpDir(),

      // the random characters to choose from
      RANDOM_CHARS = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz',

      TEMPLATE_PATTERN = /XXXXXX/,

      DEFAULT_TRIES = 3,

      CREATE_FLAGS = (_c.O_CREAT || _c.fs.O_CREAT) | (_c.O_EXCL || _c.fs.O_EXCL) | (_c.O_RDWR || _c.fs.O_RDWR),

      EBADF = _c.EBADF || _c.os.errno.EBADF,
      ENOENT = _c.ENOENT || _c.os.errno.ENOENT,

      DIR_MODE = 448 /* 0o700 */,
      FILE_MODE = 384 /* 0o600 */,

      // this will hold the objects need to be removed on exit
      _removeObjects = [];

    var
      _gracefulCleanup = false,
      _uncaughtException = false;

    /**
     * Random name generator based on crypto.
     * Adapted from http://blog.tompawlak.org/how-to-generate-random-values-nodejs-javascript
     *
     * @param {number} howMany
     * @returns {string} the generated random name
     * @private
     */
    function _randomChars(howMany) {
      var
        value = [],
        rnd = null;

      // make sure that we do not fail because we ran out of entropy
      try {
        rnd = crypto.randomBytes(howMany);
      } catch (e) {
        rnd = crypto.pseudoRandomBytes(howMany);
      }

      for (var i = 0; i < howMany; i++) {
        value.push(RANDOM_CHARS[rnd[i] % RANDOM_CHARS.length]);
      }

      return value.join('');
    }

    /**
     * Checks whether the `obj` parameter is defined or not.
     *
     * @param {Object} obj
     * @returns {boolean} true if the object is undefined
     * @private
     */
    function _isUndefined(obj) {
      return typeof obj === 'undefined';
    }

    /**
     * Parses the function arguments.
     *
     * This function helps to have optional arguments.
     *
     * @param {(Options|Function)} options
     * @param {Function} callback
     * @returns {Array} parsed arguments
     * @private
     */
    function _parseArguments(options, callback) {
      if (typeof options == 'function') {
        return [callback || {}, options];
      }

      if (_isUndefined(options)) {
        return [{}, callback];
      }

      return [options, callback];
    }

    /**
     * Generates a new temporary name.
     *
     * @param {Object} opts
     * @returns {string} the new random name according to opts
     * @private
     */
    function _generateTmpName(opts) {
      if (opts.name) {
        return path$4.join(opts.dir || tmpDir, opts.name);
      }

      // mkstemps like template
      if (opts.template) {
        return opts.template.replace(TEMPLATE_PATTERN, _randomChars(6));
      }

      // prefix and postfix
      const name = [
        opts.prefix || 'tmp-',
        process.pid,
        _randomChars(12),
        opts.postfix || ''
      ].join('');

      return path$4.join(opts.dir || tmpDir, name);
    }

    /**
     * Gets a temporary file name.
     *
     * @param {(Options|tmpNameCallback)} options options or callback
     * @param {?tmpNameCallback} callback the callback function
     */
    function tmpName(options, callback) {
      var
        args = _parseArguments(options, callback),
        opts = args[0],
        cb = args[1],
        tries = opts.name ? 1 : opts.tries || DEFAULT_TRIES;

      if (isNaN(tries) || tries < 0)
        return cb(new Error('Invalid tries'));

      if (opts.template && !opts.template.match(TEMPLATE_PATTERN))
        return cb(new Error('Invalid template provided'));

      (function _getUniqueName() {
        const name = _generateTmpName(opts);

        // check whether the path exists then retry if needed
        fs$3.stat(name, function (err) {
          if (!err) {
            if (tries-- > 0) return _getUniqueName();

            return cb(new Error('Could not get a unique tmp filename, max tries reached ' + name));
          }

          cb(null, name);
        });
      }());
    }

    /**
     * Synchronous version of tmpName.
     *
     * @param {Object} options
     * @returns {string} the generated random name
     * @throws {Error} if the options are invalid or could not generate a filename
     */
    function tmpNameSync(options) {
      var
        args = _parseArguments(options),
        opts = args[0],
        tries = opts.name ? 1 : opts.tries || DEFAULT_TRIES;

      if (isNaN(tries) || tries < 0)
        throw new Error('Invalid tries');

      if (opts.template && !opts.template.match(TEMPLATE_PATTERN))
        throw new Error('Invalid template provided');

      do {
        const name = _generateTmpName(opts);
        try {
          fs$3.statSync(name);
        } catch (e) {
          return name;
        }
      } while (tries-- > 0);

      throw new Error('Could not get a unique tmp filename, max tries reached');
    }

    /**
     * Creates and opens a temporary file.
     *
     * @param {(Options|fileCallback)} options the config options or the callback function
     * @param {?fileCallback} callback
     */
    function file(options, callback) {
      var
        args = _parseArguments(options, callback),
        opts = args[0],
        cb = args[1];

      opts.postfix = (_isUndefined(opts.postfix)) ? '.tmp' : opts.postfix;

      // gets a temporary filename
      tmpName(opts, function _tmpNameCreated(err, name) {
        if (err) return cb(err);

        // create and open the file
        fs$3.open(name, CREATE_FLAGS, opts.mode || FILE_MODE, function _fileCreated(err, fd) {
          if (err) return cb(err);

          if (opts.discardDescriptor) {
            return fs$3.close(fd, function _discardCallback(err) {
              if (err) {
                // Low probability, and the file exists, so this could be
                // ignored.  If it isn't we certainly need to unlink the
                // file, and if that fails too its error is more
                // important.
                try {
                  fs$3.unlinkSync(name);
                } catch (e) {
                  if (!isENOENT(e)) {
                    err = e;
                  }
                }
                return cb(err);
              }
              cb(null, name, undefined, _prepareTmpFileRemoveCallback(name, -1, opts));
            });
          }
          if (opts.detachDescriptor) {
            return cb(null, name, fd, _prepareTmpFileRemoveCallback(name, -1, opts));
          }
          cb(null, name, fd, _prepareTmpFileRemoveCallback(name, fd, opts));
        });
      });
    }

    /**
     * Synchronous version of file.
     *
     * @param {Options} options
     * @returns {FileSyncObject} object consists of name, fd and removeCallback
     * @throws {Error} if cannot create a file
     */
    function fileSync(options) {
      var
        args = _parseArguments(options),
        opts = args[0];

      opts.postfix = opts.postfix || '.tmp';

      const discardOrDetachDescriptor = opts.discardDescriptor || opts.detachDescriptor;
      const name = tmpNameSync(opts);
      var fd = fs$3.openSync(name, CREATE_FLAGS, opts.mode || FILE_MODE);
      if (opts.discardDescriptor) {
        fs$3.closeSync(fd); 
        fd = undefined;
      }

      return {
        name: name,
        fd: fd,
        removeCallback: _prepareTmpFileRemoveCallback(name, discardOrDetachDescriptor ? -1 : fd, opts)
      };
    }

    /**
     * Removes files and folders in a directory recursively.
     *
     * @param {string} root
     * @private
     */
    function _rmdirRecursiveSync(root) {
      const dirs = [root];

      do {
        var
          dir = dirs.pop(),
          deferred = false,
          files = fs$3.readdirSync(dir);

        for (var i = 0, length = files.length; i < length; i++) {
          var
            file = path$4.join(dir, files[i]),
            stat = fs$3.lstatSync(file); // lstat so we don't recurse into symlinked directories

          if (stat.isDirectory()) {
            if (!deferred) {
              deferred = true;
              dirs.push(dir);
            }
            dirs.push(file);
          } else {
            fs$3.unlinkSync(file);
          }
        }

        if (!deferred) {
          fs$3.rmdirSync(dir);
        }
      } while (dirs.length !== 0);
    }

    /**
     * Creates a temporary directory.
     *
     * @param {(Options|dirCallback)} options the options or the callback function
     * @param {?dirCallback} callback
     */
    function dir(options, callback) {
      var
        args = _parseArguments(options, callback),
        opts = args[0],
        cb = args[1];

      // gets a temporary filename
      tmpName(opts, function _tmpNameCreated(err, name) {
        if (err) return cb(err);

        // create the directory
        fs$3.mkdir(name, opts.mode || DIR_MODE, function _dirCreated(err) {
          if (err) return cb(err);

          cb(null, name, _prepareTmpDirRemoveCallback(name, opts));
        });
      });
    }

    /**
     * Synchronous version of dir.
     *
     * @param {Options} options
     * @returns {DirSyncObject} object consists of name and removeCallback
     * @throws {Error} if it cannot create a directory
     */
    function dirSync(options) {
      var
        args = _parseArguments(options),
        opts = args[0];

      const name = tmpNameSync(opts);
      fs$3.mkdirSync(name, opts.mode || DIR_MODE);

      return {
        name: name,
        removeCallback: _prepareTmpDirRemoveCallback(name, opts)
      };
    }

    /**
     * Prepares the callback for removal of the temporary file.
     *
     * @param {string} name the path of the file
     * @param {number} fd file descriptor
     * @param {Object} opts
     * @returns {fileCallback}
     * @private
     */
    function _prepareTmpFileRemoveCallback(name, fd, opts) {
      const removeCallback = _prepareRemoveCallback(function _removeCallback(fdPath) {
        try {
          if (0 <= fdPath[0]) {
            fs$3.closeSync(fdPath[0]);
          }
        }
        catch (e) {
          // under some node/windows related circumstances, a temporary file
          // may have not be created as expected or the file was already closed
          // by the user, in which case we will simply ignore the error
          if (!isEBADF(e) && !isENOENT(e)) {
            // reraise any unanticipated error
            throw e;
          }
        }
        try {
          fs$3.unlinkSync(fdPath[1]);
        }
        catch (e) {
          if (!isENOENT(e)) {
            // reraise any unanticipated error
            throw e;
          }
        }
      }, [fd, name]);

      if (!opts.keep) {
        _removeObjects.unshift(removeCallback);
      }

      return removeCallback;
    }

    /**
     * Prepares the callback for removal of the temporary directory.
     *
     * @param {string} name
     * @param {Object} opts
     * @returns {Function} the callback
     * @private
     */
    function _prepareTmpDirRemoveCallback(name, opts) {
      const removeFunction = opts.unsafeCleanup ? _rmdirRecursiveSync : fs$3.rmdirSync.bind(fs$3);
      const removeCallback = _prepareRemoveCallback(removeFunction, name);

      if (!opts.keep) {
        _removeObjects.unshift(removeCallback);
      }

      return removeCallback;
    }

    /**
     * Creates a guarded function wrapping the removeFunction call.
     *
     * @param {Function} removeFunction
     * @param {Object} arg
     * @returns {Function}
     * @private
     */
    function _prepareRemoveCallback(removeFunction, arg) {
      var called = false;

      return function _cleanupCallback(next) {
        if (!called) {
          const index = _removeObjects.indexOf(_cleanupCallback);
          if (index >= 0) {
            _removeObjects.splice(index, 1);
          }

          called = true;
          removeFunction(arg);
        }

        if (next) next(null);
      };
    }

    /**
     * The garbage collector.
     *
     * @private
     */
    function _garbageCollector() {
      if (_uncaughtException && !_gracefulCleanup) {
        return;
      }

      // the function being called removes itself from _removeObjects,
      // loop until _removeObjects is empty
      while (_removeObjects.length) {
        try {
          _removeObjects[0].call(null);
        } catch (e) {
          // already removed?
        }
      }
    }

    /**
     * Helper for testing against EBADF to compensate changes made to Node 7.x under Windows.
     */
    function isEBADF(error) {
      return isExpectedError(error, -EBADF, 'EBADF');
    }

    /**
     * Helper for testing against ENOENT to compensate changes made to Node 7.x under Windows.
     */
    function isENOENT(error) {
      return isExpectedError(error, -ENOENT, 'ENOENT');
    }

    /**
     * Helper to determine whether the expected error code matches the actual code and errno,
     * which will differ between the supported node versions.
     *
     * - Node >= 7.0:
     *   error.code {String}
     *   error.errno {String|Number} any numerical value will be negated
     *
     * - Node >= 6.0 < 7.0:
     *   error.code {String}
     *   error.errno {Number} negated
     *
     * - Node >= 4.0 < 6.0: introduces SystemError
     *   error.code {String}
     *   error.errno {Number} negated
     *
     * - Node >= 0.10 < 4.0:
     *   error.code {Number} negated
     *   error.errno n/a
     */
    function isExpectedError(error, code, errno) {
      return error.code == code || error.code == errno;
    }

    /**
     * Sets the graceful cleanup.
     *
     * Also removes the created files and directories when an uncaught exception occurs.
     */
    function setGracefulCleanup() {
      _gracefulCleanup = true;
    }

    const version$2 = process.versions.node.split('.').map(function (value) {
      return parseInt(value, 10);
    });

    if (version$2[0] === 0 && (version$2[1] < 9 || version$2[1] === 9 && version$2[2] < 5)) {
      process.addListener('uncaughtException', function _uncaughtExceptionThrown(err) {
        _uncaughtException = true;
        _garbageCollector();

        throw err;
      });
    }

    process.addListener('exit', function _exit(code) {
      if (code) _uncaughtException = true;
      _garbageCollector();
    });

    /**
     * Configuration options.
     *
     * @typedef {Object} Options
     * @property {?number} tries the number of tries before give up the name generation
     * @property {?string} template the "mkstemp" like filename template
     * @property {?string} name fix name
     * @property {?string} dir the tmp directory to use
     * @property {?string} prefix prefix for the generated name
     * @property {?string} postfix postfix for the generated name
     */

    /**
     * @typedef {Object} FileSyncObject
     * @property {string} name the name of the file
     * @property {string} fd the file descriptor
     * @property {fileCallback} removeCallback the callback function to remove the file
     */

    /**
     * @typedef {Object} DirSyncObject
     * @property {string} name the name of the directory
     * @property {fileCallback} removeCallback the callback function to remove the directory
     */

    /**
     * @callback tmpNameCallback
     * @param {?Error} err the error object if anything goes wrong
     * @param {string} name the temporary file name
     */

    /**
     * @callback fileCallback
     * @param {?Error} err the error object if anything goes wrong
     * @param {string} name the temporary file name
     * @param {number} fd the file descriptor
     * @param {cleanupCallback} fn the cleanup callback function
     */

    /**
     * @callback dirCallback
     * @param {?Error} err the error object if anything goes wrong
     * @param {string} name the temporary file name
     * @param {cleanupCallback} fn the cleanup callback function
     */

    /**
     * Removes the temporary created file or directory.
     *
     * @callback cleanupCallback
     * @param {simpleCallback} [next] function to call after entry was removed
     */

    /**
     * Callback function for function composition.
     * @see {@link https://github.com/raszi/node-tmp/issues/57|raszi/node-tmp#57}
     *
     * @callback simpleCallback
     */

    // exporting all the needed methods
    tmp.tmpdir = tmpDir;

    tmp.dir = dir;
    tmp.dirSync = dirSync;

    tmp.file = file;
    tmp.fileSync = fileSync;

    tmp.tmpName = tmpName;
    tmp.tmpNameSync = tmpNameSync;

    tmp.setGracefulCleanup = setGracefulCleanup;

    var CreateFileError$1 = {};

    /***
     * Node External Editor
     *
     * Kevin Gravier <kevin@mrkmg.com>
     * MIT 2018
     */
    var __extends$3 = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    Object.defineProperty(CreateFileError$1, "__esModule", { value: true });
    var CreateFileError = /** @class */ (function (_super) {
        __extends$3(CreateFileError, _super);
        function CreateFileError(originalError) {
            var _newTarget = this.constructor;
            var _this = _super.call(this, "Failed to create temporary file for editor") || this;
            _this.originalError = originalError;
            var proto = _newTarget.prototype;
            if (Object.setPrototypeOf) {
                Object.setPrototypeOf(_this, proto);
            }
            else {
                _this.__proto__ = _newTarget.prototype;
            }
            return _this;
        }
        return CreateFileError;
    }(Error));
    CreateFileError$1.CreateFileError = CreateFileError;

    var LaunchEditorError$1 = {};

    /***
     * Node External Editor
     *
     * Kevin Gravier <kevin@mrkmg.com>
     * MIT 2018
     */
    var __extends$2 = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    Object.defineProperty(LaunchEditorError$1, "__esModule", { value: true });
    var LaunchEditorError = /** @class */ (function (_super) {
        __extends$2(LaunchEditorError, _super);
        function LaunchEditorError(originalError) {
            var _newTarget = this.constructor;
            var _this = _super.call(this, "Failed launch editor") || this;
            _this.originalError = originalError;
            var proto = _newTarget.prototype;
            if (Object.setPrototypeOf) {
                Object.setPrototypeOf(_this, proto);
            }
            else {
                _this.__proto__ = _newTarget.prototype;
            }
            return _this;
        }
        return LaunchEditorError;
    }(Error));
    LaunchEditorError$1.LaunchEditorError = LaunchEditorError;

    var ReadFileError$1 = {};

    /***
     * Node External Editor
     *
     * Kevin Gravier <kevin@mrkmg.com>
     * MIT 2018
     */
    var __extends$1 = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    Object.defineProperty(ReadFileError$1, "__esModule", { value: true });
    var ReadFileError = /** @class */ (function (_super) {
        __extends$1(ReadFileError, _super);
        function ReadFileError(originalError) {
            var _newTarget = this.constructor;
            var _this = _super.call(this, "Failed to read temporary file") || this;
            _this.originalError = originalError;
            var proto = _newTarget.prototype;
            if (Object.setPrototypeOf) {
                Object.setPrototypeOf(_this, proto);
            }
            else {
                _this.__proto__ = _newTarget.prototype;
            }
            return _this;
        }
        return ReadFileError;
    }(Error));
    ReadFileError$1.ReadFileError = ReadFileError;

    var RemoveFileError$1 = {};

    /***
     * Node External Editor
     *
     * Kevin Gravier <kevin@mrkmg.com>
     * MIT 2018
     */
    var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    Object.defineProperty(RemoveFileError$1, "__esModule", { value: true });
    var RemoveFileError = /** @class */ (function (_super) {
        __extends(RemoveFileError, _super);
        function RemoveFileError(originalError) {
            var _newTarget = this.constructor;
            var _this = _super.call(this, "Failed to cleanup temporary file") || this;
            _this.originalError = originalError;
            var proto = _newTarget.prototype;
            if (Object.setPrototypeOf) {
                Object.setPrototypeOf(_this, proto);
            }
            else {
                _this.__proto__ = _newTarget.prototype;
            }
            return _this;
        }
        return RemoveFileError;
    }(Error));
    RemoveFileError$1.RemoveFileError = RemoveFileError;

    /***
     * Node External Editor
     *
     * Kevin Gravier <kevin@mrkmg.com>
     * MIT 2019
     */
    Object.defineProperty(main$1, "__esModule", { value: true });
    var chardet_1 = chardet;
    var child_process_1 = cp__default["default"];
    var fs_1 = require$$0__default$6["default"];
    var iconv_lite_1 = lib.exports;
    var tmp_1 = tmp;
    var CreateFileError_1 = CreateFileError$1;
    main$1.CreateFileError = CreateFileError_1.CreateFileError;
    var LaunchEditorError_1 = LaunchEditorError$1;
    main$1.LaunchEditorError = LaunchEditorError_1.LaunchEditorError;
    var ReadFileError_1 = ReadFileError$1;
    main$1.ReadFileError = ReadFileError_1.ReadFileError;
    var RemoveFileError_1 = RemoveFileError$1;
    main$1.RemoveFileError = RemoveFileError_1.RemoveFileError;
    function edit(text, fileOptions) {
        if (text === void 0) { text = ""; }
        var editor = new ExternalEditor(text, fileOptions);
        editor.run();
        editor.cleanup();
        return editor.text;
    }
    main$1.edit = edit;
    function editAsync$1(text, callback, fileOptions) {
        if (text === void 0) { text = ""; }
        var editor = new ExternalEditor(text, fileOptions);
        editor.runAsync(function (err, result) {
            if (err) {
                setImmediate(callback, err, null);
            }
            else {
                try {
                    editor.cleanup();
                    setImmediate(callback, null, result);
                }
                catch (cleanupError) {
                    setImmediate(callback, cleanupError, null);
                }
            }
        });
    }
    main$1.editAsync = editAsync$1;
    var ExternalEditor = /** @class */ (function () {
        function ExternalEditor(text, fileOptions) {
            if (text === void 0) { text = ""; }
            this.text = "";
            this.fileOptions = {};
            this.text = text;
            if (fileOptions) {
                this.fileOptions = fileOptions;
            }
            this.determineEditor();
            this.createTemporaryFile();
        }
        ExternalEditor.splitStringBySpace = function (str) {
            var pieces = [];
            var currentString = "";
            for (var strIndex = 0; strIndex < str.length; strIndex++) {
                var currentLetter = str[strIndex];
                if (strIndex > 0 && currentLetter === " " && str[strIndex - 1] !== "\\" && currentString.length > 0) {
                    pieces.push(currentString);
                    currentString = "";
                }
                else {
                    currentString += currentLetter;
                }
            }
            if (currentString.length > 0) {
                pieces.push(currentString);
            }
            return pieces;
        };
        Object.defineProperty(ExternalEditor.prototype, "temp_file", {
            get: function () {
                console.log("DEPRECATED: temp_file. Use tempFile moving forward.");
                return this.tempFile;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ExternalEditor.prototype, "last_exit_status", {
            get: function () {
                console.log("DEPRECATED: last_exit_status. Use lastExitStatus moving forward.");
                return this.lastExitStatus;
            },
            enumerable: true,
            configurable: true
        });
        ExternalEditor.prototype.run = function () {
            this.launchEditor();
            this.readTemporaryFile();
            return this.text;
        };
        ExternalEditor.prototype.runAsync = function (callback) {
            var _this = this;
            try {
                this.launchEditorAsync(function () {
                    try {
                        _this.readTemporaryFile();
                        setImmediate(callback, null, _this.text);
                    }
                    catch (readError) {
                        setImmediate(callback, readError, null);
                    }
                });
            }
            catch (launchError) {
                setImmediate(callback, launchError, null);
            }
        };
        ExternalEditor.prototype.cleanup = function () {
            this.removeTemporaryFile();
        };
        ExternalEditor.prototype.determineEditor = function () {
            var editor = process.env.VISUAL ? process.env.VISUAL :
                process.env.EDITOR ? process.env.EDITOR :
                    /^win/.test(process.platform) ? "notepad" :
                        "vim";
            var editorOpts = ExternalEditor.splitStringBySpace(editor).map(function (piece) { return piece.replace("\\ ", " "); });
            var bin = editorOpts.shift();
            this.editor = { args: editorOpts, bin: bin };
        };
        ExternalEditor.prototype.createTemporaryFile = function () {
            try {
                this.tempFile = tmp_1.tmpNameSync(this.fileOptions);
                var opt = { encoding: "utf8" };
                if (this.fileOptions.hasOwnProperty("mode")) {
                    opt.mode = this.fileOptions.mode;
                }
                fs_1.writeFileSync(this.tempFile, this.text, opt);
            }
            catch (createFileError) {
                throw new CreateFileError_1.CreateFileError(createFileError);
            }
        };
        ExternalEditor.prototype.readTemporaryFile = function () {
            try {
                var tempFileBuffer = fs_1.readFileSync(this.tempFile);
                if (tempFileBuffer.length === 0) {
                    this.text = "";
                }
                else {
                    var encoding = chardet_1.detect(tempFileBuffer).toString();
                    if (!iconv_lite_1.encodingExists(encoding)) {
                        // Probably a bad idea, but will at least prevent crashing
                        encoding = "utf8";
                    }
                    this.text = iconv_lite_1.decode(tempFileBuffer, encoding);
                }
            }
            catch (readFileError) {
                throw new ReadFileError_1.ReadFileError(readFileError);
            }
        };
        ExternalEditor.prototype.removeTemporaryFile = function () {
            try {
                fs_1.unlinkSync(this.tempFile);
            }
            catch (removeFileError) {
                throw new RemoveFileError_1.RemoveFileError(removeFileError);
            }
        };
        ExternalEditor.prototype.launchEditor = function () {
            try {
                var editorProcess = child_process_1.spawnSync(this.editor.bin, this.editor.args.concat([this.tempFile]), { stdio: "inherit" });
                this.lastExitStatus = editorProcess.status;
            }
            catch (launchError) {
                throw new LaunchEditorError_1.LaunchEditorError(launchError);
            }
        };
        ExternalEditor.prototype.launchEditorAsync = function (callback) {
            var _this = this;
            try {
                var editorProcess = child_process_1.spawn(this.editor.bin, this.editor.args.concat([this.tempFile]), { stdio: "inherit" });
                editorProcess.on("exit", function (code) {
                    _this.lastExitStatus = code;
                    setImmediate(callback);
                });
            }
            catch (launchError) {
                throw new LaunchEditorError_1.LaunchEditorError(launchError);
            }
        };
        return ExternalEditor;
    }());
    main$1.ExternalEditor = ExternalEditor;

    /**
     * `editor` type prompt
     */

    const chalk = source;
    const { editAsync } = main$1;
    const Base = base;
    const observe = events;
    const { Subject } = require$$4$1;

    class EditorPrompt extends Base {
      /**
       * Start the Inquiry session
       * @param  {Function} cb      Callback when prompt is done
       * @return {this}
       */

      _run(cb) {
        this.done = cb;

        this.editorResult = new Subject();

        // Open Editor on "line" (Enter Key)
        const events = observe(this.rl);
        this.lineSubscription = events.line.subscribe(this.startExternalEditor.bind(this));

        // Trigger Validation when editor closes
        const validation = this.handleSubmitEvents(this.editorResult);
        validation.success.forEach(this.onEnd.bind(this));
        validation.error.forEach(this.onError.bind(this));

        // Prevents default from being printed on screen (can look weird with multiple lines)
        this.currentText = this.opt.default;
        this.opt.default = null;

        // Init
        this.render();

        return this;
      }

      /**
       * Render the prompt to screen
       * @return {EditorPrompt} self
       */

      render(error) {
        let bottomContent = '';
        let message = this.getQuestion();

        if (this.status === 'answered') {
          message += chalk.dim('Received');
        } else {
          message += chalk.dim('Press <enter> to launch your preferred editor.');
        }

        if (error) {
          bottomContent = chalk.red('>> ') + error;
        }

        this.screen.render(message, bottomContent);
      }

      /**
       * Launch $EDITOR on user press enter
       */

      startExternalEditor() {
        // Pause Readline to prevent stdin and stdout from being modified while the editor is showing
        this.rl.pause();
        editAsync(this.currentText, this.endExternalEditor.bind(this));
      }

      endExternalEditor(error, result) {
        this.rl.resume();
        if (error) {
          this.editorResult.error(error);
        } else {
          this.editorResult.next(result);
        }
      }

      onEnd(state) {
        this.editorResult.unsubscribe();
        this.lineSubscription.unsubscribe();
        this.answer = state.value;
        this.status = 'answered';
        // Re-render prompt
        this.render();
        this.screen.done();
        this.done(this.answer);
      }

      onError(state) {
        this.render(state.isValid);
      }
    }

    var editor = EditorPrompt;

    (function (module) {
    /**
     * Inquirer.js
     * A collection of common interactive command line user interfaces.
     */

    const inquirer = module.exports;

    /**
     * Client interfaces
     */

    inquirer.prompts = {};

    inquirer.Separator = separator;

    inquirer.ui = {
      BottomBar: bottomBar,
      Prompt: prompt,
    };

    /**
     * Create a new self-contained prompt module.
     */
    inquirer.createPromptModule = function (opt) {
      const promptModule = function (questions, answers) {
        let ui;
        try {
          ui = new inquirer.ui.Prompt(promptModule.prompts, opt);
        } catch (error) {
          return Promise.reject(error);
        }
        const promise = ui.run(questions, answers);

        // Monkey patch the UI on the promise object so
        // that it remains publicly accessible.
        promise.ui = ui;

        return promise;
      };

      promptModule.prompts = {};

      /**
       * Register a prompt type
       * @param {String} name     Prompt type name
       * @param {Function} prompt Prompt constructor
       * @return {inquirer}
       */

      promptModule.registerPrompt = function (name, prompt) {
        promptModule.prompts[name] = prompt;
        return this;
      };

      /**
       * Register the defaults provider prompts
       */

      promptModule.restoreDefaultPrompts = function () {
        this.registerPrompt('list', list);
        this.registerPrompt('input', input);
        this.registerPrompt('number', number);
        this.registerPrompt('confirm', confirm);
        this.registerPrompt('rawlist', rawlist);
        this.registerPrompt('expand', expand$2);
        this.registerPrompt('checkbox', checkbox);
        this.registerPrompt('password', password);
        this.registerPrompt('editor', editor);
      };

      promptModule.restoreDefaultPrompts();

      return promptModule;
    };

    /**
     * Public CLI helper interface
     * @param  {Array|Object|Rx.Observable} questions - Questions settings array
     * @param  {Function} cb - Callback being passed the user answers
     * @return {inquirer.ui.Prompt}
     */

    inquirer.prompt = inquirer.createPromptModule();

    // Expose helper functions on the top level for easiest usage by common users
    inquirer.registerPrompt = function (name, prompt) {
      inquirer.prompt.registerPrompt(name, prompt);
    };

    inquirer.restoreDefaultPrompts = function () {
      inquirer.prompt.restoreDefaultPrompts();
    };
    }(inquirer$1));

    var inquirer = inquirer$1.exports;

    var old$1 = {};

    // Copyright Joyent, Inc. and other Node contributors.
    //
    // Permission is hereby granted, free of charge, to any person obtaining a
    // copy of this software and associated documentation files (the
    // "Software"), to deal in the Software without restriction, including
    // without limitation the rights to use, copy, modify, merge, publish,
    // distribute, sublicense, and/or sell copies of the Software, and to permit
    // persons to whom the Software is furnished to do so, subject to the
    // following conditions:
    //
    // The above copyright notice and this permission notice shall be included
    // in all copies or substantial portions of the Software.
    //
    // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
    // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
    // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
    // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
    // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
    // USE OR OTHER DEALINGS IN THE SOFTWARE.

    var pathModule = require$$1__default$1["default"];
    var isWindows = process.platform === 'win32';
    var fs$2 = require$$0__default$6["default"];

    // JavaScript implementation of realpath, ported from node pre-v6

    var DEBUG = process.env.NODE_DEBUG && /fs/.test(process.env.NODE_DEBUG);

    function rethrow() {
      // Only enable in debug mode. A backtrace uses ~1000 bytes of heap space and
      // is fairly slow to generate.
      var callback;
      if (DEBUG) {
        var backtrace = new Error;
        callback = debugCallback;
      } else
        callback = missingCallback;

      return callback;

      function debugCallback(err) {
        if (err) {
          backtrace.message = err.message;
          err = backtrace;
          missingCallback(err);
        }
      }

      function missingCallback(err) {
        if (err) {
          if (process.throwDeprecation)
            throw err;  // Forgot a callback but don't know where? Use NODE_DEBUG=fs
          else if (!process.noDeprecation) {
            var msg = 'fs: missing callback ' + (err.stack || err.message);
            if (process.traceDeprecation)
              console.trace(msg);
            else
              console.error(msg);
          }
        }
      }
    }

    function maybeCallback(cb) {
      return typeof cb === 'function' ? cb : rethrow();
    }

    pathModule.normalize;

    // Regexp that finds the next partion of a (partial) path
    // result is [base_with_slash, base], e.g. ['somedir/', 'somedir']
    if (isWindows) {
      var nextPartRe = /(.*?)(?:[\/\\]+|$)/g;
    } else {
      var nextPartRe = /(.*?)(?:[\/]+|$)/g;
    }

    // Regex to find the device root, including trailing slash. E.g. 'c:\\'.
    if (isWindows) {
      var splitRootRe = /^(?:[a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/][^\\\/]+)?[\\\/]*/;
    } else {
      var splitRootRe = /^[\/]*/;
    }

    old$1.realpathSync = function realpathSync(p, cache) {
      // make p is absolute
      p = pathModule.resolve(p);

      if (cache && Object.prototype.hasOwnProperty.call(cache, p)) {
        return cache[p];
      }

      var original = p,
          seenLinks = {},
          knownHard = {};

      // current character position in p
      var pos;
      // the partial path so far, including a trailing slash if any
      var current;
      // the partial path without a trailing slash (except when pointing at a root)
      var base;
      // the partial path scanned in the previous round, with slash
      var previous;

      start();

      function start() {
        // Skip over roots
        var m = splitRootRe.exec(p);
        pos = m[0].length;
        current = m[0];
        base = m[0];
        previous = '';

        // On windows, check that the root exists. On unix there is no need.
        if (isWindows && !knownHard[base]) {
          fs$2.lstatSync(base);
          knownHard[base] = true;
        }
      }

      // walk down the path, swapping out linked pathparts for their real
      // values
      // NB: p.length changes.
      while (pos < p.length) {
        // find the next part
        nextPartRe.lastIndex = pos;
        var result = nextPartRe.exec(p);
        previous = current;
        current += result[0];
        base = previous + result[1];
        pos = nextPartRe.lastIndex;

        // continue if not a symlink
        if (knownHard[base] || (cache && cache[base] === base)) {
          continue;
        }

        var resolvedLink;
        if (cache && Object.prototype.hasOwnProperty.call(cache, base)) {
          // some known symbolic link.  no need to stat again.
          resolvedLink = cache[base];
        } else {
          var stat = fs$2.lstatSync(base);
          if (!stat.isSymbolicLink()) {
            knownHard[base] = true;
            if (cache) cache[base] = base;
            continue;
          }

          // read the link if it wasn't read before
          // dev/ino always return 0 on windows, so skip the check.
          var linkTarget = null;
          if (!isWindows) {
            var id = stat.dev.toString(32) + ':' + stat.ino.toString(32);
            if (seenLinks.hasOwnProperty(id)) {
              linkTarget = seenLinks[id];
            }
          }
          if (linkTarget === null) {
            fs$2.statSync(base);
            linkTarget = fs$2.readlinkSync(base);
          }
          resolvedLink = pathModule.resolve(previous, linkTarget);
          // track this, if given a cache.
          if (cache) cache[base] = resolvedLink;
          if (!isWindows) seenLinks[id] = linkTarget;
        }

        // resolve the link, then start over
        p = pathModule.resolve(resolvedLink, p.slice(pos));
        start();
      }

      if (cache) cache[original] = p;

      return p;
    };


    old$1.realpath = function realpath(p, cache, cb) {
      if (typeof cb !== 'function') {
        cb = maybeCallback(cache);
        cache = null;
      }

      // make p is absolute
      p = pathModule.resolve(p);

      if (cache && Object.prototype.hasOwnProperty.call(cache, p)) {
        return process.nextTick(cb.bind(null, null, cache[p]));
      }

      var original = p,
          seenLinks = {},
          knownHard = {};

      // current character position in p
      var pos;
      // the partial path so far, including a trailing slash if any
      var current;
      // the partial path without a trailing slash (except when pointing at a root)
      var base;
      // the partial path scanned in the previous round, with slash
      var previous;

      start();

      function start() {
        // Skip over roots
        var m = splitRootRe.exec(p);
        pos = m[0].length;
        current = m[0];
        base = m[0];
        previous = '';

        // On windows, check that the root exists. On unix there is no need.
        if (isWindows && !knownHard[base]) {
          fs$2.lstat(base, function(err) {
            if (err) return cb(err);
            knownHard[base] = true;
            LOOP();
          });
        } else {
          process.nextTick(LOOP);
        }
      }

      // walk down the path, swapping out linked pathparts for their real
      // values
      function LOOP() {
        // stop if scanned past end of path
        if (pos >= p.length) {
          if (cache) cache[original] = p;
          return cb(null, p);
        }

        // find the next part
        nextPartRe.lastIndex = pos;
        var result = nextPartRe.exec(p);
        previous = current;
        current += result[0];
        base = previous + result[1];
        pos = nextPartRe.lastIndex;

        // continue if not a symlink
        if (knownHard[base] || (cache && cache[base] === base)) {
          return process.nextTick(LOOP);
        }

        if (cache && Object.prototype.hasOwnProperty.call(cache, base)) {
          // known symbolic link.  no need to stat again.
          return gotResolvedLink(cache[base]);
        }

        return fs$2.lstat(base, gotStat);
      }

      function gotStat(err, stat) {
        if (err) return cb(err);

        // if not a symlink, skip to the next path part
        if (!stat.isSymbolicLink()) {
          knownHard[base] = true;
          if (cache) cache[base] = base;
          return process.nextTick(LOOP);
        }

        // stat & read the link if not read before
        // call gotTarget as soon as the link target is known
        // dev/ino always return 0 on windows, so skip the check.
        if (!isWindows) {
          var id = stat.dev.toString(32) + ':' + stat.ino.toString(32);
          if (seenLinks.hasOwnProperty(id)) {
            return gotTarget(null, seenLinks[id], base);
          }
        }
        fs$2.stat(base, function(err) {
          if (err) return cb(err);

          fs$2.readlink(base, function(err, target) {
            if (!isWindows) seenLinks[id] = target;
            gotTarget(err, target);
          });
        });
      }

      function gotTarget(err, target, base) {
        if (err) return cb(err);

        var resolvedLink = pathModule.resolve(previous, target);
        if (cache) cache[base] = resolvedLink;
        gotResolvedLink(resolvedLink);
      }

      function gotResolvedLink(resolvedLink) {
        // resolve the link, then start over
        p = pathModule.resolve(resolvedLink, p.slice(pos));
        start();
      }
    };

    var fs_realpath = realpath;
    realpath.realpath = realpath;
    realpath.sync = realpathSync;
    realpath.realpathSync = realpathSync;
    realpath.monkeypatch = monkeypatch;
    realpath.unmonkeypatch = unmonkeypatch;

    var fs$1 = require$$0__default$6["default"];
    var origRealpath = fs$1.realpath;
    var origRealpathSync = fs$1.realpathSync;

    var version$1 = process.version;
    var ok = /^v[0-5]\./.test(version$1);
    var old = old$1;

    function newError (er) {
      return er && er.syscall === 'realpath' && (
        er.code === 'ELOOP' ||
        er.code === 'ENOMEM' ||
        er.code === 'ENAMETOOLONG'
      )
    }

    function realpath (p, cache, cb) {
      if (ok) {
        return origRealpath(p, cache, cb)
      }

      if (typeof cache === 'function') {
        cb = cache;
        cache = null;
      }
      origRealpath(p, cache, function (er, result) {
        if (newError(er)) {
          old.realpath(p, cache, cb);
        } else {
          cb(er, result);
        }
      });
    }

    function realpathSync (p, cache) {
      if (ok) {
        return origRealpathSync(p, cache)
      }

      try {
        return origRealpathSync(p, cache)
      } catch (er) {
        if (newError(er)) {
          return old.realpathSync(p, cache)
        } else {
          throw er
        }
      }
    }

    function monkeypatch () {
      fs$1.realpath = realpath;
      fs$1.realpathSync = realpathSync;
    }

    function unmonkeypatch () {
      fs$1.realpath = origRealpath;
      fs$1.realpathSync = origRealpathSync;
    }

    var concatMap$1 = function (xs, fn) {
        var res = [];
        for (var i = 0; i < xs.length; i++) {
            var x = fn(xs[i], i);
            if (isArray(x)) res.push.apply(res, x);
            else res.push(x);
        }
        return res;
    };

    var isArray = Array.isArray || function (xs) {
        return Object.prototype.toString.call(xs) === '[object Array]';
    };

    var balancedMatch = balanced$1;
    function balanced$1(a, b, str) {
      if (a instanceof RegExp) a = maybeMatch(a, str);
      if (b instanceof RegExp) b = maybeMatch(b, str);

      var r = range(a, b, str);

      return r && {
        start: r[0],
        end: r[1],
        pre: str.slice(0, r[0]),
        body: str.slice(r[0] + a.length, r[1]),
        post: str.slice(r[1] + b.length)
      };
    }

    function maybeMatch(reg, str) {
      var m = str.match(reg);
      return m ? m[0] : null;
    }

    balanced$1.range = range;
    function range(a, b, str) {
      var begs, beg, left, right, result;
      var ai = str.indexOf(a);
      var bi = str.indexOf(b, ai + 1);
      var i = ai;

      if (ai >= 0 && bi > 0) {
        if(a===b) {
          return [ai, bi];
        }
        begs = [];
        left = str.length;

        while (i >= 0 && !result) {
          if (i == ai) {
            begs.push(i);
            ai = str.indexOf(a, i + 1);
          } else if (begs.length == 1) {
            result = [ begs.pop(), bi ];
          } else {
            beg = begs.pop();
            if (beg < left) {
              left = beg;
              right = bi;
            }

            bi = str.indexOf(b, i + 1);
          }

          i = ai < bi && ai >= 0 ? ai : bi;
        }

        if (begs.length) {
          result = [ left, right ];
        }
      }

      return result;
    }

    var concatMap = concatMap$1;
    var balanced = balancedMatch;

    var braceExpansion = expandTop;

    var escSlash = '\0SLASH'+Math.random()+'\0';
    var escOpen = '\0OPEN'+Math.random()+'\0';
    var escClose = '\0CLOSE'+Math.random()+'\0';
    var escComma = '\0COMMA'+Math.random()+'\0';
    var escPeriod = '\0PERIOD'+Math.random()+'\0';

    function numeric(str) {
      return parseInt(str, 10) == str
        ? parseInt(str, 10)
        : str.charCodeAt(0);
    }

    function escapeBraces(str) {
      return str.split('\\\\').join(escSlash)
                .split('\\{').join(escOpen)
                .split('\\}').join(escClose)
                .split('\\,').join(escComma)
                .split('\\.').join(escPeriod);
    }

    function unescapeBraces(str) {
      return str.split(escSlash).join('\\')
                .split(escOpen).join('{')
                .split(escClose).join('}')
                .split(escComma).join(',')
                .split(escPeriod).join('.');
    }


    // Basically just str.split(","), but handling cases
    // where we have nested braced sections, which should be
    // treated as individual members, like {a,{b,c},d}
    function parseCommaParts(str) {
      if (!str)
        return [''];

      var parts = [];
      var m = balanced('{', '}', str);

      if (!m)
        return str.split(',');

      var pre = m.pre;
      var body = m.body;
      var post = m.post;
      var p = pre.split(',');

      p[p.length-1] += '{' + body + '}';
      var postParts = parseCommaParts(post);
      if (post.length) {
        p[p.length-1] += postParts.shift();
        p.push.apply(p, postParts);
      }

      parts.push.apply(parts, p);

      return parts;
    }

    function expandTop(str) {
      if (!str)
        return [];

      // I don't know why Bash 4.3 does this, but it does.
      // Anything starting with {} will have the first two bytes preserved
      // but *only* at the top level, so {},a}b will not expand to anything,
      // but a{},b}c will be expanded to [a}c,abc].
      // One could argue that this is a bug in Bash, but since the goal of
      // this module is to match Bash's rules, we escape a leading {}
      if (str.substr(0, 2) === '{}') {
        str = '\\{\\}' + str.substr(2);
      }

      return expand$1(escapeBraces(str), true).map(unescapeBraces);
    }

    function embrace(str) {
      return '{' + str + '}';
    }
    function isPadded(el) {
      return /^-?0\d/.test(el);
    }

    function lte(i, y) {
      return i <= y;
    }
    function gte(i, y) {
      return i >= y;
    }

    function expand$1(str, isTop) {
      var expansions = [];

      var m = balanced('{', '}', str);
      if (!m || /\$$/.test(m.pre)) return [str];

      var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body);
      var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body);
      var isSequence = isNumericSequence || isAlphaSequence;
      var isOptions = m.body.indexOf(',') >= 0;
      if (!isSequence && !isOptions) {
        // {a},b}
        if (m.post.match(/,.*\}/)) {
          str = m.pre + '{' + m.body + escClose + m.post;
          return expand$1(str);
        }
        return [str];
      }

      var n;
      if (isSequence) {
        n = m.body.split(/\.\./);
      } else {
        n = parseCommaParts(m.body);
        if (n.length === 1) {
          // x{{a,b}}y ==> x{a}y x{b}y
          n = expand$1(n[0], false).map(embrace);
          if (n.length === 1) {
            var post = m.post.length
              ? expand$1(m.post, false)
              : [''];
            return post.map(function(p) {
              return m.pre + n[0] + p;
            });
          }
        }
      }

      // at this point, n is the parts, and we know it's not a comma set
      // with a single entry.

      // no need to expand pre, since it is guaranteed to be free of brace-sets
      var pre = m.pre;
      var post = m.post.length
        ? expand$1(m.post, false)
        : [''];

      var N;

      if (isSequence) {
        var x = numeric(n[0]);
        var y = numeric(n[1]);
        var width = Math.max(n[0].length, n[1].length);
        var incr = n.length == 3
          ? Math.abs(numeric(n[2]))
          : 1;
        var test = lte;
        var reverse = y < x;
        if (reverse) {
          incr *= -1;
          test = gte;
        }
        var pad = n.some(isPadded);

        N = [];

        for (var i = x; test(i, y); i += incr) {
          var c;
          if (isAlphaSequence) {
            c = String.fromCharCode(i);
            if (c === '\\')
              c = '';
          } else {
            c = String(i);
            if (pad) {
              var need = width - c.length;
              if (need > 0) {
                var z = new Array(need + 1).join('0');
                if (i < 0)
                  c = '-' + z + c.slice(1);
                else
                  c = z + c;
              }
            }
          }
          N.push(c);
        }
      } else {
        N = concatMap(n, function(el) { return expand$1(el, false) });
      }

      for (var j = 0; j < N.length; j++) {
        for (var k = 0; k < post.length; k++) {
          var expansion = pre + N[j] + post[k];
          if (!isTop || isSequence || expansion)
            expansions.push(expansion);
        }
      }

      return expansions;
    }

    var minimatch_1 = minimatch$3;
    minimatch$3.Minimatch = Minimatch$1;

    var path$3 = { sep: '/' };
    try {
      path$3 = require('path');
    } catch (er) {}

    var GLOBSTAR = minimatch$3.GLOBSTAR = Minimatch$1.GLOBSTAR = {};
    var expand = braceExpansion;

    var plTypes = {
      '!': { open: '(?:(?!(?:', close: '))[^/]*?)'},
      '?': { open: '(?:', close: ')?' },
      '+': { open: '(?:', close: ')+' },
      '*': { open: '(?:', close: ')*' },
      '@': { open: '(?:', close: ')' }
    };

    // any single thing other than /
    // don't need to escape / when using new RegExp()
    var qmark = '[^/]';

    // * => any number of characters
    var star = qmark + '*?';

    // ** when dots are allowed.  Anything goes, except .. and .
    // not (^ or / followed by one or two dots followed by $ or /),
    // followed by anything, any number of times.
    var twoStarDot = '(?:(?!(?:\\\/|^)(?:\\.{1,2})($|\\\/)).)*?';

    // not a ^ or / followed by a dot,
    // followed by anything, any number of times.
    var twoStarNoDot = '(?:(?!(?:\\\/|^)\\.).)*?';

    // characters that need to be escaped in RegExp.
    var reSpecials = charSet('().*{}+?[]^$\\!');

    // "abc" -> { a:true, b:true, c:true }
    function charSet (s) {
      return s.split('').reduce(function (set, c) {
        set[c] = true;
        return set
      }, {})
    }

    // normalizes slashes.
    var slashSplit = /\/+/;

    minimatch$3.filter = filter;
    function filter (pattern, options) {
      options = options || {};
      return function (p, i, list) {
        return minimatch$3(p, pattern, options)
      }
    }

    function ext (a, b) {
      a = a || {};
      b = b || {};
      var t = {};
      Object.keys(b).forEach(function (k) {
        t[k] = b[k];
      });
      Object.keys(a).forEach(function (k) {
        t[k] = a[k];
      });
      return t
    }

    minimatch$3.defaults = function (def) {
      if (!def || !Object.keys(def).length) return minimatch$3

      var orig = minimatch$3;

      var m = function minimatch (p, pattern, options) {
        return orig.minimatch(p, pattern, ext(def, options))
      };

      m.Minimatch = function Minimatch (pattern, options) {
        return new orig.Minimatch(pattern, ext(def, options))
      };

      return m
    };

    Minimatch$1.defaults = function (def) {
      if (!def || !Object.keys(def).length) return Minimatch$1
      return minimatch$3.defaults(def).Minimatch
    };

    function minimatch$3 (p, pattern, options) {
      if (typeof pattern !== 'string') {
        throw new TypeError('glob pattern string required')
      }

      if (!options) options = {};

      // shortcut: comments match nothing.
      if (!options.nocomment && pattern.charAt(0) === '#') {
        return false
      }

      // "" only matches ""
      if (pattern.trim() === '') return p === ''

      return new Minimatch$1(pattern, options).match(p)
    }

    function Minimatch$1 (pattern, options) {
      if (!(this instanceof Minimatch$1)) {
        return new Minimatch$1(pattern, options)
      }

      if (typeof pattern !== 'string') {
        throw new TypeError('glob pattern string required')
      }

      if (!options) options = {};
      pattern = pattern.trim();

      // windows support: need to use /, not \
      if (path$3.sep !== '/') {
        pattern = pattern.split(path$3.sep).join('/');
      }

      this.options = options;
      this.set = [];
      this.pattern = pattern;
      this.regexp = null;
      this.negate = false;
      this.comment = false;
      this.empty = false;

      // make the set of regexps etc.
      this.make();
    }

    Minimatch$1.prototype.debug = function () {};

    Minimatch$1.prototype.make = make;
    function make () {
      // don't do it more than once.
      if (this._made) return

      var pattern = this.pattern;
      var options = this.options;

      // empty patterns and comments match nothing.
      if (!options.nocomment && pattern.charAt(0) === '#') {
        this.comment = true;
        return
      }
      if (!pattern) {
        this.empty = true;
        return
      }

      // step 1: figure out negation, etc.
      this.parseNegate();

      // step 2: expand braces
      var set = this.globSet = this.braceExpand();

      if (options.debug) this.debug = console.error;

      this.debug(this.pattern, set);

      // step 3: now we have a set, so turn each one into a series of path-portion
      // matching patterns.
      // These will be regexps, except in the case of "**", which is
      // set to the GLOBSTAR object for globstar behavior,
      // and will not contain any / characters
      set = this.globParts = set.map(function (s) {
        return s.split(slashSplit)
      });

      this.debug(this.pattern, set);

      // glob --> regexps
      set = set.map(function (s, si, set) {
        return s.map(this.parse, this)
      }, this);

      this.debug(this.pattern, set);

      // filter out everything that didn't compile properly.
      set = set.filter(function (s) {
        return s.indexOf(false) === -1
      });

      this.debug(this.pattern, set);

      this.set = set;
    }

    Minimatch$1.prototype.parseNegate = parseNegate;
    function parseNegate () {
      var pattern = this.pattern;
      var negate = false;
      var options = this.options;
      var negateOffset = 0;

      if (options.nonegate) return

      for (var i = 0, l = pattern.length
        ; i < l && pattern.charAt(i) === '!'
        ; i++) {
        negate = !negate;
        negateOffset++;
      }

      if (negateOffset) this.pattern = pattern.substr(negateOffset);
      this.negate = negate;
    }

    // Brace expansion:
    // a{b,c}d -> abd acd
    // a{b,}c -> abc ac
    // a{0..3}d -> a0d a1d a2d a3d
    // a{b,c{d,e}f}g -> abg acdfg acefg
    // a{b,c}d{e,f}g -> abdeg acdeg abdeg abdfg
    //
    // Invalid sets are not expanded.
    // a{2..}b -> a{2..}b
    // a{b}c -> a{b}c
    minimatch$3.braceExpand = function (pattern, options) {
      return braceExpand(pattern, options)
    };

    Minimatch$1.prototype.braceExpand = braceExpand;

    function braceExpand (pattern, options) {
      if (!options) {
        if (this instanceof Minimatch$1) {
          options = this.options;
        } else {
          options = {};
        }
      }

      pattern = typeof pattern === 'undefined'
        ? this.pattern : pattern;

      if (typeof pattern === 'undefined') {
        throw new TypeError('undefined pattern')
      }

      if (options.nobrace ||
        !pattern.match(/\{.*\}/)) {
        // shortcut. no need to expand.
        return [pattern]
      }

      return expand(pattern)
    }

    // parse a component of the expanded set.
    // At this point, no pattern may contain "/" in it
    // so we're going to return a 2d array, where each entry is the full
    // pattern, split on '/', and then turned into a regular expression.
    // A regexp is made at the end which joins each array with an
    // escaped /, and another full one which joins each regexp with |.
    //
    // Following the lead of Bash 4.1, note that "**" only has special meaning
    // when it is the *only* thing in a path portion.  Otherwise, any series
    // of * is equivalent to a single *.  Globstar behavior is enabled by
    // default, and can be disabled by setting options.noglobstar.
    Minimatch$1.prototype.parse = parse;
    var SUBPARSE = {};
    function parse (pattern, isSub) {
      if (pattern.length > 1024 * 64) {
        throw new TypeError('pattern is too long')
      }

      var options = this.options;

      // shortcuts
      if (!options.noglobstar && pattern === '**') return GLOBSTAR
      if (pattern === '') return ''

      var re = '';
      var hasMagic = !!options.nocase;
      var escaping = false;
      // ? => one single character
      var patternListStack = [];
      var negativeLists = [];
      var stateChar;
      var inClass = false;
      var reClassStart = -1;
      var classStart = -1;
      // . and .. never match anything that doesn't start with .,
      // even when options.dot is set.
      var patternStart = pattern.charAt(0) === '.' ? '' // anything
      // not (start or / followed by . or .. followed by / or end)
      : options.dot ? '(?!(?:^|\\\/)\\.{1,2}(?:$|\\\/))'
      : '(?!\\.)';
      var self = this;

      function clearStateChar () {
        if (stateChar) {
          // we had some state-tracking character
          // that wasn't consumed by this pass.
          switch (stateChar) {
            case '*':
              re += star;
              hasMagic = true;
            break
            case '?':
              re += qmark;
              hasMagic = true;
            break
            default:
              re += '\\' + stateChar;
            break
          }
          self.debug('clearStateChar %j %j', stateChar, re);
          stateChar = false;
        }
      }

      for (var i = 0, len = pattern.length, c
        ; (i < len) && (c = pattern.charAt(i))
        ; i++) {
        this.debug('%s\t%s %s %j', pattern, i, re, c);

        // skip over any that are escaped.
        if (escaping && reSpecials[c]) {
          re += '\\' + c;
          escaping = false;
          continue
        }

        switch (c) {
          case '/':
            // completely not allowed, even escaped.
            // Should already be path-split by now.
            return false

          case '\\':
            clearStateChar();
            escaping = true;
          continue

          // the various stateChar values
          // for the "extglob" stuff.
          case '?':
          case '*':
          case '+':
          case '@':
          case '!':
            this.debug('%s\t%s %s %j <-- stateChar', pattern, i, re, c);

            // all of those are literals inside a class, except that
            // the glob [!a] means [^a] in regexp
            if (inClass) {
              this.debug('  in class');
              if (c === '!' && i === classStart + 1) c = '^';
              re += c;
              continue
            }

            // if we already have a stateChar, then it means
            // that there was something like ** or +? in there.
            // Handle the stateChar, then proceed with this one.
            self.debug('call clearStateChar %j', stateChar);
            clearStateChar();
            stateChar = c;
            // if extglob is disabled, then +(asdf|foo) isn't a thing.
            // just clear the statechar *now*, rather than even diving into
            // the patternList stuff.
            if (options.noext) clearStateChar();
          continue

          case '(':
            if (inClass) {
              re += '(';
              continue
            }

            if (!stateChar) {
              re += '\\(';
              continue
            }

            patternListStack.push({
              type: stateChar,
              start: i - 1,
              reStart: re.length,
              open: plTypes[stateChar].open,
              close: plTypes[stateChar].close
            });
            // negation is (?:(?!js)[^/]*)
            re += stateChar === '!' ? '(?:(?!(?:' : '(?:';
            this.debug('plType %j %j', stateChar, re);
            stateChar = false;
          continue

          case ')':
            if (inClass || !patternListStack.length) {
              re += '\\)';
              continue
            }

            clearStateChar();
            hasMagic = true;
            var pl = patternListStack.pop();
            // negation is (?:(?!js)[^/]*)
            // The others are (?:<pattern>)<type>
            re += pl.close;
            if (pl.type === '!') {
              negativeLists.push(pl);
            }
            pl.reEnd = re.length;
          continue

          case '|':
            if (inClass || !patternListStack.length || escaping) {
              re += '\\|';
              escaping = false;
              continue
            }

            clearStateChar();
            re += '|';
          continue

          // these are mostly the same in regexp and glob
          case '[':
            // swallow any state-tracking char before the [
            clearStateChar();

            if (inClass) {
              re += '\\' + c;
              continue
            }

            inClass = true;
            classStart = i;
            reClassStart = re.length;
            re += c;
          continue

          case ']':
            //  a right bracket shall lose its special
            //  meaning and represent itself in
            //  a bracket expression if it occurs
            //  first in the list.  -- POSIX.2 2.8.3.2
            if (i === classStart + 1 || !inClass) {
              re += '\\' + c;
              escaping = false;
              continue
            }

            // handle the case where we left a class open.
            // "[z-a]" is valid, equivalent to "\[z-a\]"
            if (inClass) {
              // split where the last [ was, make sure we don't have
              // an invalid re. if so, re-walk the contents of the
              // would-be class to re-translate any characters that
              // were passed through as-is
              // TODO: It would probably be faster to determine this
              // without a try/catch and a new RegExp, but it's tricky
              // to do safely.  For now, this is safe and works.
              var cs = pattern.substring(classStart + 1, i);
              try {
                RegExp('[' + cs + ']');
              } catch (er) {
                // not a valid class!
                var sp = this.parse(cs, SUBPARSE);
                re = re.substr(0, reClassStart) + '\\[' + sp[0] + '\\]';
                hasMagic = hasMagic || sp[1];
                inClass = false;
                continue
              }
            }

            // finish up the class.
            hasMagic = true;
            inClass = false;
            re += c;
          continue

          default:
            // swallow any state char that wasn't consumed
            clearStateChar();

            if (escaping) {
              // no need
              escaping = false;
            } else if (reSpecials[c]
              && !(c === '^' && inClass)) {
              re += '\\';
            }

            re += c;

        } // switch
      } // for

      // handle the case where we left a class open.
      // "[abc" is valid, equivalent to "\[abc"
      if (inClass) {
        // split where the last [ was, and escape it
        // this is a huge pita.  We now have to re-walk
        // the contents of the would-be class to re-translate
        // any characters that were passed through as-is
        cs = pattern.substr(classStart + 1);
        sp = this.parse(cs, SUBPARSE);
        re = re.substr(0, reClassStart) + '\\[' + sp[0];
        hasMagic = hasMagic || sp[1];
      }

      // handle the case where we had a +( thing at the *end*
      // of the pattern.
      // each pattern list stack adds 3 chars, and we need to go through
      // and escape any | chars that were passed through as-is for the regexp.
      // Go through and escape them, taking care not to double-escape any
      // | chars that were already escaped.
      for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {
        var tail = re.slice(pl.reStart + pl.open.length);
        this.debug('setting tail', re, pl);
        // maybe some even number of \, then maybe 1 \, followed by a |
        tail = tail.replace(/((?:\\{2}){0,64})(\\?)\|/g, function (_, $1, $2) {
          if (!$2) {
            // the | isn't already escaped, so escape it.
            $2 = '\\';
          }

          // need to escape all those slashes *again*, without escaping the
          // one that we need for escaping the | character.  As it works out,
          // escaping an even number of slashes can be done by simply repeating
          // it exactly after itself.  That's why this trick works.
          //
          // I am sorry that you have to see this.
          return $1 + $1 + $2 + '|'
        });

        this.debug('tail=%j\n   %s', tail, tail, pl, re);
        var t = pl.type === '*' ? star
          : pl.type === '?' ? qmark
          : '\\' + pl.type;

        hasMagic = true;
        re = re.slice(0, pl.reStart) + t + '\\(' + tail;
      }

      // handle trailing things that only matter at the very end.
      clearStateChar();
      if (escaping) {
        // trailing \\
        re += '\\\\';
      }

      // only need to apply the nodot start if the re starts with
      // something that could conceivably capture a dot
      var addPatternStart = false;
      switch (re.charAt(0)) {
        case '.':
        case '[':
        case '(': addPatternStart = true;
      }

      // Hack to work around lack of negative lookbehind in JS
      // A pattern like: *.!(x).!(y|z) needs to ensure that a name
      // like 'a.xyz.yz' doesn't match.  So, the first negative
      // lookahead, has to look ALL the way ahead, to the end of
      // the pattern.
      for (var n = negativeLists.length - 1; n > -1; n--) {
        var nl = negativeLists[n];

        var nlBefore = re.slice(0, nl.reStart);
        var nlFirst = re.slice(nl.reStart, nl.reEnd - 8);
        var nlLast = re.slice(nl.reEnd - 8, nl.reEnd);
        var nlAfter = re.slice(nl.reEnd);

        nlLast += nlAfter;

        // Handle nested stuff like *(*.js|!(*.json)), where open parens
        // mean that we should *not* include the ) in the bit that is considered
        // "after" the negated section.
        var openParensBefore = nlBefore.split('(').length - 1;
        var cleanAfter = nlAfter;
        for (i = 0; i < openParensBefore; i++) {
          cleanAfter = cleanAfter.replace(/\)[+*?]?/, '');
        }
        nlAfter = cleanAfter;

        var dollar = '';
        if (nlAfter === '' && isSub !== SUBPARSE) {
          dollar = '$';
        }
        var newRe = nlBefore + nlFirst + nlAfter + dollar + nlLast;
        re = newRe;
      }

      // if the re is not "" at this point, then we need to make sure
      // it doesn't match against an empty path part.
      // Otherwise a/* will match a/, which it should not.
      if (re !== '' && hasMagic) {
        re = '(?=.)' + re;
      }

      if (addPatternStart) {
        re = patternStart + re;
      }

      // parsing just a piece of a larger pattern.
      if (isSub === SUBPARSE) {
        return [re, hasMagic]
      }

      // skip the regexp for non-magical patterns
      // unescape anything in it, though, so that it'll be
      // an exact match against a file etc.
      if (!hasMagic) {
        return globUnescape(pattern)
      }

      var flags = options.nocase ? 'i' : '';
      try {
        var regExp = new RegExp('^' + re + '$', flags);
      } catch (er) {
        // If it was an invalid regular expression, then it can't match
        // anything.  This trick looks for a character after the end of
        // the string, which is of course impossible, except in multi-line
        // mode, but it's not a /m regex.
        return new RegExp('$.')
      }

      regExp._glob = pattern;
      regExp._src = re;

      return regExp
    }

    minimatch$3.makeRe = function (pattern, options) {
      return new Minimatch$1(pattern, options || {}).makeRe()
    };

    Minimatch$1.prototype.makeRe = makeRe;
    function makeRe () {
      if (this.regexp || this.regexp === false) return this.regexp

      // at this point, this.set is a 2d array of partial
      // pattern strings, or "**".
      //
      // It's better to use .match().  This function shouldn't
      // be used, really, but it's pretty convenient sometimes,
      // when you just want to work with a regex.
      var set = this.set;

      if (!set.length) {
        this.regexp = false;
        return this.regexp
      }
      var options = this.options;

      var twoStar = options.noglobstar ? star
        : options.dot ? twoStarDot
        : twoStarNoDot;
      var flags = options.nocase ? 'i' : '';

      var re = set.map(function (pattern) {
        return pattern.map(function (p) {
          return (p === GLOBSTAR) ? twoStar
          : (typeof p === 'string') ? regExpEscape(p)
          : p._src
        }).join('\\\/')
      }).join('|');

      // must match entire pattern
      // ending in a * or ** will make it less strict.
      re = '^(?:' + re + ')$';

      // can match anything, as long as it's not this.
      if (this.negate) re = '^(?!' + re + ').*$';

      try {
        this.regexp = new RegExp(re, flags);
      } catch (ex) {
        this.regexp = false;
      }
      return this.regexp
    }

    minimatch$3.match = function (list, pattern, options) {
      options = options || {};
      var mm = new Minimatch$1(pattern, options);
      list = list.filter(function (f) {
        return mm.match(f)
      });
      if (mm.options.nonull && !list.length) {
        list.push(pattern);
      }
      return list
    };

    Minimatch$1.prototype.match = match;
    function match (f, partial) {
      this.debug('match', f, this.pattern);
      // short-circuit in the case of busted things.
      // comments, etc.
      if (this.comment) return false
      if (this.empty) return f === ''

      if (f === '/' && partial) return true

      var options = this.options;

      // windows: need to use /, not \
      if (path$3.sep !== '/') {
        f = f.split(path$3.sep).join('/');
      }

      // treat the test path as a set of pathparts.
      f = f.split(slashSplit);
      this.debug(this.pattern, 'split', f);

      // just ONE of the pattern sets in this.set needs to match
      // in order for it to be valid.  If negating, then just one
      // match means that we have failed.
      // Either way, return on the first hit.

      var set = this.set;
      this.debug(this.pattern, 'set', set);

      // Find the basename of the path by looking for the last non-empty segment
      var filename;
      var i;
      for (i = f.length - 1; i >= 0; i--) {
        filename = f[i];
        if (filename) break
      }

      for (i = 0; i < set.length; i++) {
        var pattern = set[i];
        var file = f;
        if (options.matchBase && pattern.length === 1) {
          file = [filename];
        }
        var hit = this.matchOne(file, pattern, partial);
        if (hit) {
          if (options.flipNegate) return true
          return !this.negate
        }
      }

      // didn't get any hits.  this is success if it's a negative
      // pattern, failure otherwise.
      if (options.flipNegate) return false
      return this.negate
    }

    // set partial to true to test if, for example,
    // "/a/b" matches the start of "/*/b/*/d"
    // Partial means, if you run out of file before you run
    // out of pattern, then that's fine, as long as all
    // the parts match.
    Minimatch$1.prototype.matchOne = function (file, pattern, partial) {
      var options = this.options;

      this.debug('matchOne',
        { 'this': this, file: file, pattern: pattern });

      this.debug('matchOne', file.length, pattern.length);

      for (var fi = 0,
          pi = 0,
          fl = file.length,
          pl = pattern.length
          ; (fi < fl) && (pi < pl)
          ; fi++, pi++) {
        this.debug('matchOne loop');
        var p = pattern[pi];
        var f = file[fi];

        this.debug(pattern, p, f);

        // should be impossible.
        // some invalid regexp stuff in the set.
        if (p === false) return false

        if (p === GLOBSTAR) {
          this.debug('GLOBSTAR', [pattern, p, f]);

          // "**"
          // a/**/b/**/c would match the following:
          // a/b/x/y/z/c
          // a/x/y/z/b/c
          // a/b/x/b/x/c
          // a/b/c
          // To do this, take the rest of the pattern after
          // the **, and see if it would match the file remainder.
          // If so, return success.
          // If not, the ** "swallows" a segment, and try again.
          // This is recursively awful.
          //
          // a/**/b/**/c matching a/b/x/y/z/c
          // - a matches a
          // - doublestar
          //   - matchOne(b/x/y/z/c, b/**/c)
          //     - b matches b
          //     - doublestar
          //       - matchOne(x/y/z/c, c) -> no
          //       - matchOne(y/z/c, c) -> no
          //       - matchOne(z/c, c) -> no
          //       - matchOne(c, c) yes, hit
          var fr = fi;
          var pr = pi + 1;
          if (pr === pl) {
            this.debug('** at the end');
            // a ** at the end will just swallow the rest.
            // We have found a match.
            // however, it will not swallow /.x, unless
            // options.dot is set.
            // . and .. are *never* matched by **, for explosively
            // exponential reasons.
            for (; fi < fl; fi++) {
              if (file[fi] === '.' || file[fi] === '..' ||
                (!options.dot && file[fi].charAt(0) === '.')) return false
            }
            return true
          }

          // ok, let's see if we can swallow whatever we can.
          while (fr < fl) {
            var swallowee = file[fr];

            this.debug('\nglobstar while', file, fr, pattern, pr, swallowee);

            // XXX remove this slice.  Just pass the start index.
            if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
              this.debug('globstar found match!', fr, fl, swallowee);
              // found a match.
              return true
            } else {
              // can't swallow "." or ".." ever.
              // can only swallow ".foo" when explicitly asked.
              if (swallowee === '.' || swallowee === '..' ||
                (!options.dot && swallowee.charAt(0) === '.')) {
                this.debug('dot detected!', file, fr, pattern, pr);
                break
              }

              // ** swallows a segment, and continue.
              this.debug('globstar swallow a segment, and continue');
              fr++;
            }
          }

          // no match was found.
          // However, in partial mode, we can't say this is necessarily over.
          // If there's more *pattern* left, then
          if (partial) {
            // ran out of file
            this.debug('\n>>> no match, partial?', file, fr, pattern, pr);
            if (fr === fl) return true
          }
          return false
        }

        // something other than **
        // non-magic patterns just have to match exactly
        // patterns with magic have been turned into regexps.
        var hit;
        if (typeof p === 'string') {
          if (options.nocase) {
            hit = f.toLowerCase() === p.toLowerCase();
          } else {
            hit = f === p;
          }
          this.debug('string match', p, f, hit);
        } else {
          hit = f.match(p);
          this.debug('pattern match', p, f, hit);
        }

        if (!hit) return false
      }

      // Note: ending in / means that we'll get a final ""
      // at the end of the pattern.  This can only match a
      // corresponding "" at the end of the file.
      // If the file ends in /, then it can only match a
      // a pattern that ends in /, unless the pattern just
      // doesn't have any more for it. But, a/b/ should *not*
      // match "a/b/*", even though "" matches against the
      // [^/]*? pattern, except in partial mode, where it might
      // simply not be reached yet.
      // However, a/b/ should still satisfy a/*

      // now either we fell off the end of the pattern, or we're done.
      if (fi === fl && pi === pl) {
        // ran out of pattern and filename at the same time.
        // an exact hit!
        return true
      } else if (fi === fl) {
        // ran out of file, but still had pattern left.
        // this is ok if we're doing the match as part of
        // a glob fs traversal.
        return partial
      } else if (pi === pl) {
        // ran out of pattern, still have file left.
        // this is only acceptable if we're on the very last
        // empty segment of a file with a trailing slash.
        // a/* should match a/b/
        var emptyFileEnd = (fi === fl - 1) && (file[fi] === '');
        return emptyFileEnd
      }

      // should be unreachable.
      throw new Error('wtf?')
    };

    // replace stuff like \* with *
    function globUnescape (s) {
      return s.replace(/\\(.)/g, '$1')
    }

    function regExpEscape (s) {
      return s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&')
    }

    var pathIsAbsolute = {exports: {}};

    function posix(path) {
    	return path.charAt(0) === '/';
    }

    function win32(path) {
    	// https://github.com/nodejs/node/blob/b3fcc245fb25539909ef1d5eaa01dbf92e168633/lib/path.js#L56
    	var splitDeviceRe = /^([a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/]+[^\\\/]+)?([\\\/])?([\s\S]*?)$/;
    	var result = splitDeviceRe.exec(path);
    	var device = result[1] || '';
    	var isUnc = Boolean(device && device.charAt(1) !== ':');

    	// UNC paths are always absolute
    	return Boolean(result[2] || isUnc);
    }

    pathIsAbsolute.exports = process.platform === 'win32' ? win32 : posix;
    pathIsAbsolute.exports.posix = posix;
    pathIsAbsolute.exports.win32 = win32;

    var common$2 = {};

    common$2.setopts = setopts$2;
    common$2.ownProp = ownProp$2;
    common$2.makeAbs = makeAbs;
    common$2.finish = finish;
    common$2.mark = mark;
    common$2.isIgnored = isIgnored$2;
    common$2.childrenIgnored = childrenIgnored$2;

    function ownProp$2 (obj, field) {
      return Object.prototype.hasOwnProperty.call(obj, field)
    }

    var fs = require$$0__default$6["default"];
    var path$2 = require$$1__default$1["default"];
    var minimatch$2 = minimatch_1;
    var isAbsolute$2 = pathIsAbsolute.exports;
    var Minimatch = minimatch$2.Minimatch;

    function alphasort (a, b) {
      return a.localeCompare(b, 'en')
    }

    function setupIgnores (self, options) {
      self.ignore = options.ignore || [];

      if (!Array.isArray(self.ignore))
        self.ignore = [self.ignore];

      if (self.ignore.length) {
        self.ignore = self.ignore.map(ignoreMap);
      }
    }

    // ignore patterns are always in dot:true mode.
    function ignoreMap (pattern) {
      var gmatcher = null;
      if (pattern.slice(-3) === '/**') {
        var gpattern = pattern.replace(/(\/\*\*)+$/, '');
        gmatcher = new Minimatch(gpattern, { dot: true });
      }

      return {
        matcher: new Minimatch(pattern, { dot: true }),
        gmatcher: gmatcher
      }
    }

    function setopts$2 (self, pattern, options) {
      if (!options)
        options = {};

      // base-matching: just use globstar for that.
      if (options.matchBase && -1 === pattern.indexOf("/")) {
        if (options.noglobstar) {
          throw new Error("base matching requires globstar")
        }
        pattern = "**/" + pattern;
      }

      self.silent = !!options.silent;
      self.pattern = pattern;
      self.strict = options.strict !== false;
      self.realpath = !!options.realpath;
      self.realpathCache = options.realpathCache || Object.create(null);
      self.follow = !!options.follow;
      self.dot = !!options.dot;
      self.mark = !!options.mark;
      self.nodir = !!options.nodir;
      if (self.nodir)
        self.mark = true;
      self.sync = !!options.sync;
      self.nounique = !!options.nounique;
      self.nonull = !!options.nonull;
      self.nosort = !!options.nosort;
      self.nocase = !!options.nocase;
      self.stat = !!options.stat;
      self.noprocess = !!options.noprocess;
      self.absolute = !!options.absolute;
      self.fs = options.fs || fs;

      self.maxLength = options.maxLength || Infinity;
      self.cache = options.cache || Object.create(null);
      self.statCache = options.statCache || Object.create(null);
      self.symlinks = options.symlinks || Object.create(null);

      setupIgnores(self, options);

      self.changedCwd = false;
      var cwd = process.cwd();
      if (!ownProp$2(options, "cwd"))
        self.cwd = cwd;
      else {
        self.cwd = path$2.resolve(options.cwd);
        self.changedCwd = self.cwd !== cwd;
      }

      self.root = options.root || path$2.resolve(self.cwd, "/");
      self.root = path$2.resolve(self.root);
      if (process.platform === "win32")
        self.root = self.root.replace(/\\/g, "/");

      // TODO: is an absolute `cwd` supposed to be resolved against `root`?
      // e.g. { cwd: '/test', root: __dirname } === path.join(__dirname, '/test')
      self.cwdAbs = isAbsolute$2(self.cwd) ? self.cwd : makeAbs(self, self.cwd);
      if (process.platform === "win32")
        self.cwdAbs = self.cwdAbs.replace(/\\/g, "/");
      self.nomount = !!options.nomount;

      // disable comments and negation in Minimatch.
      // Note that they are not supported in Glob itself anyway.
      options.nonegate = true;
      options.nocomment = true;

      self.minimatch = new Minimatch(pattern, options);
      self.options = self.minimatch.options;
    }

    function finish (self) {
      var nou = self.nounique;
      var all = nou ? [] : Object.create(null);

      for (var i = 0, l = self.matches.length; i < l; i ++) {
        var matches = self.matches[i];
        if (!matches || Object.keys(matches).length === 0) {
          if (self.nonull) {
            // do like the shell, and spit out the literal glob
            var literal = self.minimatch.globSet[i];
            if (nou)
              all.push(literal);
            else
              all[literal] = true;
          }
        } else {
          // had matches
          var m = Object.keys(matches);
          if (nou)
            all.push.apply(all, m);
          else
            m.forEach(function (m) {
              all[m] = true;
            });
        }
      }

      if (!nou)
        all = Object.keys(all);

      if (!self.nosort)
        all = all.sort(alphasort);

      // at *some* point we statted all of these
      if (self.mark) {
        for (var i = 0; i < all.length; i++) {
          all[i] = self._mark(all[i]);
        }
        if (self.nodir) {
          all = all.filter(function (e) {
            var notDir = !(/\/$/.test(e));
            var c = self.cache[e] || self.cache[makeAbs(self, e)];
            if (notDir && c)
              notDir = c !== 'DIR' && !Array.isArray(c);
            return notDir
          });
        }
      }

      if (self.ignore.length)
        all = all.filter(function(m) {
          return !isIgnored$2(self, m)
        });

      self.found = all;
    }

    function mark (self, p) {
      var abs = makeAbs(self, p);
      var c = self.cache[abs];
      var m = p;
      if (c) {
        var isDir = c === 'DIR' || Array.isArray(c);
        var slash = p.slice(-1) === '/';

        if (isDir && !slash)
          m += '/';
        else if (!isDir && slash)
          m = m.slice(0, -1);

        if (m !== p) {
          var mabs = makeAbs(self, m);
          self.statCache[mabs] = self.statCache[abs];
          self.cache[mabs] = self.cache[abs];
        }
      }

      return m
    }

    // lotta situps...
    function makeAbs (self, f) {
      var abs = f;
      if (f.charAt(0) === '/') {
        abs = path$2.join(self.root, f);
      } else if (isAbsolute$2(f) || f === '') {
        abs = f;
      } else if (self.changedCwd) {
        abs = path$2.resolve(self.cwd, f);
      } else {
        abs = path$2.resolve(f);
      }

      if (process.platform === 'win32')
        abs = abs.replace(/\\/g, '/');

      return abs
    }


    // Return true, if pattern ends with globstar '**', for the accompanying parent directory.
    // Ex:- If node_modules/** is the pattern, add 'node_modules' to ignore list along with it's contents
    function isIgnored$2 (self, path) {
      if (!self.ignore.length)
        return false

      return self.ignore.some(function(item) {
        return item.matcher.match(path) || !!(item.gmatcher && item.gmatcher.match(path))
      })
    }

    function childrenIgnored$2 (self, path) {
      if (!self.ignore.length)
        return false

      return self.ignore.some(function(item) {
        return !!(item.gmatcher && item.gmatcher.match(path))
      })
    }

    var sync = globSync$1;
    globSync$1.GlobSync = GlobSync$1;

    var rp$1 = fs_realpath;
    var minimatch$1 = minimatch_1;
    glob_1.Glob;
    var path$1 = require$$1__default$1["default"];
    var assert$1 = require$$5__default["default"];
    var isAbsolute$1 = pathIsAbsolute.exports;
    var common$1 = common$2;
    var setopts$1 = common$1.setopts;
    var ownProp$1 = common$1.ownProp;
    var childrenIgnored$1 = common$1.childrenIgnored;
    var isIgnored$1 = common$1.isIgnored;

    function globSync$1 (pattern, options) {
      if (typeof options === 'function' || arguments.length === 3)
        throw new TypeError('callback provided to sync glob\n'+
                            'See: https://github.com/isaacs/node-glob/issues/167')

      return new GlobSync$1(pattern, options).found
    }

    function GlobSync$1 (pattern, options) {
      if (!pattern)
        throw new Error('must provide pattern')

      if (typeof options === 'function' || arguments.length === 3)
        throw new TypeError('callback provided to sync glob\n'+
                            'See: https://github.com/isaacs/node-glob/issues/167')

      if (!(this instanceof GlobSync$1))
        return new GlobSync$1(pattern, options)

      setopts$1(this, pattern, options);

      if (this.noprocess)
        return this

      var n = this.minimatch.set.length;
      this.matches = new Array(n);
      for (var i = 0; i < n; i ++) {
        this._process(this.minimatch.set[i], i, false);
      }
      this._finish();
    }

    GlobSync$1.prototype._finish = function () {
      assert$1(this instanceof GlobSync$1);
      if (this.realpath) {
        var self = this;
        this.matches.forEach(function (matchset, index) {
          var set = self.matches[index] = Object.create(null);
          for (var p in matchset) {
            try {
              p = self._makeAbs(p);
              var real = rp$1.realpathSync(p, self.realpathCache);
              set[real] = true;
            } catch (er) {
              if (er.syscall === 'stat')
                set[self._makeAbs(p)] = true;
              else
                throw er
            }
          }
        });
      }
      common$1.finish(this);
    };


    GlobSync$1.prototype._process = function (pattern, index, inGlobStar) {
      assert$1(this instanceof GlobSync$1);

      // Get the first [n] parts of pattern that are all strings.
      var n = 0;
      while (typeof pattern[n] === 'string') {
        n ++;
      }
      // now n is the index of the first one that is *not* a string.

      // See if there's anything else
      var prefix;
      switch (n) {
        // if not, then this is rather simple
        case pattern.length:
          this._processSimple(pattern.join('/'), index);
          return

        case 0:
          // pattern *starts* with some non-trivial item.
          // going to readdir(cwd), but not include the prefix in matches.
          prefix = null;
          break

        default:
          // pattern has some string bits in the front.
          // whatever it starts with, whether that's 'absolute' like /foo/bar,
          // or 'relative' like '../baz'
          prefix = pattern.slice(0, n).join('/');
          break
      }

      var remain = pattern.slice(n);

      // get the list of entries.
      var read;
      if (prefix === null)
        read = '.';
      else if (isAbsolute$1(prefix) || isAbsolute$1(pattern.join('/'))) {
        if (!prefix || !isAbsolute$1(prefix))
          prefix = '/' + prefix;
        read = prefix;
      } else
        read = prefix;

      var abs = this._makeAbs(read);

      //if ignored, skip processing
      if (childrenIgnored$1(this, read))
        return

      var isGlobStar = remain[0] === minimatch$1.GLOBSTAR;
      if (isGlobStar)
        this._processGlobStar(prefix, read, abs, remain, index, inGlobStar);
      else
        this._processReaddir(prefix, read, abs, remain, index, inGlobStar);
    };


    GlobSync$1.prototype._processReaddir = function (prefix, read, abs, remain, index, inGlobStar) {
      var entries = this._readdir(abs, inGlobStar);

      // if the abs isn't a dir, then nothing can match!
      if (!entries)
        return

      // It will only match dot entries if it starts with a dot, or if
      // dot is set.  Stuff like @(.foo|.bar) isn't allowed.
      var pn = remain[0];
      var negate = !!this.minimatch.negate;
      var rawGlob = pn._glob;
      var dotOk = this.dot || rawGlob.charAt(0) === '.';

      var matchedEntries = [];
      for (var i = 0; i < entries.length; i++) {
        var e = entries[i];
        if (e.charAt(0) !== '.' || dotOk) {
          var m;
          if (negate && !prefix) {
            m = !e.match(pn);
          } else {
            m = e.match(pn);
          }
          if (m)
            matchedEntries.push(e);
        }
      }

      var len = matchedEntries.length;
      // If there are no matched entries, then nothing matches.
      if (len === 0)
        return

      // if this is the last remaining pattern bit, then no need for
      // an additional stat *unless* the user has specified mark or
      // stat explicitly.  We know they exist, since readdir returned
      // them.

      if (remain.length === 1 && !this.mark && !this.stat) {
        if (!this.matches[index])
          this.matches[index] = Object.create(null);

        for (var i = 0; i < len; i ++) {
          var e = matchedEntries[i];
          if (prefix) {
            if (prefix.slice(-1) !== '/')
              e = prefix + '/' + e;
            else
              e = prefix + e;
          }

          if (e.charAt(0) === '/' && !this.nomount) {
            e = path$1.join(this.root, e);
          }
          this._emitMatch(index, e);
        }
        // This was the last one, and no stats were needed
        return
      }

      // now test all matched entries as stand-ins for that part
      // of the pattern.
      remain.shift();
      for (var i = 0; i < len; i ++) {
        var e = matchedEntries[i];
        var newPattern;
        if (prefix)
          newPattern = [prefix, e];
        else
          newPattern = [e];
        this._process(newPattern.concat(remain), index, inGlobStar);
      }
    };


    GlobSync$1.prototype._emitMatch = function (index, e) {
      if (isIgnored$1(this, e))
        return

      var abs = this._makeAbs(e);

      if (this.mark)
        e = this._mark(e);

      if (this.absolute) {
        e = abs;
      }

      if (this.matches[index][e])
        return

      if (this.nodir) {
        var c = this.cache[abs];
        if (c === 'DIR' || Array.isArray(c))
          return
      }

      this.matches[index][e] = true;

      if (this.stat)
        this._stat(e);
    };


    GlobSync$1.prototype._readdirInGlobStar = function (abs) {
      // follow all symlinked directories forever
      // just proceed as if this is a non-globstar situation
      if (this.follow)
        return this._readdir(abs, false)

      var entries;
      var lstat;
      try {
        lstat = this.fs.lstatSync(abs);
      } catch (er) {
        if (er.code === 'ENOENT') {
          // lstat failed, doesn't exist
          return null
        }
      }

      var isSym = lstat && lstat.isSymbolicLink();
      this.symlinks[abs] = isSym;

      // If it's not a symlink or a dir, then it's definitely a regular file.
      // don't bother doing a readdir in that case.
      if (!isSym && lstat && !lstat.isDirectory())
        this.cache[abs] = 'FILE';
      else
        entries = this._readdir(abs, false);

      return entries
    };

    GlobSync$1.prototype._readdir = function (abs, inGlobStar) {

      if (inGlobStar && !ownProp$1(this.symlinks, abs))
        return this._readdirInGlobStar(abs)

      if (ownProp$1(this.cache, abs)) {
        var c = this.cache[abs];
        if (!c || c === 'FILE')
          return null

        if (Array.isArray(c))
          return c
      }

      try {
        return this._readdirEntries(abs, this.fs.readdirSync(abs))
      } catch (er) {
        this._readdirError(abs, er);
        return null
      }
    };

    GlobSync$1.prototype._readdirEntries = function (abs, entries) {
      // if we haven't asked to stat everything, then just
      // assume that everything in there exists, so we can avoid
      // having to stat it a second time.
      if (!this.mark && !this.stat) {
        for (var i = 0; i < entries.length; i ++) {
          var e = entries[i];
          if (abs === '/')
            e = abs + e;
          else
            e = abs + '/' + e;
          this.cache[e] = true;
        }
      }

      this.cache[abs] = entries;

      // mark and cache dir-ness
      return entries
    };

    GlobSync$1.prototype._readdirError = function (f, er) {
      // handle errors, and cache the information
      switch (er.code) {
        case 'ENOTSUP': // https://github.com/isaacs/node-glob/issues/205
        case 'ENOTDIR': // totally normal. means it *does* exist.
          var abs = this._makeAbs(f);
          this.cache[abs] = 'FILE';
          if (abs === this.cwdAbs) {
            var error = new Error(er.code + ' invalid cwd ' + this.cwd);
            error.path = this.cwd;
            error.code = er.code;
            throw error
          }
          break

        case 'ENOENT': // not terribly unusual
        case 'ELOOP':
        case 'ENAMETOOLONG':
        case 'UNKNOWN':
          this.cache[this._makeAbs(f)] = false;
          break

        default: // some unusual error.  Treat as failure.
          this.cache[this._makeAbs(f)] = false;
          if (this.strict)
            throw er
          if (!this.silent)
            console.error('glob error', er);
          break
      }
    };

    GlobSync$1.prototype._processGlobStar = function (prefix, read, abs, remain, index, inGlobStar) {

      var entries = this._readdir(abs, inGlobStar);

      // no entries means not a dir, so it can never have matches
      // foo.txt/** doesn't match foo.txt
      if (!entries)
        return

      // test without the globstar, and with every child both below
      // and replacing the globstar.
      var remainWithoutGlobStar = remain.slice(1);
      var gspref = prefix ? [ prefix ] : [];
      var noGlobStar = gspref.concat(remainWithoutGlobStar);

      // the noGlobStar pattern exits the inGlobStar state
      this._process(noGlobStar, index, false);

      var len = entries.length;
      var isSym = this.symlinks[abs];

      // If it's a symlink, and we're in a globstar, then stop
      if (isSym && inGlobStar)
        return

      for (var i = 0; i < len; i++) {
        var e = entries[i];
        if (e.charAt(0) === '.' && !this.dot)
          continue

        // these two cases enter the inGlobStar state
        var instead = gspref.concat(entries[i], remainWithoutGlobStar);
        this._process(instead, index, true);

        var below = gspref.concat(entries[i], remain);
        this._process(below, index, true);
      }
    };

    GlobSync$1.prototype._processSimple = function (prefix, index) {
      // XXX review this.  Shouldn't it be doing the mounting etc
      // before doing stat?  kinda weird?
      var exists = this._stat(prefix);

      if (!this.matches[index])
        this.matches[index] = Object.create(null);

      // If it doesn't exist, then just mark the lack of results
      if (!exists)
        return

      if (prefix && isAbsolute$1(prefix) && !this.nomount) {
        var trail = /[\/\\]$/.test(prefix);
        if (prefix.charAt(0) === '/') {
          prefix = path$1.join(this.root, prefix);
        } else {
          prefix = path$1.resolve(this.root, prefix);
          if (trail)
            prefix += '/';
        }
      }

      if (process.platform === 'win32')
        prefix = prefix.replace(/\\/g, '/');

      // Mark this as a match
      this._emitMatch(index, prefix);
    };

    // Returns either 'DIR', 'FILE', or false
    GlobSync$1.prototype._stat = function (f) {
      var abs = this._makeAbs(f);
      var needDir = f.slice(-1) === '/';

      if (f.length > this.maxLength)
        return false

      if (!this.stat && ownProp$1(this.cache, abs)) {
        var c = this.cache[abs];

        if (Array.isArray(c))
          c = 'DIR';

        // It exists, but maybe not how we need it
        if (!needDir || c === 'DIR')
          return c

        if (needDir && c === 'FILE')
          return false

        // otherwise we have to stat, because maybe c=true
        // if we know it exists, but not what it is.
      }
      var stat = this.statCache[abs];
      if (!stat) {
        var lstat;
        try {
          lstat = this.fs.lstatSync(abs);
        } catch (er) {
          if (er && (er.code === 'ENOENT' || er.code === 'ENOTDIR')) {
            this.statCache[abs] = false;
            return false
          }
        }

        if (lstat && lstat.isSymbolicLink()) {
          try {
            stat = this.fs.statSync(abs);
          } catch (er) {
            stat = lstat;
          }
        } else {
          stat = lstat;
        }
      }

      this.statCache[abs] = stat;

      var c = true;
      if (stat)
        c = stat.isDirectory() ? 'DIR' : 'FILE';

      this.cache[abs] = this.cache[abs] || c;

      if (needDir && c === 'FILE')
        return false

      return c
    };

    GlobSync$1.prototype._mark = function (p) {
      return common$1.mark(this, p)
    };

    GlobSync$1.prototype._makeAbs = function (f) {
      return common$1.makeAbs(this, f)
    };

    // Returns a wrapper function that returns a wrapped callback
    // The wrapper function should do some stuff, and return a
    // presumably different callback function.
    // This makes sure that own properties are retained, so that
    // decorations and such are not lost along the way.
    var wrappy_1 = wrappy$2;
    function wrappy$2 (fn, cb) {
      if (fn && cb) return wrappy$2(fn)(cb)

      if (typeof fn !== 'function')
        throw new TypeError('need wrapper function')

      Object.keys(fn).forEach(function (k) {
        wrapper[k] = fn[k];
      });

      return wrapper

      function wrapper() {
        var args = new Array(arguments.length);
        for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i];
        }
        var ret = fn.apply(this, args);
        var cb = args[args.length-1];
        if (typeof ret === 'function' && ret !== cb) {
          Object.keys(cb).forEach(function (k) {
            ret[k] = cb[k];
          });
        }
        return ret
      }
    }

    var once$3 = {exports: {}};

    var wrappy$1 = wrappy_1;
    once$3.exports = wrappy$1(once$2);
    once$3.exports.strict = wrappy$1(onceStrict);

    once$2.proto = once$2(function () {
      Object.defineProperty(Function.prototype, 'once', {
        value: function () {
          return once$2(this)
        },
        configurable: true
      });

      Object.defineProperty(Function.prototype, 'onceStrict', {
        value: function () {
          return onceStrict(this)
        },
        configurable: true
      });
    });

    function once$2 (fn) {
      var f = function () {
        if (f.called) return f.value
        f.called = true;
        return f.value = fn.apply(this, arguments)
      };
      f.called = false;
      return f
    }

    function onceStrict (fn) {
      var f = function () {
        if (f.called)
          throw new Error(f.onceError)
        f.called = true;
        return f.value = fn.apply(this, arguments)
      };
      var name = fn.name || 'Function wrapped with `once`';
      f.onceError = name + " shouldn't be called more than once";
      f.called = false;
      return f
    }

    var wrappy = wrappy_1;
    var reqs = Object.create(null);
    var once$1 = once$3.exports;

    var inflight_1 = wrappy(inflight$1);

    function inflight$1 (key, cb) {
      if (reqs[key]) {
        reqs[key].push(cb);
        return null
      } else {
        reqs[key] = [cb];
        return makeres(key)
      }
    }

    function makeres (key) {
      return once$1(function RES () {
        var cbs = reqs[key];
        var len = cbs.length;
        var args = slice(arguments);

        // XXX It's somewhat ambiguous whether a new callback added in this
        // pass should be queued for later execution if something in the
        // list of callbacks throws, or if it should just be discarded.
        // However, it's such an edge case that it hardly matters, and either
        // choice is likely as surprising as the other.
        // As it happens, we do go ahead and schedule it for later execution.
        try {
          for (var i = 0; i < len; i++) {
            cbs[i].apply(null, args);
          }
        } finally {
          if (cbs.length > len) {
            // added more in the interim.
            // de-zalgo, just in case, but don't call again.
            cbs.splice(0, len);
            process.nextTick(function () {
              RES.apply(null, args);
            });
          } else {
            delete reqs[key];
          }
        }
      })
    }

    function slice (args) {
      var length = args.length;
      var array = [];

      for (var i = 0; i < length; i++) array[i] = args[i];
      return array
    }

    // Approach:
    //
    // 1. Get the minimatch set
    // 2. For each pattern in the set, PROCESS(pattern, false)
    // 3. Store matches per-set, then uniq them
    //
    // PROCESS(pattern, inGlobStar)
    // Get the first [n] items from pattern that are all strings
    // Join these together.  This is PREFIX.
    //   If there is no more remaining, then stat(PREFIX) and
    //   add to matches if it succeeds.  END.
    //
    // If inGlobStar and PREFIX is symlink and points to dir
    //   set ENTRIES = []
    // else readdir(PREFIX) as ENTRIES
    //   If fail, END
    //
    // with ENTRIES
    //   If pattern[n] is GLOBSTAR
    //     // handle the case where the globstar match is empty
    //     // by pruning it out, and testing the resulting pattern
    //     PROCESS(pattern[0..n] + pattern[n+1 .. $], false)
    //     // handle other cases.
    //     for ENTRY in ENTRIES (not dotfiles)
    //       // attach globstar + tail onto the entry
    //       // Mark that this entry is a globstar match
    //       PROCESS(pattern[0..n] + ENTRY + pattern[n .. $], true)
    //
    //   else // not globstar
    //     for ENTRY in ENTRIES (not dotfiles, unless pattern[n] is dot)
    //       Test ENTRY against pattern[n]
    //       If fails, continue
    //       If passes, PROCESS(pattern[0..n] + item + pattern[n+1 .. $])
    //
    // Caveat:
    //   Cache all stats and readdirs results to minimize syscall.  Since all
    //   we ever care about is existence and directory-ness, we can just keep
    //   `true` for files, and [children,...] for directories, or `false` for
    //   things that don't exist.

    var glob_1 = glob;

    var rp = fs_realpath;
    var minimatch = minimatch_1;
    var inherits = inherits$2.exports;
    var EE = require$$0__default["default"].EventEmitter;
    var path = require$$1__default$1["default"];
    var assert = require$$5__default["default"];
    var isAbsolute = pathIsAbsolute.exports;
    var globSync = sync;
    var common = common$2;
    var setopts = common.setopts;
    var ownProp = common.ownProp;
    var inflight = inflight_1;
    var childrenIgnored = common.childrenIgnored;
    var isIgnored = common.isIgnored;

    var once = once$3.exports;

    function glob (pattern, options, cb) {
      if (typeof options === 'function') cb = options, options = {};
      if (!options) options = {};

      if (options.sync) {
        if (cb)
          throw new TypeError('callback provided to sync glob')
        return globSync(pattern, options)
      }

      return new Glob(pattern, options, cb)
    }

    glob.sync = globSync;
    var GlobSync = glob.GlobSync = globSync.GlobSync;

    // old api surface
    glob.glob = glob;

    function extend (origin, add) {
      if (add === null || typeof add !== 'object') {
        return origin
      }

      var keys = Object.keys(add);
      var i = keys.length;
      while (i--) {
        origin[keys[i]] = add[keys[i]];
      }
      return origin
    }

    glob.hasMagic = function (pattern, options_) {
      var options = extend({}, options_);
      options.noprocess = true;

      var g = new Glob(pattern, options);
      var set = g.minimatch.set;

      if (!pattern)
        return false

      if (set.length > 1)
        return true

      for (var j = 0; j < set[0].length; j++) {
        if (typeof set[0][j] !== 'string')
          return true
      }

      return false
    };

    glob.Glob = Glob;
    inherits(Glob, EE);
    function Glob (pattern, options, cb) {
      if (typeof options === 'function') {
        cb = options;
        options = null;
      }

      if (options && options.sync) {
        if (cb)
          throw new TypeError('callback provided to sync glob')
        return new GlobSync(pattern, options)
      }

      if (!(this instanceof Glob))
        return new Glob(pattern, options, cb)

      setopts(this, pattern, options);
      this._didRealPath = false;

      // process each pattern in the minimatch set
      var n = this.minimatch.set.length;

      // The matches are stored as {<filename>: true,...} so that
      // duplicates are automagically pruned.
      // Later, we do an Object.keys() on these.
      // Keep them as a list so we can fill in when nonull is set.
      this.matches = new Array(n);

      if (typeof cb === 'function') {
        cb = once(cb);
        this.on('error', cb);
        this.on('end', function (matches) {
          cb(null, matches);
        });
      }

      var self = this;
      this._processing = 0;

      this._emitQueue = [];
      this._processQueue = [];
      this.paused = false;

      if (this.noprocess)
        return this

      if (n === 0)
        return done()

      var sync = true;
      for (var i = 0; i < n; i ++) {
        this._process(this.minimatch.set[i], i, false, done);
      }
      sync = false;

      function done () {
        --self._processing;
        if (self._processing <= 0) {
          if (sync) {
            process.nextTick(function () {
              self._finish();
            });
          } else {
            self._finish();
          }
        }
      }
    }

    Glob.prototype._finish = function () {
      assert(this instanceof Glob);
      if (this.aborted)
        return

      if (this.realpath && !this._didRealpath)
        return this._realpath()

      common.finish(this);
      this.emit('end', this.found);
    };

    Glob.prototype._realpath = function () {
      if (this._didRealpath)
        return

      this._didRealpath = true;

      var n = this.matches.length;
      if (n === 0)
        return this._finish()

      var self = this;
      for (var i = 0; i < this.matches.length; i++)
        this._realpathSet(i, next);

      function next () {
        if (--n === 0)
          self._finish();
      }
    };

    Glob.prototype._realpathSet = function (index, cb) {
      var matchset = this.matches[index];
      if (!matchset)
        return cb()

      var found = Object.keys(matchset);
      var self = this;
      var n = found.length;

      if (n === 0)
        return cb()

      var set = this.matches[index] = Object.create(null);
      found.forEach(function (p, i) {
        // If there's a problem with the stat, then it means that
        // one or more of the links in the realpath couldn't be
        // resolved.  just return the abs value in that case.
        p = self._makeAbs(p);
        rp.realpath(p, self.realpathCache, function (er, real) {
          if (!er)
            set[real] = true;
          else if (er.syscall === 'stat')
            set[p] = true;
          else
            self.emit('error', er); // srsly wtf right here

          if (--n === 0) {
            self.matches[index] = set;
            cb();
          }
        });
      });
    };

    Glob.prototype._mark = function (p) {
      return common.mark(this, p)
    };

    Glob.prototype._makeAbs = function (f) {
      return common.makeAbs(this, f)
    };

    Glob.prototype.abort = function () {
      this.aborted = true;
      this.emit('abort');
    };

    Glob.prototype.pause = function () {
      if (!this.paused) {
        this.paused = true;
        this.emit('pause');
      }
    };

    Glob.prototype.resume = function () {
      if (this.paused) {
        this.emit('resume');
        this.paused = false;
        if (this._emitQueue.length) {
          var eq = this._emitQueue.slice(0);
          this._emitQueue.length = 0;
          for (var i = 0; i < eq.length; i ++) {
            var e = eq[i];
            this._emitMatch(e[0], e[1]);
          }
        }
        if (this._processQueue.length) {
          var pq = this._processQueue.slice(0);
          this._processQueue.length = 0;
          for (var i = 0; i < pq.length; i ++) {
            var p = pq[i];
            this._processing--;
            this._process(p[0], p[1], p[2], p[3]);
          }
        }
      }
    };

    Glob.prototype._process = function (pattern, index, inGlobStar, cb) {
      assert(this instanceof Glob);
      assert(typeof cb === 'function');

      if (this.aborted)
        return

      this._processing++;
      if (this.paused) {
        this._processQueue.push([pattern, index, inGlobStar, cb]);
        return
      }

      //console.error('PROCESS %d', this._processing, pattern)

      // Get the first [n] parts of pattern that are all strings.
      var n = 0;
      while (typeof pattern[n] === 'string') {
        n ++;
      }
      // now n is the index of the first one that is *not* a string.

      // see if there's anything else
      var prefix;
      switch (n) {
        // if not, then this is rather simple
        case pattern.length:
          this._processSimple(pattern.join('/'), index, cb);
          return

        case 0:
          // pattern *starts* with some non-trivial item.
          // going to readdir(cwd), but not include the prefix in matches.
          prefix = null;
          break

        default:
          // pattern has some string bits in the front.
          // whatever it starts with, whether that's 'absolute' like /foo/bar,
          // or 'relative' like '../baz'
          prefix = pattern.slice(0, n).join('/');
          break
      }

      var remain = pattern.slice(n);

      // get the list of entries.
      var read;
      if (prefix === null)
        read = '.';
      else if (isAbsolute(prefix) || isAbsolute(pattern.join('/'))) {
        if (!prefix || !isAbsolute(prefix))
          prefix = '/' + prefix;
        read = prefix;
      } else
        read = prefix;

      var abs = this._makeAbs(read);

      //if ignored, skip _processing
      if (childrenIgnored(this, read))
        return cb()

      var isGlobStar = remain[0] === minimatch.GLOBSTAR;
      if (isGlobStar)
        this._processGlobStar(prefix, read, abs, remain, index, inGlobStar, cb);
      else
        this._processReaddir(prefix, read, abs, remain, index, inGlobStar, cb);
    };

    Glob.prototype._processReaddir = function (prefix, read, abs, remain, index, inGlobStar, cb) {
      var self = this;
      this._readdir(abs, inGlobStar, function (er, entries) {
        return self._processReaddir2(prefix, read, abs, remain, index, inGlobStar, entries, cb)
      });
    };

    Glob.prototype._processReaddir2 = function (prefix, read, abs, remain, index, inGlobStar, entries, cb) {

      // if the abs isn't a dir, then nothing can match!
      if (!entries)
        return cb()

      // It will only match dot entries if it starts with a dot, or if
      // dot is set.  Stuff like @(.foo|.bar) isn't allowed.
      var pn = remain[0];
      var negate = !!this.minimatch.negate;
      var rawGlob = pn._glob;
      var dotOk = this.dot || rawGlob.charAt(0) === '.';

      var matchedEntries = [];
      for (var i = 0; i < entries.length; i++) {
        var e = entries[i];
        if (e.charAt(0) !== '.' || dotOk) {
          var m;
          if (negate && !prefix) {
            m = !e.match(pn);
          } else {
            m = e.match(pn);
          }
          if (m)
            matchedEntries.push(e);
        }
      }

      //console.error('prd2', prefix, entries, remain[0]._glob, matchedEntries)

      var len = matchedEntries.length;
      // If there are no matched entries, then nothing matches.
      if (len === 0)
        return cb()

      // if this is the last remaining pattern bit, then no need for
      // an additional stat *unless* the user has specified mark or
      // stat explicitly.  We know they exist, since readdir returned
      // them.

      if (remain.length === 1 && !this.mark && !this.stat) {
        if (!this.matches[index])
          this.matches[index] = Object.create(null);

        for (var i = 0; i < len; i ++) {
          var e = matchedEntries[i];
          if (prefix) {
            if (prefix !== '/')
              e = prefix + '/' + e;
            else
              e = prefix + e;
          }

          if (e.charAt(0) === '/' && !this.nomount) {
            e = path.join(this.root, e);
          }
          this._emitMatch(index, e);
        }
        // This was the last one, and no stats were needed
        return cb()
      }

      // now test all matched entries as stand-ins for that part
      // of the pattern.
      remain.shift();
      for (var i = 0; i < len; i ++) {
        var e = matchedEntries[i];
        if (prefix) {
          if (prefix !== '/')
            e = prefix + '/' + e;
          else
            e = prefix + e;
        }
        this._process([e].concat(remain), index, inGlobStar, cb);
      }
      cb();
    };

    Glob.prototype._emitMatch = function (index, e) {
      if (this.aborted)
        return

      if (isIgnored(this, e))
        return

      if (this.paused) {
        this._emitQueue.push([index, e]);
        return
      }

      var abs = isAbsolute(e) ? e : this._makeAbs(e);

      if (this.mark)
        e = this._mark(e);

      if (this.absolute)
        e = abs;

      if (this.matches[index][e])
        return

      if (this.nodir) {
        var c = this.cache[abs];
        if (c === 'DIR' || Array.isArray(c))
          return
      }

      this.matches[index][e] = true;

      var st = this.statCache[abs];
      if (st)
        this.emit('stat', e, st);

      this.emit('match', e);
    };

    Glob.prototype._readdirInGlobStar = function (abs, cb) {
      if (this.aborted)
        return

      // follow all symlinked directories forever
      // just proceed as if this is a non-globstar situation
      if (this.follow)
        return this._readdir(abs, false, cb)

      var lstatkey = 'lstat\0' + abs;
      var self = this;
      var lstatcb = inflight(lstatkey, lstatcb_);

      if (lstatcb)
        self.fs.lstat(abs, lstatcb);

      function lstatcb_ (er, lstat) {
        if (er && er.code === 'ENOENT')
          return cb()

        var isSym = lstat && lstat.isSymbolicLink();
        self.symlinks[abs] = isSym;

        // If it's not a symlink or a dir, then it's definitely a regular file.
        // don't bother doing a readdir in that case.
        if (!isSym && lstat && !lstat.isDirectory()) {
          self.cache[abs] = 'FILE';
          cb();
        } else
          self._readdir(abs, false, cb);
      }
    };

    Glob.prototype._readdir = function (abs, inGlobStar, cb) {
      if (this.aborted)
        return

      cb = inflight('readdir\0'+abs+'\0'+inGlobStar, cb);
      if (!cb)
        return

      //console.error('RD %j %j', +inGlobStar, abs)
      if (inGlobStar && !ownProp(this.symlinks, abs))
        return this._readdirInGlobStar(abs, cb)

      if (ownProp(this.cache, abs)) {
        var c = this.cache[abs];
        if (!c || c === 'FILE')
          return cb()

        if (Array.isArray(c))
          return cb(null, c)
      }

      var self = this;
      self.fs.readdir(abs, readdirCb(this, abs, cb));
    };

    function readdirCb (self, abs, cb) {
      return function (er, entries) {
        if (er)
          self._readdirError(abs, er, cb);
        else
          self._readdirEntries(abs, entries, cb);
      }
    }

    Glob.prototype._readdirEntries = function (abs, entries, cb) {
      if (this.aborted)
        return

      // if we haven't asked to stat everything, then just
      // assume that everything in there exists, so we can avoid
      // having to stat it a second time.
      if (!this.mark && !this.stat) {
        for (var i = 0; i < entries.length; i ++) {
          var e = entries[i];
          if (abs === '/')
            e = abs + e;
          else
            e = abs + '/' + e;
          this.cache[e] = true;
        }
      }

      this.cache[abs] = entries;
      return cb(null, entries)
    };

    Glob.prototype._readdirError = function (f, er, cb) {
      if (this.aborted)
        return

      // handle errors, and cache the information
      switch (er.code) {
        case 'ENOTSUP': // https://github.com/isaacs/node-glob/issues/205
        case 'ENOTDIR': // totally normal. means it *does* exist.
          var abs = this._makeAbs(f);
          this.cache[abs] = 'FILE';
          if (abs === this.cwdAbs) {
            var error = new Error(er.code + ' invalid cwd ' + this.cwd);
            error.path = this.cwd;
            error.code = er.code;
            this.emit('error', error);
            this.abort();
          }
          break

        case 'ENOENT': // not terribly unusual
        case 'ELOOP':
        case 'ENAMETOOLONG':
        case 'UNKNOWN':
          this.cache[this._makeAbs(f)] = false;
          break

        default: // some unusual error.  Treat as failure.
          this.cache[this._makeAbs(f)] = false;
          if (this.strict) {
            this.emit('error', er);
            // If the error is handled, then we abort
            // if not, we threw out of here
            this.abort();
          }
          if (!this.silent)
            console.error('glob error', er);
          break
      }

      return cb()
    };

    Glob.prototype._processGlobStar = function (prefix, read, abs, remain, index, inGlobStar, cb) {
      var self = this;
      this._readdir(abs, inGlobStar, function (er, entries) {
        self._processGlobStar2(prefix, read, abs, remain, index, inGlobStar, entries, cb);
      });
    };


    Glob.prototype._processGlobStar2 = function (prefix, read, abs, remain, index, inGlobStar, entries, cb) {
      //console.error('pgs2', prefix, remain[0], entries)

      // no entries means not a dir, so it can never have matches
      // foo.txt/** doesn't match foo.txt
      if (!entries)
        return cb()

      // test without the globstar, and with every child both below
      // and replacing the globstar.
      var remainWithoutGlobStar = remain.slice(1);
      var gspref = prefix ? [ prefix ] : [];
      var noGlobStar = gspref.concat(remainWithoutGlobStar);

      // the noGlobStar pattern exits the inGlobStar state
      this._process(noGlobStar, index, false, cb);

      var isSym = this.symlinks[abs];
      var len = entries.length;

      // If it's a symlink, and we're in a globstar, then stop
      if (isSym && inGlobStar)
        return cb()

      for (var i = 0; i < len; i++) {
        var e = entries[i];
        if (e.charAt(0) === '.' && !this.dot)
          continue

        // these two cases enter the inGlobStar state
        var instead = gspref.concat(entries[i], remainWithoutGlobStar);
        this._process(instead, index, true, cb);

        var below = gspref.concat(entries[i], remain);
        this._process(below, index, true, cb);
      }

      cb();
    };

    Glob.prototype._processSimple = function (prefix, index, cb) {
      // XXX review this.  Shouldn't it be doing the mounting etc
      // before doing stat?  kinda weird?
      var self = this;
      this._stat(prefix, function (er, exists) {
        self._processSimple2(prefix, index, er, exists, cb);
      });
    };
    Glob.prototype._processSimple2 = function (prefix, index, er, exists, cb) {

      //console.error('ps2', prefix, exists)

      if (!this.matches[index])
        this.matches[index] = Object.create(null);

      // If it doesn't exist, then just mark the lack of results
      if (!exists)
        return cb()

      if (prefix && isAbsolute(prefix) && !this.nomount) {
        var trail = /[\/\\]$/.test(prefix);
        if (prefix.charAt(0) === '/') {
          prefix = path.join(this.root, prefix);
        } else {
          prefix = path.resolve(this.root, prefix);
          if (trail)
            prefix += '/';
        }
      }

      if (process.platform === 'win32')
        prefix = prefix.replace(/\\/g, '/');

      // Mark this as a match
      this._emitMatch(index, prefix);
      cb();
    };

    // Returns either 'DIR', 'FILE', or false
    Glob.prototype._stat = function (f, cb) {
      var abs = this._makeAbs(f);
      var needDir = f.slice(-1) === '/';

      if (f.length > this.maxLength)
        return cb()

      if (!this.stat && ownProp(this.cache, abs)) {
        var c = this.cache[abs];

        if (Array.isArray(c))
          c = 'DIR';

        // It exists, but maybe not how we need it
        if (!needDir || c === 'DIR')
          return cb(null, c)

        if (needDir && c === 'FILE')
          return cb()

        // otherwise we have to stat, because maybe c=true
        // if we know it exists, but not what it is.
      }
      var stat = this.statCache[abs];
      if (stat !== undefined) {
        if (stat === false)
          return cb(null, stat)
        else {
          var type = stat.isDirectory() ? 'DIR' : 'FILE';
          if (needDir && type === 'FILE')
            return cb()
          else
            return cb(null, type, stat)
        }
      }

      var self = this;
      var statcb = inflight('stat\0' + abs, lstatcb_);
      if (statcb)
        self.fs.lstat(abs, statcb);

      function lstatcb_ (er, lstat) {
        if (lstat && lstat.isSymbolicLink()) {
          // If it's a symlink, then treat it as the target, unless
          // the target does not exist, then treat it as a file.
          return self.fs.stat(abs, function (er, stat) {
            if (er)
              self._stat2(f, abs, null, lstat, cb);
            else
              self._stat2(f, abs, er, stat, cb);
          })
        } else {
          self._stat2(f, abs, er, lstat, cb);
        }
      }
    };

    Glob.prototype._stat2 = function (f, abs, er, stat, cb) {
      if (er && (er.code === 'ENOENT' || er.code === 'ENOTDIR')) {
        this.statCache[abs] = false;
        return cb()
      }

      var needDir = f.slice(-1) === '/';
      this.statCache[abs] = stat;

      if (abs.slice(-1) === '/' && stat && !stat.isDirectory())
        return cb(null, false, stat)

      var c = true;
      if (stat)
        c = stat.isDirectory() ? 'DIR' : 'FILE';
      this.cache[abs] = this.cache[abs] || c;

      if (needDir && c === 'FILE')
        return cb()

      return cb(null, c, stat)
    };

    var ejs = {};

    var utils = {};

    /*
     * EJS Embedded JavaScript templates
     * Copyright 2112 Matthew Eernisse (mde@fleegix.org)
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *         http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     *
    */

    (function (exports) {

    var regExpChars = /[|\\{}()[\]^$+*?.]/g;

    /**
     * Escape characters reserved in regular expressions.
     *
     * If `string` is `undefined` or `null`, the empty string is returned.
     *
     * @param {String} string Input string
     * @return {String} Escaped string
     * @static
     * @private
     */
    exports.escapeRegExpChars = function (string) {
      // istanbul ignore if
      if (!string) {
        return '';
      }
      return String(string).replace(regExpChars, '\\$&');
    };

    var _ENCODE_HTML_RULES = {
      '&': '&amp;',
      '<': '&lt;',
      '>': '&gt;',
      '"': '&#34;',
      "'": '&#39;'
    };
    var _MATCH_HTML = /[&<>'"]/g;

    function encode_char(c) {
      return _ENCODE_HTML_RULES[c] || c;
    }

    /**
     * Stringified version of constants used by {@link module:utils.escapeXML}.
     *
     * It is used in the process of generating {@link ClientFunction}s.
     *
     * @readonly
     * @type {String}
     */

    var escapeFuncStr =
      'var _ENCODE_HTML_RULES = {\n'
    + '      "&": "&amp;"\n'
    + '    , "<": "&lt;"\n'
    + '    , ">": "&gt;"\n'
    + '    , \'"\': "&#34;"\n'
    + '    , "\'": "&#39;"\n'
    + '    }\n'
    + '  , _MATCH_HTML = /[&<>\'"]/g;\n'
    + 'function encode_char(c) {\n'
    + '  return _ENCODE_HTML_RULES[c] || c;\n'
    + '};\n';

    /**
     * Escape characters reserved in XML.
     *
     * If `markup` is `undefined` or `null`, the empty string is returned.
     *
     * @implements {EscapeCallback}
     * @param {String} markup Input string
     * @return {String} Escaped string
     * @static
     * @private
     */

    exports.escapeXML = function (markup) {
      return markup == undefined
        ? ''
        : String(markup)
          .replace(_MATCH_HTML, encode_char);
    };
    exports.escapeXML.toString = function () {
      return Function.prototype.toString.call(this) + ';\n' + escapeFuncStr;
    };

    /**
     * Naive copy of properties from one object to another.
     * Does not recurse into non-scalar properties
     * Does not check to see if the property has a value before copying
     *
     * @param  {Object} to   Destination object
     * @param  {Object} from Source object
     * @return {Object}      Destination object
     * @static
     * @private
     */
    exports.shallowCopy = function (to, from) {
      from = from || {};
      for (var p in from) {
        to[p] = from[p];
      }
      return to;
    };

    /**
     * Naive copy of a list of key names, from one object to another.
     * Only copies property if it is actually defined
     * Does not recurse into non-scalar properties
     *
     * @param  {Object} to   Destination object
     * @param  {Object} from Source object
     * @param  {Array} list List of properties to copy
     * @return {Object}      Destination object
     * @static
     * @private
     */
    exports.shallowCopyFromList = function (to, from, list) {
      for (var i = 0; i < list.length; i++) {
        var p = list[i];
        if (typeof from[p] != 'undefined') {
          to[p] = from[p];
        }
      }
      return to;
    };

    /**
     * Simple in-process cache implementation. Does not implement limits of any
     * sort.
     *
     * @implements {Cache}
     * @static
     * @private
     */
    exports.cache = {
      _data: {},
      set: function (key, val) {
        this._data[key] = val;
      },
      get: function (key) {
        return this._data[key];
      },
      remove: function (key) {
        delete this._data[key];
      },
      reset: function () {
        this._data = {};
      }
    };

    /**
     * Transforms hyphen case variable into camel case.
     *
     * @param {String} string Hyphen case string
     * @return {String} Camel case string
     * @static
     * @private
     */
    exports.hyphenToCamel = function (str) {
      return str.replace(/-[a-z]/g, function (match) { return match[1].toUpperCase(); });
    };
    }(utils));

    var name = "ejs";
    var description = "Embedded JavaScript templates";
    var keywords = [
    	"template",
    	"engine",
    	"ejs"
    ];
    var version = "3.1.6";
    var author = "Matthew Eernisse <mde@fleegix.org> (http://fleegix.org)";
    var license = "Apache-2.0";
    var bin = {
    	ejs: "./bin/cli.js"
    };
    var main = "./lib/ejs.js";
    var jsdelivr = "ejs.min.js";
    var unpkg = "ejs.min.js";
    var repository = {
    	type: "git",
    	url: "git://github.com/mde/ejs.git"
    };
    var bugs = "https://github.com/mde/ejs/issues";
    var homepage = "https://github.com/mde/ejs";
    var dependencies = {
    	jake: "^10.6.1"
    };
    var devDependencies = {
    	browserify: "^16.5.1",
    	eslint: "^6.8.0",
    	"git-directory-deploy": "^1.5.1",
    	jsdoc: "^3.6.4",
    	"lru-cache": "^4.0.1",
    	mocha: "^7.1.1",
    	"uglify-js": "^3.3.16"
    };
    var engines = {
    	node: ">=0.10.0"
    };
    var scripts = {
    	test: "mocha"
    };
    var require$$3 = {
    	name: name,
    	description: description,
    	keywords: keywords,
    	version: version,
    	author: author,
    	license: license,
    	bin: bin,
    	main: main,
    	jsdelivr: jsdelivr,
    	unpkg: unpkg,
    	repository: repository,
    	bugs: bugs,
    	homepage: homepage,
    	dependencies: dependencies,
    	devDependencies: devDependencies,
    	engines: engines,
    	scripts: scripts
    };

    /*
     * EJS Embedded JavaScript templates
     * Copyright 2112 Matthew Eernisse (mde@fleegix.org)
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *         http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     *
    */

    (function (exports) {

    /**
     * @file Embedded JavaScript templating engine. {@link http://ejs.co}
     * @author Matthew Eernisse <mde@fleegix.org>
     * @author Tiancheng "Timothy" Gu <timothygu99@gmail.com>
     * @project EJS
     * @license {@link http://www.apache.org/licenses/LICENSE-2.0 Apache License, Version 2.0}
     */

    /**
     * EJS internal functions.
     *
     * Technically this "module" lies in the same file as {@link module:ejs}, for
     * the sake of organization all the private functions re grouped into this
     * module.
     *
     * @module ejs-internal
     * @private
     */

    /**
     * Embedded JavaScript templating engine.
     *
     * @module ejs
     * @public
     */

    var fs = require$$0__default$6["default"];
    var path = require$$1__default$1["default"];
    var utils$1 = utils;

    var scopeOptionWarned = false;
    /** @type {string} */
    var _VERSION_STRING = require$$3.version;
    var _DEFAULT_OPEN_DELIMITER = '<';
    var _DEFAULT_CLOSE_DELIMITER = '>';
    var _DEFAULT_DELIMITER = '%';
    var _DEFAULT_LOCALS_NAME = 'locals';
    var _NAME = 'ejs';
    var _REGEX_STRING = '(<%%|%%>|<%=|<%-|<%_|<%#|<%|%>|-%>|_%>)';
    var _OPTS_PASSABLE_WITH_DATA = ['delimiter', 'scope', 'context', 'debug', 'compileDebug',
      'client', '_with', 'rmWhitespace', 'strict', 'filename', 'async'];
    // We don't allow 'cache' option to be passed in the data obj for
    // the normal `render` call, but this is where Express 2 & 3 put it
    // so we make an exception for `renderFile`
    var _OPTS_PASSABLE_WITH_DATA_EXPRESS = _OPTS_PASSABLE_WITH_DATA.concat('cache');
    var _BOM = /^\uFEFF/;

    /**
     * EJS template function cache. This can be a LRU object from lru-cache NPM
     * module. By default, it is {@link module:utils.cache}, a simple in-process
     * cache that grows continuously.
     *
     * @type {Cache}
     */

    exports.cache = utils$1.cache;

    /**
     * Custom file loader. Useful for template preprocessing or restricting access
     * to a certain part of the filesystem.
     *
     * @type {fileLoader}
     */

    exports.fileLoader = fs.readFileSync;

    /**
     * Name of the object containing the locals.
     *
     * This variable is overridden by {@link Options}`.localsName` if it is not
     * `undefined`.
     *
     * @type {String}
     * @public
     */

    exports.localsName = _DEFAULT_LOCALS_NAME;

    /**
     * Promise implementation -- defaults to the native implementation if available
     * This is mostly just for testability
     *
     * @type {PromiseConstructorLike}
     * @public
     */

    exports.promiseImpl = (new Function('return this;'))().Promise;

    /**
     * Get the path to the included file from the parent file path and the
     * specified path.
     *
     * @param {String}  name     specified path
     * @param {String}  filename parent file path
     * @param {Boolean} [isDir=false] whether the parent file path is a directory
     * @return {String}
     */
    exports.resolveInclude = function(name, filename, isDir) {
      var dirname = path.dirname;
      var extname = path.extname;
      var resolve = path.resolve;
      var includePath = resolve(isDir ? filename : dirname(filename), name);
      var ext = extname(name);
      if (!ext) {
        includePath += '.ejs';
      }
      return includePath;
    };

    /**
     * Try to resolve file path on multiple directories
     *
     * @param  {String}        name  specified path
     * @param  {Array<String>} paths list of possible parent directory paths
     * @return {String}
     */
    function resolvePaths(name, paths) {
      var filePath;
      if (paths.some(function (v) {
        filePath = exports.resolveInclude(name, v, true);
        return fs.existsSync(filePath);
      })) {
        return filePath;
      }
    }

    /**
     * Get the path to the included file by Options
     *
     * @param  {String}  path    specified path
     * @param  {Options} options compilation options
     * @return {String}
     */
    function getIncludePath(path, options) {
      var includePath;
      var filePath;
      var views = options.views;
      var match = /^[A-Za-z]+:\\|^\//.exec(path);

      // Abs path
      if (match && match.length) {
        path = path.replace(/^\/*/, '');
        if (Array.isArray(options.root)) {
          includePath = resolvePaths(path, options.root);
        } else {
          includePath = exports.resolveInclude(path, options.root || '/', true);
        }
      }
      // Relative paths
      else {
        // Look relative to a passed filename first
        if (options.filename) {
          filePath = exports.resolveInclude(path, options.filename);
          if (fs.existsSync(filePath)) {
            includePath = filePath;
          }
        }
        // Then look in any views directories
        if (!includePath && Array.isArray(views)) {
          includePath = resolvePaths(path, views);
        }
        if (!includePath && typeof options.includer !== 'function') {
          throw new Error('Could not find the include file "' +
              options.escapeFunction(path) + '"');
        }
      }
      return includePath;
    }

    /**
     * Get the template from a string or a file, either compiled on-the-fly or
     * read from cache (if enabled), and cache the template if needed.
     *
     * If `template` is not set, the file specified in `options.filename` will be
     * read.
     *
     * If `options.cache` is true, this function reads the file from
     * `options.filename` so it must be set prior to calling this function.
     *
     * @memberof module:ejs-internal
     * @param {Options} options   compilation options
     * @param {String} [template] template source
     * @return {(TemplateFunction|ClientFunction)}
     * Depending on the value of `options.client`, either type might be returned.
     * @static
     */

    function handleCache(options, template) {
      var func;
      var filename = options.filename;
      var hasTemplate = arguments.length > 1;

      if (options.cache) {
        if (!filename) {
          throw new Error('cache option requires a filename');
        }
        func = exports.cache.get(filename);
        if (func) {
          return func;
        }
        if (!hasTemplate) {
          template = fileLoader(filename).toString().replace(_BOM, '');
        }
      }
      else if (!hasTemplate) {
        // istanbul ignore if: should not happen at all
        if (!filename) {
          throw new Error('Internal EJS error: no file name or template '
                        + 'provided');
        }
        template = fileLoader(filename).toString().replace(_BOM, '');
      }
      func = exports.compile(template, options);
      if (options.cache) {
        exports.cache.set(filename, func);
      }
      return func;
    }

    /**
     * Try calling handleCache with the given options and data and call the
     * callback with the result. If an error occurs, call the callback with
     * the error. Used by renderFile().
     *
     * @memberof module:ejs-internal
     * @param {Options} options    compilation options
     * @param {Object} data        template data
     * @param {RenderFileCallback} cb callback
     * @static
     */

    function tryHandleCache(options, data, cb) {
      var result;
      if (!cb) {
        if (typeof exports.promiseImpl == 'function') {
          return new exports.promiseImpl(function (resolve, reject) {
            try {
              result = handleCache(options)(data);
              resolve(result);
            }
            catch (err) {
              reject(err);
            }
          });
        }
        else {
          throw new Error('Please provide a callback function');
        }
      }
      else {
        try {
          result = handleCache(options)(data);
        }
        catch (err) {
          return cb(err);
        }

        cb(null, result);
      }
    }

    /**
     * fileLoader is independent
     *
     * @param {String} filePath ejs file path.
     * @return {String} The contents of the specified file.
     * @static
     */

    function fileLoader(filePath){
      return exports.fileLoader(filePath);
    }

    /**
     * Get the template function.
     *
     * If `options.cache` is `true`, then the template is cached.
     *
     * @memberof module:ejs-internal
     * @param {String}  path    path for the specified file
     * @param {Options} options compilation options
     * @return {(TemplateFunction|ClientFunction)}
     * Depending on the value of `options.client`, either type might be returned
     * @static
     */

    function includeFile(path, options) {
      var opts = utils$1.shallowCopy({}, options);
      opts.filename = getIncludePath(path, opts);
      if (typeof options.includer === 'function') {
        var includerResult = options.includer(path, opts.filename);
        if (includerResult) {
          if (includerResult.filename) {
            opts.filename = includerResult.filename;
          }
          if (includerResult.template) {
            return handleCache(opts, includerResult.template);
          }
        }
      }
      return handleCache(opts);
    }

    /**
     * Re-throw the given `err` in context to the `str` of ejs, `filename`, and
     * `lineno`.
     *
     * @implements {RethrowCallback}
     * @memberof module:ejs-internal
     * @param {Error}  err      Error object
     * @param {String} str      EJS source
     * @param {String} flnm     file name of the EJS file
     * @param {Number} lineno   line number of the error
     * @param {EscapeCallback} esc
     * @static
     */

    function rethrow(err, str, flnm, lineno, esc) {
      var lines = str.split('\n');
      var start = Math.max(lineno - 3, 0);
      var end = Math.min(lines.length, lineno + 3);
      var filename = esc(flnm);
      // Error context
      var context = lines.slice(start, end).map(function (line, i){
        var curr = i + start + 1;
        return (curr == lineno ? ' >> ' : '    ')
          + curr
          + '| '
          + line;
      }).join('\n');

      // Alter exception message
      err.path = filename;
      err.message = (filename || 'ejs') + ':'
        + lineno + '\n'
        + context + '\n\n'
        + err.message;

      throw err;
    }

    function stripSemi(str){
      return str.replace(/;(\s*$)/, '$1');
    }

    /**
     * Compile the given `str` of ejs into a template function.
     *
     * @param {String}  template EJS template
     *
     * @param {Options} [opts] compilation options
     *
     * @return {(TemplateFunction|ClientFunction)}
     * Depending on the value of `opts.client`, either type might be returned.
     * Note that the return type of the function also depends on the value of `opts.async`.
     * @public
     */

    exports.compile = function compile(template, opts) {
      var templ;

      // v1 compat
      // 'scope' is 'context'
      // FIXME: Remove this in a future version
      if (opts && opts.scope) {
        if (!scopeOptionWarned){
          console.warn('`scope` option is deprecated and will be removed in EJS 3');
          scopeOptionWarned = true;
        }
        if (!opts.context) {
          opts.context = opts.scope;
        }
        delete opts.scope;
      }
      templ = new Template(template, opts);
      return templ.compile();
    };

    /**
     * Render the given `template` of ejs.
     *
     * If you would like to include options but not data, you need to explicitly
     * call this function with `data` being an empty object or `null`.
     *
     * @param {String}   template EJS template
     * @param {Object}  [data={}] template data
     * @param {Options} [opts={}] compilation and rendering options
     * @return {(String|Promise<String>)}
     * Return value type depends on `opts.async`.
     * @public
     */

    exports.render = function (template, d, o) {
      var data = d || {};
      var opts = o || {};

      // No options object -- if there are optiony names
      // in the data, copy them to options
      if (arguments.length == 2) {
        utils$1.shallowCopyFromList(opts, data, _OPTS_PASSABLE_WITH_DATA);
      }

      return handleCache(opts, template)(data);
    };

    /**
     * Render an EJS file at the given `path` and callback `cb(err, str)`.
     *
     * If you would like to include options but not data, you need to explicitly
     * call this function with `data` being an empty object or `null`.
     *
     * @param {String}             path     path to the EJS file
     * @param {Object}            [data={}] template data
     * @param {Options}           [opts={}] compilation and rendering options
     * @param {RenderFileCallback} cb callback
     * @public
     */

    exports.renderFile = function () {
      var args = Array.prototype.slice.call(arguments);
      var filename = args.shift();
      var cb;
      var opts = {filename: filename};
      var data;
      var viewOpts;

      // Do we have a callback?
      if (typeof arguments[arguments.length - 1] == 'function') {
        cb = args.pop();
      }
      // Do we have data/opts?
      if (args.length) {
        // Should always have data obj
        data = args.shift();
        // Normal passed opts (data obj + opts obj)
        if (args.length) {
          // Use shallowCopy so we don't pollute passed in opts obj with new vals
          utils$1.shallowCopy(opts, args.pop());
        }
        // Special casing for Express (settings + opts-in-data)
        else {
          // Express 3 and 4
          if (data.settings) {
            // Pull a few things from known locations
            if (data.settings.views) {
              opts.views = data.settings.views;
            }
            if (data.settings['view cache']) {
              opts.cache = true;
            }
            // Undocumented after Express 2, but still usable, esp. for
            // items that are unsafe to be passed along with data, like `root`
            viewOpts = data.settings['view options'];
            if (viewOpts) {
              utils$1.shallowCopy(opts, viewOpts);
            }
          }
          // Express 2 and lower, values set in app.locals, or people who just
          // want to pass options in their data. NOTE: These values will override
          // anything previously set in settings  or settings['view options']
          utils$1.shallowCopyFromList(opts, data, _OPTS_PASSABLE_WITH_DATA_EXPRESS);
        }
        opts.filename = filename;
      }
      else {
        data = {};
      }

      return tryHandleCache(opts, data, cb);
    };

    /**
     * Clear intermediate JavaScript cache. Calls {@link Cache#reset}.
     * @public
     */

    /**
     * EJS template class
     * @public
     */
    exports.Template = Template;

    exports.clearCache = function () {
      exports.cache.reset();
    };

    function Template(text, opts) {
      opts = opts || {};
      var options = {};
      this.templateText = text;
      /** @type {string | null} */
      this.mode = null;
      this.truncate = false;
      this.currentLine = 1;
      this.source = '';
      options.client = opts.client || false;
      options.escapeFunction = opts.escape || opts.escapeFunction || utils$1.escapeXML;
      options.compileDebug = opts.compileDebug !== false;
      options.debug = !!opts.debug;
      options.filename = opts.filename;
      options.openDelimiter = opts.openDelimiter || exports.openDelimiter || _DEFAULT_OPEN_DELIMITER;
      options.closeDelimiter = opts.closeDelimiter || exports.closeDelimiter || _DEFAULT_CLOSE_DELIMITER;
      options.delimiter = opts.delimiter || exports.delimiter || _DEFAULT_DELIMITER;
      options.strict = opts.strict || false;
      options.context = opts.context;
      options.cache = opts.cache || false;
      options.rmWhitespace = opts.rmWhitespace;
      options.root = opts.root;
      options.includer = opts.includer;
      options.outputFunctionName = opts.outputFunctionName;
      options.localsName = opts.localsName || exports.localsName || _DEFAULT_LOCALS_NAME;
      options.views = opts.views;
      options.async = opts.async;
      options.destructuredLocals = opts.destructuredLocals;
      options.legacyInclude = typeof opts.legacyInclude != 'undefined' ? !!opts.legacyInclude : true;

      if (options.strict) {
        options._with = false;
      }
      else {
        options._with = typeof opts._with != 'undefined' ? opts._with : true;
      }

      this.opts = options;

      this.regex = this.createRegex();
    }

    Template.modes = {
      EVAL: 'eval',
      ESCAPED: 'escaped',
      RAW: 'raw',
      COMMENT: 'comment',
      LITERAL: 'literal'
    };

    Template.prototype = {
      createRegex: function () {
        var str = _REGEX_STRING;
        var delim = utils$1.escapeRegExpChars(this.opts.delimiter);
        var open = utils$1.escapeRegExpChars(this.opts.openDelimiter);
        var close = utils$1.escapeRegExpChars(this.opts.closeDelimiter);
        str = str.replace(/%/g, delim)
          .replace(/</g, open)
          .replace(/>/g, close);
        return new RegExp(str);
      },

      compile: function () {
        /** @type {string} */
        var src;
        /** @type {ClientFunction} */
        var fn;
        var opts = this.opts;
        var prepended = '';
        var appended = '';
        /** @type {EscapeCallback} */
        var escapeFn = opts.escapeFunction;
        /** @type {FunctionConstructor} */
        var ctor;
        /** @type {string} */
        var sanitizedFilename = opts.filename ? JSON.stringify(opts.filename) : 'undefined';

        if (!this.source) {
          this.generateSource();
          prepended +=
            '  var __output = "";\n' +
            '  function __append(s) { if (s !== undefined && s !== null) __output += s }\n';
          if (opts.outputFunctionName) {
            prepended += '  var ' + opts.outputFunctionName + ' = __append;' + '\n';
          }
          if (opts.destructuredLocals && opts.destructuredLocals.length) {
            var destructuring = '  var __locals = (' + opts.localsName + ' || {}),\n';
            for (var i = 0; i < opts.destructuredLocals.length; i++) {
              var name = opts.destructuredLocals[i];
              if (i > 0) {
                destructuring += ',\n  ';
              }
              destructuring += name + ' = __locals.' + name;
            }
            prepended += destructuring + ';\n';
          }
          if (opts._with !== false) {
            prepended +=  '  with (' + opts.localsName + ' || {}) {' + '\n';
            appended += '  }' + '\n';
          }
          appended += '  return __output;' + '\n';
          this.source = prepended + this.source + appended;
        }

        if (opts.compileDebug) {
          src = 'var __line = 1' + '\n'
            + '  , __lines = ' + JSON.stringify(this.templateText) + '\n'
            + '  , __filename = ' + sanitizedFilename + ';' + '\n'
            + 'try {' + '\n'
            + this.source
            + '} catch (e) {' + '\n'
            + '  rethrow(e, __lines, __filename, __line, escapeFn);' + '\n'
            + '}' + '\n';
        }
        else {
          src = this.source;
        }

        if (opts.client) {
          src = 'escapeFn = escapeFn || ' + escapeFn.toString() + ';' + '\n' + src;
          if (opts.compileDebug) {
            src = 'rethrow = rethrow || ' + rethrow.toString() + ';' + '\n' + src;
          }
        }

        if (opts.strict) {
          src = '"use strict";\n' + src;
        }
        if (opts.debug) {
          console.log(src);
        }
        if (opts.compileDebug && opts.filename) {
          src = src + '\n'
            + '//# sourceURL=' + sanitizedFilename + '\n';
        }

        try {
          if (opts.async) {
            // Have to use generated function for this, since in envs without support,
            // it breaks in parsing
            try {
              ctor = (new Function('return (async function(){}).constructor;'))();
            }
            catch(e) {
              if (e instanceof SyntaxError) {
                throw new Error('This environment does not support async/await');
              }
              else {
                throw e;
              }
            }
          }
          else {
            ctor = Function;
          }
          fn = new ctor(opts.localsName + ', escapeFn, include, rethrow', src);
        }
        catch(e) {
          // istanbul ignore else
          if (e instanceof SyntaxError) {
            if (opts.filename) {
              e.message += ' in ' + opts.filename;
            }
            e.message += ' while compiling ejs\n\n';
            e.message += 'If the above error is not helpful, you may want to try EJS-Lint:\n';
            e.message += 'https://github.com/RyanZim/EJS-Lint';
            if (!opts.async) {
              e.message += '\n';
              e.message += 'Or, if you meant to create an async function, pass `async: true` as an option.';
            }
          }
          throw e;
        }

        // Return a callable function which will execute the function
        // created by the source-code, with the passed data as locals
        // Adds a local `include` function which allows full recursive include
        var returnedFn = opts.client ? fn : function anonymous(data) {
          var include = function (path, includeData) {
            var d = utils$1.shallowCopy({}, data);
            if (includeData) {
              d = utils$1.shallowCopy(d, includeData);
            }
            return includeFile(path, opts)(d);
          };
          return fn.apply(opts.context, [data || {}, escapeFn, include, rethrow]);
        };
        if (opts.filename && typeof Object.defineProperty === 'function') {
          var filename = opts.filename;
          var basename = path.basename(filename, path.extname(filename));
          try {
            Object.defineProperty(returnedFn, 'name', {
              value: basename,
              writable: false,
              enumerable: false,
              configurable: true
            });
          } catch (e) {/* ignore */}
        }
        return returnedFn;
      },

      generateSource: function () {
        var opts = this.opts;

        if (opts.rmWhitespace) {
          // Have to use two separate replace here as `^` and `$` operators don't
          // work well with `\r` and empty lines don't work well with the `m` flag.
          this.templateText =
            this.templateText.replace(/[\r\n]+/g, '\n').replace(/^\s+|\s+$/gm, '');
        }

        // Slurp spaces and tabs before <%_ and after _%>
        this.templateText =
          this.templateText.replace(/[ \t]*<%_/gm, '<%_').replace(/_%>[ \t]*/gm, '_%>');

        var self = this;
        var matches = this.parseTemplateText();
        var d = this.opts.delimiter;
        var o = this.opts.openDelimiter;
        var c = this.opts.closeDelimiter;

        if (matches && matches.length) {
          matches.forEach(function (line, index) {
            var closing;
            // If this is an opening tag, check for closing tags
            // FIXME: May end up with some false positives here
            // Better to store modes as k/v with openDelimiter + delimiter as key
            // Then this can simply check against the map
            if ( line.indexOf(o + d) === 0        // If it is a tag
              && line.indexOf(o + d + d) !== 0) { // and is not escaped
              closing = matches[index + 2];
              if (!(closing == d + c || closing == '-' + d + c || closing == '_' + d + c)) {
                throw new Error('Could not find matching close tag for "' + line + '".');
              }
            }
            self.scanLine(line);
          });
        }

      },

      parseTemplateText: function () {
        var str = this.templateText;
        var pat = this.regex;
        var result = pat.exec(str);
        var arr = [];
        var firstPos;

        while (result) {
          firstPos = result.index;

          if (firstPos !== 0) {
            arr.push(str.substring(0, firstPos));
            str = str.slice(firstPos);
          }

          arr.push(result[0]);
          str = str.slice(result[0].length);
          result = pat.exec(str);
        }

        if (str) {
          arr.push(str);
        }

        return arr;
      },

      _addOutput: function (line) {
        if (this.truncate) {
          // Only replace single leading linebreak in the line after
          // -%> tag -- this is the single, trailing linebreak
          // after the tag that the truncation mode replaces
          // Handle Win / Unix / old Mac linebreaks -- do the \r\n
          // combo first in the regex-or
          line = line.replace(/^(?:\r\n|\r|\n)/, '');
          this.truncate = false;
        }
        if (!line) {
          return line;
        }

        // Preserve literal slashes
        line = line.replace(/\\/g, '\\\\');

        // Convert linebreaks
        line = line.replace(/\n/g, '\\n');
        line = line.replace(/\r/g, '\\r');

        // Escape double-quotes
        // - this will be the delimiter during execution
        line = line.replace(/"/g, '\\"');
        this.source += '    ; __append("' + line + '")' + '\n';
      },

      scanLine: function (line) {
        var self = this;
        var d = this.opts.delimiter;
        var o = this.opts.openDelimiter;
        var c = this.opts.closeDelimiter;
        var newLineCount = 0;

        newLineCount = (line.split('\n').length - 1);

        switch (line) {
        case o + d:
        case o + d + '_':
          this.mode = Template.modes.EVAL;
          break;
        case o + d + '=':
          this.mode = Template.modes.ESCAPED;
          break;
        case o + d + '-':
          this.mode = Template.modes.RAW;
          break;
        case o + d + '#':
          this.mode = Template.modes.COMMENT;
          break;
        case o + d + d:
          this.mode = Template.modes.LITERAL;
          this.source += '    ; __append("' + line.replace(o + d + d, o + d) + '")' + '\n';
          break;
        case d + d + c:
          this.mode = Template.modes.LITERAL;
          this.source += '    ; __append("' + line.replace(d + d + c, d + c) + '")' + '\n';
          break;
        case d + c:
        case '-' + d + c:
        case '_' + d + c:
          if (this.mode == Template.modes.LITERAL) {
            this._addOutput(line);
          }

          this.mode = null;
          this.truncate = line.indexOf('-') === 0 || line.indexOf('_') === 0;
          break;
        default:
          // In script mode, depends on type of tag
          if (this.mode) {
            // If '//' is found without a line break, add a line break.
            switch (this.mode) {
            case Template.modes.EVAL:
            case Template.modes.ESCAPED:
            case Template.modes.RAW:
              if (line.lastIndexOf('//') > line.lastIndexOf('\n')) {
                line += '\n';
              }
            }
            switch (this.mode) {
            // Just executing code
            case Template.modes.EVAL:
              this.source += '    ; ' + line + '\n';
              break;
              // Exec, esc, and output
            case Template.modes.ESCAPED:
              this.source += '    ; __append(escapeFn(' + stripSemi(line) + '))' + '\n';
              break;
              // Exec and output
            case Template.modes.RAW:
              this.source += '    ; __append(' + stripSemi(line) + ')' + '\n';
              break;
            case Template.modes.COMMENT:
              // Do nothing
              break;
              // Literal <%% mode, append as raw output
            case Template.modes.LITERAL:
              this._addOutput(line);
              break;
            }
          }
          // In string mode, just add the output
          else {
            this._addOutput(line);
          }
        }

        if (self.opts.compileDebug && newLineCount) {
          this.currentLine += newLineCount;
          this.source += '    ; __line = ' + this.currentLine + '\n';
        }
      }
    };

    /**
     * Escape characters reserved in XML.
     *
     * This is simply an export of {@link module:utils.escapeXML}.
     *
     * If `markup` is `undefined` or `null`, the empty string is returned.
     *
     * @param {String} markup Input string
     * @return {String} Escaped string
     * @public
     * @func
     * */
    exports.escapeXML = utils$1.escapeXML;

    /**
     * Express.js support.
     *
     * This is an alias for {@link module:ejs.renderFile}, in order to support
     * Express.js out-of-the-box.
     *
     * @func
     */

    exports.__express = exports.renderFile;

    /**
     * Version of EJS.
     *
     * @readonly
     * @type {String}
     * @public
     */

    exports.VERSION = _VERSION_STRING;

    /**
     * Name for detection of EJS.
     *
     * @readonly
     * @type {String}
     * @public
     */

    exports.name = _NAME;

    /* istanbul ignore if */
    if (typeof window != 'undefined') {
      window.ejs = exports;
    }
    }(ejs));

    function getProjectTemplate () {
        return request({
            url: '/project/template'
        });
    }

    const TYPE_PROJECT = 'project';
    const TYPE_COMPONENT = 'component';
    const TEMPLATE_TYPE_NORMAL = 'normal';
    const TEMPLATE_TYPE_CUSTOM = 'custom';
    const WHITE_COMMAND = ['npm', 'cnpm'];
    const userHome = require$$0__default$4["default"].homedir();
    class InitCommand extends Command {
        constructor(args) {
            super(args);
            this.projectName = '';
            this.force = false;
            this.projectInfo = {};
            this.template = [];
        }
        init() {
            this.projectName = this._argv[0] || '';
            this.force = !!this._cmd.force;
            log.verbose('projectName', this.projectName);
            log.verbose('force', this.force.toString());
        }
        exec() {
            return __awaiter$3(this, void 0, void 0, function* () {
                try {
                    const projectInfo = yield this.prepare();
                    if (projectInfo) {
                        this.projectInfo = projectInfo;
                        yield this.downloadTemplate();
                        yield this.installTemplate();
                    }
                }
                catch (e) {
                    log.error('exec', e.message);
                    if (process.env.LOG_LEVEL === 'verbose') {
                        console.log(e);
                    }
                }
            });
        }
        downloadTemplate() {
            return __awaiter$3(this, void 0, void 0, function* () {
                const { projectTemplate } = this.projectInfo;
                this.templateInfo = this.template.find(item => item.npmName === projectTemplate);
                const targetPath = require$$1__default$1["default"].resolve(userHome, '.js-cli', 'template');
                const storeDir = require$$1__default$1["default"].resolve(userHome, '.js-cli', 'template', 'node_modules');
                const { npmName, version } = this.templateInfo;
                this.templateNpm = new Package({
                    targetPath,
                    storeDir,
                    packageName: npmName,
                    packageVersion: version
                });
                if (!(yield this.templateNpm.exists())) {
                    const spinner = spinnerStart('...');
                    yield sleep();
                    try {
                        yield this.templateNpm.install();
                    }
                    catch (e) {
                        throw e;
                    }
                    finally {
                        spinner.stop(true);
                        if (yield this.templateNpm.exists()) {
                            log.success('');
                        }
                    }
                }
                else {
                    const spinner = spinnerStart('...');
                    yield sleep();
                    try {
                        yield this.templateNpm.update();
                    }
                    catch (e) {
                        throw e;
                    }
                    finally {
                        spinner.stop(true);
                        if (yield this.templateNpm.exists()) {
                            log.success('');
                        }
                    }
                }
            });
        }
        installTemplate() {
            return __awaiter$3(this, void 0, void 0, function* () {
                if (this.templateInfo) {
                    if (this.templateInfo.type) {
                        if (!this.templateInfo.type) {
                            this.templateInfo.type = TEMPLATE_TYPE_NORMAL;
                        }
                        if (this.templateInfo.type === TEMPLATE_TYPE_NORMAL) {
                            yield this.installNormalTemplate();
                        }
                        else if (this.templateInfo.type === TEMPLATE_TYPE_CUSTOM) {
                            yield this.installCustomTemplate();
                        }
                        else {
                            throw new Error('');
                        }
                    }
                }
                else {
                    throw new Error('');
                }
            });
        }
        installNormalTemplate() {
            return __awaiter$3(this, void 0, void 0, function* () {
                // 
                let spinner = spinnerStart('');
                try {
                    const templatePath = require$$1__default$1["default"].resolve(this.templateNpm.cacheFilePath, 'template');
                    const targetPath = process.cwd();
                    lib$1.ensureDirSync(templatePath);
                    lib$1.ensureDirSync(targetPath);
                    lib$1.copySync(templatePath, targetPath);
                }
                catch (e) {
                    throw e;
                }
                finally {
                    spinner.stop(true);
                    log.success('');
                }
                const { installCommand, startCommand } = this.templateInfo;
                const templateIgnore = this.templateInfo.ignore || [];
                const ignore = ['**/node_modules/**', ...templateIgnore];
                yield this.ejsRender({ ignore });
                yield this.execCommand(installCommand, '');
                yield this.execCommand(startCommand, '');
            });
        }
        installCustomTemplate() {
            return __awaiter$3(this, void 0, void 0, function* () {
                // 
                if (yield this.templateNpm.exists()) {
                    const rootFile = this.templateNpm.getRootFilePath();
                    if (rootFile && require$$0__default$6["default"].existsSync(rootFile)) {
                        log.notice('', '');
                        const templatePath = require$$1__default$1["default"].resolve(this.templateNpm.cacheFilePath, 'template');
                        const options = {
                            templateInfo: this.templateInfo,
                            projectInfo: this.projectInfo,
                            sourcePath: templatePath,
                            targetPath: process.cwd()
                        };
                        const code = `require('${rootFile}')(${JSON.stringify(options)})`;
                        yield execSpawn('node', ['-e', code], {
                            stdio: 'inherit',
                            cwd: process.cwd()
                        });
                        log.success('');
                    }
                    else {
                        throw new Error('');
                    }
                }
            });
        }
        execCommand(command, errMsg) {
            return __awaiter$3(this, void 0, void 0, function* () {
                let ret;
                if (command) {
                    const cmdArray = command.split(' ');
                    const cmd = this.checkCommand(cmdArray[0]);
                    if (!cmd) {
                        throw new Error('' + command);
                    }
                    const args = cmdArray.slice(1);
                    ret = yield execSpawn(cmd, args, {
                        stdio: 'inherit',
                        cwd: process.cwd()
                    });
                    if (ret !== 0) {
                        throw new Error(errMsg);
                    }
                }
            });
        }
        checkCommand(cmd) {
            if (WHITE_COMMAND.includes(cmd)) {
                return cmd;
            }
            return null;
        }
        ejsRender(options) {
            return __awaiter$3(this, void 0, void 0, function* () {
                const dir = process.cwd();
                const projectInfo = this.projectInfo;
                return new Promise((resolve, reject) => {
                    glob_1('**', {
                        cwd: dir,
                        ignore: options.ignore || '',
                        nodir: true
                    }, (err, files) => {
                        if (err) {
                            reject(err);
                        }
                        Promise.all(files.map(file => {
                            const filePath = require$$1__default$1["default"].join(dir, file);
                            return new Promise((resolve1, reject1) => {
                                ejs.renderFile(filePath, projectInfo, {}, (err, result) => {
                                    if (err) {
                                        reject1(err);
                                    }
                                    else {
                                        lib$1.writeFileSync(filePath, result);
                                        resolve1(result);
                                    }
                                });
                            });
                        })).then(() => {
                            resolve(null);
                        }).catch(() => {
                            reject(err);
                        });
                    });
                });
            });
        }
        createTemplateChoices() {
            return this.template.map(item => ({
                value: item.npmName,
                name: item.name
            }));
        }
        prepare() {
            return __awaiter$3(this, void 0, void 0, function* () {
                const localPath = process.cwd();
                const template = (yield getProjectTemplate());
                if (!template || template.length === 0) {
                    throw new Error('');
                }
                this.template = template;
                if (!this.isDirEmpty(localPath)) {
                    let ifContinue = false;
                    if (!this.force) {
                        ifContinue = (yield inquirer.prompt({
                            type: 'confirm',
                            name: 'ifContinue',
                            default: false,
                            message: ''
                        })).ifContinue;
                        if (!ifContinue)
                            return;
                    }
                    if (ifContinue || this.force) {
                        const { confirmDelete } = yield inquirer.prompt({
                            type: 'confirm',
                            name: 'confirmDelete',
                            default: false,
                            message: ''
                        });
                        if (confirmDelete) {
                            lib$1.emptyDirSync(localPath);
                        }
                    }
                }
                return yield this.getProjectInfo();
            });
        }
        getProjectInfo() {
            return __awaiter$3(this, void 0, void 0, function* () {
                function isValidName(v) {
                    return /^[a-zA-Z]+([-][a-zA-Z][a-zA-Z0-9]*|[_][a-zA-Z][a-zA-Z0-9]*|[a-zA-Z0-9])*$/.test(v);
                }
                let projectInfo = {};
                let isProjectNameValid = false;
                if (isValidName(this.projectName)) {
                    isProjectNameValid = true;
                    projectInfo.projectName = this.projectName;
                }
                // 
                const { type } = yield inquirer.prompt({
                    type: 'list',
                    name: 'type',
                    default: TYPE_PROJECT,
                    choices: [{
                            name: '',
                            value: TYPE_PROJECT
                        }, {
                            name: '',
                            value: TYPE_COMPONENT
                        }],
                    message: ''
                });
                this.template = this.template.filter(template => template.tag.includes(type));
                const title = type === TYPE_PROJECT ? '' : '';
                const projectNamePrompt = {
                    type: 'input',
                    name: 'projectName',
                    message: `${title}`,
                    default: '',
                    validate: function (v) {
                        return new Promise((resolve, reject) => {
                            setTimeout(() => {
                                if (!isValidName(v)) {
                                    reject(`${title}1.; 2.;3.'-_'`);
                                    return;
                                }
                                resolve(true);
                            }, 0);
                        });
                    },
                    filter: (v) => {
                        return v;
                    }
                };
                const projectPrompt = [];
                if (!isProjectNameValid) {
                    projectPrompt.push(projectNamePrompt);
                }
                projectPrompt.push({
                    type: 'input',
                    name: 'projectVersion',
                    message: `${title}`,
                    default: '1.0.0',
                    validate: function (v) {
                        return new Promise((resolve, reject) => {
                            setTimeout(() => {
                                if (!(!!semver$2.valid(v))) {
                                    reject('');
                                    return;
                                }
                                resolve(true);
                            }, 0);
                        });
                    },
                    filter: (v) => {
                        if (!!semver$2.valid(v)) {
                            return semver$2.valid(v);
                        }
                        else {
                            return v;
                        }
                    }
                }, {
                    type: 'list',
                    name: 'projectTemplate',
                    message: `${title}`,
                    choices: this.createTemplateChoices(),
                });
                if (type === TYPE_PROJECT) {
                    const project = yield inquirer.prompt(projectPrompt);
                    projectInfo = Object.assign(Object.assign(Object.assign({}, projectInfo), { type }), project);
                }
                else if (type === TYPE_COMPONENT) {
                    const descriptionPrompt = {
                        type: 'input',
                        name: 'componentDescription',
                        message: '',
                        default: '',
                        validate: function (v) {
                            return new Promise((resolve, reject) => {
                                setTimeout(() => {
                                    if (!v) {
                                        reject('');
                                        return;
                                    }
                                    resolve(true);
                                }, 0);
                            });
                        },
                    };
                    projectPrompt.push(descriptionPrompt);
                    // 2.
                    const component = yield inquirer.prompt(projectPrompt);
                    projectInfo = Object.assign(Object.assign(Object.assign({}, projectInfo), { type }), component);
                }
                //  className
                if (projectInfo.projectName) {
                    projectInfo.name = projectInfo.projectName;
                    projectInfo.className = kebabCase(projectInfo.projectName).replace(/^-/, '');
                }
                if (projectInfo.projectVersion) {
                    projectInfo.version = projectInfo.projectVersion;
                }
                if (projectInfo.componentDescription) {
                    projectInfo.description = projectInfo.componentDescription;
                }
                console.log('projectInfo', projectInfo);
                return projectInfo;
            });
        }
        isDirEmpty(localPath) {
            let fileList = require$$0__default$6["default"].readdirSync(localPath);
            fileList = fileList.filter(file => !file.startsWith('.') && ['node_modules'].indexOf(file) < 0);
            return !fileList || fileList.length <= 0;
        }
    }
    const init = (...args) => {
        return new InitCommand(args);
    };

    exports["default"] = init;
    exports.init = init;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
